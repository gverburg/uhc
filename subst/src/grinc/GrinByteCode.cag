%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Grin ByteCode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}GrinByteCode} import({%{EH}Base.Common},{%{EH}Base.Builtin},{%{EH}GrinCode},qualified {%{GRIN}Config} as Cfg,{%{EH}GrinCode.Pretty})
%%]

%%[8 hs import(EH.Util.Pretty,Data.Bits,qualified EH.Util.FastSeq as Seq,qualified Data.Map as Map)
%%]

%%[8 hs export(AGItf(..),Module(..),Instr(..), Instrs, Meta(..))
%%]

%%[8 hs export(InsOp_LocE(..), InsOp_LocB(..), InsOp_LocODst(..), InsOp_LocOSrc(..), InsOp_TyOp(..), InsOp_DataOp(..), InsOp_ImmSz(..), InsOp_Deref(..), InsOp_DerefB(..), Imm(..))
%%]

%%[8 import({GrinByteCode/AbsSyn})
%%]

%%[20 hs import({%{EH}Core(HsName2OffsetMpMp)})
%%]

%%[99 hs import({%{EH}Base.ForceEval})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Configuration like constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nr of words occupied by header in node

%%[8 hs  export(nrNodeHdrWords)
nrNodeHdrWords :: Int
nrNodeHdrWords = 1
%%]

Nr of words required for call return info:
return address + saved bp

%%[8 hs  export(nrCallRetWords)
nrCallRetWords :: Int
nrCallRetWords = 2
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional datastructures, not incorporated as AST
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Instruction sequence

%%[8 hs export(InsSeq)
type InsSeq = Seq.FastSeq Instr
%%]

Constants

%%[8 hs export(Const(..))
data Const
  = Const_Str           { constInx    :: !Int    }
  | Const_CFunction     { constCFunNm :: !String }
  | Const_CallInfo      { constCINm   :: !String }		-- used only in ToC
%%[[20
  | Const_ImpNode
%%]]
  deriving(Eq,Ord,Show)

%%]

Link items, to be resolved at runtime initialization.

%%[8 hs export(Link(..),LinkTbl(..))
data LinkTbl
  = LinkTbl_Const
  | LinkTbl_ConstPtr
  | LinkTbl_CodeEntry
  | LinkTbl_PatchCode				-- patch with linkVal
  | LinkTbl_PatchCode_Deref1		-- patch with *linkVal
  | LinkTbl_PatchCode_Deref2		-- patch with **linkVal
  | LinkTbl_PatchOffsets			-- patch offsets to absolute address
  | LinkTbl_CallInfo				-- same as LinkTbl_Const, with implicit offset in determined by size of const table, used only in ToC
%%[[20
  | LinkTbl_ImpEntry
%%]]
  deriving (Show,Eq,Ord,Enum)

data Link
  = Link
      { linkTbl :: !LinkTbl
      , linkVal :: !Int
      }
  deriving Show
%%]

%%[8 hs export(linkCode,linkConst,linkConstPtr,linkOffsets)
linkConst :: Int -> Link
linkConst x = Link LinkTbl_Const x

linkConstPtr :: Int -> Link
linkConstPtr x = Link LinkTbl_ConstPtr x

linkCode :: Int -> Link
linkCode x = Link LinkTbl_CodeEntry x

linkOffsets :: Int -> Link
linkOffsets x = Link LinkTbl_PatchOffsets x
%%]

%%[20 hs export(linkImpEntry)
linkImpEntry :: Int -> Link
linkImpEntry m = Link LinkTbl_ImpEntry m
%%]

Reference to defining location in code

%%[8 hs export(LocRef(..),LabelId,newLabelId,lrefIsLabel)
type LabelId = Int

newLabelId :: LabelId -> (LabelId,LabelId)
newLabelId l = (l+1,l)

lrefIsLabel :: LocRef -> Bool
lrefIsLabel (LocRef_Label _) = True
lrefIsLabel _                = False

data LocRef
  = LocRef_CodeEntry    !Int                         -- resolved at initialization runtime, translates to
  | LocRef_Label        { lrefId :: !LabelId }       -- resolved before runtime, translates to offsets
  deriving (Eq,Ord)
%%]

%%[8 hs export(StackDepth)
type StackDepth = Int
%%]

Call Info

%%[8 hs export(CallInfo(..),CallInfoKind(..))
type MbStrInx = Maybe Int

data CallInfo
  = CallInfo
      { ciKind			:: !CallInfoKind
      , ciMbNmStrInx	:: !MbStrInx					-- index of string, if any
      }
  deriving(Eq,Ord,Show)

data CallInfoKind
  = CallInfoKind_Call             -- normal call
  | CallInfoKind_Tail             -- tail call
  | CallInfoKind_Eval             -- eval call
  | CallInfoKind_EvalWrap         -- eval call internal wrapper
  | CallInfoKind_TailEv           -- tail eval call
  | CallInfoKind_Apply            -- apply call
  | CallInfoKind_CCall            -- C call
  | CallInfoKind_EvCont           -- eval update continuation
  | CallInfoKind_ApCont           -- apply continuation
  | CallInfoKind_PApCont          -- partial apply continuation
  | CallInfoKind_Hdlr             -- exception handler installment
  deriving (Enum,Eq,Ord,Show)
%%]

%%[8 hs export(mkCICall)
mkCI :: CallInfoKind -> MbStrInx -> CallInfo
mkCI k i = CallInfo k i

mkCICall  = mkCI CallInfoKind_Call
mkCICCall = mkCI CallInfoKind_CCall
mkCIEval  = mkCI CallInfoKind_Eval
mkCIApply = mkCI CallInfoKind_Apply
%%]

Entry point info

%%[8 hs export(EntryInfo(..))
data EntryInfo
  = EntryInfo
      { eiNm			:: !HsName
      , eiEntryNr		:: !Int
      , eiIsCAF			:: !Bool
      , eiNmStrConst	:: !Const
      }
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Optimisation info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(OptimCtxt(..),defaultOptimCtxt)
data OptimCtxt
  = OptimCtxt
      { ocxOmitTOSLd        :: !Bool
      }

defaultOptimCtxt :: OptimCtxt
defaultOptimCtxt = OptimCtxt False
%%]

%%[8 hs export(OptimEffect(..),defaultOptimEffect)
data OptimEffect
  = OptimEffect
{- -- moved to separate transformation to eliminate redundant eval's
      { oefIsEvaluated         :: Bool
      }
-}

defaultOptimEffect :: OptimEffect
defaultOptimEffect = OptimEffect {- False -}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Environmental info for name resolution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(ValAccess(..),ValAccessGam)
data ValAccess
  = Val_LocalOffset     StackDepth
  | Val_Int             Integer
  | Val_GlobEntry       { vaEntryInx :: Int }
%%[[20
  | Val_ImpEntry        { vaModOff, vaEntryOff :: Int }
%%]]
  deriving Show

instance PP ValAccess where
  pp = pp . show

type ValAccessGam = Map.Map HsName ValAccess
%%]

%%[20 hs export(ImpNmMp)
type ImpNmMp = Map.Map HsName Int
%%]

%%[8 hs export(NmEnv(..))
data NmEnv
  = NmEnv
      { neVAGam     :: ValAccessGam
%%[[20
      , neImpNmMp   :: HsName2OffsetMpMp
%%]]
      }
%%]

%%[8.nmEnvLookup hs export(nmEnvLookup)
nmEnvLookup :: HsName -> NmEnv -> Maybe ValAccess
nmEnvLookup nm env = Map.lookup nm $ neVAGam env
%%]

%%[20 -8.nmEnvLookup hs export(nmEnvLookup)
nmEnvLookup :: HsName -> NmEnv -> Maybe ValAccess
nmEnvLookup nm env
  = case Map.lookup nm $ neVAGam env of
      Nothing
        -> do { q <- hsnQualifier nm
              ; (mo,entryMp) <- Map.lookup q $ neImpNmMp env
              ; eo <- Map.lookup nm entryMp
              ; return (Val_ImpEntry mo eo)
              }
      v -> v
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Load info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(LoadSrc(..))
data LoadSrc
  = LoadSrc_TOS
  | LoadSrc_Imm         { ldsrcImm      :: !Integer      }
  | LoadSrc_Imm_Int     { ldsrcImm      :: !Integer      }
  | LoadSrc_TOS_Rel     { ldsrcOff      :: !StackDepth   }
  | LoadSrc_Reg_Rel     { ldsrcOff      :: !StackDepth   }
  deriving (Show)

ldsrc2ins' :: (Instr -> Instr) -> LoadSrc -> (InsSeq,StackDepth)
ldsrc2ins' ann s
  = case s of
      LoadSrc_TOS       -> (Seq.empty,0)
      LoadSrc_TOS_Rel o -> (Seq.singleton $ ann $ ldl  o,1)
      LoadSrc_Reg_Rel o -> (Seq.singleton $ ann $ l1tr o,1)
      LoadSrc_Imm     c -> (Seq.singleton $ ann $ ldc  c,1)
      LoadSrc_Imm_Int c -> (Seq.singleton $ ann $ ldi  c,1)

ldsrc2ins :: LoadSrc -> (InsSeq,StackDepth)
ldsrc2ins = ldsrc2ins' id
%%]

%%[8 hs export(Load(..))
data Load
  = Load
      { ldPreIns        :: !InsSeq
      , ldPreStackInc   :: !StackDepth
      , ldPreLoc        :: !LoadSrc
      }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value access
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(nmLd')
nmLd' :: OptimCtxt -> NmEnv -> Int -> StackDepth -> HsName -> (Maybe ValAccess,Load)
nmLd' optim env modNmConstInx stkDepth nm
  = case nmEnvLookup nm env of
      mva@(Just va)
        -> case va of
             Val_LocalOffset o
               -> (mva,Load Seq.empty 0 (if off == 0 then LoadSrc_TOS else LoadSrc_TOS_Rel off))
               where off = stkDepth - o
             Val_Int i
               -> (mva,Load Seq.empty 0 (LoadSrc_Imm_Int i))
             Val_GlobEntry o
               -> (mva,Load (Seq.singleton $ ann nm $ ldg InsOp_LocB_TOS (linkCode o)) 1 LoadSrc_TOS)
%%[[20
             Val_ImpEntry mo eo
               -> (mva,Load (Seq.fromList [ann nm $ ldg InsOp_LocB_Reg (linkImpEntry mo)]) 0 (LoadSrc_Reg_Rel $ eo+1))
%%]]
      _ -> (Nothing,Load (Seq.singleton $ ann ("dummy ld for" >#< nm) $ ldl stkDepth) 1 LoadSrc_TOS)
%%]

%%[8 hs
vaAndLd2Ins :: OptimCtxt -> HsName -> (Maybe ValAccess,Load) -> (InsSeq,StackDepth)
vaAndLd2Ins optim nm vald
  = case vald of
      (Just (Val_LocalOffset _),Load pins pdep LoadSrc_TOS)
        | not (ocxOmitTOSLd optim)
          -> (pins Seq.:++: ins,pdep + dep)
          where (ins,dep) = ldsrc2ins' (ann nm) (LoadSrc_TOS_Rel 0)
      (_,Load pins pdep ls)
          -> (pins Seq.:++: ins,pdep + dep)
          where (ins,dep) = ldsrc2ins' (ann $ show ls) ls
%%]

%%[8 hs export(nmLd)
nmLd :: OptimCtxt -> NmEnv -> Int -> StackDepth -> HsName -> (InsSeq,StackDepth)
nmLd optim env modNmConstInx stkDepth nm
  = vaAndLd2Ins optim nm $ nmLd' optim env modNmConstInx stkDepth nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(GrValIntro(..),GrValIntroAlt(..))
data GrValIntro
  = GrValIntro_Nm    !HsName
  | GrValIntro_Int   !Integer
  | GrValIntro_Str   !String !Link
  | GrValIntro_Grp   !GrTag ![GrValIntro]
  | GrValIntro_None

data GrValIntroAlt
  = GrValIntroAlt_OnTOS     InsSeq StackDepth OptimEffect
  | GrValIntroAlt_Delay     InsSeq StackDepth OptimEffect (Maybe ValAccess) Load
%%]

%%[8 hs export(gviLd,gviLd',gviLdFold)
gviLdFold' :: GrValIntroAlt -> OptimCtxt -> NmEnv -> Int -> StackDepth -> [GrValIntro] -> GrValIntroAlt
gviLdFold' dflt optim env modNmConstInx stkDepth introL
  = foldl ld dflt $ reverse $ introL
  where ld (GrValIntroAlt_OnTOS ins dep _) intro
          = GrValIntroAlt_OnTOS (ins Seq.:++: ins') (dep+dep') defaultOptimEffect
          where (GrValIntroAlt_OnTOS ins' dep' _) = gviLd optim env modNmConstInx (stkDepth+dep) intro

gviLdFold :: OptimCtxt -> NmEnv -> Int -> StackDepth -> [GrValIntro] -> GrValIntroAlt
gviLdFold = gviLdFold' (GrValIntroAlt_OnTOS Seq.empty 0 defaultOptimEffect)

gviLd' :: OptimCtxt -> NmEnv -> Int -> StackDepth -> GrValIntro -> GrValIntroAlt
gviLd' optim env modNmConstInx stkDepth intro
  = ld optim (GrValIntroAlt_OnTOS Seq.empty 0 defaultOptimEffect) intro
  where ld optim dflt@(GrValIntroAlt_OnTOS ins dfltInc _) intro
          = case intro of
              GrValIntro_Nm nm
                -> GrValIntroAlt_Delay ins dfltInc defaultOptimEffect mbva l
                where (mbva,l) = nmLd' optim env modNmConstInx stkDepth nm
              GrValIntro_Str s l
                -> GrValIntroAlt_OnTOS (ins Seq.::+: (ann (show l) $ ldg InsOp_LocB_TOS l)) (dfltInc+1) defaultOptimEffect
              GrValIntro_Int i
                -> GrValIntroAlt_Delay ins dfltInc defaultOptimEffect Nothing (Load Seq.empty 0 $ LoadSrc_Imm_Int i)
{-
              GrValIntro_Grp gtag [i] | tagIsUnboxed gtag
                -> ld optim dflt i
-}
              GrValIntro_Grp gtag is
                -> GrValIntroAlt_OnTOS (ins Seq.:++: Seq.fromList [meta (ppGrTag gtag)] Seq.:++: tins Seq.:++: sins) sinc defaultOptimEffect
                where i@(GrValIntroAlt_OnTOS ins inc _) = gviLdFold' dflt (optim {ocxOmitTOSLd = False}) env modNmConstInx dep' is
                      (tins,tinc,allocInc,isEvaluated) = tag env modNmConstInx (dep'+inc) gtag inc
                      (sins,sinc) = ndStore (allocInc + inc + tinc)
              _ -> dflt
          where dep' = stkDepth + dfltInc

gviLd :: OptimCtxt -> NmEnv -> Int -> StackDepth -> GrValIntro -> GrValIntroAlt
gviLd optim env modNmConstInx stkDepth intro
  = case gviLd' optim env modNmConstInx stkDepth intro of
      GrValIntroAlt_Delay ins inc optimEffect mbva l
        -> GrValIntroAlt_OnTOS (ins Seq.:++: sins) (inc + sinc) optimEffect
        where (sins,sinc) = vaAndLd2Ins optim hsnUnknown (mbva,l)
      a -> a
%%]

%%[8 hs export(gvCall)
gvCall :: MbStrInx -> NmEnv -> Int -> InsSeq -> Int -> StackDepth -> HsName -> (InsSeq,StackDepth)
gvCall i nmEnv modNmConstInx ins inc stkDepth nm
  = (ins Seq.:++: fins Seq.:++: Seq.fromList [call i InsOp_LocB_TOS], 1)
  where (fins,_) = nmLd defaultOptimCtxt nmEnv modNmConstInx (stkDepth + inc) nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
pow2 :: Int -> Integer
pow2 x = 1 `shiftL` x

pow2' :: Int -> (Integer,Integer,Integer)
pow2' x
  = (p,-p,p-1)
  where p = pow2 x

(pow2_7 ,pow2_7neg ,pow2_7sub1 ) = pow2' 7
(pow2_8 ,pow2_8neg ,pow2_8sub1 ) = pow2' 8

(pow2_15,pow2_15neg,pow2_15sub1) = pow2' 15
(pow2_16,pow2_16neg,pow2_16sub1) = pow2' 16

(pow2_31,pow2_31neg,pow2_31sub1) = pow2' 31
(pow2_32,pow2_32neg,pow2_32sub1) = pow2' 32

(pow2_63,pow2_63neg,pow2_63sub1) = pow2' 63
(pow2_64,pow2_64neg,pow2_64sub1) = pow2' 64
%%]

%%[8 hs
mask2 :: Int -> Integer
mask2 x = pow2 x - 1

[mask2_8,mask2_16,mask2_32,mask2_64] = map mask2 [8,16,32,64]
%%]

%%[8 hs export(nrWord2Byte)
nrWord2Byte :: Integral c => c -> c
nrWord2Byte sz
  = sz * wSz
  where wSz = fromInteger Cfg.sizeofGrWord
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unboxed values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(tagIsUnboxed)
tagIsUnboxed :: GrTag -> Bool
tagIsUnboxed gt
  = case gt of
      GrTag_Con _ _ nm | nm == hsnInt || nm == hsnChar
        -> True
      GrTag_Unboxed
        -> True
      _ -> False
%%]

%%[8 hs export(tagUnbox)
tagUnbox :: GrTag -> Unbox
tagUnbox gt
  = if tagIsUnboxed gt
    then Unbox_FirstField
    else case gt of
           GrTag_Con ann t nm | gtannMaxArity ann == 0
             -> Unbox_Tag t
           _ -> Unbox_None
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: immediate operands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
imm :: Integral c => c -> (InsOp_ImmSz,Imm)
imm c
  = (s,Imm_Int i)
  where (s,i)
          = case toInteger c of
              i | i <  0 -> (s, i .&. m)
                         where (s,m) = case i of
                                         i | i >= pow2_7neg  -> (InsOp_ImmSz_Bits08,mask2_8 )
                                           | i >= pow2_15neg -> (InsOp_ImmSz_Bits16,mask2_16)
                                           | i >= pow2_31neg -> (InsOp_ImmSz_Bits32,mask2_32)
                                           | otherwise       -> (InsOp_ImmSz_Bits64,mask2_64)
              i | i >= 0 -> (s, i .&. mask2_64)
                         where s = case i of
                                     i | i < pow2_7sub1  -> InsOp_ImmSz_Bits08
                                       | i < pow2_15sub1 -> InsOp_ImmSz_Bits16
                                       | i < pow2_31sub1 -> InsOp_ImmSz_Bits32
                                       | otherwise       -> InsOp_ImmSz_Bits64
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: loading
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(ldc,ldl,ldg,ldi,l1tr,l2ts,ldnt)
ld :: Integral c => InsOp_Deref -> InsOp_LocB -> InsOp_LocE -> c -> Instr
ld ind locB locE c
  = Instr_Ld ind locB locE s i
  where (s,i) = imm c

ldc :: Integral c => c -> Instr
ldc = ld InsOp_Deref_Zero InsOp_LocB_TOS InsOp_LocE_Imm

ldi :: Integral c => c -> Instr
ldi = ld InsOp_Deref_Int InsOp_LocB_TOS InsOp_LocE_Imm

ldl :: Integral c => c -> Instr
ldl c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_SP (nrWord2Byte c)

l1tr :: Integral c => c -> Instr
l1tr c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_Reg (nrWord2Byte c)

l2ts :: Integral c => c -> Instr
l2ts c = ld InsOp_Deref_Two InsOp_LocB_TOS InsOp_LocE_SP (nrWord2Byte c)

ldg :: InsOp_LocB -> Link -> Instr
ldg locB l = Instr_LdGlobal locB l

ldnt :: Instr
ldnt = Instr_LdNodeTag
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: link
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(link)
link :: Link -> Instr
link = Instr_Link
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: storing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- not implemented yet

%%[8 hs export()
st :: Integral c => InsOp_DerefB -> InsOp_LocE -> InsOp_LocB -> c -> Instr
st ind locE locB c
  = Instr_St ind locE locB s i
  where (s,i) = imm c
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(labelref,label)
labelref :: LocRef -> Instr
labelref l = Instr_LabelRef l

label :: LocRef -> Instr
label l = Instr_Label l
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: allocation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(allocstore,fetch,fetchupdate,ndStore)
allocstore :: InsOp_LocB -> Instr
allocstore locB = Instr_AllocStore locB

fetch :: InsOp_LocB -> Instr
fetch locB = Instr_Fetch locB

fetchupdate :: Instr
fetchupdate = Instr_FetchUpdate

ndStore :: Int -> (InsSeq,StackDepth)
ndStore sz = (Seq.fromList [ldc (nrWord2Byte sz),ann "alloc+store" $ allocstore InsOp_LocB_TOS], 1)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: eval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(eval,apply,taileval)
eval :: MbStrInx -> InsOp_LocB -> Instr
eval i locB = Instr_Eval locB (mkCIEval i)

taileval :: Integral c => InsOp_LocB -> c -> Instr
taileval locB nArgSurr
  = Instr_TailEval locB s1 i1
  where (s1,i1) = imm $ nrWord2Byte nArgSurr
        -- (s2,i2) = imm $ nrWord2Byte retOffSurr

apply :: MbStrInx -> InsOp_LocB -> Instr
apply i locB = Instr_Apply locB (mkCIApply i)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: control, call, etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(call,retcall,tailcall,casecall,retcase,callc)
call :: MbStrInx -> InsOp_LocB -> Instr
call i locB = Instr_Call locB (mkCICall i)

rettailcall :: Integral c => (InsOp_ImmSz -> InsOp_ImmSz -> Imm -> Imm -> Instr) -> c -> c -> Instr
rettailcall mk nArgMine nArgSurr -- retOffSurr
  = mk s1 s2 i1 i2
  where (s1,i1) = imm $ nrWord2Byte nArgMine
        (s2,i2) = imm $ nrWord2Byte nArgSurr
        -- (s3,i3) = imm $ nrWord2Byte retOffSurr

retcall :: Integral c => c -> c -> Instr
retcall = rettailcall Instr_RetCall

tailcall :: Integral c => InsOp_LocB -> c -> c -> Instr
tailcall locB = rettailcall (Instr_TailCall locB)

casecall :: Instr
casecall
  = Instr_CaseCall

callc :: Integral c => MbStrInx -> c -> Instr
callc i nArg
  = Instr_CallC s1 i1 (mkCICCall i)
  where (s1,i1) = imm nArg

retcase :: Integral c => c -> c -> Instr
retcase nRes retOffSurr
  = Instr_RetCase s1 s2 i1 i2
  where (s1,i1) = imm $ nrWord2Byte nRes
        (s2,i2) = imm $ nrWord2Byte retOffSurr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(op)
op :: Integral c => InsOp_TyOp -> InsOp_DataOp -> InsOp_LocODst -> InsOp_Deref -> InsOp_LocOSrc -> c -> Instr
op opTy opndTy locDst ind locSrc c
  = Instr_Op opTy opndTy locDst ind locSrc s1 i1
  where (s1,i1) = imm c
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: comment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(meta,ann)
meta :: PP a => a -> Instr
meta a = Instr_Meta $ Meta_CmtHeader $ pp a

ann :: PP a => a -> Instr -> Instr
ann a = Instr_Ann $ showPP a
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: tag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Offsets should coincide with def of GB_NodeHeader, src/rts/grinbc/grinbc

%%[8 hs
[tgShSize,tgShNdEv,tgShCateg,tagShGC]
  = if Cfg.use32Bits then [16,14,12,10::Int] else [32,30,28,26]

tgNeedEval_No, tgNeedEval_Yes, tgNeedEval_BlH :: Integer
tgNeedEval_No  = 0
tgNeedEval_Yes = 1
tgNeedEval_BlH = 2
%%]

load tag, yield stack increment and additional size to alloc

%%[8 hs export(tag)
tag :: NmEnv -> Int -> StackDepth -> GrTag -> Int -> (InsSeq,StackDepth,StackDepth,Bool)
tag env modNmConstInx stkDepth gt sz
  = case gt of
      GrTag_Unboxed -> (Seq.empty,0,0,False)
      GrTag_Any     -> (Seq.empty,0,0,False) 
      _
        -> (tins Seq.:++: Seq.fromList [ldc tword],tinc+1,allocInc,isEvaluated)
        where (needEval,categ',tg',tins,tinc,allocInc)
                = case gt of
                    GrTag_Con _ tg nm    -> (tgNeedEval_No ,0,tg,Seq.empty      ,0  ,0)
                    GrTag_Hole           -> (tgNeedEval_BlH,0, 0,Seq.fromList [ldc 0],1  ,0)
                    GrTag_Rec            -> (tgNeedEval_No ,0, 0,Seq.empty      ,0  ,0)
                    GrTag_App      nm    -> (tgNeedEval_Yes,1, 0,Seq.empty      ,0  ,0)
                    GrTag_Fun      nm    -> (tgNeedEval_Yes,0, 0,ins            ,inc,0)
                                         where (ins,inc) = nmLd defaultOptimCtxt env modNmConstInx stkDepth nm
                    GrTag_PApp m   nm    -> (tgNeedEval_No ,1,m ,ins            ,inc,0)
                                         where (ins,inc) = nmLd defaultOptimCtxt env modNmConstInx stkDepth nm
              tword = (toInteger (sz+tinc+allocInc+1) `shiftL` tgShSize) .|. needEval `shiftL` tgShNdEv .|. categ' `shiftL` tgShCateg .|. toInteger tg'
              isEvaluated = needEval == tgNeedEval_No
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: misc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(halt)
halt :: Instr
halt = Instr_Halt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ForceEval instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[99 hs
instance ForceEval Const
instance ForceEval Link
instance ForceEval LocRef
instance ForceEval CallInfo
instance ForceEval EntryInfo
%%]

