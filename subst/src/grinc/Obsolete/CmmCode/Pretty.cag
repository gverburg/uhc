%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% C-- pretty printer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}CmmCode.Pretty} import(Data.Char,EH.Util.Pretty,{%{GRIN}GRINCCommon},{%{GRIN}CmmCode}) export(ppCmmUnit)
%%]

%%[8.WRAPPER import({CmmCode/AbsSyn})
WRAPPER CmmUnit
%%]

%%[8 hs
ppCmmUnit :: CmmUnit -> PP_Doc
ppCmmUnit cmmUnit
  =  let  t = wrap_CmmUnit (sem_CmmUnit cmmUnit) Inh_CmmUnit
     in   (pp_Syn_CmmUnit t)

instance PP CmmUnit where
  pp cu = ppCmmUnit cu
%%]

%%[8
ATTR All [ | | pp USE {>-<} {empty} : PP_Doc ]

SEM CmmToplevel
  | Section         lhs . pp    = "section" >#< (ppString @name) >#< ppCurlys @body.pp

SEM CmmSectionElement
  | Span            loc . pp    = "span" >#< @key.pp >#< @value.pp >#< ppCurlys @body.pp

SEM CmmDatum
  | Label           loc . pp    = pp @name >|< ":"
  | Align           loc . pp    = "align" >#< pp @align >|< ";"
  | Reserve         loc . pp    = pp @type >|< @size.pp >#< @init.pp >|< ";"

SEM CmmSize
  | Sized           loc . pp    = ppBrackets @size.pp
  | Many            loc . pp    = ppBrackets empty

SEM CmmInitString
  | List            loc . pp    = ppBlock "{ " " }" ", " @elements.pps
  | String          loc . pp    = ppString @string
  | UnicodeString   loc . pp    = "unicode" >#< ppString @string

SEM CmmDeclaration
  | Import          loc . pp    = "import" >#< ppListComma (ppExternalName False) @names    >|< ";"
  | Export          loc . pp    = "export" >#< ppListComma (ppExternalName True ) @names    >|< ";"
  | Constant        loc . pp    = "const" >#< pp @type >#< pp @name >#< "=" >#< @value.pp >|< ";"
  | Typedef         loc . pp    = "typedef" >#< pp @type >#< ppListComma pp @names >|< ";"
  | Var             loc . pp    = if @invariant then pp "invariant " else empty 
                                  >|< ppKind @kind >|< pp @type >#< ppListComma ppHwName @names >|< ";"
  | Target          loc . pp    = pp @targetSpec >|< ";"

SEM CmmProcedure
  | Procedure       loc . pp    = ppCallConv @callConv >|< pp @name >|< ppParens (ppListComma ppFormal @args) >-< ppCurlys @body.pp

SEM CmmBodyElement
  | StackData       loc . pp    = "stackdata" >#< ppCurlys @data.pp

SEM CmmStatement
  | Nop             loc . pp    = pp ";"
  | If              loc . pp    = "if" >#< @condition.pp >-< ppCurlys @body.pp
  | IfElse          loc . pp    = "if ">#< @condition.pp >-< ppCurlys @ifbody.pp >-< "else" >-< ppCurlys @elsebody.pp
  | Switch          loc . pp    = "switch" >#< @expr.pp >-< ppCurlys @alts.pp
  | Span            loc . pp    = "span" >#< @key.pp >#< @value.pp >-< ppCurlys @body.pp
  | Assign          loc . pp    = @lvals.pp >#< "=" >#< ppListComma id @expressions.pps              >|< ";"
  | Call            loc . ppLHS = ppListComma ppReciever @recievers
                    loc . ppRHS = ppCallConv @callConv >|< @fun.pp >|< ppParens @args.pp >#< @flow.pp >|< ";"
                    loc . pp    = if null @recievers then @ppRHS else @ppLHS >#< "=" >#< @ppRHS
  | TailCall        loc . pp    = ppCallConv @callConv >|< "jump" >#< @fun.pp >|< ppParens @args.pp >|< ";"
  | Return          loc . pp    = ppCallConv @callConv >|< "return" >#< ppParens @args.pp           >|< ";"
  | Label           loc . pp    = pp @name >|< ":"
  | GoTo            loc . pp    = "goto" >#< pp @target                                              >|< ";"
  | CutTo           loc . pp    = "cut to" >#< @cont.pp >|< ppParens @args.pp  >#< @flow.pp         >|< ";"
  | Continuation    loc . pp    = "continuation" >#< pp @name >|< ppParens (ppListComma ppReciever @args) >|< ":"

SEM CmmExpression
  | Int             loc . pp    = pp   @val >|< ppTypeAnn @type
  | Float           loc . pp    = error "CmmExpression_Float: no pp" -- pp   @val >|< ppTypeAnn @type
  | Char            loc . pp    = show @val >|< ppTypeAnn @type
  | Var             loc . pp    = pp @name
  | MemRef          loc . pp    = pp @type >#< ppBrackets @location.pp
  | Parens          loc . pp    = ppParens @expr.pp
  | Not             loc . pp    = "~" >#< @expr.pp
  | Primitive       loc . pp    = "%" >|< pp @name >|< ppParens @args.pp

SEM CmmExpressions [ | | pps : {[PP_Doc]} ]
  | Cons            loc . pps    = @hd.pp : @tl.pps
  | Nil             loc . pps    = []

SEM CmmActuals
  | Cons            loc . pp    = @hd.pp >|< "," >|< @tl.pp

SEM CmmActual
  | Actual          loc . pp    = ppKind @kind >|< @val.pp

SEM CmmLValues
  | Cons            loc . pp    = @hd.pp >|< "," >-< @tl.pp

SEM CmmLValue
  | Var             loc . pp    = pp @name
  | MemRef          loc . pp    = pp @type >#< ppBrackets @location.pp

SEM CmmAlternative
  | Alt             loc . pp    = "case" >#< @ranges.pp >#< ":" >-< ppCurlys @body.pp

SEM CmmRanges
  | Cons            loc . pp    = @hd.pp >|< "," >|< @tl.pp

SEM CmmRange
  | Ranged          loc . pp    = @from.pp >#< ".." >#< @to.pp

SEM CmmFlow
  | Cons            loc . pp    = @hd.pp >#< @tl.pp

SEM CmmFlowElement
  | Aborts         loc . pp     = pp "also aborts"
  | NoReturn       loc . pp     = pp "never returns"
  | Cuts           loc . pp     = "also cuts to"    >#< ppListComma pp @names
  | Unwinds        loc . pp     = "also unwinds to" >#< ppListComma pp @names
  | Returns        loc . pp     = "also returns to" >#< ppListComma pp @names
%%]


%%[8 hs
ppListComma ::  (a -> PP_Doc) -> [a] -> PP_Doc
ppListComma f = ppList (\e -> f e >|< ",")
	where
	ppList ::  (a -> PP_Doc) -> [a] -> PP_Doc
	ppList f = foldr (\e p -> f e >-< p) empty

ppKind :: CmmKind -> PP_Doc
ppKind kind = if null kind then empty else pp (ppString kind) >#< empty

ppReciever :: CmmKindedName -> PP_Doc
ppReciever (kind, name) = (if null kind then empty else ppKind kind) >|< pp name

ppFormal :: CmmFormal -> PP_Doc
ppFormal (kind, invariant, ty, name) = ppKind kind 
                                         >|< if invariant then pp "invariant " else empty
                                         >|< pp ty
                                         >#< pp name

ppExternalName :: Bool -> CmmExternalName -> PP_Doc
ppExternalName export  (internal, Just external) | export    = pp       internal >#< "as" >#< ppString external
                                                 | otherwise = ppString external >#< "as" >#< pp       internal
ppExternalName _       (internal, Nothing      )             = pp   internal

ppHwName :: CmmHwName -> PP_Doc
ppHwName (name, Just hwRegister) = pp name >#< "=" >#< ppString hwRegister
ppHwName (name, Nothing        ) = pp name

ppCallConv :: CmmCallConv -> PP_Doc
ppCallConv conv = case conv of
                    ""    -> empty
                    "C--" -> empty
                    _     -> "foreign" >#< ppString conv >#< empty

ppTypeAnn :: CmmOptionalType -> PP_Doc
ppTypeAnn = maybe empty (\t -> " ::" >#< pp t)

instance PP CmmType where
  pp (CmmBits i) = "bits" >|< (show i)
  pp (CmmName n) =  pp n


{- -- instance PP a => PP (Maybe a) exists
instance PP CmmOptionalType where
  pp (Nothing  ) = empty
  pp (Just ty) = pp ty
-}

instance PP CmmTargetSpec where
  pp (TargetSpec memsize byteorder pointersize wordsize) = "target"
                                                              >#< "memsize"     >#< show memsize 
                                                              >#< "byteorder"    >#< byteorderString
                                                              >#< "pointersize" >#< show pointersize
                                                              >#< "wordsize"    >#< show wordsize
    where byteorderString = case byteorder of 
                              LittleEndian -> "little"
                              BigEndian    -> "big"

ppString :: String -> PP_Doc
ppString = pp_doubleQuotes . pp . concatMap escapeChar

escapeChar :: Char -> String
escapeChar c | isPrint c = [c]
             | otherwise = '\\':'x':(int2hex $ ord c)

int2hex :: Int -> String
int2hex i | i == 0    = "0"
          | otherwise = let int2hexR i | i == 0    = ""
                                       | otherwise = intToDigit rem : int2hexR val
                                           where (val,rem) = i `divMod` 16
                        in  reverse (int2hexR i) 
%%]
