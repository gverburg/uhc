%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Cmm code, top level %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Merge everyting together into a C-- compilation unit

%%[8
ATTR GrAGItf GrModule [ entryNm: HsName | | cmmUnit : CmmUnit ]

SEM GrModule
  | Mod          loc . cmmUnit  = let addTl mtl             = maybe emptyBuilder id mtl
                                      externals             = addTl @imports ~> addTl @exports ~>
                                                              exports [ ( "@TAG_InfoTable"
                                                                        , Just "GRIN_TAG_InfoTable"
                                                                        )
                                                                      ]
                                      globalNodes           = @sectionGlobals :: CmmToplevelBuilder
                                      tagInfo               = @sectionTagInfo :: CmmToplevelBuilder
                                      unitTypedefs          = typedefs bits32 ["@grWord"]
                                      unitTarget            = target 8 LittleEndian 32 32
                                      heapPointer           = globalVarDecl False "address" bits32 [("@eh", Nothing)]
                                      grin_main             = buildDriver @lhs.entryNm @returnSizeEnv
                                      tagConstants          = fst $ foldl buildTagConst (emptyBuilder,0) @tags
                                      buildTagConst (r,i) (n,_) = (constant (Just valType) n (int i) ~> r, i+1)
                                  in CmmUnit_Unit (  build $ unitTarget ~> unitTypedefs ~> heapPointer
                                                  ~> externals ~> tagConstants ~> globalNodes ~> tagInfo ~> @strings
                                                  ~> grin_main ~> @bindL.cmmProcs
                                                  )
%%]

%%[8.driver hs
buildDriver nm env = procedure callConv "@grin_main" [] (vars ~> registerRoots ~> callMain ~> endGrin)
    where
    callConv = "" -- error $ "size=" ++ show (lookup name env)
    vars     = varDecl False "" valType [("$_", Nothing), ("@result", Nothing)]
    callMain = cmmCall "" (cmmVar name) [] receivers []
    registerRoots = cmmCall "C" (cmmVar "@roots") [ptrArg $ cmmVar "@Global_Nodes", ptrArg $ cmmVar "@Global_Nodes_End"] [] []
    endGrin  = cmmReturn callConv [valArg $ cmmVar resultVar]
    name = cmmName' nm
    receivers = padWith (const tmpVar) [tmpVar, tmpVar, ("", resultVar)] (fromJust' ("entrypoint not found: " ++ show name) $ lookup name env)
    tmpVar    = ("", "$_")
    resultVar = "@result"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, procedures %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

We collect the code for each Grin binding to map to a C-- procedure. Note that
we skip here apply, since we cannot generate code for this function.

%%[8
ATTR AllBind [ | | cmmProcs USE {~>} {emptyBuilder}: {CmmToplevelBuilder} ]

SEM GrBind
  | Bind        loc . cmmProcs = buildProcedure @nm @argNmL @cmmBody
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Expressions %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

The attributes needed for code generation for expressions. The names in which
to generate the code and the function which builds up the C-- body representing
the Grin code.

%%[8.Expressions
ATTR GrExpr    [ | | cmmBody USE {~>} {emptyBuilder}: {CmmBodyBuilder} ]

SEM GrBind
  | Bind        loc . cmmBody      = @traceStm ~> @tmpVar ~> @expr.cmmBody ~> @expr.handlers
                loc . tmpVar       = varDecl False "" valType [("$_", Nothing)]
%%]

%%%%%%%%%%%%%%%%%%%
%% Cmm code, Seq %%
%%%%%%%%%%%%%%%%%%%

The sequence operation does not generate code by itself, but does the chaining
of commands. The left hand side must create its result in the variables named
in the pattern in this bind operation which must be defined earlier. This is
the main task of GrExpr_Seq.

TODO: refactor CmmNameRegister - a map would be better for lookup
      CmmVars.cag might be a good location for the attribute, and it's threading
%%[8.Seq
ATTR AllGrExpr [ targetNames: {CmmNameRegister} | | allUsedNames USE {++} {[]}: {CmmNameRegister} ]

SEM GrExpr
  | Seq      expr . targetNames  = @pat.definedNames
             body . targetNames  = @lhs.targetNames
             lhs  . cmmBody      = nreg2varDef @pat.definedNames ~> @expr.cmmBody ~> @body.cmmBody

SEM GrExpr  
  | Seq      lhs  . allUsedNames = @expr.allUsedNames ++ @pat.definedNames ++ @body.allUsedNames

SEM GrBind
  | Bind   expr . targetNames = []

  
-- Collect names for a pattern in Seq
ATTR GrPat [ | | definedNames USE {++} {[]}: {CmmNameRegister} ]
SEM GrPat
  | Node       loc . fldNames = map (elemVar.cmmName') @fldL
               loc . definedNames = let knownTag   = maybe @fldNames (const $ tagVar "$_" : @fldNames) @tag.tagName
                                        unknownTag = maybe @fldNames (\n -> tagVar n : @fldNames) @tag.tagName
                                    in if @tag.isPtr then unknownTag else knownTag
  | NodeSplit  loc . definedNames = error "No NodeAdapt suport in GrPat"
  | Tag        loc . definedNames = let knownTag   = maybe [] (const [tagVar "$_"]) @tag.tagName
                                        unknownTag = maybe [] (\e -> [tagVar e]) @tag.tagName
                                    in if @tag.isPtr then unknownTag else knownTag
  | Empty      loc . definedNames = []
  | Var        loc . definedNames = [ elemVar . cmmName' $ @nm ]
%%]

%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Unit %%
%%%%%%%%%%%%%%%%%%%%

The grin unit operation returns values, both as a function return and as a copy
operation. We use the size info to pad the return if necessary.

%%[8.Unit
SEM GrExpr
  | Unit   loc  . dummyRet    = const . valArg $ int (-1)
                . returnStm   = cmmReturn ""  (padWith @dummyRet @val.cmmReturnArgs @lhs.maxReturnSize)
                . copyStm     = updates $ zipWith (\l e -> (varUpdate . fst $ l, e)) @lhs.targetNames @val.cmmExpressions
                . cmmBody     = if @isLastExpr then @returnStm else @copyStm
%%]

%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Case %%
%%%%%%%%%%%%%%%%%%%%

The case is more a lot of translation work than anything else.  Case
shortcutting can be done here. This is currently not implemented.

TODO: implement case shortcutting

Lowering grin has made the case expressions simple: the value to be scrutinised
is a tag variable.  A pattern in an alternative list only a tag constant.

%%[8.case
ATTR GrAltL    [  | | cmmAlts: {CmmAlternatives} ]
ATTR GrAlt     [  | | cmmAlt: {CmmAlternative} ]

SEM GrAltL
  | Cons   lhs  . cmmAlts     = @hd.cmmAlt : @tl.cmmAlts
  | Nil    lhs  . cmmAlts     = []

SEM GrAlt 
  | Alt    lhs  . cmmAlt      = CmmAlternative_Alt [@pat.cmmRange] (build @expr.cmmBody)

-- case alternative range
ATTR GrPat [ | | cmmRange: {CmmRange} ] 
SEM GrPat
  | Tag        loc . cmmTN    = maybe (error "unknown tag in case pattern") (\n -> CmmRange_Single $ cmmVar n) @tag.tagName
                   . cmmRange = if @tag.isPtr then error "not a constant in pattern of case alternative" else @cmmTN
  | * - Tag    loc . cmmRange = error "no tag in case pattern"

-- case scrutiniser
ATTR GrVal [ | | caseExpr: {CmmExpression} ]
SEM GrVal
  | Tag        lhs . caseExpr = maybe (error "cannot scrutinise an unbox tag") id @tag.cmmExpr
  | * - Tag    lhs . caseExpr = error "not a tag in a case"

SEM GrExpr
  | Case   loc  . cmmBody     = cmmSwitch @val.caseExpr @altL.cmmAlts
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Calls %%
%%%%%%%%%%%%%%%%%%%%%

Function call, which can be tail calls if they are the last statement.
targetNames might need to change to tell what kind of names are used. so
names2knames can use this info.

Apply and Eval calls are handled exactly the same currently.

Note: this is a copy paste - after inlining of app is done this is not needed anymore
%%[8 hs
newNames :: HsName -> Int -> [HsName]
newNames base count | count == 0 = []
                    | otherwise  = suffix "_Tag" : map (\n -> suffix $ "_Field" ++ show n) [1..(count-1)]
    where
    suffix = hsnSuffix base
%%]

%%[8.Call
SEM GrExpr
  | Call   loc  . realReceivers = nreg2knames @lhs.targetNames
                . argsReturned  = fromJust' ("Call: " ++ show @nm) $ lookup (cmmName' @nm) @lhs.returnSizeEnv
                . receivers     = padWith mkTempVar @realReceivers @argsReturned
                . mbFlow        = if null @lhs.handlerName then 
                                    if @isLastExpr then
                                      Nothing
                                    else
                                      Just []
                                  else
                                    if @isLastExpr then
                                      error "Tailcall found while exception handler is active"
                                    else
                                      Just [ CmmFlowElement_Cuts [@lhs.handlerName] ]
                . cmmBody       = call' @mbFlow @nm @argL.cmmFunctionArgs @receivers

  | App    loc  . realReceivers = nreg2knames @lhs.targetNames
                . argsReturned  = fromJust' ("Apply: " ++ show @appArgs) $ lookup apply @lhs.returnSizeEnv
                . receivers     = padWith mkTempVar @realReceivers @argsReturned
                . evalReturnCount = fromJust $ lookup eval @lhs.returnSizeEnv
                . appArgs       = map (valArg. cmmVar') (newNames @nm @evalReturnCount)
                . mbFlow        = if @isLastExpr then Nothing else Just []
                . cmmBody       = error "Apply call while generating code"
                                  --call @mbFlow apply (@appArgs ++ @argL.cmmFunctionArgs) @receivers

  | Eval   loc  . realReceivers = nreg2knames @lhs.targetNames
                . argsReturned  = fromJust' ("Eval: " ++ show @nm) $ lookup eval @lhs.returnSizeEnv
                . receivers     = padWith mkTempVar @realReceivers @argsReturned
                . mbFlow        = if @isLastExpr then Nothing else Just []
                . cmmBody       = error "Eval call while generating code"
                                  -- call @mbFlow eval [arg' @nm] @receivers

-- Collect function arguments 
ATTR GrValL [ | | cmmFunctionArgs : {CmmActuals} ]
ATTR GrVal  [ | | cmmFunctionArg  : {CmmActual } ]

SEM GrValL
  | Cons     lhs . cmmFunctionArgs = @hd.cmmFunctionArg : @tl.cmmFunctionArgs
  | Nil      lhs . cmmFunctionArgs = []

SEM GrVal
  | Var      loc . cmmFunctionArg = head @cmmReturnArgs -- see: ValueInfo.cag
  | * - Var  loc . cmmFunctionArg = error $ "actual requested, but no GrVal_Var"
%%]

%%%%%%%%%%%%%%%%%%%
%% Cmm code, FFI %%
%%%%%%%%%%%%%%%%%%%

FFI is used for primitives and foreign calls (with the C calling convention).
note that a C call cannot be handled as a last expression, this might change.

%%[8.FFI
SEM GrExpr
  | FFI    loc  . receivers   = nreg2knames @lhs.targetNames
                . primStm     = @primStmF (map cmmName' @argL) @options
                . callStm     = cmmCall "C" (cmmVar $ cmmName @nm) (map (valArg . cmmVar') @argL) @receivers []
                . cmmBody     = if @isPrim then @primStm
                                else if not @isLastExpr then @callStm
                                else error "FFI as last expression"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Monadic operations %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We assume cmmExpressions gives us the correct code
note: Store and Update cannot occur at return spine. Fetch can!

generic fetch code:
tag   = fetch p;
size  = bits32[tag_info+tag] - 4;
f_0   = bits32[p];
f_1   = bits32[p + 4];
f_2   = bits32[p + 8];
if (size > 0) {
  p = bits32[p +12];
  for(i = 0; i < size; i++) {
    f_i = bits32[p + i*4];
} else {
  f_3 = bits32[p + 12];
}
return (tag f_0 .. f_size);

%%[8.MO
SEM GrExpr
  | Store  loc  . cmmBody  =  buildStore @val.cmmExpressions (nreg2names @lhs.targetNames)
                             
  | Fetch  loc  . cmmBody  =  buildFetch @nm (fromJust' "unspecialiced fetch" @mbOffset) @mbTag @lhs.allTags (nreg2names @lhs.targetNames)
                             
  | Update loc  . cmmBody  =  buildUpdate @nm @val.cmmExpressions
%%]


TODO: gc alloc in two blocks (usefull only if gc maintains a list of free blocks)

current layout is:
tag, field1, field2, field3, pointer  -> field4 ... fieldn

better layout would be something like:
smaller or equal to 4: tag, field1, field2, field3
bigger than 4        : tag, field1, field2, pointer -> field4 ... fieldn

but this means that update must be specialized

%%[8.MO hs
buildStore nms [p] = let (first4, others)  = splitAt 4 nms
                         (snms, overflow)  = (first4, []) -- if null others then (first4, []) else splitAt 3 first4
                         bnms              = overflow ++ others
                         bigsize       = length bnms
                         grow          = (5 + bigsize) * 4
                         --biggrow       = if bigsize > 0 then Just (4 * bigsize) else Nothing
                         alloc         = [ (varUpdate p, cmmVar "@hp")
                                         , (varUpdate "@hp", cmmVar "@hp" <+> int grow)
                                         ] ++ (if bigsize > 0
                                               then [ (varUpdate "$_", cmmVar "@hp" <+> int (5*4))]
                                               else []
                                              )
                         assign v e tf i = let hd = (memUpdate valType (cmmVar v) i, e)
                                               tl = tf (i+4)
                                           in hd:tl
                         bigStore      = if bigsize > 0 then
                                         foldr (assign "$_") (const [(memUpdate ptrType (cmmVar p) (4*4), cmmVar "$_")]) bnms 0
                                         else []
                         store         = foldr (assign p) (const bigStore) snms 0
                         gc_alloc      = cmmCall "C" (cmmVar "@alloc") [valArg $ int 20] [("address", p)] [] ~>
                                         cmmCall "C" (cmmVar "@alloc") [valArg $ int (grow - 20)] [("address", "$_")] []
                     in gc_alloc ~> updates store

buildFetch p offset mbTag tags targetNames = let loadSingle = fetch (cmmVar' p) (offset*4)
                                                 loadPtr    = cmmAssign [varUpdate "$_"] [fetch (cmmVar' p) (4*4)]
                                                 loadDouble = fetch (cmmVar "$_") ((offset-4)*4)
                                                 tagLayout = do { t <- mbTag
                                                                ; let cmmTagName = tagLit2cmmName t
                                                                ; (layout, _, _) <- Map.lookup cmmTagName tags
                                                                ; return layout
                                                                }
                                                 isSingle = offset < 4 -- || case fromJust tagLayout of
                                                                       --       SmallLayout -> True
                                                                       --       BigLayout   -> False
                                                 loadArg = if isSingle then loadSingle else loadDouble
                                                 load = case targetNames of
                                                            []   -> cmmReturn "" [valArg loadArg]
                                                            [n]  -> cmmAssign [varUpdate n] [loadArg]
                                                            _    -> error "multiple variables after fetch!"
                                             in if isSingle then load else loadPtr ~> load

-- TODO: allow update to cope with multiple layouts

-- generic update hard to implement:
-- generic update p (t:[0..n])
-- size = sizeof t + 1  -- (nodeSize)
-- if (size > 4) {
--     b = alocate (size-3)
--     p[3] = b
--     for(i=0; i < size-4; i++)
--         b[i] = $(i+2) -- field nr (i+2)
-- } else {
--     p[3] = 2
-- }
-- for(i=1-max(size, 3); i>0; i--)
--     p[i] = $(i-1) -- field nr (i-1)
-- p[0] = t

--update allocates the maximum needed size. It might write some undefined values to the heap.
buildUpdate p es = let (first4, others)  = splitAt 4 es
                       (ses, overflow)   = (first4, []) -- if null others then (first4, []) else splitAt 3 first4
                       bes               = overflow ++ others
                       bigsize       = length bes
                       alloc         =  [ (varUpdate "$_", cmmVar "@hp")
                                        , (varUpdate "@hp", cmmVar "@hp" <+> int (4*bigsize))
                                        ]
                       assign v e tf i = let hd = (memUpdate valType (cmmVar v) i, e)
                                             tl = tf (i+4)
                                         in hd:tl
                       bigStore      = if bigsize > 0 then
                                       foldr (assign "$_") (const [(memUpdate ptrType (cmmVar' p) (4*4), cmmVar "$_")]) bes 0
                                       else []
                       store         = foldr (assign (cmmName' p)) (const bigStore) ses 0
                       gc_alloc      = cmmCall "C" (cmmVar "@alloc") [valArg $ int (4*bigsize)] [("address", "$_")] []
                    in if bigsize > 0 then gc_alloc ~> updates store else updates store
%%]

%%%%%%%%%%%%%%%%%%%%%%%
%% Exception support %%
%%%%%%%%%%%%%%%%%%%%%%%

Here we introduce the code to enter and leave an exception handler. The handler
itself is generated by ExceptionHandlers.cag

%%[8.exceptions
SEM GrExpr                             
  | Throw  loc  .  cmmBody   =  lift body (CmmStatement_CutTo (cmmVar "@eh") [ptrArg $ cmmVar' @nm] @flow)
                .  flow      =  if null @lhs.handlerName then [] else [ CmmFlowElement_Cuts [@lhs.handlerName] ]
  | Catch  loc  .  cmmBody   =  @enterTry ~> @body.cmmBody ~> @leaveTry ~> cmmLabel @afterLabel
                .  enterTry     =  (CmmBodyElement_StackData [CmmDatum_Label @prevName, reserve 1 bits32 noInit] :) ~>
                                   updates [(memUpdate bits32 @prevVar 0, @ehVar), (varUpdate @ehName, cmmVar @handlerName)]
%%]

% vim:et:ts=4:
