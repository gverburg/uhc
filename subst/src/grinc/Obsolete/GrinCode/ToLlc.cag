%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8
-- Change the options according to your taste

SEM GrAGItf
  | AGItf module.optJumpTailCalls = True   -- when True, tail calls are implemented with a goto
                                           --            need to define the Config.machDepCForTailcallXXX variables in that case
          module.optOwnParameters = True   -- when True, parameter passing is via the Stack datastructure
                                           --            (forced to True when optJumpTailCalls is True)
          module.optOwnLocals     = False  -- when True, local variables are allocated on the Stack datastructure
          module.optTraceCall     = False  -- when True, function entrance/exit is logged
          module.optCaseDefault   = False  -- when True, error messages are given as default case for each switch

{
optTraceAssign = False
}


-- Declaration of the option attirbutes

ATTR GrModule GrBind GrBindL GrExpr GrAlt GrAltL
  [ optJumpTailCalls : {Bool}
    optOwnParameters : {Bool}
    optOwnLocals     : {Bool}
    optTraceCall     : {Bool}
    optCaseDefault   : {Bool}
  | | ]

-- Force OwnParameters when JumpTailCalls

SEM GrModule
  | Mod bindL.optOwnParameters = @lhs.optOwnParameters || @lhs.optJumpTailCalls

%%]



%%[8

{
data Var = VarHs  HsName
         | VarIdx Var Int
         | VarDeref Var
         | VarSP
         | VarBP
         | VarRP

instance Show Var
 where show (VarHs h) = show h
       show VarSP     = "SP"
       show VarBP     = "BP"
       show VarRP     = "RP"
       show (VarIdx a i) = showPt a ++ "[" ++ show i ++ "]"
       show (VarDeref p) = "*" ++ show p

showPt :: Var -> String
showPt (VarHs h) =  "((Pointer)" ++ show h ++ ")"
showPt x = show x
}
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Attribute declarations: almost everything has a PP-representation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8
ATTR GrAGItf GrModule  [ entryNm: {HsName} | |  ]

ATTR GrAGItf GrModule GrBindL GrBind GrExpr GrAltL GrAlt GrVal GrTag GrPat GrGlobal GrGlobalL [ | | llcDoc USE {>-<} {empty} : {PP_Doc} ]

ATTR GrGlobal GrGlobalL [ | | initDoc USE {>-<} {empty} : {PP_Doc}
                              declDoc USE {>-<} {empty} : {PP_Doc}]

ATTR GrValL GrVal [ | | llcDocs : {[PP_Doc]} ]

ATTR GrExpr GrAlt GrAltL [ numberParameters : {Int}
                         |
                         | localsF USE {.} {id}: {[HsName]->[HsName]}
                           maxChildParameters USE {`max`} {0} : {Int}
                         ]

ATTR GrBindL GrBind GrExpr GrAlt GrAltL GrGlobal GrGlobalL [ maxConstrParameters : {Int} | | ]

ATTR GrBindL GrBind [ | | fwdDoc USE {>-<} {empty} : {PP_Doc} ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Find out whether a tailcall optimized call has been done
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8

ATTR GrExpr GrAlt GrAltL [ | | tailJumps USE {&&} {True} : {Bool} ]

SEM GrExpr
 | Seq     lhs.tailJumps = @body.tailJumps
 | Call    lhs.tailJumps = @isLastExpr && @lhs.optJumpTailCalls
 | Case    lhs.tailJumps = @altL.tailJumps
 | * - Seq Call Case
           lhs.tailJumps = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

SEM GrValL
  | Nil lhs.llcDocs = []
  | Cons lhs.llcDocs = @hd.llcDoc : @tl.llcDocs

SEM GrModule
  | Mod   lhs . llcDoc = moduleHeader @moduleNm @lhs.entryNm
                         >-< comment "Tag constants"
                         >-< tagConstants @evalTagMp
                         >-< text ""
                         >-< comment "Global table"
                         >-< @globalL.declDoc
                         >-< text ""
                         >-< initMethod @globalL.initDoc
                         >-< text ""
                         >-< comment "Function declarations"
                         >-< @bindL.fwdDoc
                         >-< text ""
                         >-< comment "Function definitions"
                         >-< @bindL.llcDoc

          loc . maxConstrParameters = foldr max 0 (map (ctagArity.snd) (concat (map snd @ctagsMp)))

SEM GrGlobal
  | Global lhs.initDoc =  let vs = @val.llcDocs
                              n  = length vs
                              pn = show @nm
                              p  = text pn
                          in  assignment (VarHs @nm) (allocate pn n @lhs.maxConstrParameters)
                              >-< vertically (zipWith assignment (map (VarIdx (VarHs @nm)) [0..]) vs)

           lhs.declDoc =  "GrWord" >#< show @nm >|< ";"


SEM GrBind
  | Bind  lhs . fwdDoc = methodHead @lhs.optOwnParameters @nm @argNmL >|< ";"

SEM GrBind
  | Bind  lhs . llcDoc = methodHeader @lhs.optTraceCall @lhs.optOwnParameters @nm @argNmL
                         >-< indent 4 (   ppWhen @expr.tailJumps
                                                 jumpPrepare
                                      >-< methodLocals @lhs.optOwnLocals @loc.locals
                                      >-< ppWhen @lhs.optOwnParameters
                                                 (methodParameters @lhs.optOwnLocals @argNmL)
                                      >-< ppWhen @loc.ownAllocation
                                                 (methodEnter (if @lhs.optOwnLocals     then length @loc.locals       else 0)
                                                              (if @lhs.optOwnParameters then @expr.maxChildParameters else 0)
                                                 )
                                      >-< @expr.llcDoc
                                      >-< ppWhen (@loc.ownAllocation && not @expr.tailJumps)
                                                 methodLeave
                                      )
                         >-< methodFooter @lhs.optTraceCall @nm

          expr . numberParameters = length @argNmL
          loc  . locals = @expr.localsF []
          loc  . ownAllocation = @lhs.optOwnParameters || @lhs.optOwnLocals


SEM GrExpr
 | Seq     lhs.llcDoc = @expr.llcDoc
                        >-< @body.llcDoc

 | Unit    lhs.llcDoc = comment "Unit"
                        >-< vertically [ assignment v e
                                       | (v,e) <-zip  (if @isLastExpr
                                                       then (map (VarIdx VarRP) [0..])
                                                       else (map VarHs @lhs.targets)
                                                      )
                                                      @val.llcDocs

                                       ]


 | Store   lhs.llcDoc = let ph = head @lhs.targets
                            pn = show ph
                            p  = text pn
                            vs = @val.llcDocs
                            n  = length vs
                        in comment "Store"
                           >-< assignment (VarHs ph) (allocate pn n @lhs.maxConstrParameters)
                           >-< vertically (zipWith assignment (map (VarIdx (VarHs ph)) [0..]) vs)

           lhs.localsF = (@lhs.targets ++)

 | Update  lhs.llcDoc = let p = (text.show) @nm
                            vs = @val.llcDocs
                        in comment "Update"
                           >-< vertically (zipWith assignment (map (VarIdx (VarHs @nm)) [0..]) vs)

 | Fetch   lhs.llcDoc = comment "Fetch"
                        >-< assignment (VarHs (head @lhs.targets))
                                       (arrayindex ((castpt.text.show) @nm) (fromJust @mbOffset))

           lhs.localsF = (@lhs.targets ++)

 | Case    lhs.llcDoc = comment "Case"
                        >-< caseHeader @val.llcDoc
                        >-< indent 4 @altL.llcDoc
                        >-< ppWhen @lhs.optCaseDefault (caseDefault @val.llcDoc)
                        >-< caseFooter

           lhs.localsF = ((filter (not . (=="_") . show) @lhs.targets) ++) . @altL.localsF

 | Call    lhs.llcDoc = if @isLastExpr && @lhs.optJumpTailCalls
                         then (   comment "Call (Tail)"
                              >-< vertically (zipWith assignment
                                                      (map (VarIdx VarRP) [1..])
                                                      @argL.llcDocs
                                             )
                              >-< indent 4 methodLeave
                              >-< let n = length @argL - @lhs.numberParameters
                                  in  ppWhen (n>0) (incrementWith stackpointer n)
                              >-< vertically (zipWith assignment
                                                      (map (VarIdx VarSP) [-1,-2..])
                                                      (map (arrayindex returnpointer) [1..length @argL])
                                             )
                              >-< ppWhen @lhs.optTraceCall (trace ("jumps "++ show @nm))
                              >-< jump @nm
                              )
                         else (   comment "Call (Normal)"
                              >-< (if @lhs.optOwnParameters
                                   then (   vertically (zipWith assignment
                                                                (map (VarIdx VarSP) [-1,-2..])
                                                                @argL.llcDocs
                                                       )
                                        >-< callStat @nm []
                                        )
                                   else callStat @nm @argL.llcDocs
                                  )
                              >-< vertically (zipWith assignment
                                                      (map VarHs @lhs.targets)
                                                      (map (arrayindex returnpointer) [0..])
                                             )
                              )

           lhs.localsF = (@lhs.targets ++)
           lhs.maxChildParameters = length @argL

 | FFI     lhs.llcDoc = comment "FFI"
                        >-< assignment (if @isLastExpr
                                        then (VarIdx VarRP 0)
                                        else (VarHs (head @lhs.targets))
                                       )
                                       (call @nm (map (text.show) @argL))

           lhs.localsF = (@lhs.targets ++)

 | App     lhs.llcDoc = comment "App: SHOULDNT"
 | Eval    lhs.llcDoc = comment "Eval: SHOULDNT"
 | Throw   lhs.llcDoc = comment "Throw: TODO"
 | Catch   lhs.llcDoc = comment "Catch: TODO"


SEM GrAlt
 | Alt     lhs.llcDoc = "case" >#< @pat.llcDoc >|< ":"
                        >-< indent 4 (@expr.llcDoc >-< "break;")

SEM GrVal
 | LitInt  lhs.llcDoc = text (show @int)
 | Var     lhs.llcDoc = text (show @nm)
 | Tag     lhs.llcDoc = @tag.llcDoc
 | Node    lhs.llcDoc = "{" >#< horizontally (intersperse (text ", ") (@tag.llcDoc : @fldL.llcDocs)) >#< "}"
 | * - LitInt Var Tag Node lhs.llcDoc = text "GrVal:other"


SEM GrVal
 | Node     lhs.llcDocs = @tag.llcDoc : @fldL.llcDocs
 | Var      lhs.llcDocs = [text (show @nm)]
 | * - Node Var lhs.llcDocs = repeat (text "GrVal:others")


SEM GrTag
 | Lit     lhs.llcDoc = text (showGrTagCategLetter @categ ++ show (hsnAlphanumeric @nm))
 | Var     lhs.llcDoc = text (show @nm)
 | Unboxed lhs.llcDoc = text "GrTag:Unboxed"
 | Any     lhs.llcDoc = text "GrTag:Any"

SEM GrPat
 | Tag     lhs.llcDoc = @tag.llcDoc
 | Var     lhs.llcDoc = text "GrPat:Var"
 | LitInt  lhs.llcDoc = text "GrPat:LitInt"
 | * - Tag Var LitInt lhs.llcDoc = text "GrPat:other"






{
showGrTag :: GrTag -> String
showGrTag (GrTag_Lit categ n nm) = showGrTagCategLetter categ ++ show (hsnAlphanumeric nm)
showGrTag (GrTag_Var nm) = show nm
showGrTag (GrTag_Unboxed) = "GrTag:Unboxed"
showGrTag (GrTag_Any    ) = "GrTag:Any"
}


%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determining the target
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR AllGrExpr [ targets : {[HsName]} | | ]
ATTR GrPat GrTag [ | |  patternNames: {[HsName]} ]

SEM GrBind
  | Bind     expr . targets = []

SEM GrExpr
  | Seq      expr . targets = @pat.patternNames
             body . targets = @lhs.targets

SEM GrPat
  | Var   lhs  .  patternNames = [@nm]
  | Node  lhs  .  patternNames = @tag.patternNames ++ @fldL
  | * - Var Node Tag  lhs  .  patternNames  =  []

SEM GrTag
  | Var      lhs  .  patternNames  = [@nm]
  | Unboxed  lhs  .  patternNames  = []
  | * - Var Unboxed lhs  .  patternNames  = [wildcardNr]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%  EHC specific constructions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8
{
moduleHeader :: HsName -> HsName -> PP_Doc
moduleHeader baseNm entryNm
 = comment ("Generated C code for module " ++ show baseNm ++ " entry name " ++ show entryNm)
   >-< text "#include <stdio.h>"
   >-< text ""
   >-< text "typedef int GrWord;"
   >-< text "typedef GrWord* Pointer;"
   >-< text ""
   >-< text "extern Pointer SP, RP, Stack;"
   >-< text "Pointer BP;"
   >-< text "GrWord _;"
   >-< text ""


methodHead :: Bool -> HsName -> [HsName] -> PP_Doc
methodHead optOwn nm params
 =  let parameters = if optOwn
                      then "void"
                      else commaSeparated (map (declareName "GrWord") params)
    in  "void" >#< functionName nm >|< "(" >|< parameters >|< ")"


methodHeader :: Bool -> Bool -> HsName -> [HsName] -> PP_Doc
methodHeader optTrace optOwn nm params
 =  methodHead optOwn nm params
    >#< "{"
    >-< ppWhen optTrace (trace ("enter " ++ show nm))


methodFooter ::  Bool -> HsName -> PP_Doc
methodFooter optTrace nm
 =  ppWhen optTrace (trace ("leave "++show nm))
    >-< text "}"
    >-< text ""

methodEnter :: Int -> Int -> PP_Doc
methodEnter n k
 = comment "Enter"
   >-< assignment (VarDeref VarSP) (castword basepointer)
   >-< assignment VarBP stackpointer
   >-< incrementWith stackpointer (n+k+1)

methodLeave :: PP_Doc
methodLeave
 = comment "Leave"
   >-< assignment VarSP basepointer
   >-< assignment VarBP (castpt (deref stackpointer))

methodLocals :: Bool -> [HsName] -> PP_Doc
methodLocals optOwn ns
 = ppUnless (null ns)
            (   comment "Local names"
            >-< if optOwn
                then allocateNames ns [1..]
                else declareNames "GrWord" ns
            )

methodParameters :: Bool -> [HsName] -> PP_Doc
methodParameters optOwn ns
 = ppUnless (null ns)
            (   comment "Parameters"
            >-< if optOwn
                then allocateNames ns [-1,-2..]
                else (   declareNames "GrWord" ns
                     >-< vertically (zipWith methodParameter ns [-1,-2..])
                     )
            )

methodParameter :: HsName -> Int -> PP_Doc
methodParameter p n
 = assignment (VarHs p)
              (arrayindex stackpointer n)

allocateNames :: [HsName] -> [Int] -> PP_Doc
allocateNames names numbers
 = vertically (zipWith allocateName names numbers)

allocateName :: HsName -> Int -> PP_Doc
allocateName name number
 = macrodefinition (text (show name)) (arrayindex basepointer number)

declareNames :: String -> [HsName] -> PP_Doc
declareNames tp ns
 = tp >#< commaSeparated (map show ns) >|< ";"

declareName :: String -> HsName -> String
declareName tp nm
 = tp ++ (' ' : show nm)

tagConstants :: EvApTagMp -> PP_Doc
tagConstants eas
 = let f ((t,s),_) n = constantDefinition "GrWord" ((text.showGrTag) t) ((text.show) n)
   in  vertically (zipWith f eas [0..])

functionName :: HsName -> String
functionName nm
 = show nm

callStat ::  HsName -> [PP_Doc] -> PP_Doc
callStat nm ps
 = call (functionName nm) ps >|< ";"

jumpPrepare :: PP_Doc
jumpPrepare
 =  pp machDepCForTailcallEnter

jump :: HsName -> PP_Doc
jump nm
 =  machDepCForTailcallLeave1
    >-< "register void* _tail_call_dest = ((void*)" >|< functionName nm >|< ");"
    >-< machDepCForTailcallLeave2
    >-< "goto *_tail_call_dest;"

basepointer   = text "BP";
stackpointer  = text "SP";
returnpointer = text "RP";

initMethod :: PP_Doc -> PP_Doc
initMethod b
 = text "void initialize(void) {"
   >-< indent 4 (assignment VarBP (text "0"))
   >-< indent 4 b
   >-< text "}"

constantDefinition :: String -> PP_Doc -> PP_Doc -> PP_Doc
constantDefinition tp x v
 = "#define" >#< x >#< v

castpt :: PP_Doc -> PP_Doc
castpt = cast "Pointer"

castword :: PP_Doc -> PP_Doc
castword = cast "GrWord"

-- n1 is the number of parameters of the tag
-- n2 is the maximum number of parameters of all constructorfunctions
-- tags other than C may be overwritten later with a C-tag, which might have more parameters.
-- We anticipate here for the maximum number of parameters.
-- Obvious improvement: do not take the global maximum, but only the maximum over the constructors
-- that are actually possible for this function.
-- Source of this information could be the Haskell-type, or the Grin HPT-analysis.

allocate :: String -> Int -> Int -> PP_Doc
allocate (tag:_) n1 n2
 = let n | tag=='C'  = n1
         | otherwise = max n1 n2
       alloc = if useBoehmGC then text "GC_MALLOC" else text "heapalloc" -- duplicate code in ToSilly
   in castword (alloc >|< "(" >|< show n >|< ")")
}
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Auxiliary PrettyPrint functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8
{
ppUnless :: Bool -> PP_Doc -> PP_Doc
ppUnless b p = if b then empty else p

ppWhen :: Bool -> PP_Doc -> PP_Doc
ppWhen b p = if b then p else empty

vertically :: [PP_Doc] -> PP_Doc
vertically = foldr (>-<) empty

horizontally :: [PP_Doc] -> PP_Doc
horizontally = foldr (>|<) empty

intersperse :: a -> [a] -> [a]
intersperse _ []  = []
intersperse _ xs@[_] = xs
intersperse i (x:xs)  = x:i:(intersperse i xs)

commaSeparated :: [String] -> String
commaSeparated = concat . intersperse ", "
}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Building a C program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8
{

macrodefinition :: PP_Doc -> PP_Doc -> PP_Doc
macrodefinition nm body
 = "#define" >#< nm >#< body

deref p = text "*" >|< p

decrementWith p n
 = incrementWith p (-n)

incrementWith p n
 = if n>0
   then p >#< "+=" >#< n >#< ";"
   else if n<0
   then p >#< "-=" >#< (-n) >#< ";"
   else empty

trace :: String -> PP_Doc
trace s
 = text ("printf(\"" ++ s ++ " SP=%d\\n\", SP-Stack); fflush(stdout);")

cast :: String -> PP_Doc -> PP_Doc
cast tp x = "((" >|< tp >|< ")" >|< x >|< ")"

caseHeader :: PP_Doc -> PP_Doc
caseHeader x
 =  "switch (" >|< x >|< ")" >#< "{"

caseDefault :: PP_Doc -> PP_Doc
caseDefault x
 =  "    default: printf(\"undefined case for " >|< x >|< " : %d\\n\", " >|< x >|< "); exit(1);"


caseFooter :: PP_Doc
caseFooter
 = text "}"

comment :: String -> PP_Doc
comment s = text ("/* " ++ s ++ " */")

call :: String -> [PP_Doc] -> PP_Doc
call f ps
 = f >|< "(" >|< horizontally (intersperse (text ", ") ps) >|< ")"

arrayindex :: PP_Doc -> Int -> PP_Doc
arrayindex a i
 = a >|< "[" >|< show i >|< "]"

assignment :: Var -> PP_Doc -> PP_Doc
assignment v e
 = show v
   >#< "="
   >#< e
   >|< ";"
   >|< ppWhen optTraceAssign
              (" printf(\"assignment" >#< show v >#< "=" >#< e >#< " : %d\\n\", " >#< show v >#< ");")
}

%%]
