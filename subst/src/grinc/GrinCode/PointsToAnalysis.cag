%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]
%%[8 import({GrinCode/AbsSyn})
%%]
%%[8.wrapper
WRAPPER GrAGItf
%%]
%%[8 hs module {%{GRIN}GrinCode.PointsToAnalysis}
%%]
%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe, Data.List(transpose))
%%]
%%[8 hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[8 hs import({%{GRIN}GRINCCommon}, {%{GRIN}HeapPointsToFixpoint})
%%]
%%[8 hs import(Debug.Trace)
%%]


%%[8 hs export(heapPointsToAnalysis)

{-
Main module entry point:
Given a Grin-program, traverse it and collect equations for variables and locations.
Then solve the constraints, and return the resulting abstract environment&heap: the "HptMap".
As an additional Int parameter, take the first number that is not the number of any variable.
Also return it, possibly modified.
As an additional Int result, return the number of iterations that it took to solve the equations.
-}

heapPointsToAnalysis :: GrModule -> Int -> (Int,HptMap)
heapPointsToAnalysis grmod unique
  = let -- traverse the tree
        inh = Inh_GrAGItf { location_Inh_GrAGItf = 0, unique_Inh_GrAGItf = unique  }
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) inh

        -- get three synthesized attributes
        equations = equations_Syn_GrAGItf syn
        heapEqs   = heapEqs_Syn_GrAGItf syn
        lenHeap   = location_Syn_GrAGItf syn
        
        -- now solve the equations
    in  solveEquations unique lenHeap equations heapEqs
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Main attributes %%
%%%%%%%%%%%%%%%%%%%%%
%%[8
{- 
The overall goal is to collect equations that express
what constraints variables and heaplocations satisfy.
-}

ATTR GrAGItf GrModule AllDef AllGrExpr [ | | equations  USE {++} {[]} : {Equations}
                                             heapEqs    USE {++} {[]} : {HeapEquations}
                                       ]

{-
A unique integer "location" is threaded through all expressions to number all Stores locations
The value "unique", the first unused variable number, is made available to the root
-}

ATTR GrAGItf GrModule AllDef AllGrExpr [                    | location: Int |                       ]
ATTR GrAGItf GrModule                  [ unique: {Int}      |               |                       ]

SEM GrAGItf
  | AGItf  module . location = 0

SEM GrAGItf
  | AGItf  lhs.equations = [ IsApplication Nothing (map fromJust args)             (getNr nm)
                           | (InNode (GrTag_App nm) args) <- @module.fpaNodes
                           ]
                           ++
                           [ IsEqual x y
                           | (funnr, args) <- @module.allCalls
                           , (x, Just y) <- zip [funnr + 2 ..] args
                           ]
                           ++
                           [ IsEqual x y
                           | (InNode (GrTag_Fun nm) args) <- @module.fpaNodes
                           , (x, Just y) <- zip [getNr nm + 2 ..] args
                           ]
                           ++
                           [ IsEqual x y
                           | (InNode (GrTag_PApp needs nm) args) <- @module.fpaNodes
                           , (x, Just y) <- zip [getNr nm + 2 ..] args
                           ]
                           ++  @module.equations
%%]

%%[8
ATTR AllGrVal 
     AllGrTag 
%%[[10
     AllAdapt     
%%]]
              [ | | self : SELF ]
%%]




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% value and pattern nodes  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs
-- A grin value is either a single variable or a complete node denotation (with known tag)
data NodeInfo a 
  =  InVar   Variable 
  |  InNode  GrTag [a]
  deriving Show
  
fromInVar :: NodeInfo a -> Variable
fromInVar (InVar v)  = v
fromInVar _          = error "HPT: Apply arguments should all be variables"  

%%]

%%[8.valInfo

ATTR GrVal             [ | | valInfo : { NodeInfo (Maybe Variable) }  var   : { Maybe Variable } ]
ATTR GrValL            [ | | valsInfo: {[NodeInfo (Maybe Variable)]}  vars  : {[Maybe Variable]} ]
ATTR GrPatAlt GrPatLam [ | | patInfo : { NodeInfo        Variable  }                             ]
ATTR GrVar             [ | | tag     : GrTag                          var   : { Variable }       ]
ATTR GrVarL            [ | | headTag : GrTag                          vars  : {[Variable]}       ]


SEM GrVal
  | Tag       lhs.valInfo  =  InNode  @tag.self []
  | Var       lhs.valInfo  =  InVar   (getNr @nm)
  | Node      lhs.valInfo  =  InNode  @tag.self @fldL.vars
  | Empty
    LitInt
    LitStr
    VarNode
%%[[10
    NodeAdapt 
%%]]
              lhs.valInfo  =  error $ "HPT: valinfo: " ++ show @loc.self ++ " has no known tag"
              

SEM GrValL
  | Cons      lhs.valsInfo  =  @hd.valInfo : @tl.valsInfo
  | Nil       lhs.valsInfo  =  []

SEM GrVal
  | Var      lhs.var  =  Just (getNr @nm)
  | * - Var  lhs.var  =  Nothing

SEM GrValL
  | Cons     lhs.vars  =  @hd.var : @tl.vars
  | Nil      lhs.vars  =  []

SEM GrPatAlt
  | LitInt     lhs.patInfo  =  error "HPT: patInfo: literal"
  | Tag        lhs.patInfo  =  InNode @tag.self []
  | Node       lhs.patInfo  =  InNode @tag.self (map getNr @fldL)
  | Otherwise  lhs.patInfo  =  error "HPT: patInfo: Otherwise"
%%[[10
  | NodeSplit  lhs.patInfo  =  error "HPT: patInfo: nodesplit"
%%]]

SEM GrPatLam
  | Empty      lhs.patInfo  =  InVar (getNr wildcardNr)
  | Var        lhs.patInfo  =  InVar (getNr @nm)
  | VarNode    lhs.patInfo  =  InNode (@fldL.headTag) (tail @fldL.vars)

SEM GrVarL  
  | Cons         lhs.headTag  =  @hd.tag
  | Nil          lhs.headTag  =  error "GrVarL headtag"
  
SEM GrVarL
  | Nil          lhs.vars  =  []
  | Cons         lhs.vars  =  @hd.var : @tl.vars  

SEM GrVar
  | KnownTag     lhs.tag   =  @tag.self
  | * - KnownTag lhs.tag   =  error "GrVar tag"
  | Var          lhs.var   =  getNr @nm
  | * - Var      lhs.var   =  error "GrVar name"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.targetInformation
{- 
Target information is either:
- the variable to which an expression is bound in a Sequence
- the result of a binding
- nothing (in the body of a Case and a Catch)
-}

ATTR AllGrExpr [ targetInfo: {NodeInfo Variable} | | ]

SEM GrBind
  | Bind  expr     . targetInfo  = InVar (getNr @nm)

SEM GrExpr
  | Seq    expr    . targetInfo  = @pat.patInfo
           body    . targetInfo  = @lhs.targetInfo


-- The value of the scrutinee is passed down to all alternatives
ATTR AllAlt [ valInfo: {NodeInfo (Maybe Variable)} | | ]


%%]


%%%%%%%%%%
%% Unit %%
%%%%%%%%%%
%%[8.unit
{-
There are five cases, depending on the structure of target and source
If there is no target, no equations are necessary
(this is the case for the unit at the end of an Case- or Catch-alternative).
If the target is a variable, we generate a single equation for it
 - if the source is a variable as well, the equation states that they should be the same
 - if the source is a node, the equation states that the variable refers to the node
If the target is a node, we generate a list of equations: one for each variable in the target
 - if the source is a variable, selections are created
 - if the source is a node, corresponding elements are equated
-}

SEM GrExpr
  | Unit 
    UpdateUnit
               loc.equations1 = case (@lhs.targetInfo, @val.valInfo) of
                                 (InVar tvar        ,  InVar svar        )  -> [IsEqual tvar svar]
                                 (InVar tvar        ,  InNode stag snms  )  -> [IsConstruction tvar stag snms Nothing]
                                 (InNode ttag tnms  ,  InVar svar        )  -> buildSelectEquations svar ttag tnms
                                 (InNode ttag tnms  ,  InNode stag snms  )  -> buildUnifyEquations  snms tnms
  | UpdateUnit loc.equations2 =  [ IsEqual (getNr @nm)  (fromJust @val.var) ]
  | Unit       lhs.equations  =  @loc.equations1
  | UpdateUnit lhs.equations  =  @loc.equations2 ++ @loc.equations1

                                                       
%%]
%%[8.unitaux hs

buildSelectEquations :: Variable -> GrTag -> [Variable] -> Equations
buildSelectEquations svar ttag tnms
  = [ IsSelection tvar svar i ttag
    | (tvar,i) <- zip tnms [0..]
    , tvar /= getNr wildcardNr
    ]

buildUnifyEquations :: [Maybe Variable] -> [Variable] -> Equations
buildUnifyEquations snms tnms
  = [ case mbSvar of
       Nothing    -> IsKnown tvar AbsBasic
       Just svar  -> IsEqual tvar svar
    | (tvar,mbSvar) <- zip tnms snms
    , tvar /= getNr wildcardNr
    ]

%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%
%%[8.store
{-
A unique heaplocation is allocated.
A heap-equation is generated, which associates the heaplocation with the node to be stored.
An equation is generated, which states that the targetvariable is known to be associated with this heaplocation.
-}

SEM GrExpr
  | Store  lhs . location    =  @lhs.location + 1  
           lhs . heapEqs     =  case @val.valInfo of
                                  InNode stag snms  -> [ WillStore @lhs.location stag snms ]
                                  _                 -> error "HPT: source of Store should be a node"
           lhs . equations   =  case (@val.valInfo, @lhs.targetInfo) of
                                  (InNode stag snms, InVar tvar)  -> [IsKnown tvar (AbsLocs (Set.singleton @lhs.location))] 
                                  _                               -> error "HPT: destination of Store should be a variable, source a node"

{-
A global definition is similar to a Store expression
-}

SEM GrGlobal
  | Global lhs . location    =  @lhs.location + 1
           lhs . heapEqs     =  case @val.valInfo of
                                  InNode stag snms  -> [ WillStore @lhs.location stag snms ]
                                  _                 -> error "HPT: source of Global should be a node"
           loc . tvar        =  getNr @nm
           lhs . equations   =  case @val.valInfo of
                                  InNode stag snms  -> [IsKnown @loc.tvar (AbsLocs (Set.singleton @lhs.location))]
                                  _                 -> error "HPT: source of Global should be a node"
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%
%%[8.alt

{-
In every alternative,
a select-equation is generated for each variable in the pattern: the values are selected from the scrutinee
The scrutinee is always a variable because of earlier normalisation.
-}
SEM GrAlt
  | Alt  lhs . equations  =  case (@pat.patInfo, @lhs.valInfo) of
                               (InNode ttag tnms, InVar svar)  -> buildSelectEquations svar ttag tnms
                               _                               -> error "HPT: Alternative scrutinee must be a variable, pattern a node"
                             ++ @expr.equations
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fetch, Update, FetchUpdate %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8.fetch
SEM GrExpr
  | FetchNode    lhs . equations =  case @lhs.targetInfo of
                                      InVar tvar  -> [ IsEqual tvar (getNr @nm) ]
                                      _           -> error "HPT: FetchNode target should be a variable"
  | FetchUpdate  lhs . equations =  [ IsEqual (getNr @dst) (getNr @src) ]
  | FetchField   lhs . equations =  case @lhs.targetInfo of
                                      InVar tvar  ->  [ IsSelection tvar (getNr @nm) @offset (fromJust @mbTag) ]
                                      _           -> error "HPT: FetchField target should be a variable"
  
%%]




%%%%%%%%%%
%% Call %%
%%%%%%%%%%
%%[8.call
{-
If the target is a single variable, it is required to have the same value as the function result.
If the target is a node denotation, a select-equation is generated for each variable in the node.
-}
SEM GrExpr
  | Call  loc  .  exceptions  =  getNr @nm + 1 : @lhs.exceptions
          lhs  .  equations   =  case @lhs.targetInfo of
                                   InVar  tvar       -> [ IsEqual tvar (getNr @nm) ]
                                   InNode ttag tnms  -> buildSelectEquations (getNr @nm) ttag tnms
%%]


%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%
%%[8.ffi

SEM GrExpr
  | FFI  loc . nodemap   =  Map.fromList ( [ (con, if con==GrTag_Unboxed then [AbsBasic] else [] ) | con <- @tagL.self ] )
         lhs . equations =  case @lhs.targetInfo of
                              InVar tvar        -> [ IsKnown tvar (AbsNodes @loc.nodemap) ]
                              InNode ttag tnms  -> zipWith IsKnown tnms (fromJust (Map.lookup ttag @loc.nodemap))
%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%
%%[8.eval
{-
A single equation is generated, associating the targetvariable with the evaluation result of the function
The target cannot be a node; these have been simplified earlier by the NormForHPT transformation
-}
SEM GrExpr
  | Eval  lhs . equations = case @lhs.targetInfo of
                              InVar tvar  -> [ IsEvaluation tvar (getNr @nm) @lhs.exceptVar ]
                              _        -> error "HPT: Eval target must be variable (NormForHPT should have made it so)"
%%]



%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%
%%[8.apply
SEM GrExpr
  | App  lhs . equations = case @lhs.targetInfo of
                             InVar tvar -> [ IsApplication (Just tvar) (getNr @nm : map fromInVar @argL.valsInfo) @lhs.exceptVar ]
                             _          -> error "HPT: Apply target should be a variable"
%%]


%%%%%%%%%%%%%%%%%%
%% Throw, Catch %%
%%%%%%%%%%%%%%%%%%
%%[8.throw
SEM GrExpr
  | Throw  loc     .  exceptions =  getNr @nm : @lhs.exceptions
           lhs     .  equations  =  case @lhs.targetInfo of
                                      InVar tvar  -> [ IsKnown tvar AbsBottom ]
                                      _           -> []

  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEqs   =  [ IsEqual @handlerVar e | e <- @body.exceptions ]
                   . handlerVar  =  getNr @arg

SEM GrExpr
  | Catch  lhs   .  equations   =   @loc.exceptEqs ++ @body.equations ++ @handler.equations

-- Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)
ATTR AllGrExpr [ exceptVar: Variable | exceptions: {[Variable]} | ]

SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   =  getNr @nm + 1
          loc     . exceptEqs   =  [ IsEqual @exceptVar e | e <- @expr.exceptions ]
          lhs     . equations   =  @loc.exceptEqs ++ @expr.equations
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8
-- Collect all Fun, PApp and App nodes, and all Calls

ATTR AllGrVal AllGrExpr AllDef GrModule [ | | fpaNodes USE {++} {[]} : {[NodeInfo (Maybe Variable)]} 
                                              allCalls USE {++} {[]} : {AbstractCallList}
                                        ]
ATTR GrTag [ | | isfpa : {Bool}  ]


SEM GrVal
  |  Node   lhs . fpaNodes  =  if @tag.isfpa then [ InNode @tag.self @fldL.vars ] else []

SEM GrExpr
  | Call    lhs . allCalls  =  [ (getNr @nm, @argL.vars) ]


SEM GrTag
  | Fun      lhs . isfpa  = True
  | PApp     lhs . isfpa  = True
  | App      lhs . isfpa  = True
  | * - Fun PApp App
             lhs . isfpa  = False
%%]
