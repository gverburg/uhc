Split fetch operation and right hoist the fetch operation until it does not
load an undefined value.

TODO: Rename map is obsolete: remove it, but add new variables to HptMap

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.SplitFetch} import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(splitFetch)

splitFetch :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
splitFetch (input,unique,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap, uniq_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  (grTrf_Syn_GrAGItf syn, uniq_Syn_GrAGItf syn, hptMap)  -- _Syn_GrAGItf syn)

%%]

%%[8
ATTR GrAGItf [  hptMap: HptMap | uniq: Int | grTrf: GrModule ]
ATTR AllNT [  hptMap: HptMap | uniq: Int | grTrf: SELF ]

ATTR AllNT [ renameMap: RenameMap  | | ]

SEM GrAGItf
  | AGItf  module  .  renameMap = []
%%]

%%%%%%%%%%%%%%%%
%% Node sizes %%
%%%%%%%%%%%%%%%%

%%[8.nodeSizes
ATTR AllBind AllGrExpr [ nodeSizes: {Map.Map GrTag Int} | | ]

SEM GrModule
  | Mod  loc  .  nodeSizes = Map.fromList (map fst @evalTagMp)
%%]


%%%%%%%%%%%%%%%%%%
%%% SplitFetch %%%
%%%%%%%%%%%%%%%%%%

%%[8.fetchInfo

ATTR GrPatLam GrVarL GrVar [ | | mbTag : {Maybe GrTag} ]

SEM GrPatLam
 | VarNode   lhs . mbTag = @fldL.mbTag
 | Var Empty lhs . mbTag = Nothing
 
SEM GrVarL
 | Cons   lhs . mbTag = @hd.mbTag
 | Nil    lhs . mbTag = Nothing

SEM GrVar
 | KnownTag   lhs . mbTag = Just @tag.self
 | Ignore Var lhs. mbTag  = Nothing



ATTR AllGrTag GrVarL GrVar [ | | self:SELF ]

SEM GrExpr [ | | fetchPointer: {Maybe HsName} ]
  | FetchNode     lhs  .  fetchPointer  =  Just @nm
  | * - FetchNode lhs  .  fetchPointer  =  Nothing


SEM GrPatAlt [ | | mbTag: {Maybe GrTag} ]
  |     Tag Node         lhs  .  mbTag  =  Just @tag.grTrf
  | * - Tag Node         lhs  .  mbTag  =  Nothing


SEM GrPatLam [ | |  names: {GrVarL} ]
  | VarNode              lhs  .  names  =  @fldL.self
  | Var                  lhs  .  names  =  error "SplitFetch.ag: attempt to get names from GrPat_Var"
  | Empty                lhs  .  names  =  []

SEM GrExpr
  | Seq   loc  .  fetches  = do { p  <- @expr.fetchPointer
                                ; let buildFetchInfo (GrVar_Var v) l o  =  (v, GrExpr_FetchField p o @pat.mbTag) : l (o+1)
                                      buildFetchInfo _             l o  =                                          l (o+1)
                                ; return $ foldr buildFetchInfo (const []) @pat.names 0
                                }
%%]


%%%%%%%%%%%%%%%%
%% RightHoist %%
%%%%%%%%%%%%%%%%

invariant: a field will only be used after the tag is used.

invariant: a fetch is followed by a case which scrutenizes the tag variable or
tag is known at compile time. (is this truly the case?)

We will not check the usage of variables, just search for a case in which the
tag variable is scrutinized. To prevent duplicate names we must rename each
variable when we write out the floating fetches.

%%[8.rightHoist

ATTR AllGrExpr [ floatingFetches : FetchEnv | | ]

SEM GrBind
  | Bind  expr  .  floatingFetches = Map.empty

SEM GrExpr
  | Seq  loc  .  isLit         = isJust @pat.mbTag
              .  fetchesInfo   = do { p <- @expr.fetchPointer
                                    ; l <- @fetches
                                    ; let mbTag             = checkSingleTag @lhs.hptMap p
                                          (h:t)             = l
                                          tagVar            = fst h
                                          buildFetches tag  = (tagVar, GrExpr_Unit (GrVal_Tag tag))
                                                              : map (\(a,b) -> (a, specializeFetch tag b)) t
                                          knownFetches      = if @loc.isLit
                                                              then l
                                                              else maybe [h] buildFetches mbTag
                                          unknownFetches    = if @loc.isLit || isJust mbTag 
                                                              then [] 
                                                              else t
                                    ; return (knownFetches, (tagVar, unknownFetches))
                                    }
         lhs   .  grTrf             = maybe @grTrf 
                                            (buildSeqs @body.grTrf . fst)        -- build FetchFields for the known fetches
                                            @fetchesInfo
         body  .  floatingFetches   = maybe @lhs.floatingFetches 
                                            (addFetchInfo @lhs.floatingFetches . snd)   -- add (tag,unknowns) to the floating fetches
                                            @fetchesInfo
                                            
                                            
                                            
  | Case  loc  .  (mbRes, newMap)   = Map.updateLookupWithKey (\k v -> Nothing) 
                                                              (getTagName @val.grTrf) 
                                                              @lhs.floatingFetches
               .  mbFetches         = @mbRes
               .  floatingFetches   = @newMap

ATTR AllAlt [ mbFetches: {Maybe [(HsName, GrExpr)]} | | ]

SEM GrAlt
  | Alt  loc  .  mbExprInfo  =  do { fetches <- @lhs.mbFetches
                                   ; tag     <- @pat.mbTag
                                   ; fetches <- return $ take (nodeSizeTag tag @lhs.nodeSizes) fetches
                                   ; return $  (foldr (specializeFetch' tag)
                                                      (@lhs.uniq, @lhs.renameMap, [])
                                                      fetches
                                               )
                                   }
         expr  .  uniq       =  maybe @lhs.uniq      (\(u, _ , _) -> u ) @mbExprInfo
               .  renameMap  =  maybe @lhs.renameMap (\(_, nm, _) -> nm) @mbExprInfo
         loc   .  newExpr    =  maybe @expr.grTrf    (\(_, _ , e) -> buildSeqs @expr.grTrf e) @mbExprInfo
         lhs   .  grTrf      =  GrAlt_Alt @pat.grTrf @newExpr
%%]

%%[8.lastFetch import({GrinCode/LastExpr})
SEM GrExpr
  | Catch  loc  . hasNext      =  False
  | FetchNode FetchField
           loc  .  mbKnownTag  =  checkSingleTag @lhs.hptMap @nm
                .  knownTag    =  fromJust' ("unknown tag in returning fetch " ++ show @nm ++ " tags can be " ++ show (getNodes (absFetch @lhs.hptMap @nm))) @mbKnownTag
                .  size        =  nodeSizeTag @knownTag @lhs.nodeSizes
                .  fetches     =  let buildFetchInfo o  =  Just (GrExpr_FetchField @nm o @mbKnownTag, o+1)
                                  in take @size $ unfoldr buildFetchInfo 1
                .  names       =  map (\n->HNmNr n Nothing) [@lhs.uniq .. @uniq  - 1]
                .  uniq        =  if @isLastExpr then @lhs.uniq + @size else @lhs.uniq
                .  node        =  GrVal_Node @knownTag (map GrVal_Var @names)
           lhs  .  grTrf       =  if @isLastExpr
                                  then buildSeqs (GrExpr_Unit @node) (zip @names @fetches)
                                  else @grTrf
%%]

TODO: must create some nice substitution applying AG snip (with Data.Map, scoping rules, etc.)

%%[8.applySubst
SEM GrVal
  | Var      loc . maybeVars   = lookup (getNr @nm) @lhs.renameMap
             lhs . grTrf       = maybe @grTrf (GrVal_Var . (\n->HNmNr n Nothing) . head) @maybeVars

SEM GrExpr
  | FetchNode FetchField Eval Throw UpdateUnit
               loc  . maybeVars  = lookup (getNr @nm) @lhs.renameMap
               loc  . newName    = maybe @nm ((\n->HNmNr n Nothing) . head) @maybeVars
  | FetchNode  loc  . grTrf      = GrExpr_FetchNode  @newName
  | FetchField loc  . grTrf      = GrExpr_FetchField @newName @offset @mbTag
  | UpdateUnit loc  . grTrf      = GrExpr_UpdateUnit @newName @val.grTrf
  | Eval       loc  . grTrf      = GrExpr_Eval  @newName
  | Throw      loc  . grTrf      = GrExpr_Throw @newName
%%]

%%[8 hs import(qualified Data.Map as Map, Data.Maybe, Data.List)
type FetchEnv = Map.Map HsName [(HsName, GrExpr)]

fromJust' s Nothing = error $ "fromJust':" ++ s
fromJust' _ (Just v) = v

nodeSizeTag t nodeSizes 
  =  Map.findWithDefault 1 t nodeSizes

getTagName (GrVal_Var v) =  v
getTagName v             = error $ "getName: value not a variable: '" ++ show v ++ "'"

addFetchInfo ffm (v, unknownFetches) = if null unknownFetches
                                       then ffm
                                       else Map.insert v unknownFetches ffm

buildSeqs body = foldr buildSeq body
    where
    buildSeq (v, e) b = GrExpr_Seq e (GrPatLam_Var v) b

checkSingleTag hptMap p = if singleton nodes
                          then Just (fst $ head nodes)
                          else Nothing
    where
    nodes = getNodes (absFetch hptMap p)

singleton [a] = True
singleton _   = False

specializeFetch' :: GrTag -> (HsName, GrExpr) -> (Int, RenameMap, [(HsName, GrExpr)]) -> (Int, RenameMap, [(HsName, GrExpr)])
specializeFetch' tag (var, fetch) (u, nm, fetchesL) =
    let var'      = HNmNr u Nothing
        u'        = u+1
        nm'       = (getNr var, [u]) : nm
        fetchesL' = (var', specializeFetch tag fetch) : fetchesL
    in (u', nm', fetchesL')

specializeFetch tag fetch = case fetch of
                                GrExpr_FetchField nm offset mbTag -> GrExpr_FetchField nm offset (Just tag)
                                otherwise                         -> error "specializeFetch: GrExpr is not a FetchField"
%%]

%%[8 hs
-- not used at the moment
smallestNode hptMap p = fst $ inBetweenLength (map snd nodes) 0
    where
    nodes = getNodes (absFetch hptMap p)

inBetweenLength list n = if allHaveMore
                         then inBetweenLength newList (n+1)
                         else (n, n + foldl (flip $ max . length) 0 list)
    where
    (newList, allHaveMore) = all' hasMore list

hasMore []     =  ([], False)
hasMore (h:t)  =  (t , True )

all' f []     =  ([], True)
all' f (h:t)  =  (h':t', b && b')
    where
    (h', b)  = f h
    (t', b') = all' f t

%%]
