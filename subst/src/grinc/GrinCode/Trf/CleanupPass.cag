cleanup EHC generated GRIN:
- eval and apply functions not needed (their semantics are builtin)
- better F-tag than P0-tag (altough they are aliases)
- primThrow and primCatch are not primitives, but ehc does not support the grin statements

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.CleanupPass} import(qualified Data.Set as Set, {%{EH}Base.Builtin}(hsnIsConstructorName))
%%]

debug:
%%[8 hs import(EH.Util.Utils)
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(cleanupPass)
cleanupPass :: GrModule -> GrModule
cleanupPass grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                         (Inh_GrAGItf)
                    in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF ]

SEM GrModule
  | Mod  lhs  .  grTrf         =  GrModule_Mod @moduleNm @newGlobals @bindL.grTrf @ctagsMp @newEvalTagMp @applyTagMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Eval and Apply are builtin %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.dropEvalApply
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  @nm `elem` [evalNm, evalNr,  applyNm, applyNr] 
  | Rec   lhs  . dropBinding  =  False


SEM GrBindL
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf
                            else @hd.grTrf : @tl.grTrf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% F-Tag  <== P0-Tag %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ehc outputs P0-tags instead of F-Tags in some situations, we rewrite them to F-Tags
Also, replace F-Tags for constructorfunctions by C-tags

%%[8.P0tag_TO_Ftag

SEM GrTag
  | Fun  lhs . grTrf = if   hsnIsConstructorName @nm
                       then GrTag_Con emptyGrTagAnn 99 @nm  -- (error ("cleaned F-tag " ++ show @nm)) @nm
                       else @loc.grTrf
  | PApp lhs . grTrf = if   @needs==0 
                       then (if   hsnIsConstructorName @nm
                             then GrTag_Con emptyGrTagAnn 99 @nm  -- (error ("cleaned P0-tag " ++ show @nm)) @nm
                             else GrTag_Fun @nm
                            )
                       else @loc.grTrf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Add Global variables %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Introduce global variables: each binding without arguments must have a
corresponding global variable. (CAF's)
Filter out the constructor functions.

Note: EHC does not generate these yet

A CAF is a GRIN function which takes no parametes. every CAF has a variable
named the same as GRIN function that maps to a FNode. Which, if evaluated,
calls the corresponding GRIN function.

%%[8.caf

ATTR GrModule  [ | | cafNames              : {[HsName]}              ]
ATTR AllBind   [ | | cafNamesF USE {.} {id}: {[HsName]->[HsName]}    ]

SEM GrModule
  | Mod         loc . cafNames   =  @bindL.cafNamesF []
SEM GrBind
  | Bind        loc . cafNamesF  =  if null @argNmL then (@nm:) else id


SEM GrModule
  | Mod  loc  .  newGlobals  =  let buildGlobalVar n  =  GrGlobal_Global n (GrVal_Node (tag n) [])
                                    tag n             =  let  ts = filter (\x -> n==ctagNm x) @allCTags
                                                         in   if null ts
                                                              then GrTag_Fun n
                                                              else let t = head ts
                                                                   in  GrTag_Con (mkGrTagAnn (ctagArity t) (ctagMaxArity t)) (ctagTag t) n
                                    globalL           =  map buildGlobalVar
                                                             @cafNames
                                in (if null @globalL.grTrf then globalL else @globalL.grTrf)
              .   allCTags    =   [ ct | (_,xs) <- @ctagsMp, (_,ct) <- xs ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Fix Primitives to Exception statements %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.hackPrimToExceptionStatments

-- we need an node which eval interprets as 'throw exception'
SEM GrModule
  | Mod  loc  .  newEvalTagMp  =  ((throwTag,1), EvApTagThrow) : @evalTagMp

SEM GrBind
  | Bind  lhs  .  grTrf    =  GrBind_Bind @nm @argNmL @newExpr
          loc  .  newExpr  =  if @nm == HNm "_catch" then buildCatchExpr @argNmL
                              else if @nm == HNm "_throw" then buildThrowExpr @argNmL
                              else @expr.grTrf
%%]

%%[8.hackPrimToExceptionStatments hs
buildThrowExpr [exceptNm] = GrExpr_Throw exceptNm

buildCatchExpr [tryNm, handlerNm] = let  exceptNm = hsnPrefix "except_ptr@" handlerNm
                                         evalNm   = hsnPrefix "except_node@" handlerNm
                                    in GrExpr_Catch (GrExpr_Eval tryNm)
                                                    exceptNm
                                                    (GrExpr_Seq (GrExpr_Eval handlerNm)
                                                                (GrPatLam_Var evalNm)
                                                                (GrExpr_App evalNm [GrVal_Var exceptNm])
                                                    )
%%]
