Rename numbered identifiers to their names.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.NameIdents} import({%{GRIN}GRINCCommon}, Data.Maybe, {%{EH}Base.Common}, {%{EH}GrinCode}, Data.Array.IArray, qualified Data.Map as Map) export(nameIdents)

nameIdents :: IdentNameMap -> GrModule -> GrModule
nameIdents m grmod = let t        = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                        (Inh_GrAGItf { names_Inh_GrAGItf = m })
                     in grTrf_Syn_GrAGItf t
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF     ]
%%]

%%[8.rename
ATTR GrAGItf AllNT  [ names: IdentNameMap | | ]

SEM GrGlobal
  | Global  lhs  .  grTrf  =  GrGlobal_Global (getName' @lhs.names @nm) @val.grTrf

SEM GrPatAlt
  | Node    lhs  .  grTrf  = GrPatAlt_Node @tag.grTrf (map (getName' @lhs.names) @fldL)

SEM GrPatLam
  | Var     lhs  .  grTrf  = GrPatLam_Var                  (getName' @lhs.names @nm)

SEM GrBind
  | Bind  loc  .  bindName  = getName' @lhs.names @nm
               .  newNames  = map (getName' @lhs.names) @argNmL
          lhs  .  grTrf     = GrBind_Bind @bindName @newNames @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (getName' @lhs.names @nm)
SEM GrVar
  | Var  lhs  .  grTrf  = GrVar_Var (getName' @lhs.names @nm)

SEM GrExpr
  | App Eval Call FetchNode FetchField Throw UpdateUnit
                loc  .  newName  =  getName' @lhs.names @nm
  | App         lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval        lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call        lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | FetchNode   lhs  .  grTrf    =  GrExpr_FetchNode  @newName
  | FetchField  lhs  .  grTrf    =  GrExpr_FetchField @newName @offset @mbTag
  | UpdateUnit  lhs  .  grTrf    =  GrExpr_UpdateUnit @newName @val.grTrf
  | FetchUpdate lhs  .  grTrf    =  GrExpr_FetchUpdate  (getName' @lhs.names @src)(getName' @lhs.names @dst)
  | FFI         lhs  .  grTrf    =  GrExpr_FFI     @nm (map (getName' @lhs.names) @argL) @tagL.grTrf
  | Throw       lhs  .  grTrf    =  GrExpr_Throw   @newName
  | Catch       lhs  .  grTrf    =  GrExpr_Catch   @body.grTrf (getName' @lhs.names @arg) @handler.grTrf

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @moduleNm @globalL.grTrf @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.names) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.names) @applyTagMp
%%]

%%[8 hs
newMap map (k, EvApTagVar nm) = (k, EvApTagVar $ getName' map nm)
newMap map x                  = x

getName' :: IdentNameMap -> HsName -> HsName
getName' (names, m) nm@(HNmNr i Nothing    ) = nm
getName' (names, m) nm@(HNmNr i (Just orig)) = orig
getName' (names, m) nm@(HNPos p) = nm
getName' (names, m) nm@(HNm s) = error $ "findNewVar: name: " ++ s

type IdentNameMap   = (Array Int HsName, Map.Map Int Int)

mergeRenameMap :: IdentNameMap -> RenameMap -> IdentNameMap
mergeRenameMap (a,m) rm = (a,foldl addToMap m rm)
    where
    addToMap m (orig,vars) = foldl (\m v -> Map.insert v orig m) m vars

%%]
