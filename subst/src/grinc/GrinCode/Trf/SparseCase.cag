Sparse case optimisation: remove alternatives with the use of the hpt info 

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.SparseCase} import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(sparseCase)
sparseCase :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
sparseCase (input,unique,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  (grTrf_Syn_GrAGItf syn, unique, hptMap)
%%]

%%[8
ATTR GrAGItf [ hptMap: HptMap | | grTrf: GrModule ]
ATTR AllNT [ hptMap: HptMap | | grTrf: SELF ]
%%]

%%%%%%%%%%%%%%%%%%%
%%% Spares Case %%%
%%%%%%%%%%%%%%%%%%%

%%[8.spareCase
ATTR AllAlt [ possibleTags: {[GrTag]} | | ]
ATTR GrAlt [ | | isPossible: Bool ]

SEM GrAltL
  | Cons  lhs  .  grTrf       =  if @hd.isPossible then @hd.grTrf : @tl.grTrf else @tl.grTrf

SEM GrAlt
  | Alt   lhs  .  isPossible  =  @pat.tag `elem` @lhs.possibleTags
                                 || @pat.tag == GrTag_Unboxed

SEM GrExpr
  | Case  altL  .  possibleTags  =  getTags . getEnvVar @lhs.hptMap $ @val.varId
%%]

%%[8.tag
ATTR GrPatAlt [ | | tag: GrTag ]
SEM GrPatAlt 
  | Tag           lhs  .  tag  =  @tag.grTrf
  | Node          lhs  .  tag  =  @tag.grTrf
  | * - Node Tag  lhs  .  tag  =  error "no supported tag in pattern alternative"
%%]

%%[8.val
ATTR GrVal [ | | varId: Int ]

SEM GrVal
  | Var          lhs  .  varId  =  getNr @nm
  | * - Var      lhs  .  varId  =  error "not a simple variable as scrutinizer"
  
%%]
