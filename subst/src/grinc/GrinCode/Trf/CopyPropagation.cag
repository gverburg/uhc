%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]
%%[8 import({GrinCode/AbsSyn})
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.CopyPropagation} import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}, Data.Maybe, qualified Data.Map as Map) export(propagate)

{-
 Try to shortcut two sorts of copying:
  "Left unit law":  Transform   unit v ; \p -> e   into   e [v/p]
  "Right unit law": Transform   e ; \p -> unit p   into   e
 Left transformation is not possible if v is a single variable and p is a node
-}

propagate :: GrModule -> (Bool, GrModule)
propagate grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                       (Inh_GrAGItf)
                  in (changed_Syn_GrAGItf t, grTrf_Syn_GrAGItf t)
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT   [ | | grTrf: SELF     ]
ATTR GrAGItf GrModule AllBind GrExpr AllAlt [ | | changed USE {||} {False}: Bool ]

SEM GrExpr
  | Seq loc   .  mbLeft   =  testLeft @pat.grTrf @expr.mbUnitValue     -- test if left-law is applicable, and determine the substitution to be used
        loc   .  isLeft   =  isJust @loc.mbLeft
        loc   .  isRight  =  testRight @pat.grTrf @body.mbUnitValue    -- test if right-law is applicable
        lhs   .  changed  =  @expr.changed || @body.changed || @loc.isLeft || @loc.isRight
        body  .  subst    =  maybe id id @loc.mbLeft $ @lhs.subst      -- merge substitution neccessary for left-law with inherited substitution
        lhs   .  grTrf    =  if @loc.isLeft            -- first try left-law
                              then @body.grTrf         -- if it is possible, @expr can be ignored because it contains the copied unit
                              else if @loc.isRight     -- otherwise try right-law
                                    then @expr.grTrf   -- if it is possible, @body can be ignored because it contains the copied unit
                                    else @loc.grTrf    -- no transformations possible
%%]

%%%%%%%%%%%%%%%%%%%%%%
%%% Right Unit law %%%
%%%%%%%%%%%%%%%%%%%%%%
%%[8.rightUnit hs

testRight :: GrPatLam -> Maybe GrVal -> Bool
testRight pat mbVal
   =  maybe False (testR pat) mbVal

testR :: GrPatLam -> GrVal -> Bool
testR pat val
   =  case pat of
       GrPatLam_Empty      -> case val of
                               GrVal_Empty      -> True
                               _                -> False
       GrPatLam_Var     v  -> case val of
                               GrVal_Var x      -> v==x
                               _                -> False
       GrPatLam_VarNode vs -> case val of
                               GrVal_Node t  xs -> equalNodes vs (GrVal_Tag t:xs)
                               GrVal_VarNode xs -> equalNodes vs              xs
                               _                -> False

equalNodes :: [GrVar] -> [GrVal] -> Bool
equalNodes []     []      =  True
equalNodes []     xs      =  False
equalNodes ps     []      =  False
equalNodes (p:ps) (x:xs)  =  equalVars p x && equalNodes ps xs

equalVars :: GrVar -> GrVal -> Bool
equalVars (GrVar_KnownTag t1) (GrVal_Tag t2) =  t1==t2
equalVars (GrVar_Var v1)      (GrVal_Var v2) =  v1==v2
equalVars _                   _              =  False

%%]

%%%%%%%%%%%%%%%%%%%%%
%%% Left Unit law %%%
%%%%%%%%%%%%%%%%%%%%%

%%[8.leftUnit hs
testLeft :: GrPatLam -> Maybe GrVal -> Maybe SubstTrafo
testLeft pat mbVal
  =  do { val <- mbVal
        ; testL pat val
        }

testL :: GrPatLam -> GrVal -> Maybe SubstTrafo
testL pat val
  = case pat of
      GrPatLam_Empty      -> case val of
                              GrVal_Empty         -> Just id
                              _                   -> error "CopyProp: left: empty-pattern does not match"
      GrPatLam_Var     v  ->                         Just (Map.insert v val)
      GrPatLam_VarNode vs -> case val of
                              GrVal_Var      _    -> Nothing
                              GrVal_Node     t xs -> Just (unifyNodes vs (GrVal_Tag t:xs))
                              GrVal_VarNode    xs -> Just (unifyNodes vs              xs )
                              _                   -> error "CopyProp: left: node-pattern does not match"
                              
unifyNodes :: [GrVar] -> [GrVal] -> Substitution -> Substitution
unifyNodes []     []     s  =  s
unifyNodes []     xs     s  =  s  -- ignore superfluous values
unifyNodes ps     []     s  =  error "CopyProp: unify: too many patterns"
unifyNodes (p:ps) (x:xs) s  =  unifyNodes ps xs (unifyVars p x s)
                              
unifyVars :: GrVar -> GrVal -> Substitution -> Substitution
unifyVars GrVar_Ignore        _              s              =  s
unifyVars (GrVar_KnownTag t1) (GrVal_Tag t2) s | t1==t2     =  s
                                               | otherwise  =  error "CopyProp: unify: tags do not match"
unifyVars (GrVar_KnownTag _ ) _              s              =  s
unifyVars (GrVar_Var v1)      x              s              =  Map.insert v1 x s
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Value Information %%%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.valueInfo
ATTR GrExpr [ | | mbUnitValue : {Maybe GrVal} ]

SEM GrExpr
  | Unit       loc  .  mbUnitValue = Just @val.grTrf
  | * - Unit   loc  .  mbUnitValue = Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Apply substitutions
%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs
type Substitution = Map.Map HsName GrVal
type SubstTrafo = Substitution -> Substitution

getHsName nm subst 
  =  case Map.lookup nm subst of
      Nothing    -> nm
      Just repl  -> case repl of
                      GrVal_Var v -> v
                      _           -> nm
%%]
%%[8.applySubstitutions
ATTR AllExpr [ subst: Substitution | | ]

SEM GrVal
  | Var      lhs  .  grTrf  =  Map.findWithDefault   @grTrf @nm @lhs.subst
  | Node     lhs  .  grTrf  =  GrVal_Node @tag.grTrf @fldL.grTrf
  | VarNode  lhs  .  grTrf  =  GrVal_VarNode         @fldL.grTrf

SEM GrExpr
  | FetchNode  lhs  .  grTrf  = GrExpr_FetchNode  (getHsName @nm @lhs.subst)
  | FetchField lhs  .  grTrf  = GrExpr_FetchField (getHsName @nm @lhs.subst) @offset @mbTag
  | FFI        lhs  .  grTrf  = GrExpr_FFI @nm (map (flip getHsName @lhs.subst) @argL) @tagL.grTrf

SEM GrBind
  | Bind  expr . subst     = Map.empty
SEM GrGlobal
  | *     loc  . subst     = Map.empty
%%[[10
SEM GrAdapt
  | *     loc  . subst     = Map.empty
SEM GrSplit
  | *     loc  . subst     = Map.empty
%%]]
%%]
