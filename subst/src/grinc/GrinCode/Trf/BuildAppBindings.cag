The input contains nodes with an A/apply tags and a variable number of fields. 
The first field always represents the function to be applied, the other fields are arguments for this function.
This transformation replaces the tag with a tag that also encodes the number of arguments.
Examples:
  (A/apply f a1 a2 a3)  ==>  (A/app3 f a1 a2 a3)
  (A/apply f a1 a2)     ==>  (A/app2 f a1 a2)
  (A/apply f a1)        ==>  (A/app1 f a1)

The transformation also builds new functions app1, app2, app3 ...
for all number of arguments for which A tags exist.


%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.BuildAppBindings} import(qualified Data.Set as Set)
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(buildAppBindings)

buildAppBindings :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
buildAppBindings (code,unique,hptMap)
  = let inh = Inh_GrAGItf {unique_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf code)) inh
    in  (grTrf_Syn_GrAGItf syn, unique_Syn_GrAGItf syn, hptMap)

%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF ]

ATTR GrAGItf GrModule [ | unique: Int | ]
%%]

%%[8.retrieveApplyNodeSizes
ATTR AllBind AllGrExpr [ | applyNodeSizes: {Set.Set Int} | ]

SEM GrModule
  | Mod           bindL  .  applyNodeSizes  = Set.empty

SEM GrExpr
  | Store  lhs . applyNodeSizes = maybe @lhs.applyNodeSizes (\e -> Set.insert e @lhs.applyNodeSizes) @val.applyNodeSize

SEM GrVal [ | | applyNodeSize: {Maybe Int} ]
  | Node          loc  . fieldCount             =  @fldL.fieldCount
  | Tag           loc  . fieldCount             =  0
  | Node Tag      lhs  .  applyNodeSize         =  if @tag.isGenApplyTag
                                                   then Just @fieldCount
                                                   else Nothing
  | * - Node Tag  lhs  .  applyNodeSize         =  Nothing

SEM GrValL [ | | fieldCount: Int ]
  | Cons  lhs  .  fieldCount  =  1 + @tl.fieldCount
  | Nil   lhs  .  fieldCount  =  0

SEM GrTag [ | | isGenApplyTag : Bool ]
  | App      lhs  .  isGenApplyTag  =  @nm == HNm "!apply"
  | * - App  lhs  .  isGenApplyTag  =  False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replace A/apply wit A/appN %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%[8.replaceApplyTags
SEM GrVal
  | Node Tag  loc  . appTag      = size2tag (@fieldCount - 1)
                   . newTag      = if @tag.isGenApplyTag then @appTag else @tag.grTrf
  | Node      lhs  . grTrf       = GrVal_Node @newTag @fldL.grTrf
  | Tag       lhs  . grTrf       = GrVal_Tag @newTag
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Building the appN bindings %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.buildAppBinding hs
buildAppBinding unique size = let funcNr  = unique
                                  minArg  = funcNr + 2
                                  maxArg  = minArg + size
                                  unique' = maxArg + 2
                                  funcName                  = HNmNr funcNr (Just origFuncName)
                                  origFuncName              = HNm $ "app" ++ show size
                                  args@(partialApp:appArgs) = map (\n->HNmNr n Nothing) [minArg .. maxArg]
                                  evalPartialApp            = HNmNr (maxArg + 1) Nothing
                                  code = GrBind_Bind funcName args body
                                  body = GrExpr_Seq (GrExpr_Eval partialApp)
                                                    (GrPatLam_Var evalPartialApp)
                                                    (GrExpr_App evalPartialApp $ map GrVal_Var appArgs)
                              in (unique', origFuncName, funcName, code)

size2tag size = GrTag_App (HNm $ "app" ++ show size)

node2app size (unique, origNamesMap, evalMap, bindings) =
    let key = (size2tag (size-1), size)
        (unique', origFuncName, funcName, code) = buildAppBinding unique (size-1)
        origNameMap = (funcName, origFuncName)
        evalMapElem = (key, EvApTagVar funcName)

    in (unique', origNameMap:origNamesMap, evalMapElem:evalMap, code:bindings)
%%]

%%[8.addAppBindings
SEM GrModule
  | Mod  loc  . (unique', origNamesMap, evalTagMp', binds)  = foldr node2app
                                                                    (@lhs.unique, [], @evalTagMp, @bindL.grTrf)
                                                                    (Set.elems @bindL.applyNodeSizes)
         lhs  . unique = @unique'
         lhs  . grTrf  = GrModule_Mod @moduleNm @globalL.grTrf @binds @ctagsMp @evalTagMp' @applyTagMp
%%]
