Restores the right skewed property of the bind (Seq) operator:
	In a GrExpr_Seq the expr field shall not contain a GrExpr_Seq constructor.

(m ; \a -> k a) ; \b -> h b  =>  m; \a -> (k a ; \b -> h b)

Seq (Seq m a k) b h
Seq m a (Seq k b h)

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.RightSkew} import({%{EH}Base.Common}, {%{EH}GrinCode}) export(rightSkew)
rightSkew :: GrModule -> (GrModule, Bool)
rightSkew grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                    in (grTrf_Syn_GrAGItf t, active_Syn_GrAGItf t)
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF     ] 
ATTR AllNT [ | | copy:  SELF     ]
ATTR AllGrExpr AllBind GrModule GrAGItf [ | | active USE {||} {False} : Bool ]
%%]

The copy is needed to implement the transformation in a top down fashion rather
than bottom up. This saves needless movements.  (If the tree is left skewed
more than one deep.)

1 deep:
Seq (Seq m a k) b h
Seq m a (Seq k b h)

2 deep - top down:
Seq (Seq (Seq m c l) a k) b h
run one:
Seq (Seq m c l) a (Seq k b h)
run two:
Seq m c (Seq l a (Seq k b h))

2 deep - bottom up:
Seq (Seq (Seq m c l) a k) b h
run one:
Seq (Seq m c (Seq l a k)) b h
Seq m c (Seq (Seq l a k) b h)
run two:
Seq m c (Seq l a (Seq k b h))

%%[8.rightSkew
SEM GrExpr
  | Seq  lhs  . (active, grTrf) = case @expr.copy of
                                      GrExpr_Seq e p b -> (True , GrExpr_Seq e p (GrExpr_Seq b @pat.grTrf @body.grTrf))
                                      otherwise        -> (@active, @grTrf)
         loc  . active          = @expr.active || @body.active
%%]
