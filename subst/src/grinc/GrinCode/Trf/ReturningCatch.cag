Returning catch operation introduces a unit operation after a catch at the
return spine.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.ReturningCatch} import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(returnCatch)

returnCatch :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
returnCatch (input,unique,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap, uniq_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  (grTrf_Syn_GrAGItf syn, uniq_Syn_GrAGItf syn, hptMap)

%%]

%%[8
ATTR GrAGItf [ hptMap: HptMap | uniq: Int | grTrf: GrModule ]
ATTR AllNT [ hptMap: HptMap | uniq: Int | grTrf: SELF ]
%%]

%%[8.catch import({GrinCode/LastExpr})

ATTR AllGrExpr [ size: {Int} | | ]
SEM GrBind
  | Bind    loc  .  size = foldl (\len (tag,fields) -> (length fields) `max` len) 0 $ getNodes (getEnvVar @lhs.hptMap (getNr @nm))

SEM GrExpr
  | Catch   loc  .  tag         =  GrTag_Var (HNmNr @handler.uniq Nothing)
                 .  vars        =  take @lhs.size (map (\n->HNmNr n Nothing) [@handler.uniq+1 ..])
                 .  pattern     =  GrPatLam_Node @tag @vars
                 .  value       =  GrVal_Node @tag (map GrVal_Var @vars)
                 .  appendUnit  =  GrExpr_Seq @grTrf @pattern (GrExpr_Unit @value)
            lhs  .  grTrf       =  if @lhs.hasNext then @grTrf else @appendUnit
                 .  uniq        =  if @lhs.hasNext then @handler.uniq else @handler.uniq + 1 + @lhs.size
%%]
