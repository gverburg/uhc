%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}GrinCode.ToSilly} export(grin2silly)
%%]

%%[8 hs import(EH.Util.Pretty, {%{GRIN}GRINCCommon} hiding (Variable(..)), Data.List(nub), Data.Maybe, {%{EH}GrinCode}, {%{GRIN}Config})
%%]
%%[8 hs import({%{GRIN}Silly})
%%]
%%[8 hs import(EH.Util.Utils,{%{EH}Base.Common} hiding "((<+>))")
%%]
%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Bits)
%%]
%%[8 hs import({%{EH}Base.Opts})
%%]
%%[8 import({GrinCode/AbsSyn})
%%]
%%[8 import({GrinCode/LastExpr})
%%]
%%[8 hs import(Debug.Trace)
%%]

%%[20 hs import(qualified Data.Set as Set, Data.Bits)
%%]

%%[8
WRAPPER GrAGItf
%%]

%%[8 hs
grin2silly :: HptMap -> GrModule -> EHCOpts -> SilModule
grin2silly hptmap gr opts
 = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr))
                        (Inh_GrAGItf { opts_Inh_GrAGItf = opts
                                     , hptMap_Inh_GrAGItf = hptmap
                                     }
                        )
   in silModule_Syn_GrAGItf t 
%%]

%%[20 hs import({%{EH}Base.Builtin},{%{GRIN}Config})
-- primitive related names which should be globally available, in unqualified form

primGlobalNames :: Set.Set HsName
primGlobalNames
  = Set.fromList
  $ map (hsnPrefix rtsGlobalVarPrefix . hsnQualified)
  $ [ hsnTrue, hsnFalse
%%[[99
    , hsnDataOrderingAltEQ, hsnDataOrderingAltLT, hsnDataOrderingAltGT
%%]]
    ]

hsnToGlobal :: HsName -> HsName
hsnToGlobal n
  = if n2 `Set.member` primGlobalNames then n2 else n
  where n2 = hsnQualified n
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR GrAGItf GrModule GrGlobalL GrGlobal GrBindL GrBind GrExpr GrAlt GrAltL [ hptMap : {HptMap} | | ]

ATTR GrAGItf GrModule   [ | | silModule                  : {SilModule}    ]
ATTR GrBindL GrBind     [ | | functions    USE {++} {[]} : {Functions}    ]
ATTR GrExpr             [ | | stats        USE {++} {[]} : {Statements}   ]
ATTR GrAltL             [ | | alternatives               : {Alternatives} ]
ATTR GrAlt              [ | | alternative                : {Alternative}  ]
ATTR GrVal GrPatAlt GrTag  [ | | value                      : {Value}        ]
ATTR GrPatAlt GrTag        [ | | constant                   : {Constant}     ]
ATTR GrValL GrVal       [ | | values                     : {Values}       ]
ATTR GrGlobal GrGlobalL [ | | initStats    USE {++} {[]} : {Statements}
                              names        USE {++} {[]} : {[HsName]}     ]

ATTR GrExpr GrAlt GrAltL [ numberParameters : {Int}
                         |
                         | localsSet USE {`Set.union`} {Set.empty}: {Set.Set HsName}
                           tailJumps USE {&&} {True} : {Bool}
                         ]

ATTR GrBindL GrBind GrExpr GrAlt GrAltL GrGlobal GrGlobalL [ maxConstrParameters : {Int} | | ]

ATTR GrTagL [ | | mbOnlyTagValue : {Maybe Value}  isEmpty : {Bool} ]

ATTR GrAlt GrAltL [ | | hasAnies USE {||} {False} : {Bool} ]
ATTR GrPatAlt GrTag  [ | | isAny: {Bool} ]
ATTR GrTag GrVal  [ | | isUnboxed: {Bool} ]

SEM GrTagL
  | Nil            lhs . isEmpty        = True
                   lhs . mbOnlyTagValue = Nothing
  | Cons           lhs . isEmpty        = False
                   lhs . mbOnlyTagValue = if @tl.isEmpty
                                           then Just @hd.value
                                           else Nothing

SEM GrAlt
  | Alt            loc . hasAnies = @pat.isAny
 
SEM GrTag
  | Any            lhs . isAny = True
  | * - Any        lhs . isAny = False
  | Unboxed        lhs . isUnboxed = True
  | * - Unboxed    lhs . isUnboxed = False

SEM GrVal
  | Node           lhs . isUnboxed = @tag.isUnboxed
  | * - Node       lhs . isUnboxed = False

SEM GrPatAlt
  | Tag            lhs . isAny = @tag.isAny
  | * - Tag        lhs . isAny = False
  

ATTR GrValL [ | | length : {Int} ]
SEM GrValL
  | Nil lhs.length = 0
  | Cons lhs.length = 1 + @tl.length


ATTR GrBind GrBindL GrExpr GrAlt GrAltL
         [  |  retNr : {Int} |  ]



ATTR GrExpr GrAltL GrAlt
  [ realNodes: {[HsName]} | | ]
  
ATTR GrExpr
  [  | | mbExtraRealNode: {Maybe HsName} ]


SEM GrExpr
  | FetchField      lhs.mbExtraRealNode = if  @offset==0
                                           then Just @nm
                                           else Nothing
  | * - FetchField  lhs.mbExtraRealNode = Nothing
  
SEM GrExpr
  | Seq             body.realNodes      = maybe id (:) @expr.mbExtraRealNode $ @lhs.realNodes

SEM GrBind
  | Bind            expr.realNodes      = []




%%]

%%[8
SEM GrModule
  | Mod lhs.silModule    =   SilModule_SilModule
                                (tagConstants1 (tagConstants2 @ctagsMp) @evalTagMp)    -- constants
                                @globalL.names              -- variables
                                ( Function_Function (HNm "initialize") False [] []
                                                    ( @globalL.initStats
                                                    ++ (if @lhs.optOwn>=1
                                                         then [ Statement_Assignment Variable_SP (Value_Offset Variable_BP (0+2)) ]
                                                         else []
                                                       )
                                                    ++ [ Statement_Return 1 ]
                                                    )
                                : @bindL.functions            -- functions
                                )

        loc . maxConstrParameters = foldr max 0 (map (ctagArity.snd) (concat (map snd @ctagsMp)))
        bindL . retNr   = 3



SEM GrBind
  | Bind   lhs.functions =  [ Function_Function
                                -- name
                                @nm
                                @expr.tailJumps
                                -- parameters
                                @argNmL
                                -- locals
                                @loc.locals
                                -- body
                                @expr.stats
                            ]

          expr . numberParameters = length @argNmL
          loc  . locals  = filter (\(HNmNr n _)->n/=0) (Set.toList @expr.localsSet)
          loc  . nParams      = if @lhs.optOwn>=1 then length @argNmL else 0
          

SEM GrExpr
 | Seq     lhs.stats  = @expr.stats
                        ++ @body.stats

 | UpdateUnit
           loc.name   = mkVar @nm
           loc.overwr = if @val.isUnboxed
                          then [ Statement_Assignment @loc.name (Value_UnboxCon (head(tail @val.values))) ]
                          else []
                                
           lhs.stats   = if @isLastExpr
                          then internal2 "Update" @loc.name @val.values
                               ++ @loc.overwr
                               ++ yielding "Unit" (@lhs.optOwn>=1) @val.values @lhs.numberParameters
                          else 
                               []
                               -- ++ internal2 "Update" @loc.name @val.values
                               -- ++ internal1 "Unit" @lhs.targets @val.values 
                               ++ internal3 "UpdateUnit" @loc.name @lhs.targets @val.values
                               ++ @loc.overwr                         

 | Unit    lhs.stats  = if @isLastExpr
                          then yielding  "Unit" (@lhs.optOwn>=1) @val.values @lhs.numberParameters
                          else internal1 "Unit" @lhs.targets @val.values

 | FFI     lhs.stats  = if @isLastExpr
                         then yielding  "FFI" (@lhs.optOwn>=1) @loc.callres @lhs.numberParameters
                         else internal1 "FFI" @lhs.targets @loc.callres

           lhs.localsSet = Set.fromList @lhs.targets
           loc.callres = maybe id (:) @tagL.mbOnlyTagValue $ [Value_Call @nm (map (Value_Var . mkVar) @argL)]


 | Store   lhs.stats  = let ph = head @lhs.targets
                            vs = @val.values
                            n  = length vs
                            --n2 = @lhs.maxConstrParameters
                            n2 = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap ph)))
                        in Statement_Comment ["Store"]
                           : store (mkVar ph) n n2 vs

           lhs.localsSet = Set.fromList @lhs.targets

 | FetchUpdate 
           lhs.stats  = let -- use hptMap to determine size, because hptMap can now be used even after changing numbered variables back to names
                            n = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap @src)))
                         in Statement_Comment ["FetchUpdate"]
                            : zipWith Statement_Assignment
                                     (map (arrayVariab (mkVar @dst)) [0..n])
                                     (map (arrayValue  (mkVar @src)) [0..n])



 | FetchNode
           lhs.stats  = error "FetchNode found while generating Silly"
           lhs.localsSet= error "FetchNode found while generating Silly"
           
 | FetchField
           lhs.stats  = [ Statement_Comment ["Fetch"]
                        , Statement_Assignment (mkVar (head @lhs.targets))
                                               (if   @offset==1 && maybe False (==GrTag_Unboxed) @mbTag && not (elem @nm @lhs.realNodes)
                                                then Value_BoxVar (mkVar @nm)
                                                else arrayValue (mkVar @nm) @offset
                                               )
                        ]
           lhs.localsSet = Set.fromList @lhs.targets

 | Case    lhs.stats  = [ Statement_Comment ["Case"]
                        , if @altL.hasAnies

                           then Statement_If     @val.value

                                                 @altL.alternatives

                           else Statement_Switch @val.value

                                                 @altL.alternatives
                        ]
                        
           lhs.localsSet = Set.union (Set.fromList @lhs.targets) @altL.localsSet

 | Call    lhs.stats  = if @isLastExpr && @lhs.optOwn>=1
                         then [ Statement_Comment ["Call (Tail) "]
                              , Statement_Smart (reverse @argL.values ++ map (Value_Var . Variable_Subs Variable_BP) [1, 0] )
                              , Statement_Assignment  Variable_SP (Value_Offset Variable_BP (@lhs.numberParameters+2- @loc.nMyParams-2))
                              , Statement_Jump @nm
                              ]
                         else (   Statement_Comment ["Call (Normal)"]
                              :   (if @lhs.optOwn>=1
                                   then (  zipWith Statement_Assignment
                                                   (map (arrayVariab Variable_SP) [-1,-2..])
                                                   (  reverse @argL.values
                                                   ++ [ if @lhs.optOwn>=3 
                                                         then Value_Label @loc.label
                                                         else Value_Con (Constant_LiteralInt 0)
                                                      , Value_Cast (Value_Offset Variable_BP 0) True
                                                      ]
                                                   )
                                        ++ [ Statement_Assignment  Variable_SP (Value_Offset Variable_SP (- @loc.nMyParams-2))
                                           , Statement_Call @nm [] 
                                           ]
                                        ++ if @lhs.optOwn>=3
                                            then [ Statement_Label @loc.label ]
                                            else []
                                        )
                                   else [Statement_Call @nm @argL.values ]
                                  )
                              ++ [ Statement_Assignment v e
                                 | (v,e) <-zip  [mkVar x  | x <- @lhs.targets]
                                                ( if @lhs.optOwn>=1
                                                   then map (arrayValue Variable_SP) [-1,-2..]
                                                   else map (arrayValue Variable_RP) [0..]
                                                )
                                 , isRealVar v
                                 ]
                              )

           loc.nMyParams = @argL.length
           lhs.localsSet = Set.fromList @lhs.targets
           lhs.retNr     = @lhs.retNr + 1
           loc.label     = "retlab"++show @lhs.retNr

 | App     lhs.stats  = [Statement_Comment ["App: SHOULDNT"]]
 | Eval    lhs.stats  = [Statement_Comment ["Eval: SHOULDNT"]]
 | Throw   lhs.stats  = [Statement_Comment ["Throw: TODO"]]
 | Catch   lhs.stats  = [Statement_Comment ["Catch: TODO"]]


SEM GrAltL
  | Nil    lhs.alternatives = []
  | Cons   lhs.alternatives = @hd.alternative : @tl.alternatives

SEM GrAlt
 | Alt     lhs.alternative = Alternative_Alternative @pat.constant
                                                     @expr.stats


SEM GrGlobal
%%[[8
 | Global  loc.globNm      = @nm
%%][20
 | Global  loc.globNm      = hsnToGlobal @nm
%%]]
 		   lhs.names       = [@globNm]
           lhs.initStats   = let vs = @val.values
                                 n  = length vs
                                 n2 = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap @globNm)))
                             in  store (Variable_Global @globNm) n n2 vs



SEM GrVal
 | LitInt  lhs.value  = Value_Con (Constant_LiteralInt @int)
 | LitStr  lhs.value  = Value_Con (Constant_LiteralStr @str)
%%[[8
 | Var     loc.value  = Value_Var (mkVar @nm)
%%][20
 | Var     loc.value  = Value_Var (mkVar (hsnToGlobal @nm))
%%]]
           lhs.value  = @loc.value
           lhs.values = [@loc.value]
 | Tag     lhs.value  = @tag.value
 | Node    lhs.values = @tag.value : @fldL.values
 | VarNode lhs.values =              @fldL.values
 | Node    lhs.value  = @tag.value                            -- TODO: why does this not need the values of fldL? can this be removed after CopyPropgation is repaired?
 | * - LitInt LitStr Var Tag Node
           lhs.value  = error "GrVal:other value"
 | * - Node VarNode Var
           lhs.values = error "GrVal:other values"

SEM GrValL
 | Nil    lhs.values = []
 | Cons   lhs.values = @hd.value : @tl.values

SEM GrTag
 | Con     loc.constant = Constant_Alias ("C" ++ hsnShowAlphanumeric @nm)
 | Fun     loc.constant = Constant_Alias ("F" ++ hsnShowAlphanumeric @nm)
 | PApp    loc.constant = Constant_Alias ("P" ++ show @needs ++ "_" ++ hsnShowAlphanumeric @nm)
 | Con Fun PApp
           lhs.constant = @loc.constant
           lhs.value    = Value_Con (@loc.constant)
 | Unboxed lhs.value    = Value_Con (Constant_Alias "UNBOXED")
 | Any     lhs.value    = error "GrTag:Any value"
 | Unboxed lhs.constant = Constant_Alias "UNBOXED"
 | Any     lhs.constant = Constant_Alias "ANY"
 | * - Con Fun PApp Unboxed Any
           lhs.constant = error "GrTag:other constant"
           lhs.value    = error "GrTag:other value"

SEM GrPatAlt
 | Tag     lhs.value    = @tag.value
           lhs.constant = @tag.constant
 | * - Tag lhs.value    = error "GrPatAlt:other value"
           lhs.constant = error "GrPatAlt:other constant"
-- TODO: | LitInt = ...



SEM GrExpr
 | Seq     lhs.tailJumps = @body.tailJumps
 | Call    lhs.tailJumps = @isLastExpr && @lhs.optOwn>=1
 | Case    lhs.tailJumps = @altL.tailJumps
 | * - Seq Call Case
           lhs.tailJumps = False


%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determining the target
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR AllGrExpr [ targets : {[HsName]} | | ]
ATTR GrPatLam GrVarL [ | |  patternNames: {[HsName]} ]
ATTR GrVar [ | |  patternName: {HsName} ]

SEM GrBind
  | Bind     expr . targets = []

SEM GrExpr
  | Seq      expr . targets = @pat.patternNames
             body . targets = @lhs.targets

SEM GrPatLam
  | Var     lhs  .  patternNames = [@nm]
--  | Node    lhs  .  patternNames = wildcardNr : @fldL
  | VarNode lhs  .  patternNames = @fldL.patternNames
--  | Tag     lhs  .  patternNames = [wildcardNr]
  | * - Var VarNode lhs  .  patternNames  =  []
--  | * - Var Node VarNode Tag lhs  .  patternNames  =  []

SEM GrVarL
  | Nil   lhs.patternNames = []
  | Cons  lhs.patternNames = @hd.patternName : @tl.patternNames
  
SEM GrVar
  | Var      lhs.patternName = @nm
  | KnownTag lhs.patternName = wildcardNr
  | Ignore   lhs.patternName = wildcardNr

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8


ATTR GrAGItf
  [ opts : {EHCOpts} | | ]

ATTR GrModule GrBind GrBindL GrExpr GrAlt GrAltL
  [ optOwn : {Int}   | | ]

SEM GrAGItf
  | AGItf loc.optOwn  = ehcOptOwn @lhs.opts

%%]





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Auxiliary Haskell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

yielding what own values numberParameters
  =  let nMyRes  = length values
         moveRet = nMyRes > numberParameters
     in  Statement_Comment [what ++ " (Yielding)"]
         : if own
            then [ Statement_Smart (values ++ [Value_Var (Variable_Subs Variable_BP 1) | moveRet])
                 , Statement_Assignment Variable_SP (Value_Offset Variable_BP (numberParameters+2))
                 , Statement_Return (max nMyRes numberParameters + 1)
                 ]
            else [ Statement_Assignment v e
                 | (v,e) <-zip [arrayVariab Variable_RP i | i <- [0..] ]
                               values
                 ]

internal1 what targets values
   = Statement_Comment [what ++ " (Internal)"]
     : [ Statement_Assignment v e
       | (v,e) <-zip [mkVar x | x <- targets]
                     values
       , isRealVar v
       ]                         

internal2 what name values
  =  Statement_Comment [what] 
     :  
     --Statement_Assignment Variable_Ptr (Value_Var @loc.name) :           -- if this line is enabled, uses option 2 instead of option 1
     zipWith Statement_Assignment
             (map (arrayVariab name) [0..])                                -- option 1
             --(map (Variable_Subs Variable_Ptr) [0..])   -- option 2
             values
                        

internal3 what name targets values
  = Statement_Comment [what] 
    :
    [ if isRealVar v1
       then (if isRealVar v2
              then Statement_Assignment2 v2 v1 e
              else Statement_Assignment v1 e
            )
       else Statement_Assignment v2 e
    | (v1,v2,e) <-zip3 (map (arrayVariab name) [0..])
                       [mkVar x | x <- targets]
                       values
    , isRealVar v1 || isRealVar v2
    ]













isRealVar Variable_None = False
isRealVar (Variable_Unembedded (HNmNr 0 _)) = False
isRealVar _             = True

-- n1 is the number of parameters of the tag
-- n2 is the maximum number of parameters of all constructorfunctions
-- tags other than C may be overwritten later with a C-tag, which might have more parameters.
-- We anticipate here for the maximum number of parameters.
-- Obvious improvement: do not take the global maximum, but only the maximum over the constructors
-- that are actually possible for this function.
-- Source of this information could be the Haskell-type, or the Grin HPT-analysis.

allocate :: Char -> Int -> Int -> Value
allocate 'C' n1 _  = Value_Alloc n1
allocate _   n1 n2 = Value_Alloc (max n1 n2)
       
-- tagcat is "C" for constructors, "F" for function thunks, "P" for partialapp thunks, "U" for unboxed, etc.
tagcat :: [Value] -> Char
tagcat (Value_Con (Constant_Alias (c:_)):_) = c
tagcat _ = ' '


mkVar :: HsName -> Variable
mkVar = Variable_Unembedded

store :: Variable -> Int -> Int -> [Value] -> Statements
store v n1 n2 vs
       =  let cat = tagcat vs
          in  if    cat=='U'
              then [Statement_Assignment v (Value_UnboxCon (head (tail vs)))]
              else Statement_Assignment v (allocate cat n1 n2)
                   : zipWith Statement_Assignment
                             (map (arrayVariab v) [0..])
                             vs

arrayValue :: Variable -> Int -> Value
arrayValue a i = Value_Var (Variable_Subs a i)

arrayVariab :: Variable -> Int -> Variable
arrayVariab a i = Variable_Subs a i

tagConstants1 :: [(String,Int)] -> EvApTagMp -> [(String,Int)]
tagConstants1 bs eas
 = let m = Map.fromList bs
       f n ((t,s),k) = let nm = showGrTag t
                       in  maybe (nm,n) (\n2->(nm,n2)) (Map.lookup nm m)
   in  zipWith f [0..] eas 

tagConstants2 :: CTagsMp -> [(String,Int)]
tagConstants2 cts
 = let f n (nm,ct) = ('C' : hsnShowAlphanumeric (ctagNm ct), n)
   in  concat (map ((zipWith f [0..]).snd) cts)


showGrTag :: GrTag -> String
showGrTag (GrTag_Con a i nm) = "C" ++ hsnShowAlphanumeric nm
showGrTag (GrTag_Fun nm) = "F" ++ hsnShowAlphanumeric nm
showGrTag (GrTag_PApp n nm) = "P" ++ show n ++ "_" ++ hsnShowAlphanumeric nm
showGrTag (GrTag_App nm) = "A" ++ hsnShowAlphanumeric nm
showGrTag (GrTag_Rec) = "GrTag:Rec"
showGrTag (GrTag_Hole) = "GrTag:hole"
showGrTag (GrTag_Unboxed) = "GrTag:Unboxed"
showGrTag (GrTag_Any    ) = "GrTag:Any"
showGrTag (GrTag_World    ) = "GrTag:World"

%%]
