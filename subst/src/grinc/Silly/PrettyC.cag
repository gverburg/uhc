%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Prettyprint Silly program as C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}Silly.PrettyC} import(Data.List(intersperse), EH.Util.Pretty,  qualified Data.Map as Map, {%{GRIN}GRINCCommon} hiding (Variable(..)),{%{GRIN}Silly}, {%{GRIN}BuiltinPrims}, {%{GRIN}Config}) export(prettyC)
%%]
%%[8 hs import({%{EH}Base.Common})
%%]
%%[8 hs import({%{EH}Base.Opts})
%%]
%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyC :: EHCOpts -> SilModule -> PP_Doc
prettyC opts silmod
  = let t = wrap_SilModule (sem_SilModule silmod)
                           (Inh_SilModule { opts_Inh_SilModule = opts
                                          }
                           )
     in  prettyC_Syn_SilModule t

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

ATTR SilModule
  [ opts : {EHCOpts} | | ]

ATTR Functions Function Statements Statement Alternatives Alternative
  [ optTraceCall     : {Bool} -- when True, function entrance/exit is logged
    optCaseDefault   : {Bool} -- when True, error messages are given as default case for each switch
    optOwn           : {Int}
  | | ]

SEM SilModule
  | SilModule  loc.optTraceCall   = ehcOptGenTrace       @lhs.opts
               loc.optCaseDefault = ehcOptGenCaseDefault @lhs.opts
               loc.optOwn         = ehcOptOwn            @lhs.opts

{
optTraceAssign = False
}
%%]


%%[8
ATTR SilModule Functions Function Statements Statement Alternatives Alternative Value Variable Constant
         [ | | prettyC USE {>-<} {empty} : PP_Doc ]

ATTR Alternatives [ | | prettyTE : PP_Doc   prettyE : PP_Doc ]
ATTR Alternative  [ | | prettyTE : PP_Doc ]

ATTR Functions Function [ | | protoC USE {>-<} {empty} : {PP_Doc} ]

ATTR Values [ | | prettyCs : {[PP_Doc]} ]

ATTR Variable [ | | prettyPtr : {PP_Doc}  ]

SEM SilModule
  | SilModule   lhs.prettyC   = preambule
                                >-< comment ["Tag constants"]
                                >-< constantDefinition ("UNBOXED",1)
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment ["Global table"]
                                >-< ppVertically (map (variableDeclaration.hsnShowAlphanumeric) @variables)
                                >-< text ""
                                >-< comment ["Auxiliary variable"]
                                >-< text "GrWord auxVar;"
                                >-< text "GrWord auxPtr;"
                                >-< text ""
                                >-< comment ["Function definitions"]
                                >-< if @loc.optOwn>=3
                                     then  @loc.silMain1

                                           >-< text ""
                                           >-< @functions.prettyC
                                           >-< @loc.silMain2

                                     else  @functions.protoC
                                           >-< text ""
                                           >-< @loc.silMain1

                                           >-< @loc.silMain2

                                           >-< text ""
                                           >-< @functions.prettyC
                                >-< text ""
                loc.silMain1 =  text "int silly_main()"

                                >-< text "{"
                                >-< ppWhen (@loc.optOwn>=4) (text "register GrWord* SP asm (\"%esp\");")

                                -- >-< ppWhen (@loc.optOwn>=4) (text "register GrWord  auxPtr asm (\"%ecx\");")

                                >-< indent 4 (    callSillyFunctionFromC @loc.optOwn 1 "initialize"

                                             >-<  callSillyFunctionFromC @loc.optOwn 2 "fun_main"
                                             >-<  "if (RP[1]==0) { RP[0] = SP[-1]; RP[1] = SP[-2]; }"
                                             >-<  "return 0;"

                                             )

                loc.silMain2 =  text "}"


SEM Function
  | Function    lhs.prettyC   = methodHeader @lhs.optOwn @lhs.optTraceCall (hsnShowAlphanumeric @name) (map hsnShowAlphanumeric @parameters)
                                >-< indent 4 (   ppWhen @tailJumps jumpPrepare
                                             >-< methodLocals (map hsnShowAlphanumeric @locals)
                                             >-< @body.prettyC
                                             )
                                >-< methodFooter @lhs.optOwn @lhs.optTraceCall (hsnShowAlphanumeric @name)

                lhs.protoC    = methodHead (hsnShowAlphanumeric @name) (map hsnShowAlphanumeric @parameters) >|< ";"

SEM Statement
  | Comment     lhs.prettyC   = comment @comment
  | Assignment  lhs.prettyC   = assignment  @dest.prettyC  @source.prettyC
  | Assignment2 lhs.prettyC   = assignment2 @dest1.prettyC @dest2.prettyC @source.prettyC
  | Switch      lhs.prettyC   = switch @lhs.optCaseDefault @scrutinee.prettyC @body.prettyC
  | If          lhs.prettyC   = ifstat                     @scrutinee.prettyC @body.prettyTE
  | Call        lhs.prettyC   = callSillyFunctionFromSilly @lhs.optOwn (hsnShowAlphanumeric @name) @args.prettyCs
  | Jump        lhs.prettyC   = jumpSillyFunctionFromSilly @lhs.optOwn (hsnShowAlphanumeric @name)
  | Return      lhs.prettyC   = returnFromSillyFunction @retdiff @lhs.optOwn
  | Label       lhs.prettyC   = label @name
  | Smart       lhs.prettyC   = error "Statement_Smart found while generating C"



SEM Alternative
  | Alternative lhs.prettyC   = alternative @when.prettyC @body.prettyC
                lhs.prettyTE  = (text "{" >|< indent 4 @body.prettyC) >-< text "}"

SEM Alternatives
  | Nil         lhs.prettyTE  = error "nil case in prettyTE"
  | Cons        lhs.prettyTE  = @hd.prettyTE >-< text "else" >-< @tl.prettyE
  | Nil         lhs.prettyE   = error "nil case in prettyE"
  | Cons        lhs.prettyE   = @hd.prettyTE
    



SEM Values
  | Nil         lhs.prettyCs  = []
  | Cons        lhs.prettyCs  = @hd.prettyC : @tl.prettyCs

SEM Value
  | Con         lhs.prettyC   = @con.prettyC
  | UnboxCon    lhs.prettyC   = "((" >#< @con.prettyC >#< ")<<1)|1 "
  | BoxVar      lhs.prettyC   = "(" >#< @var.prettyC >#< ")>>1 "
  | Var         lhs.prettyC   = @var.prettyC
  | Offset      lhs.prettyC   = @var.prettyC >|< "+" ++ show @off
  | Cast        lhs.prettyC   = ("((" ++ (if @word then "GrWord" else "Pointer") ++ ")(") >|< @val.prettyC >|< "))"
  | Call        lhs.prettyC   = ( maybe (callCfunction @name)
                                        fromSillyPrim
                                        (lookupPrim BackendSilly @name)  ) @args.prettyCs
  | Alloc       lhs.prettyC   = "heapalloc(" >|< show @size >|< ")"
  | Label       lhs.prettyC   = "((GrWord)(&&" >|< @name >|< "))"

SEM Constant
  | LiteralInt  lhs.prettyC   = text (show @value)
  | LiteralStr  lhs.prettyC   = "((GrWord)" >|< text (show @value) >|< ")"
  | Alias       lhs.prettyC   = text @name

SEM Variable
  | Global
    Local
    Param       lhs.prettyC   = text (hsnShowAlphanumeric @name)
                lhs.prettyPtr = "((Pointer)" >|< text (hsnShowAlphanumeric @name) >|< ")"
  | SP          lhs.prettyC   = text "SP"
                lhs.prettyPtr = text "SP"
  | BP          lhs.prettyC   = text "BP"
                lhs.prettyPtr = text "BP"
  | RP          lhs.prettyC   = text "RP"
                lhs.prettyPtr = text "RP"
  | Subs        lhs.prettyC   =                   @array.prettyPtr >|< "[" >|< show @index >|< "]"
                lhs.prettyPtr = "((Pointer)(" >|< @array.prettyPtr >|< "[" >|< show @index >|< "]" >|< "))"
  | Aux         lhs.prettyC   = text "auxVar"
                lhs.prettyPtr = text "auxVar"
  | Ptr         lhs.prettyC   = text "auxPtr"
                lhs.prettyPtr = text "((Pointer)auxPtr)"
  | None        lhs.prettyC   = error "attempt to use Variable_None as value"
                lhs.prettyPtr = error "attempt to use Variable_None as pointer"
  | Unembedded  lhs.prettyC   = text ("UNEMB " ++ hsnShowAlphanumeric @name)  -- error "attempt to use Variable_Unembedded as value"
                lhs.prettyPtr = error "attempt to use Variable_Unembedded as pointer"


%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Building a C program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs


label :: String -> PP_Doc
label nm 
 = nm >|< ":"
   >|< ppWhen optTraceAssign
              (" printf(\"def label" >#< nm >#< "= %d \\n\",  && " >#< nm >#< "); fflush(stdout);")

commaSeparated :: [String] -> String
commaSeparated = concat . intersperse ", "

macroDefinition :: PP_Doc -> PP_Doc -> PP_Doc
macroDefinition nm body
 = "#define" >#< nm >#< body

declareNames :: String -> [String] -> PP_Doc
declareNames tp ns
 = tp >#< commaSeparated ns >|< ";"

declareName :: String -> String -> String
declareName tp nm
 = tp ++ (' ' : nm)

trace :: String -> PP_Doc
trace s
 = text ("printf(\"" ++ s ++ " SP=%d\\n\", SP-Stack); fflush(stdout);")

caseDefault :: PP_Doc -> PP_Doc
caseDefault x
 =  "default: printf(\"undefined case for " >|< x >|< " : %d\\n\", " >|< x >|< "); exit(1);"

comment :: [String] -> PP_Doc
comment []  = text ""
comment [s] = text ("// " ++ s)
comment xs  = text "/* " >#< foldr1 (>-<) (map text xs) >-< text "*/"

callCfunction ::  String -> [PP_Doc] -> PP_Doc
callCfunction f ps
 = f >|< "(" >|< ppHorizontally (intersperse (text ", ") ps) >|< ")"

callSillyFunctionFromC :: Int -> Int -> String -> PP_Doc
callSillyFunctionFromC optOwn n nm
 | optOwn<=2 = nm >|< "();"
 | optOwn>=3 = let lab = "mainlab" ++ show n
               in  "*--SP = (GrWord)(&&" >|< lab >|< ");"   -- return address
                   >-< ppWhen optTraceAssign
                              (" printf(\"def label" >#< lab >#< "= %d \\n\", " >#< "SP[0]" >#< "); fflush(stdout);")
                   >-< "*--SP = (GrWord)0;"                 -- link
                   >-< "goto" >#< nm >|< ";"                -- do the call
                   >-< label lab                            -- return here
 
 
callSillyFunctionFromSilly ::  Int -> String -> [PP_Doc] -> PP_Doc
callSillyFunctionFromSilly optOwn nm pars
 | optOwn<=2 = callCfunction nm pars >|< ";"
 | optOwn>=3 = "goto" >#< nm >|< ";"


quoted :: String -> String
quoted s = "\"" ++ s ++ "\""

returnFromSillyFunction retdiff optOwn
 | optOwn>=5   = "asm ( " >|< (  --  quoted ("movl -" ++ show (4*retdiff) ++ "(%esp),%eax\\n\\t")
                                 --  >-<  quoted "jmp *%eax"
                                 quoted ("jmp\\t*-" ++ show (4*retdiff) ++ "(%esp)")
                              )
                          >|< ");"
                 >-< "goto *(SP[-" >|< show retdiff >|< "]);"                          
 | optOwn>=3   = "goto *(SP[-" >|< show retdiff >|< "]);"
 | optOwn<=2   = text ""


%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Semantic functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

preambule :: PP_Doc
preambule
 = comment ["Generated C code"]
   >-< text "#include \"rts.h\""
   >-< text ""

constantDefinition :: (String,Int) -> PP_Doc
constantDefinition (x,n)
 = macroDefinition (text x) (text (show n))

variableDeclaration :: String -> PP_Doc
variableDeclaration x
 = "GrWord" >#< text x >|< ";"

methodHead :: String -> [String] -> PP_Doc
methodHead nm params
 =  let parameters = if null params
                      then "void"
                      else commaSeparated (map (declareName "GrWord") params)
    in  "void" >#< nm >|< "(" >|< parameters >|< ")"

methodHeader :: Int -> Bool -> String -> [String] -> PP_Doc
methodHeader optOwn optTrace nm params
 | optOwn<=2 =  methodHead nm params
                >#< "{"
                >-< ppWhen optTrace (trace ("enter " ++ init (tail (show nm))))
 | optOwn>=3 = label nm
                >-< ppWhen optTrace (trace ("enter " ++ init (tail (show nm))))

methodFooter :: Int -> Bool -> String -> PP_Doc
methodFooter optOwn optTrace nm
 | optOwn<=2 =  ppWhen optTrace (trace ("leave "++init (tail (show nm))))
                >-< text "}"
                >-< text ""
 | optOwn>=3 = text ""

methodLocals :: [String] -> PP_Doc
methodLocals ns
 = ppUnless (null ns)
            (   comment ["Local names"]
            >-< declareNames "GrWord" ns
            )


jumpPrepare :: PP_Doc
jumpPrepare
 =  pp machDepCForTailcallEnter

jumpSillyFunctionFromSilly :: Int -> String -> PP_Doc
jumpSillyFunctionFromSilly optOwn nm
 | optOwn<=2 = ppWhen optTraceAssign
                      (" printf(\"goto " >#< nm >#< "\\n\"); fflush(stdout);")
 	           >-< machDepCForTailcallLeave1
               >#< "{ register void* _tail_call_dest = ((void*)" >|< nm >|< ");"
               >#< machDepCForTailcallLeave2
               >-< "goto *_tail_call_dest; }"
 | optOwn>=3 = "goto" >#< nm >|< ";"


assignment2 :: PP_Doc -> PP_Doc -> PP_Doc -> PP_Doc
assignment2 v1 v2 e
 = v1
   >#< "="
   >#< v2
   >#< "="
   >#< e
   >|< ";"
   >|< ppWhen optTraceAssign
              (" printf(\"assignment" >#< show v1 >#< "=" >#< show v2 >#< "=" >#< e >#< " : %d at %d/%d\\n\", " >#< show v1 >#< ", &(" >#< show v1 >#<  "), &(" >#< show v2 >#<  ")); fflush(stdout);")

assignment :: PP_Doc -> PP_Doc -> PP_Doc
assignment v e
 = v
   >#< "="
   >#< e
   >|< ";"
   >|< ppWhen optTraceAssign
              (" printf(\"assignment" >#< show v >#< "=" >#< e >#< " : %d at %d\\n\", " >#< show v >#< ", &(" >#< show v >#<  ")); fflush(stdout);")

switch :: Bool -> PP_Doc -> PP_Doc -> PP_Doc
switch optDef scrutinee body
 = "switch ("
   >|< scrutinee
   >|< ")"
   >#< "{"
   >-< indent 4 body
   >-< ppWhen optDef (indent 4 (caseDefault scrutinee))
   >-< "}"

ifstat ::  PP_Doc -> PP_Doc -> PP_Doc
ifstat scrutinee body
 = "if ("
   >|< scrutinee
   >|< " & 1)"
   >-< body

alternative :: PP_Doc -> PP_Doc -> PP_Doc
alternative when body
 = "case"
   >#< when
   >|< ":"
   >-< indent 4 (body >-< "break;")


%%]
