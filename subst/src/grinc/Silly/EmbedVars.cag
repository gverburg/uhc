%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8.wrapper
WRAPPER SilModule
%%]

%%[8 hs module {%{GRIN}Silly.EmbedVars} export(embedVars)
%%]
%%[8 hs import({%{GRIN}Silly})
%%]
%%[8 hs import({%{EH}Base.Common})
%%]
%%[8 hs import({%{EH}Base.Opts})
%%]
%%[8 hs import(qualified Data.Map as Map)
%%]
%%[8 hs import(qualified Data.Set as Set)
%%]


%%[8 hs
embedVars :: EHCOpts -> SilModule -> SilModule
embedVars options input   
  = let t = wrap_SilModule (sem_SilModule input)
                           (Inh_SilModule {opts_Inh_SilModule = options} )
    in trf_Syn_SilModule t
%%]

%%[8

ATTR SilModule   [ opts : {EHCOpts} | | ]
ATTR AllNT [ | | trf: SELF ]
ATTR Statement Statements Alternative Alternatives Variable Variables Value Values [ distance : {Int}  embed : {EmbedFunction} | | ]
ATTR Statement Statements Alternative Alternatives Variable [ | | localsSet USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]
ATTR Statement Statements Alternative Alternatives [ numberParameters : {Int} | | ]
ATTR Statement  [ | | trfStats: {[Statement]} ]
ATTR Function Functions  [ optOwn  : {Int}  | | ]

SEM SilModule
  | SilModule  loc.optOwn  = ehcOptOwn @lhs.opts


%%]

%%[8
SEM Statements
  | Cons      lhs . trf      = @hd.trfStats ++ @tl.trf

SEM Statement
  | Smart     lhs . trf      = Statement_Comment ["Smart"]
  | Smart     lhs . trfStats = let dp = @lhs.distance+ @lhs.numberParameters
                                   smartTups = zip [dp+1,dp ..] @vals.trf
                                in smartAssignment (filter hasRealVal smartTups)
  | * - Smart lhs . trfStats = [@loc.trf]
  


SEM Function
  | Function  lhs . trf    =  Function_Function @name
                                                @tailJumps
                                                -- parameters
                                                (if @lhs.optOwn>=1 then [] else @parameters)
                                                -- locals
                                                (if @lhs.optOwn>=2
                                                 then [] 
                                                 else if @lhs.optOwn>=1 then @loc.newlocals ++ @parameters else @loc.newlocals
                                                )
                                                -- body
                                                (  (if   @lhs.optOwn==1 && not (null @parameters)
                                                    then Statement_Comment ["Parameters"]
                                                         : zipWith Statement_Assignment
                                                                   (map (Variable_Param undefined) @parameters)
                                                                   (map (Value_Var . Variable_Subs Variable_SP) [2..])
                                                    else []
                                                   )
                                                ++ (if   @lhs.optOwn>=1
                                                    then [ Statement_Assignment Variable_SP (Value_Offset Variable_SP (- @loc.distance))
                                                         -- , Statement_Comment (map (showEmbedPair @loc.distance @lhs.hptMap) @loc.embedList)
                                                         ]
                                                    else []
                                                   )
                                                ++ @body.trf
                                                )
                                                
SEM Function
  | Function  body . numberParameters = length @parameters
              loc  . distance = @loc.nLocals + @loc.roomForCcalls
              loc  . nLocals      = if @lhs.optOwn>=2  then length @loc.newlocals   else 0
              loc  . roomForCcalls= 2
              body . embed    = (if @lhs.optOwn>=2 then (embed2 @loc.distance) else embed) @loc.embedMap
              loc  . newlocals  =  Set.toList (Set.difference @body.localsSet (Set.fromList @parameters))
              loc  . embedMap = Map.fromList @loc.embedList
              loc  . embedList = @loc.paramsTup ++ @loc.localsTup
              loc  . localsTup = zipWith (makeEmbedTupel Variable_Local) [1..] @loc.newlocals
              loc  . paramsTup = zipWith (makeEmbedTupel Variable_Param) [1..] @parameters

SEM Variable
  | Unembedded      lhs . localsSet = Set.singleton @name

SEM Variable
  | Unembedded   lhs.trf = @lhs.embed @name

SEM Variable
  | Subs         lhs.trf = if @array.trf==Variable_BP
                            then Variable_Subs Variable_SP (@index + @lhs.distance)
                            else Variable_Subs @array.trf @index

SEM Value
  | Offset       lhs.trf = if @var.trf==Variable_BP
                            then Value_Offset Variable_SP (@off + @lhs.distance)
                            else Value_Offset @var.trf @off

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Embedding of parameters and local variables on the stack
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

type EmbedMap = Map.Map Int Variable
type EmbedFunction = HsName->Variable

makeEmbedTupel :: (Int->HsName->Variable) -> Int -> HsName -> (Int,Variable)
makeEmbedTupel constr k x@(HNmNr n _) = (n, constr k x)

embed :: EmbedMap -> EmbedFunction
embed m x@(HNmNr n _) = if n==0
                         then Variable_None
                         else maybe (Variable_Global x)
                                    id
                                    (Map.lookup n m)

embed2 :: Int -> EmbedMap -> EmbedFunction
embed2 d m x@(HNmNr n _) = if n==0
                            then Variable_None
                            else maybe (Variable_Global x)
                                       (\v -> case v of
                                                Variable_Local n _ -> Variable_Subs Variable_SP (d+0-n)
                                                Variable_Param n _ -> Variable_Subs Variable_SP (d+1+n)
                                       )
                                       (Map.lookup n m)

--showEmbedPair :: Int -> HptMap -> (Int,Variable) -> String
--showEmbedPair d h (i, Variable_Param n name) = "Param " ++ show n ++ " \t" ++ postPad 12 (hsnShowAlphanumeric name) ++ "\tSP[" ++ show (d+1+n) ++ "]\t(" ++ show (getEnvVar h i) ++ ")"
--showEmbedPair d h (i, Variable_Local n name) = "Local " ++ show n ++ " \t" ++ postPad 12 (hsnShowAlphanumeric name) ++ "\tSP[" ++ show (d+0-n) ++ "]\t(" ++ show (getEnvVar h i) ++ ")"

postPad n s = let w = length s
              in  if w>=n then s else s ++ replicate (n-w) ' '
                  

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The Smart Assignation strategy (probably reinvented a topological sort algorithm here)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

hasRealVal (_, Value_Con (Constant_Alias "UNBOXED")) = False
hasRealVal _                                         = True

type EIV = Either Int Value
data SmartTree = SmartTree EIV [SmartTree]

smartAssignment :: [(Int,Value)] -> [Statement]
smartAssignment = concat . map smartAss . foldr smartAdd [] . convertTups

convertTups :: [(Int,Value)] -> [(EIV,Int)]
convertTups tups = [ (dependency, destination) 
                   | (destination, value) <- tups
                   , let dependency = smartDep value
                   , either (\n->n/=destination) (\v->True) dependency
                   ]

smartDep :: Value -> EIV
smartDep (Value_Var (Variable_Subs Variable_SP n)) = Left n
smartDep v = Right v

smartFind :: EIV -> [SmartTree] -> (SmartTree, [SmartTree])
smartFind n [] =  (SmartTree n [], [])
smartFind n (t@(SmartTree r ks):ts)
  | n==r       =  (t, ts)
  | otherwise  =  let (t2,ts2) = smartFind n ts
                  in (t2, t:ts2)

smartAdd :: (EIV,Int) -> [SmartTree] -> [SmartTree]
smartAdd p@(x,y) ts = let (y2,ts2) = smartFind (Left y) ts
                          (rs,b) = smartIns (x,y2) ts2
                      in  if b
                           then rs
                           else (SmartTree x [y2]) : ts2
                           
smartInsert :: (EIV,SmartTree) -> SmartTree -> (SmartTree,Bool)
smartInsert p@(x,y) t@(SmartTree root kids)
 | x==root   =  (SmartTree root (y:kids), True)
 | otherwise =  let (rs,b) = smartIns p kids
                in  if b
                     then (SmartTree root rs, True)
                     else (t                , False)
                    
smartIns :: (EIV,SmartTree) -> [SmartTree] -> ([SmartTree],Bool)
smartIns p ts = foldr f ([],False) ts
  where f t (rs,True) = (t:rs, True)
        f t (rs,False) = let (r,b) = smartInsert p t
                         in  (r:rs, b)
       
smartElems :: SmartTree -> [Int]
smartElems (SmartTree (Left n) [])   = [n]
smartElems (SmartTree (Left n) kids) = n : concat (map smartElems kids)


auxVar = Variable_Aux
auxVal = Value_Var auxVar

smartAss :: SmartTree -> [Statement]
smartAss t@(SmartTree root kids) 
  =  either
     (\n -> if  n `elem` concat (map smartElems kids)
             then Statement_Assignment auxVar (Value_Var (Variable_Subs Variable_SP n))
                  : concat (map (smartChain auxVal) kids)
             else concat (map (smartChain (Value_Var (Variable_Subs Variable_SP n))) kids)
     )
     (\v -> concat (map (smartChain v) kids)
     )
     root
  
smartChain :: Value -> SmartTree -> [Statement]
smartChain v (SmartTree (Left root) kids) 
   = concat (map (smartChain (Value_Var (Variable_Subs Variable_SP root))) kids) 
     ++ [ Statement_Assignment (Variable_Subs Variable_SP root) v ]

       
%%]
