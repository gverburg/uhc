Arity Raising
What: Avoid boxing when it's known they're unboxed later anyway.

Why: TODO: Write short summary here
When: TODO: Figure this out

Assumptions:
- HPT table is available
- TODO: Perhaps more?


%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.ArityRaise} export(arityRaise)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common(HsName, CTagsMp)})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import(Debug.Trace)
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common(HptMap, AbstractValue, getTags, getNr, getEnvVar, absFetch)})
%%]
%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs
arityRaise :: (GrModule,HptMap) -> GrModule
arityRaise (input,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  grTrf_Syn_GrAGItf syn
%%]

%%[(8 codegen grin)
-- synthesize a modified copy
ATTR GrAGItf   [ | | grTrf: GrModule ]
ATTR AllNT     [ | | grTrf: SELF     ]

-- bring the HPT map down to the Expression level
ATTR GrAGItf
     GrModule
     AllBind
     AllGrExpr [ hptMap: HptMap | | ]

ATTR GrExpr [ | | rScruts USE {++} {[]} : {[HsName]} ]
ATTR GrExpr [ | | rSize USE {`siz`} {0} : {Int} ]

SEM GrBind
         -- H1: function definition
  | Bind loc . rCondDef  = length @argNmL > 0
         -- H2: check for "sufficiently small" function
         loc . rCondSize = @expr.rSize <= specSizeTreshold
         -- H5 & H6: Create "call patterns" using hptMap and rScruts
         loc . rPats = []
         
--         lhs . grTrf = @loc.grTrf
--  | Rec lhs . grTrf = 

SEM GrExpr
         -- H6: Collect all scrutinized arguments of the function
  | Case lhs . rScruts = case @val of
                           (GrVal_Var nm) -> [nm]
                           _ -> []


%%]


Find recursive top-level bindings by descending into the Rec-block,
and giving the list of grouped function to every defined function in the group.
These recursive functions the candidates for optimization.

%%[(8 codegen grin)

ATTR GrBindL [ | | recBindsUp USE {++} {[]} : {[HsName]} ]
ATTR GrModule AllBind AllGrExpr [ recBindsDown : {[HsName]} | | ]

SEM GrModule
  | Mod bindL . recBindsDown = []

SEM GrBind
  | Rec bindL . recBindsDown = @bindL.recBindsUp -- push down all (mutual) recursive bindings

SEM GrBind
  | Rec lhs . recBindsUp = []
  | Bind lhs . recBindsUp = [@nm]

SEM GrExpr
  | Call loc . isRecursive = elem @nm @lhs.recBindsDown
         lhs . grTrf       = GrExpr_Comment (show @lhs.recBindsDown) @loc.grTrf

%%]


%%[8.arityRaise hs

-- Treshold to determine which functions we want to specialize
-- hence big functions (according to the treshold) will not be
-- specialized to avoid excessive code increase
--
-- Unit: number of nested GRIN expressions
specSizeTreshold = 100

siz :: Num a => a -> a -> a
siz a b = a + b + 1

pats :: [(Maybe HsName,AbstractValue)] -> HptMap -> [HsName] -> [(Maybe HsName,AbstractValue)]
pats ps hpt [] = ps
pats ps hpt (x:xs) = pats (getPat x (absFetch hpt x) : ps) hpt xs

getPat :: HsName -> AbstractValue -> (Maybe HsName,AbstractValue)
getPat nm abs = (Nothing,abs)

%%]
