Arity Raising
What: Avoid boxing when it's known they're unboxed later anyway.

Why: TODO: Write short summary here
When: TODO: Figure this out

Assumptions:
- HPT table is available
- TODO: Perhaps more?


%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.ArityRaise} export(arityRaise)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs import (Data.Map (Map))
%%]
%%[(8 codegen grin) hs import (Data.List)
%%]
%%[(8 codegen grin) hs import (Data.Maybe)
%%]
%%[(8 codegen grin) hs import (Debug.Trace)
%%]
%%[(8 codegen grin) hs import (qualified Data.Map as Map)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common(HsName (..), CTagsMp)})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common(HptMap, AbstractValue, getTags, getNr, getEnvVar, absFetch)})
%%]
%%[(8 codegen grin) hs import (Maybe (fromMaybe))
%%]
%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs
arityRaise :: (GrModule,HptMap) -> GrModule
arityRaise (input,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  grTrf_Syn_GrAGItf syn
%%]

%%[(8 codegen grin)
-- synthesize a modified copy
ATTR GrAGItf   [ | | grTrf: GrModule ]
ATTR AllNT     [ | | grTrf: SELF     ]

-- bring the HPT map down to the Expression level
ATTR GrAGItf
     GrModule
     AllBind
     AllGrExpr [ hptMap: HptMap | | ]

ATTR AllGrExpr [ | | rSize USE {+} {1} : Int ]


SEM GrBind
  | Bind lhs . grTrf = GrBind_Bind @nm @annot @argNmL $
                         GrExpr_Comment ("Doorzicht: " ++ show @expr.doorzichtUp) $
                           GrExpr_Comment ("Scrutinized: " ++ show @expr.scruts) @expr.grTrf

SEM GrBind
         -- H1: function definition
  | Bind loc . rCondDef  = length @argNmL > 0
         -- H2: check for "sufficiently small" function
         loc . rCondSize = @expr.rSize <= specSizeTreshold

%%]


Find recursive top-level bindings by descending into the Rec-block,
and giving the list of grouped function to every defined function in the group.
These recursive functions the candidates for optimization.

%%[(8 codegen grin)

ATTR AllBind [ | | recBindsUp USE {++} {[]} : {[HsName]} ]
ATTR GrModule AllBind AllGrExpr [ recBindsDown : {[HsName]} | | ]

SEM GrModule
  | Mod bindL . recBindsDown = []

SEM GrBind
  | Rec bindL . recBindsDown = @bindL.recBindsUp -- push down all (mutual) recursive bindings

SEM GrBind
  | Rec lhs . recBindsUp = []
  | Bind lhs . recBindsUp = if @loc.rCondSize && @loc.rCondDef then [@nm] else [] -- only include specialisable bindings

SEM GrExpr
  | Call loc . isRecursive = elem @nm @lhs.recBindsDown
         lhs . grTrf       = if @loc.isRecursive
                               then GrExpr_Comment "Specialisable call!" @loc.grTrf
                               else GrExpr_Comment "Non-specialisable call" @loc.grTrf

%%]

%%[(8 codegen grin)

ATTR GrExpr GrAlt [ | | doorzichtUp : {[[GrVal]]} ]
ATTR AllGrExpr [ doorzicht : {[[GrVal]]} | | ]
ATTR GrAltL [ | | doorzichtUp : {[[[GrVal]]]} ]

SEM GrBind
  | Bind expr . doorzicht = @expr.doorzichtUp

-- Needs variable usage for other GrExpr cases added.
SEM GrExpr
  | Seq lhs . doorzichtUp = case @expr.interestingVal of
                              Nothing -> @body.doorzichtUp
                              Just x  -> addDoorzicht (patLamToVal @pat) x @body.doorzichtUp
  | Unit lhs . doorzichtUp = [[@val.grTrf]]
  | UpdateUnit lhs . doorzichtUp = [[GrVal_Var @nm , @val.grTrf]]
  | Case lhs . doorzichtUp = unionAll (concat @altL.doorzichtUp)
  | FetchNode lhs . doorzichtUp = [[GrVal_Var @nm]]
  | Store lhs . doorzichtUp = [[@val.grTrf]]
  | Call lhs . doorzichtUp = map (:[]) (@argL.grTrf)

SEM GrAltL
  | Nil lhs . doorzichtUp = []
  | Cons lhs . doorzichtUp = @hd.doorzichtUp : @tl.doorzichtUp

ATTR GrExpr [ | | interestingVal : {Maybe GrVal} ]

SEM GrExpr
  | Unit lhs . interestingVal = Just @val.grTrf
  | FetchNode lhs . interestingVal = Just (GrVal_Var @nm)
  | Store lhs . interestingVal = Just @val.grTrf
  | Case lhs . interestingVal = if (any isUnit @altL.grTrf ) then Just @val.grTrf else Nothing
  | * -Unit -FetchNode -Store -Case lhs . interestingVal = Nothing


%%]

%%[(8 codegen grin)

ATTR GrExpr [ | | scruts USE {++} {[]} : {[GrVal]} ]

SEM GrExpr
  | Seq loc . scrut = case @expr.interestingVal of
                          (Just s) -> case @pat of
                                        (GrPatLam_VarNode _) -> Just s
                                        _ -> Nothing
                          _ -> Nothing
        lhs . scruts = case @loc.scrut of
                         (Just s) -> s : (@body.scruts)
                         _ -> @body.scruts
        lhs . grTrf = if isJust @loc.scrut then GrExpr_Comment ("Scrutinee: " ++ show @loc.scrut) @loc.grTrf
                                           else @loc.grTrf

%%]

%%[8.arityRaise hs

-- Voegt twee verzamelingen nog niet samen als ze opeens overlappen.
-- Niet zeker of dit Ã¼berhaupt voorkomt
addDoorzicht :: GrVal -> GrVal -> [[GrVal]] -> [[GrVal]]
addDoorzicht key value doorzicht = map addMe doorzicht
  where addMe groep | key `elem` groep = value : groep
                    | otherwise        = groep

isUnit :: GrAlt -> Bool
isUnit (GrAlt_Alt ann _ _) = ann == GrAltAnnIdent

unionAll :: [[GrVal]] -> [[GrVal]]
unionAll = foldr mergeIn []

mergeIn :: [GrVal] -> [[GrVal]] -> [[GrVal]]
mergeIn x []     = [x]
mergeIn x (y:ys) | null (x `intersect` y) = y : mergeIn x ys
                 | otherwise              = mergeIn (x `union` y) ys

patLamToVal :: GrPatLam -> GrVal
patLamToVal l = trace (show l) (patLamToVal' l)

patLamToVal' GrPatLam_Empty = GrVal_Empty
patLamToVal' (GrPatLam_Var nm) = GrVal_Var nm
patLamToVal' (GrPatLam_VarNode fldL) = mkVal fldL
  where mkVal (GrVar_KnownTag tag:fields) = GrVal_Node tag (map varToVal fields)
        mkVal fields                      = GrVal_VarNode (map varToVal fields)
-- tag? Example program crashes on this one.
patLamToVal' (GrPatLam_BasicNode annot nm) = GrVal_BasicNode GrTag_Any nm
patLamToVal' (GrPatLam_EnumNode nm) = GrVal_EnumNode nm
patLamToVal' (GrPatLam_PtrNode nm) = GrVal_PtrNode nm
patLamToVal' (GrPatLam_OpaqueNode nm) = GrVal_OpaqueNode nm
-- tag?
-- Ik neem aan dat de <x>Annot overeenkomen met <x>Node
patLamToVal' (GrPatLam_BasicAnnot annot nm) = GrVal_BasicNode GrTag_Any nm
-- unused tagL x2?
patLamToVal' (GrPatLam_EnumAnnot tagL nm) = GrVal_EnumNode nm
patLamToVal' (GrPatLam_PtrAnnot tagL nm) = GrVal_PtrNode nm
patLamToVal' (GrPatLam_OpaqueAnnot nm) = GrVal_OpaqueNode nm

varToVal :: GrVar -> GrVal
varToVal (GrVar_Var nm) = GrVal_Var nm
-- ? x2
varToVal (GrVar_KnownTag tag) = error "GrVar_KnownTag"
varToVal (GrVar_Ignore) = error "Grvar_Ignore"

%%]




%%[8.arityRaise hs

-- Treshold to determine which functions we want to specialize
-- hence big functions (according to the treshold) will not be
-- specialized to avoid excessive code increase
--
-- Unit: number of nested GRIN expressions
specSizeTreshold = 1000000 -- big number to avoid headaches during testing

unionPlus :: Map HsName Int -> Map HsName Int -> Map HsName Int
unionPlus = Map.unionWith (+)

const2 c a b = c
co = const2 Nothing

nod a (HNmNr i _) = getEnvVar a i

%%]
