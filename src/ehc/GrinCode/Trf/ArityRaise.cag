Arity Raising
What: Avoid boxing when it's known they're unboxed later anyway.

Why: TODO: Write short summary here
When: TODO: Figure this out

Assumptions:
- HPT table is available
- TODO: Perhaps more?


%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.ArityRaise} export(arityRaise)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs import (Data.Map (Map))
%%]
%%[(8 codegen grin) hs import (Data.List)
%%]
%%[(8 codegen grin) hs import (Data.Maybe)
%%]
%%[(8 codegen grin) hs import (Debug.Trace)
%%]
%%[(8 codegen grin) hs import (qualified Data.Map as Map)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common(HsName (..), CTagsMp, hsnSuffix)})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common(HptMap, AbstractValue, getTags, getNr, getEnvVar, absFetch)})
%%]
%%[(8 codegen grin) hs import (Maybe (fromMaybe))
%%]
%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs
arityRaise :: (GrModule,HptMap) -> GrModule
arityRaise (input,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  grTrf_Syn_GrAGItf syn
%%]

%%[(8 codegen grin)
-- synthesize a modified copy
ATTR GrAGItf   [ | | grTrf: GrModule ]
ATTR AllNT     [ | | grTrf: SELF     ]

-- bring the HPT map down to the Expression level
ATTR GrAGItf
     GrModule
     AllBind
     AllGrExpr [ hptMap: HptMap | | ]

ATTR AllGrExpr [ | | rSize USE {+} {1} : Int ]


SEM GrBind
  | Bind lhs . grTrf = let orig = GrBind_Bind @nm @annot @argNmL $
                                    GrExpr_Comment ("Doorzicht: " ++ show @loc.doorzicht) $
                                      GrExpr_Comment ("Specializable calls: " ++ show @expr.specCalls) $
                                        GrExpr_Comment ("Pats: " ++ show @loc.pats) @expr.grTrf
                           clone = GrBind_Bind (cloneName @nm) @annot @argNmL $
                                     GrExpr_Comment ("This is a clone of " ++ show @nm) $
                                       @expr.grTrf
                           in GrBind_Rec [orig, clone]

SEM GrBind
         -- H1: function definition
  | Bind loc . rCondDef  = length @argNmL > 0
         -- H2: check for "sufficiently small" function
         loc . rCondSize = @expr.rSize <= specSizeTreshold

%%]


Find recursive top-level bindings by descending into the Rec-block,
and giving the list of grouped function to every defined function in the group.
These recursive functions the candidates for optimization.

%%[(8 codegen grin)

ATTR AllBind [ | | recBindsUp USE {++} {[]} : {[HsName]} ]
ATTR GrModule AllBind AllGrExpr [ recBindsDown : {[HsName]} | | ]
ATTR AllGrExpr [  | | specCalls USE {++} {[]} : {[[GrVal]]} ]

SEM GrModule
  | Mod bindL . recBindsDown = []

SEM GrBind
  | Rec bindL . recBindsDown = @bindL.recBindsUp -- push down all (mutual) recursive bindings

SEM GrBind
  | Rec lhs . recBindsUp = []
  | Bind lhs . recBindsUp = if @loc.rCondSize && @loc.rCondDef then [@nm] else [] -- only include specialisable bindings

SEM GrExpr
  | Call loc . isSpecializable = elem @nm @lhs.recBindsDown
         lhs . specCalls = if @loc.isSpecializable then [@argL.grTrf] else []
         lhs . grTrf       = if @loc.isSpecializable
                               then GrExpr_Comment "Specialisable call!" $
                                      callComment @loc.grTrf @argL.grTrf @lhs.doorzicht
                               else GrExpr_Comment "Non-specialisable call" @loc.grTrf

%%]

%%[(8 codegen grin)

ATTR GrExpr GrAlt [ | | doorzichtUp : {[[GrVal]]} ]
ATTR AllGrExpr [ doorzicht : {[[GrVal]]} | | ]	-- jean: we probably don't need to send the doorzicht up anymore, since all information is available at the binding-level
ATTR GrAltL [ | | doorzichtUp : {[[[GrVal]]]} ]

-- doorzicht is an ordered list of related variables/nodes.
-- The first element corresponds to the first parameter,
-- The second element corresponds to the second paremeter, etc.
SEM GrBind
  | Bind loc . doorzicht = map (findRelated @expr.doorzichtUp . GrVal_Var) @argNmL
         loc . pats = map (mkPat @loc.doorzicht) @expr.specCalls
         expr . doorzicht = @loc.doorzicht

-- Needs variable usage for other GrExpr cases added.
SEM GrExpr
  | Seq lhs . doorzichtUp = case @expr.interestingVal of
                              Nothing -> @body.doorzichtUp
                              Just x  -> addDoorzicht (patLamToVal @pat) x @body.doorzichtUp
  | Unit lhs . doorzichtUp = [[@val.grTrf]]
  | UpdateUnit lhs . doorzichtUp = [[GrVal_Var @nm , @val.grTrf]]
  | Case lhs . doorzichtUp = unionAll (concat @altL.doorzichtUp)
  | FetchNode lhs . doorzichtUp = [[GrVal_Var @nm]]
  | Store lhs . doorzichtUp = [[@val.grTrf]]
  | Call lhs . doorzichtUp = map (:[]) (@argL.grTrf)

SEM GrAltL
  | Nil lhs . doorzichtUp = []
  | Cons lhs . doorzichtUp = @hd.doorzichtUp : @tl.doorzichtUp

ATTR GrExpr [ | | interestingVal : {Maybe GrVal} ]

SEM GrExpr
  | Unit lhs . interestingVal = Just @val.grTrf
  | FetchNode lhs . interestingVal = Just (GrVal_Var @nm)
  | Store lhs . interestingVal = Just @val.grTrf
  | Case lhs . interestingVal = if (any isUnit @altL.grTrf ) then Just @val.grTrf else Nothing
  | * -Unit -FetchNode -Store -Case lhs . interestingVal = Nothing


%%]

%%[8.arityRaise hs

addDoorzicht :: GrVal -> GrVal -> [[GrVal]] -> [[GrVal]]
addDoorzicht key value doorzicht = map addMe doorzicht
  where addMe groep | key `elem` groep = value : groep
                    | otherwise        = groep

isUnit :: GrAlt -> Bool
isUnit (GrAlt_Alt ann _ _) = ann == GrAltAnnIdent

unionAll :: [[GrVal]] -> [[GrVal]]
unionAll = foldr mergeIn []

mergeIn :: [GrVal] -> [[GrVal]] -> [[GrVal]]
mergeIn x []     = [x]
mergeIn x (y:ys) | null (x `intersect` y) = y : mergeIn x ys
                 | otherwise              = mergeIn (x `union` y) ys

-- Convert a pattern that's allowed in a lambda to a value that would match that pattern.
patLamToVal :: GrPatLam -> GrVal
patLamToVal GrPatLam_Empty = GrVal_Empty
patLamToVal (GrPatLam_Var nm) = GrVal_Var nm
patLamToVal (GrPatLam_VarNode fldL) = mkVal fldL
  where mkVal (GrVar_KnownTag tag:fields) = GrVal_Node tag (map varToVal fields)
        mkVal fields                      = GrVal_VarNode (map varToVal fields)
patLamToVal (GrPatLam_BasicNode annot nm) = GrVal_BasicNode GrTag_Any nm
patLamToVal (GrPatLam_EnumNode nm) = GrVal_EnumNode nm
patLamToVal (GrPatLam_PtrNode nm) = GrVal_PtrNode nm
patLamToVal (GrPatLam_OpaqueNode nm) = GrVal_OpaqueNode nm
patLamToVal (GrPatLam_BasicAnnot annot nm) = GrVal_BasicNode GrTag_Any nm
-- unused tagL x2?
patLamToVal (GrPatLam_EnumAnnot tagL nm) = GrVal_EnumNode nm
patLamToVal (GrPatLam_PtrAnnot tagL nm) = GrVal_PtrNode nm
patLamToVal (GrPatLam_OpaqueAnnot nm) = GrVal_OpaqueNode nm

varToVal :: GrVar -> GrVal
varToVal (GrVar_Var nm) = GrVal_Var nm
varToVal (GrVar_KnownTag tag) = GrVal_Tag tag
varToVal (GrVar_Ignore) = error "Grvar_Ignore"

findRelated :: [[GrVal]] -> GrVal -> [GrVal]
findRelated doorzicht val = case filter (val `elem`) doorzicht of
                              []     -> []
                              (x:xs) -> x

callComment :: GrExpr -> [GrVal] -> [[GrVal]] -> GrExpr
callComment res args doorzicht = foldr (uncurry addArgComment) res (zip args doorzicht)
  where addArgComment arg dz rest = GrExpr_Comment (argComment arg dz) rest
        argComment arg dz = show arg ++ " ~= " ++ show dz

cloneName :: HsName -> HsName
cloneName name = hsnSuffix name "_clone"

%%]

%%[8.arityRaise hs

-- Treshold to determine which functions we want to specialize
-- hence big functions (according to the treshold) will not be
-- specialized to avoid excessive code increase
--
-- Unit: number of nested GRIN expressions
specSizeTreshold = 1000000 -- big number to avoid headaches during testing

mkPat :: [[GrVal]] -> [GrVal] -> [GrVal]
mkPat dzicht call = zipWith combine call dzicht
  where
    combine callArg dzs | elem callArg dzs = let ns = nodes dzs
                                             in  case length ns of
                                                   1 -> ns !! 0
                                                   _ -> callArg
                        | otherwise = callArg
    nodes = filter isNode
    isNode (GrVal_Node _ _) = True
    isNode _ = False

%%]
