Arity Raising
What: Avoid boxing when it's known they're unboxed later anyway.

Why: TODO: Write short summary here
When: TODO: Figure this out

Assumptions:
- HPT table is available
- TODO: Perhaps more?


%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.ArityRaise} export(arityRaise)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common(HsName, CTagsMp)})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import(Debug.Trace)
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common(HptMap, AbstractValue, getTags, getNr, getEnvVar, absFetch)})
%%]
%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs
arityRaise :: (GrModule,HptMap) -> GrModule
arityRaise (input,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  grTrf_Syn_GrAGItf syn
%%]

%%[(8 codegen grin)
-- synthesize a modified copy
ATTR GrAGItf   [ | | grTrf: GrModule ]
ATTR AllNT     [ | | grTrf: SELF     ]

-- bring the HPT map down to the Expression level
ATTR GrAGItf
     GrModule
     AllBind
     AllGrExpr [ hptMap: HptMap | | ]

ATTR AllGrExpr [ | | rSize USE {+} {1} : {Int} ]
ATTR GrExpr [ | | rScruts USE {++} {[]} : {[HsName]} ] -- note: rScruts only on "top-level" expressions
                                                       --       i.e. not in case alternatives

SEM GrBind
         -- H1: function definition
  | Bind loc . rCondDef  = length @argNmL > 0
         -- H2: check for "sufficiently small" function
         loc . rCondSize = @expr.rSize <= specSizeTreshold

SEM GrExpr
         -- H6: Collect all scrutinized arguments of the function
  | Case lhs . rScruts = case @val of
                           (GrVal_Var nm) -> [nm]
                           _ -> []

%%]


Find recursive top-level bindings by descending into the Rec-block,
and giving the list of grouped function to every defined function in the group.
These recursive functions the candidates for optimization.

%%[(8 codegen grin)

ATTR AllBind [ | | recBindsUp USE {++} {[]} : {[HsName]} ]
ATTR GrModule AllBind AllGrExpr [ recBindsDown : {[HsName]} | | ]

SEM GrModule
  | Mod bindL . recBindsDown = []

SEM GrBind
  | Rec bindL . recBindsDown = @bindL.recBindsUp -- push down all (mutual) recursive bindings

SEM GrBind
  | Rec lhs . recBindsUp = []
  | Bind lhs . recBindsUp = if @loc.rCondSize && @loc.rCondDef then [@nm] else [] -- only include specialisable bindings

SEM GrExpr
  | Call loc . isRecursive = elem @nm @lhs.recBindsDown
         lhs . grTrf       = if @loc.isRecursive
                               then GrExpr_Comment "Specialisable call!" @loc.grTrf
                               else GrExpr_Comment "Non-specialisable call" @loc.grTrf

%%]

Create call patterns at all call-sites that are marked as recursive
and send them up to the Rec-element which can then add specializations

%%[(8 codegen grin)

ATTR AllBind AllGrExpr [ | | recCalls USE {++} {[]} : {[(HsName,GrValL)]} ]

SEM GrExpr
  | Call lhs . recCalls = if @loc.isRecursive
                          then [ (@nm,@argL) ]
                          else []

SEM GrBind
  | Bind lhs . grTrf    = GrBind_Bind @nm @annot @argNmL
                            $ GrExpr_Comment ("Size " ++ show @expr.rSize) @expr.grTrf


%%]


%%[8.arityRaise hs

-- Treshold to determine which functions we want to specialize
-- hence big functions (according to the treshold) will not be
-- specialized to avoid excessive code increase
--
-- Unit: number of nested GRIN expressions
specSizeTreshold = 1000000 -- big number to avoid headaches during testing

%%]
