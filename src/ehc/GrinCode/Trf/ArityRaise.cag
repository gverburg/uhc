Arity Raising
What: Avoid boxing when it's known they're unboxed later anyway.

Why: TODO: Write short summary here
When: TODO: Figure this out

Assumptions:
- HPT table is available
- TODO: Perhaps more?


%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.ArityRaise} export(arityRaise)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs import (Data.Map (Map))
%%]
%%[(8 codegen grin) hs import (Data.List)
%%]
%%[(8 codegen grin) hs import (qualified Data.Map as Map)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common(HsName (..), CTagsMp)})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common(HptMap, AbstractValue, getTags, getNr, getEnvVar, absFetch)})
%%]
%%[(8 codegen grin) hs import (Maybe (fromMaybe))
%%]
%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs
arityRaise :: (GrModule,HptMap) -> GrModule
arityRaise (input,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  grTrf_Syn_GrAGItf syn
%%]

%%[(8 codegen grin)
-- synthesize a modified copy
ATTR GrAGItf   [ | | grTrf: GrModule ]
ATTR AllNT     [ | | grTrf: SELF     ]

-- bring the HPT map down to the Expression level
ATTR GrAGItf
     GrModule
     AllBind
     AllGrExpr [ hptMap: HptMap | | ]

ATTR AllGrExpr [ | | varOrigin USE {`Map.union`} {Map.empty} : {Map HsName HsName} ]
ATTR AllGrExpr [  | | varOriginUp USE {`co`} {Nothing} : {Maybe HsName} ]
ATTR GrVal [ | | topVar USE {`co`} {Nothing} : {Maybe HsName} ]
ATTR AllGrExpr GrVal [ | | nVarUse USE {`unionPlus`} {Map.empty} : {Map HsName Int}  ]
ATTR AllGrExpr [ | | rSize USE {+} {1} : Int ]
ATTR GrExpr [ | | rScruts USE {++} {[]} : {[HsName]} ] -- note: rScruts only on "top-level" expressions
                                                       --       i.e. not in case alternatives

SEM GrBind
         -- H1: function definition
  | Bind loc . rCondDef  = length @argNmL > 0
         -- H2: check for "sufficiently small" function
         loc . rCondSize = @expr.rSize <= specSizeTreshold
         loc . scruts = selectScruts @expr.varOrigin @expr.nVarUse @expr.rScruts

SEM GrVal
  | Var lhs . topVar = Just @nm
        lhs . nVarUse = Map.insert @nm 1 Map.empty

SEM GrExpr
  | FetchNode lhs . nVarUse = Map.insert @nm 1 Map.empty
  | FetchUpdate lhs . nVarUse = Map.insert @src 1 (Map.insert @dst 1 Map.empty)
  | FetchField lhs . nVarUse = Map.insert @nm 1 Map.empty

SEM GrExpr
  | Case lhs . rScruts = case @val.topVar of
                           (Just nm) -> [nm]
                           _ -> []
  | FetchNode lhs . varOriginUp =  Just @nm
  | Seq lhs . varOrigin = case @expr.varOriginUp of
                            (Just nm1) -> case @pat of
                                           (GrPatLam_Var nm2) -> Map.insert nm2 nm1 @body.varOrigin
                                           _ -> @body.varOrigin
                            _ -> @body.varOrigin

%%]


Find recursive top-level bindings by descending into the Rec-block,
and giving the list of grouped function to every defined function in the group.
These recursive functions the candidates for optimization.

%%[(8 codegen grin)

ATTR AllBind [ | | recBindsUp USE {++} {[]} : {[HsName]} ]
ATTR GrModule AllBind AllGrExpr [ recBindsDown : {[HsName]} | | ]

SEM GrModule
  | Mod bindL . recBindsDown = []

SEM GrBind
  | Rec bindL . recBindsDown = @bindL.recBindsUp -- push down all (mutual) recursive bindings

SEM GrBind
  | Rec lhs . recBindsUp = []
  | Bind lhs . recBindsUp = if @loc.rCondSize && @loc.rCondDef then [@nm] else [] -- only include specialisable bindings

SEM GrExpr
  | Call loc . isRecursive = elem @nm @lhs.recBindsDown
         lhs . grTrf       = if @loc.isRecursive
                               then GrExpr_Comment "Specialisable call!" (GrExpr_Comment (show @lhs.doorzicht)@loc.grTrf)
                               else GrExpr_Comment "Non-specialisable call" @loc.grTrf

%%]

%%[(8 codegen grin)

ATTR AllGrExpr [ | | doorzichtUp : {[[GrVal]]} ]
ATTR AllGrExpr [ doorzicht : {[[GrVal]]} | | ]

SEM GrBind
  | Bind expr . doorzicht = @expr.doorzichtUp

-- Basisgeval, meerdere verzamelingen.
SEM GrExpr
  | Seq lhs . doorzichtUp = case @expr.interestingVal of
                              Nothing -> @body.doorzichtUp
                              Just x  -> addDoorzicht (patLamToVal @pat) x @body.doorzichtUp
  | Case lhs . doorzichtUp = @altL.doorzichtUp
  | Unit lhs . doorzichtUp = [[@val.grTrf]]

SEM GrAltL
  | Nil lhs . doorzichtUp = [[]]
  | Cons lhs . doorzichtUp = mergeDoorzicht @hd.doorzichtUp @tl.doorzichtUp

ATTR GrExpr [ | | interestingVal : {Maybe GrVal} ]

SEM GrExpr
  | Unit lhs . interestingVal = Just @val.grTrf
  | FetchNode lhs . interestingVal = Just (GrVal_Var @nm)
  | Store lhs . interestingVal = Just @val.grTrf
  | * -Unit -FetchNode -Store lhs . interestingVal = Nothing

%%]

%%[8.arityRaise hs

-- Voegt twee verzamelingen nog niet samen als ze opeens overlappen.
-- Niet zeker of dit Ã¼berhaupt voorkomt
addDoorzicht :: GrVal -> GrVal -> [[GrVal]] -> [[GrVal]]
addDoorzicht key value doorzicht = map addMe doorzicht
  where addMe groep | key `elem` groep = value : groep
                    | otherwise        = groep

mergeDoorzicht :: [[GrVal]] -> [[GrVal]] -> [[GrVal]]
mergeDoorzicht x y = unionAll (x ++ y)

unionAll :: [[GrVal]] -> [[GrVal]]
unionAll = foldr mergeIn []

mergeIn :: [GrVal] -> [[GrVal]] -> [[GrVal]]
mergeIn x []     = [x]
mergeIn x (y:ys) | null (x `intersect` y) = y : mergeIn x ys
                 | otherwise              = mergeIn (x `union` y) ys

patLamToVal :: GrPatLam -> GrVal
patLamToVal GrPatLam_Empty = GrVal_Empty
patLamToVal (GrPatLam_Var nm) = GrVal_Var nm
patLamToVal (GrPatLam_VarNode fldL) = GrVal_VarNode (map varToVal fldL)
-- tag? Example program crashes on this one.
patLamToVal (GrPatLam_BasicNode annot nm) = GrVal_BasicNode (error "GrPatLam_BasicNode") nm
patLamToVal (GrPatLam_EnumNode nm) = GrVal_EnumNode nm
patLamToVal (GrPatLam_PtrNode nm) = GrVal_PtrNode nm
patLamToVal (GrPatLam_OpaqueNode nm) = GrVal_OpaqueNode nm
-- tag?
-- Ik neem aan dat de <x>Annot overeenkomen met <x>Node
patLamToVal (GrPatLam_BasicAnnot annot nm) = GrVal_BasicNode (error "GrPatLam_BasicAnnot") nm
-- unused tagL x2?
patLamToVal (GrPatLam_EnumAnnot tagL nm) = GrVal_EnumNode nm
patLamToVal (GrPatLam_PtrAnnot tagL nm) = GrVal_PtrNode nm
patLamToVal (GrPatLam_OpaqueAnnot nm) = GrVal_OpaqueNode nm

varToVal :: GrVar -> GrVal
varToVal (GrVar_Var nm) = GrVal_Var nm
-- ? x2
varToVal (GrVar_KnownTag tag) = error "GrVar_KnownTag"
varToVal (GrVar_Ignore) = error "Grvar_Ignore"

%%]




%%[8.arityRaise hs

data VarUsage = Scrut | Read

-- Treshold to determine which functions we want to specialize
-- hence big functions (according to the treshold) will not be
-- specialized to avoid excessive code increase
--
-- Unit: number of nested GRIN expressions
specSizeTreshold = 1000000 -- big number to avoid headaches during testing

unionPlus :: Map HsName Int -> Map HsName Int -> Map HsName Int
unionPlus = Map.unionWith (+)

selectScruts :: Map HsName HsName -> Map HsName Int -> [HsName] -> [HsName]
selectScruts origMap useMap xs = map findOriginal (filter usedOnce xs)
  where
    findOriginal x = fromMaybe x (Map.lookup x origMap)
    usedOnce x = nUses x == 1
    nUses x = fromMaybe 0 (Map.lookup x useMap)


const2 c a b = c
co = const2 Nothing

nod a (HNmNr i _) = getEnvVar a i

%%]
