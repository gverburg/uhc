Arity Raising
What: Avoid boxing when it's known they're unboxed later anyway.

Why: TODO: Write short summary here
When: TODO: Figure this out

Assumptions:
- HPT table is available
- TODO: Perhaps more?


%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.ArityRaise} export(arityRaise)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs import (Data.Map (Map) )
%%]
%%[(8 codegen grin) hs import (Data.List)
%%]
%%[(8 codegen grin) hs import (Data.Maybe)
%%]
%%[(8 codegen grin) hs import (Debug.Trace)
%%]
%%[(8 codegen grin) hs import (qualified Data.Map as Map)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common(HsName (..), OrigName(..), CTagsMp, hsnSuffix)})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common(HptMap, AbstractValue, getTags, getNr, getEnvVar, absFetch)})
%%]
%%[(8 codegen grin) hs import (Maybe (fromMaybe))
%%]
%%[(8 codegen grin)
WRAPPER GrAGItf GrExpr GrBindL
%%]

%%[(8 codegen grin) hs
arityRaise :: (GrModule,HptMap) -> GrModule
arityRaise (input,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  grTrf_Syn_GrAGItf syn
%%]

===============================================================================
== Basic functions
===============================================================================

%%[(8 codegen grin)
-- synthesize a modified copy
ATTR GrAGItf   [ | | grTrf: GrModule ]
ATTR AllNT     [ | | grTrf: SELF     ]

-- bring the HPT map down to the Expression level
ATTR GrAGItf
     GrModule
     AllBind
     AllGrExpr [ hptMap: HptMap | | ]

{-
SEM GrBind
  | Bind lhs . grTrf = GrBind_Rec $
                          (GrBind_Bind @nm @annot @argNmL $
                            exprComments (@loc.doorzichtComment ++ @loc.specComment ++ @loc.patsComment)
                            @expr.grTrf) : @loc.clones
-}

SEM GrBind
  | Bind lhs . grTrf = GrBind_Rec $ @loc.grTrf : locGrTrf_Syn_GrBindL @loc.info

SEM GrExpr
  | Call lhs . grTrf = exprComments (@loc.specComment) @loc.liftedCall

%%]

===============================================================================
== Find specializable functions
===============================================================================

%%[(8 codegen grin)

ATTR AllBind [ | | recBindsUp USE {++} {[]} : {[HsName]} ]
ATTR GrModule AllBind AllGrExpr [ recBindsDown : {[HsName]} | | ]
ATTR AllGrExpr [  | | specCalls USE {++} {[]} : {[[GrVal]]} ]
ATTR AllGrExpr [ | | rSize USE {+} {1} : Int ]

SEM GrModule
  | Mod bindL . recBindsDown = []

SEM GrBind
  | Rec lhs . recBindsUp = []
        bindL . recBindsDown = @bindL.recBindsUp -- push down all (mutual) recursive bindings
  | Bind loc . funArgsOk  = length @argNmL > 0 -- H1: function definition
         loc . funSizeOk = @expr.rSize <= specSizeTreshold -- H2: check for "sufficiently small" function
         lhs . recBindsUp = if @loc.funSizeOk && @loc.funArgsOk then [@nm] else [] -- only include specialisable bindings

SEM GrExpr
  | Call loc . isSpecializable = elem @nm @lhs.recBindsDown
         lhs . specCalls = if @loc.isSpecializable then [@argL.grTrf] else []

-- Comments
SEM GrExpr
  | Call
         loc . specComment = if @loc.isSpecializable && actualPattern @loc.pattern
                               then ["Specialisable call!",show @loc.pattern] ++ dzichtCallComment @argL.grTrf @lhs.doorzicht
                               else ["Non-specialisable call"]

SEM GrBind
  | Bind loc . specComment = ["Specializable calls: " ++ show @expr.specCalls]

%%]

===============================================================================
== Variable re-numbering
===============================================================================

%%[(8 codegen grin)

-- maxVar is the highest variable number occurring in the nonterminal
-- newVar is a threaded attribute for the first available variable number.
ATTR AllNT [ | newVar : Int | maxVar USE {`max`} {0} : Int ]

SEM GrBind
  | Bind lhs . maxVar = max (getNr @nm) (@expr.maxVar)
         expr . newVar = locNewVar_Syn_GrBindL @loc.info

SEM GrPatLam
  | Var lhs . maxVar = getNr @nm

SEM GrModule
  | Mod bindL . newVar = @bindL.maxVar + 1

%%]

%%[8.arityRaise hs

-- | Adds comments that indicate which arguments have which associated values.
dzichtCallComment :: [GrVal] -> [[GrVal]] -> [String]
dzichtCallComment args doorzicht = map (uncurry mkComment) (zip args doorzicht)
  where
    mkComment arg dz = show arg ++ " ~= " ++ show dz

%%]

===============================================================================
== "Doorzicht" analysis
===============================================================================

%%[(8 codegen grin)

-- doorzicht is an ordered list of related variables/nodes.
-- The first element corresponds to the first parameter,
-- The second element corresponds to the second paremeter, etc.
ATTR AllGrExpr [ doorzicht : {[[GrVal]]} | | ]	-- jean: we probably don't need to send the doorzicht down anymore, since all information is available at the binding-level

-- | doorzichtUp collects the information needed to construct the doorzicht attribute.
--   It is a list of associated ("equivalent") values.
ATTR GrExpr GrAlt [ | | doorzichtUp : {[[GrVal]]} ]
ATTR GrAltL [ | | doorzichtUp : {[[[GrVal]]]} ]

SEM GrBind
  | Bind loc . doorzicht = map (findRelated @expr.doorzichtUp . GrVal_Var) @argNmL
         expr . doorzicht = @loc.doorzicht
         loc . doorzichtComment = ["Doorzicht: " ++ show @loc.doorzicht]

-- Needs variable usage for other GrExpr cases added.
SEM GrExpr
  | Seq lhs . doorzichtUp = case @expr.interestingVal of
                              Nothing -> @body.doorzichtUp
                              Just x  -> addDoorzicht (patLamToVal @pat.grTrf) x @body.doorzichtUp
  | Unit lhs . doorzichtUp = [[@val.grTrf]]
  | UpdateUnit lhs . doorzichtUp = [[GrVal_Var @nm , @val.grTrf]]
  | Case lhs . doorzichtUp = unionAll (concat @altL.doorzichtUp)
  | FetchNode lhs . doorzichtUp = [[GrVal_Var @nm]]
  | Store lhs . doorzichtUp = [[@val.grTrf]]
  | Call lhs . doorzichtUp = map (:[]) (@argL.grTrf)

SEM GrAltL
  | Nil lhs . doorzichtUp = []
  | Cons lhs . doorzichtUp = @hd.doorzichtUp : @tl.doorzichtUp


-- | Just x if x is effectively the same thing as what it'll be bound to.
--   Nothing when this isn't the case.
ATTR GrExpr [ | | interestingVal : {Maybe GrVal} ]

SEM GrExpr
  | Unit lhs . interestingVal = Just @val.grTrf
  | FetchNode lhs . interestingVal = Just (GrVal_Var @nm)
  | Store lhs . interestingVal = Just @val.grTrf
  | Case lhs . interestingVal = if (any isIdent @altL.grTrf ) then Just @val.grTrf else Nothing
  | * -Unit -FetchNode -Store -Case lhs . interestingVal = Nothing

%%]

%%[8.arityRaise hs

-- | 'findRelated doorzicht val' looks up all values in the doorzicht map that are related to 'val'.
findRelated :: [[GrVal]] -> GrVal -> [GrVal]
findRelated doorzicht val = case filter (val `elem`) doorzicht of
                              []     -> []
                              (x:xs) -> x


-- | 'addDoorzicht key value doorzicht' adds 'value' to the list of values associated with 'key'.
addDoorzicht :: GrVal -> GrVal -> [[GrVal]] -> [[GrVal]]
addDoorzicht key value doorzicht = map addMe doorzicht
  where addMe groep | key `elem` groep = value : groep
                    | otherwise        = groep


-- Convert a pattern that's allowed in a lambda to a value that would match that pattern.
patLamToVal :: GrPatLam -> GrVal
patLamToVal GrPatLam_Empty = GrVal_Empty
patLamToVal (GrPatLam_Var nm) = GrVal_Var nm
patLamToVal (GrPatLam_VarNode fldL) = mkVal fldL
  where mkVal (GrVar_KnownTag tag:fields) = GrVal_Node tag (map varToVal fields)
        mkVal fields                      = GrVal_VarNode (map varToVal fields)
patLamToVal (GrPatLam_BasicNode annot nm) = GrVal_BasicNode GrTag_Any nm
patLamToVal (GrPatLam_EnumNode nm) = GrVal_EnumNode nm
patLamToVal (GrPatLam_PtrNode nm) = GrVal_PtrNode nm
patLamToVal (GrPatLam_OpaqueNode nm) = GrVal_OpaqueNode nm
patLamToVal (GrPatLam_BasicAnnot annot nm) = GrVal_BasicNode GrTag_Any nm
-- unused tagL x2?
patLamToVal (GrPatLam_EnumAnnot tagL nm) = GrVal_EnumNode nm
patLamToVal (GrPatLam_PtrAnnot tagL nm) = GrVal_PtrNode nm
patLamToVal (GrPatLam_OpaqueAnnot nm) = GrVal_OpaqueNode nm

varToVal :: GrVar -> GrVal
varToVal (GrVar_Var nm) = GrVal_Var nm
varToVal (GrVar_KnownTag tag) = GrVal_Tag tag
varToVal (GrVar_Ignore) = error "Grvar_Ignore"


-- | unionAll sanitizes the given doorzicht map such that afterwards every element only occurs in one sublist.
unionAll :: [[GrVal]] -> [[GrVal]]
unionAll = foldr mergeIn []

-- | 'mergeIn values doorzicht' adds a list of values to the doorzicht map.
mergeIn :: [GrVal] -> [[GrVal]] -> [[GrVal]]
mergeIn x []     = [x]
mergeIn x (y:ys) | null (x `intersect` y) = y : mergeIn x ys
                 | otherwise              = mergeIn (x `union` y) ys


-- | Test if the annotation is a GrAltAnnIdent
isIdent :: GrAlt -> Bool
isIdent (GrAlt_Alt ann _ _) = ann == GrAltAnnIdent

%%]

===============================================================================
== Pattern generation
===============================================================================

%%[(8 codegen grin)

SEM GrBind
  | Bind loc . pats = filter actualPattern $ map (mkPat @loc.doorzicht) @expr.specCalls
         loc . patsComment = ["Pats: " ++ show @loc.pats]

SEM GrExpr
  | Call loc . pattern = mkPat @lhs.doorzicht @argL.grTrf

{
mkPat :: [[GrVal]] -> [GrVal] -> [GrVal]
mkPat dzicht call = zipWith combine call dzicht
  where
    combine callArg dzs | elem callArg dzs = let ns = nodes dzs
                                             in  case ns of
                                                   [n] -> n
                                                   _   -> callArg
                        | otherwise = callArg
    nodes = filter isNode

-- Test if this is an actual specializable pattern. i.e.: contains nodes.
actualPattern :: [GrVal] -> Bool
actualPattern = any isNode
}

%%]

===============================================================================
== Function cloning
===============================================================================

%%[(8 codegen grin)

ATTR AllGrExpr [ usedPats : {[([GrVal],Int)]} | | ]


SEM GrBind
  | Bind expr . usedPats = locUsedPats_Syn_GrBindL @loc.info

SEM GrBind
  | Bind loc . info = localTrf @loc.grTrf @loc.pats @lhs.newVar

SEM GrExpr
  | Call loc . liftedCall = if @loc.isSpecializable && actualPattern @loc.pattern
                            then GrExpr_Call (cloneName @lhs.usedPats @loc.pattern) (@argL.grTrf)
                            else @loc.grTrf

{

-- | Returns the name of the clone of the input name.
cloneName :: [([GrVal],Int)] -> [GrVal] -> HsName
cloneName pats pat = case lookup pat pats of
  Just n -> nameNum n
  _      -> error $ "cloneName: " ++ show pat

-- Substitutions of Fetch to Unit that need to be done.
mkSubsts :: [HsName] -> [GrVal] -> Map HsName GrVal
mkSubsts oldArgs pat = foldr (uncurry Map.insert) Map.empty argpat
  where
    argpat = filter (isNode . snd) (zip oldArgs pat)
}

%%]

===============================================================================
== Local function transformation
===============================================================================

%%[(8 codegen grin)

ATTR AllNTNoMod [ | | locGrTrf : SELF ]

SEM GrExpr
  | FetchNode lhs . locGrTrf = case Map.lookup @nm @lhs.substs of
                                   (Just s) -> GrExpr_Comment "Substituted" (GrExpr_Unit s)
                                   _        -> @loc.locGrTrf

SEM GrBind
  | Bind lhs . locGrTrf = GrBind_Bind (nameNum @lhs.locNewVar) @annot (concat @loc.newArgs) @expr.locGrTrf
         loc . argVar = foldr (uncurry op) e (zip @argNmL @lhs.locPat) (@lhs.locNewVar + 1)
                            where op arg pat rest var = case patVars pat of
                                       [_]  -> let (var',rest') = rest var
                                               in (var',[arg]:rest')
                                       more -> let (var',rest') = rest (var + length more)
                                               in (var',map nameNum [var..var + length more - 1]:rest')
                                  e var = (var,[])
         loc . newArgs = snd @loc.argVar
         expr . locNewVar = fst @loc.argVar

{
patVars :: GrVal -> [GrVal]
patVars (GrVal_Node _ fldL) = fldL
patVars (GrVal_VarNode fldL) = tail fldL
patVars val = [val]
}

-- Collect a mapping of new bindings to their number.
-- GrVal is no instance of Ord, so I can't use Data.Map here.
ATTR AllBind [ | | locUsedPats USE {++} {[]} : {[( [GrVal], Int)]} ]

SEM GrBind
  | Bind lhs . locUsedPats = [(@lhs.locPat, @lhs.locNewVar)]


ATTR AllNTNoMod [ | locNewVar : Int | ]

-- Substitutions to make.
ATTR AllExpr [ substs : {Map HsName GrVal} | | ]

SEM GrBind
  | Bind expr . substs = mkSubsts @argNmL @lhs.locPat

-- Local transformation initially gets a list of identical GrBinds.
-- locPats and locPat make sure every GrBind gets a different pattern.
ATTR GrBindL [ locPats : {[[GrVal]]} | | ]
ATTR GrBind AllExpr [ locPat : {[GrVal]} | | ]

SEM GrBindL
  | Cons hd . locPat = head @lhs.locPats
         tl . locPats = tail @lhs.locPats

{
-- We're doing some nasty things here since not all inherited attributes are provided
-- this will give some warnings
localTrf :: GrBind -> [[GrVal]] -> Int -> Syn_GrBindL
localTrf bind pats varNum = let inh = Inh_GrBindL { locNewVar_Inh_GrBindL = varNum
                                                   , locPats_Inh_GrBindL = pats }
                             in wrap_GrBindL (sem_GrBindL bindl) inh
  where bindl = replicate (length pats) bind

}

%%]

===============================================================================
== Utility functions
===============================================================================

%%[8.arityRaise hs

-- Treshold to determine which functions we want to specialize
-- hence big functions (according to the treshold) will not be
-- specialized to avoid excessive code increase
--
-- Unit: number of nested GRIN expressions
specSizeTreshold = 1000000 -- big number to avoid headaches during testing

exprComments :: [String] -> GrExpr -> GrExpr
exprComments cs r = foldr GrExpr_Comment r cs

isNode :: GrVal -> Bool
isNode (GrVal_Node _ _) = True
isNode _ = False

nameNum :: Int -> HsName
nameNum n = HNmNr n OrigNone

%%]
