%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrExpr
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.SubstituteVars} import({%{EH}Base.Common}, {%{EH}GrinCode}, qualified Data.Map as Map, qualified Data.Set as Set) export(substituteVars, allVars, freshSubs)
type GrSubs = Map.Map HsName HsName

substituteVars :: GrExpr -> GrSubs -> GrExpr
substituteVars grExpr subs = let t = wrap_GrExpr (sem_GrExpr grExpr) (Inh_GrExpr { subs_Inh_GrExpr = subs, vars_Inh_GrExpr = Set.empty })
                             in grTrf_Syn_GrExpr t

allVars :: GrExpr -> Set.Set HsName
allVars grExpr = let t = wrap_GrExpr (sem_GrExpr grExpr) (Inh_GrExpr { subs_Inh_GrExpr = Map.empty, vars_Inh_GrExpr = Set.empty })
                 in vars_Syn_GrExpr t

freshSubs :: Int -> GrExpr -> (GrSubs, Int)
freshSubs i grExpr = let av = Set.toList $ allVars grExpr
		     in (Map.fromList $ zipWith (\x y ->(x, HNPos y)) av [i..], i + length av)
%%]

%%[8
ATTR AllExpr [ | vars: {Set.Set HsName} | ]
-- only introduced in patterns (Case Alt, or Seq)
SEM GrPat
  | Var	lhs . vars  = Set.insert @nm @lhs.vars
SEM GrExpr
  | Catch lhs . vars = Set.insert @arg @lhs.vars --FIXME

ATTR AllExpr AllAdapt AllSplit [ subs:GrSubs | | grTrf:SELF ]
SEM GrVal
  | Var 	lhs . grTrf = GrVal_Var (subsLookup @nm @lhs.subs)
SEM GrPat
  | Var 	lhs . grTrf = GrPat_Var (subsLookup @nm @lhs.subs)
SEM GrExpr
  | Fetch	lhs . grTrf = GrExpr_Fetch (subsLookup @nm @lhs.subs) @mbOffset @mbTag
  | Catch       lhs . grTrf = GrExpr_Catch @body.grTrf (subsLookup @arg @lhs.subs) @handler.grTrf

{
subsLookup :: HsName -> GrSubs -> HsName
subsLookup nm subs = Map.findWithDefault nm nm subs
}

%%]

