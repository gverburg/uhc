%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
{
import qualified Data.Map as Map
import Maybe(fromMaybe)
}
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.CaseHoisting} import({%{EH}Base.Common}, {%{EH}GrinCode}) export(caseHoisting)
caseHoisting :: GrModule -> GrModule
caseHoisting grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                    in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
ATTR AllGrNT [ | | self : SELF     ]
%%]


It would be nice to leave the descision whether to inline the case (if it duplicates much code) to the inliner.

(case v of 
	pat1 -> e1
	pat2 -> e2
); \u ->
(case u of
	pat3 -> <m1>
	pat4 -> <m2>
); \w ->
<m3>

==>

LET 
	m1 = <m1>
	m2 = <m2>
IN
(case v of 
	pat1 -> e1; \u ->
		(case u of
			pat3 -> m1
			pat4 -> m2
		)		
	pat2 -> e2; \u ->
		(case u of
			pat3 -> m1
			pat4 -> m2
		)
); \w ->
<m3>

Unfortunately, m1 and m2 have to be evaluated lazily here (expressed by the LET),
because they depend on (Var u),
but there is no way to express laziness in GRINs `built-in monad'.

-- todo what about making _continuation functions_ for m1, m2? (p. 142 second-last par of 'Limiting code duplication')

(p. 189 RISC code generation optimisation)
"Unfortunately there is no general and good solution to this problem on the GRIN level\footnote{We do not consider continuation functions a very good solution.}." -- TODO why not?
"The key observation is that when an alternative of the first case expression returns a known tag, the code can jump directly into the corresponding branch of the second case expression, bypassing the extra test."
"The implementation of this optimisation is very similar to _the GRIN case hoisting transformation_, but here we only insert different branch instructions instead of duplicate code like in the GRIN transformation."
"The actual bookkeeping that needs to be done for this transformation is rather involved, to handle sequences of more than two case expressions, nested case expressions, etc., and we will not explain the details here."

-- todo how does GRIN treat LETs?

-- TODO does SSA need (Var u) to be renamed in the different case branches?
-- what if (Var u) is used in <m3>?

-- todo can we vary the order of inlining? (p. 142 last par of 'Limiting code duplication')
-- seems silly: we need evaluated u

To measure code duplication:
 * simple: count _known returns_ (i.e. (Unit x) where x has a known tag) -- TODO synth attr `known'
 * extended: track more -- todo `local hpt-extension'

Think about:
 * how many cases are left? if ==1, then the whole case expression can be removed -- todo inherit `local hpt-extension' to produce synth attr `matches' (todo could also perform constant propagation immediately)
 * what is the (summed) size of the code involved in each of these cases? -- todo synth attr `size'

(The `scrutinized' pat1, pat2 are thus TOTALLY IRRELEVANT to case hoisting.)

Recursiveness of this optimisation:
 * easy: When 3 or more case expressions are sequenced, and CaseExpr#2 is hoisted to CaseExpr#1; and moreover hoisting CaseExpr#3 to CaseExpr#2 is considered too expensive. Then after hoisting CaseExpr#2 (e.g. much alternatives) to CaseExpr#1 (e.g. few alternatives), the cost of hoisting CaseExpr#3 might be (much) reduced. -- TODO recurse
 * difficult: It would occur if e1 or e2 (case branches of CaseExpr#1 above) would contain other (CaseExpr#2) which have _known tags_. These would of course only be usefull if the branches e1 or e2 would lack _known tags_. But then, the decision to inline at CaseExpr#1 would depend on the decision to inline at CaseExpr#2!! -- todo




ATTR GrExpr GrAltL GrAlt [ hoistThis: {Maybe (GrPat, GrExpr)} | | ]
-- expr; \pat -> body
SEM GrExpr
  | Seq   (@expr.hoistThis, lhs.grTrf) = if @expr.isCase && @body.isSeqExprCase && @expr.hoistHerePlease
                      			 then (Just (@pat.grTrf, @body.grTrfExpr), @expr.grTrf) -- after hoist, we can throw away the Seq that binds body
                      			 else (Nothing, GrExpr_Seq @expr.grTrf @pat.grTrf @body.grTrf)
  | Case  @altL.hoistThis = lhs.hoistThis


%%[8
-- determine if we have a seq of two cases
SEM GrExpr [ | | isCase USE {`constfalse`} {False} : Bool
                 leftIsCase USE {`constfalse`} {False} : Bool
           ]
  | Case  lhs.isCase     = True
  | Seq   lhs.leftIsCase = @expr.isCase --fixme: || @expr.leftIsCase ?
          loc.isCaseSeq  = @expr.isCase && (@body.leftIsCase || @body.isCase)


-- Count the number of alternatives of which we know what tag it will return
SEM GrAltL [ | | knownAltRets : Int -- no. alternatives with a known return tag
                 noAlts : Int -- no. alternatives
           ] 
  | Cons  lhs.knownAltRets = if @hd.knownReturn then @tl.knownAltRets + 1 else @tl.knownAltRets
          lhs.noAlts = 1 + @tl.noAlts
  | Nil   lhs.knownAltRets = 0
          lhs.noAlts = 0


-- determine wether a case alternative has a known return tag
ATTR GrExpr GrAlt [ | | knownReturn USE {`constfalse`} {False} : Bool ]
SEM GrExpr
  | Seq   lhs.knownReturn = @body.knownReturn -- propagate
  | Case  lhs.knownReturn = False  --fixme: should we determine what a case's returns are?
  | Unit  lhs.knownReturn = @val.knownTag
          -- advanced would like listing of unknown-returns, then using local-hpt to calculate reduction

SEM GrVal [ | | knownTag USE {`constfalse`} {False} : Bool ]
  | Node   lhs.knownTag = True
  | LitInt lhs.knownTag = True
  | Tag    lhs.knownTag = True
  | Var    lhs.knownTag = True --TODO: lookup the possible tags


-- Decide wether or not to apply the hoisting transformation on a 
-- particular sequence
SEM GrExpr [ doHoist : Bool 
             -- tell left case (in expr) of a seq to hoist
             -- and tell seq body to remove its case
           | 
           | allKnownRets USE {`constfalse`} {False} : Bool 
             -- true if all alternatives of a case are true
             -- or if the (left) expr of a seq is has all known returns
           ]
  | Case lhs.allKnownRets = @altL.noAlts == @altL.knownAltRets
  | Seq  loc.canHoist = @loc.isCaseSeq && not @lhs.doHoist && @expr.allKnownRets
         expr.doHoist = @loc.canHoist
         body.doHoist = @loc.canHoist
         --lhs.allKnownRets = @expr.allKnownRets

SEM GrBind
  | Bind  expr.doHoist = False
SEM GrAlt
  | Alt   expr.doHoist = False

-- pass the values that would be needed for a case hoist
SEM GrExpr [ hoistedCasePat : GrPat -- pattern of the right case (u in the example)
           | hoistedCase : GrExpr -- case that is inlined
           | pushPattern : GrPat -- the pattern that has to be moved upwards (w in the example)
           ]
  | Seq   lhs.hoistedCase = @expr.self
          expr.hoistedCasePat = @pat.self
          expr.hoistedCase = @body.hoistedCase
          lhs.pushPattern = @pat.self


-- Apply case hoisting if we're told to
SEM GrExpr
  | Seq  lhs.grTrf = if @loc.canHoist 
                     then if @body.isCase
                          then @expr.grTrf
                          else GrExpr_Seq @expr.grTrf @body.pushPattern @body.grTrf
                     else if @lhs.doHoist  -- true if we're the body of a hoisted seq
                          then @body.grTrf -- in which case we remove the case in expr
                          else GrExpr_Seq @expr.grTrf @pat.grTrf @body.grTrf
  | Case altL.caseMap = if @lhs.doHoist
                        then mkCaseMap @lhs.hoistedCasePat @lhs.hoistedCase
                        else const id

ATTR GrAltL GrAlt GrExpr [ caseMap : CaseMap | | ]

SEM GrExpr
  | Unit  loc.transformer = if @lhs.isLast
                            then @lhs.caseMap (getValTag @val.grTrf) 
                            else id
          lhs.grTrf       = @loc.transformer (GrExpr_Unit @val.grTrf)

SEM GrExpr [ isLast : Bool | | ]
  | Seq body.isLast = True
        expr.isLast = False

SEM GrBind
  | Bind  expr.isLast = True
          expr.caseMap = const id
SEM GrAlt
  | Alt   expr.isLast = True



{
type CaseMap = GrTag -> GrExpr -> GrExpr

getValTag :: GrVal -> GrTag
getValTag = undefined

mkCaseMap :: GrPat -> GrExpr -> CaseMap
mkCaseMap u body _ expr =
  GrExpr_Seq expr u body
--mkCaseMap u (GrExpr_Case _ altL) tag e = 
--  let altTups = map mkTup altL
--      mkTup (GrAlt_Alt pat expr) = (pat, \e -> GrExpr_Seq e u expr)
--      caseMap = Map.fromList altTups
--      lookuperr = id --TODO: really make this an error
--  in fromMaybe lookuperr $ Map.lookup tag caseMap
}

{
--mkSeq :: GrExpr -> GrExpr -> GrExpr
--mkSeq newExpr oldBody (GrExpr_Seq (GrExpr_Case valV altLA) pattU (GrExpr_Seq (GrExpr_Case valU altLB) pattW expr)) =
--mkSeq (GrExpr_Seq (GrExpr_Case valV altLA) pattU (GrExpr_Seq (GrExpr_Case valU altLB) pattW expr)) =
}


--SEM GrAlt
--  | Alt   lhs.grTrf = GrAlt @pat.grTrf (hoist lhs.hoistThis @expr.grTrf)

{
--hoist :: MayBe (GrPat, GrExpr) -> GrExpr -> GrExpr
--hoist Nothing = id
--hoist (Just (pat, tailCase)) e = GrExpr_Seq e pat tailCase -- TODO SSA for pat?
}

{
constfalse _ _ = False
}
%%]

% vim:ts=4:et:
