%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.CaseHoisting} import({%{EH}Base.Common}, {%{EH}GrinCode}) export(caseHoisting)
caseHoisting :: GrModule -> GrModule
caseHoisting grmod = undefined
--let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
--                    in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]


It would be nice to leave the descision whether to inline the case (if it duplicates much code) to the inliner.

(case v of 
	pat1 -> e1
	pat2 -> e2
); \u ->
(case u of
	pat3 -> <m1>
	pat4 -> <m2>
); \w ->
<m3>

==>

LET 
	m1 = <m1>
	m2 = <m2>
IN
(case v of 
	pat1 -> e1; \u ->
		(case u of
			pat3 -> m1
			pat4 -> m2
		)		
	pat2 -> e2; \u ->
		(case u of
			pat3 -> m1
			pat4 -> m2
		)
); \w ->
<m3>

Unfortunately, m1 and m2 have to be evaluated lazily here (expressed by the LET),
because they depend on (Var u),
but there is no way to express laziness in GRINs `built-in monad'.

-- todo what about making _continuation functions_ for m1, m2? (p. 142 second-last par of 'Limiting code duplication')

(p. 189 RISC code generation optimisation)
"Unfortunately there is no general and good solution to this problem on the GRIN level\footnote{We do not consider continuation functions a very good solution.}." -- TODO why not?
"The key observation is that when an alternative of the first case expression returns a known tag, the code can jump directly into the corresponding branch of the second case expression, bypassing the extra test."
"The implementation of this optimisation is very similar to _the GRIN case hoisting transformation_, but here we only insert different branch instructions instead of duplicate code like in the GRIN transformation."
"The actual bookkeeping that needs to be done for this transformation is rather involved, to handle sequences of more than two case expressions, nested case expressions, etc., and we will not explain the details here."

-- todo how does GRIN treat LETs?

-- TODO does SSA need (Var u) to be renamed in the different case branches?
-- what if (Var u) is used in <m3>?

-- todo can we vary the order of inlining? (p. 142 last par of 'Limiting code duplication')
-- seems silly: we need evaluated u

To measure code duplication:
 * simple: count _known returns_ (i.e. (Unit x) where x has a known tag) -- TODO synth attr `known'
 * extended: track more -- todo `local hpt-extension'

Think about:
 * how many cases are left? if ==1, then the whole case expression can be removed -- todo inherit `local hpt-extension' to produce synth attr `matches' (todo could also perform constant propagation immediately)
 * what is the (summed) size of the code involved in each of these cases? -- todo synth attr `size'

(The `scrutinized' pat1, pat2 are thus TOTALLY IRRELEVANT to case hoisting.)

Recursiveness of this optimisation:
 * easy: When 3 or more case expressions are sequenced, and CaseExpr#2 is hoisted to CaseExpr#1; and moreover hoisting CaseExpr#3 to CaseExpr#2 is considered too expensive. Then after hoisting CaseExpr#2 (e.g. much alternatives) to CaseExpr#1 (e.g. few alternatives), the cost of hoisting CaseExpr#3 might be (much) reduced. -- TODO recurse
 * difficult: It would occur if e1 or e2 (case branches of CaseExpr#1 above) would contain other (CaseExpr#2) which have _known tags_. These would of course only be usefull if the branches e1 or e2 would lack _known tags_. But then, the decision to inline at CaseExpr#1 would depend on the decision to inline at CaseExpr#2!! -- todo




ATTR GrExpr GrAltL GrAlt [ hoistThis: {Maybe (GrPat, GrExpr)} | | ]
-- expr; \pat -> body
SEM GrExpr
  | Seq   (@expr.hoistThis, lhs.grTrf) = if @expr.isCase && @body.isSeqExprCase && @expr.hoistHerePlease
                      			 then (Just (@pat.grTrf, @body.grTrfExpr), @expr.grTrf) -- after hoist, we can throw away the Seq that binds body
                      			 else (Nothing, GrExpr_Seq @expr.grTrf @pat.grTrf @body.grTrf)
  | Case  @altL.hoistThis = lhs.hoistThis



-- determine if we have a seq of two cases
SEM GrExpr [ | | isCase leftIsCase USE {`constfalse`} {False} : Bool, grTrfExpr : GrExpr ]
  | Case  lhs.isCase     = True
  | Seq   lhs.leftIsCase = @expr.isCase --fixme: || @expr.leftIsCase ?
          loc.isCaseSeq  = @expr.isCase && @body.leftIsCase
   	      lhs.grTrfExpr  = @expr.grTrf --todo: move this to where it is used

SEM GrExpr [ | | isHoistTarget USE {`constfalse`} {False} : Bool ] 
  | Case  lhs.hoistHerePlease = @argL.known == length @argL

-- Count the number of alternatives of which we know what tag it will return
SEM GrAltL [ | | knownAltRets : Int -- no. alternatives with a known return tag
                 noAlts : Int -- no. alternatives
           ] 
  | Cons  lhs.knownAltRets = if @hd.knownReturn then @tl.known + 1 else @tl.known
          lhs.noAlts = 1 + @tl.noAlts
  | Nil   lhs.knownAltRets = 0
          lhs.noAlts = 0

-- determine wether a case alternative has a known return tag
ATTR GrExpr GrAlt [ | | knownReturn USE {`constfalse`} {False} : Bool ]
SEM GrExpr
  | Seq   lhs.knownReturn = @body.knownReturn -- propagate
  | Case  lhs.knownReturn = False  --fixme: should we determine what a case's returns are?
  | Unit  lhs.knownReturn = @val.knownTag
          -- advanced would like listing of unknown-returns, then using local-hpt to calculate reduction

--fixme: we only need these for expressions, right?
--ATTR GrExpr GrAltL GrAlt [ doHoist : Bool 
ATTR GrExpr [ doHoist : Bool -- tell left case of a seq to hoist
              hoistedCasePat : GrPat -- pattern of the right case (u in the example
              hoistedCase : GrExpr -- the case that will be hoisted
            | | ]

-- Decide wether or not to apply the hoisting transformation on a particular
-- sequence and pass down the values that would be needed for a hoist.
-- TODO: rename hoistedCasePat's variables in hoistedCase
SEM GrExpr
  | Seq loc.doHoist = @loc.isCaseSeq && @expr.hoistHere
        lhs.grTrf = if @loc.doHoist then @expr.grTrf 
                    else GrExpr_Seq @expr.grTrf @pat.grTrf @body.grTrf
        expr.doHoist = @loc.doHoist
        expr.hoistedCasePat = @pat.grTrf --fixme: copy rule?
        expr.hoistedCase = @body.grTrfExpr

-- Apply case hoisting if we're told to
SEM GrAlt
  | Alt lhs.grTrf = undefined


--SEM GrAlt
--  | Alt   lhs.grTrf = GrAlt @pat.grTrf (hoist lhs.hoistThis @expr.grTrf)

{
--hoist :: MayBe (GrPat, GrExpr) -> GrExpr -> GrExpr
--hoist Nothing = id
--hoist (Just (pat, tailCase)) e = GrExpr_Seq e pat tailCase -- TODO SSA for pat?
}



{constfalse _ _ = False}



% vim:ts=4:et:
