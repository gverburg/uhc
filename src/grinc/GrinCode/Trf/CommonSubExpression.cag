%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.Identity} import({%{EH}Base.Common}, {%{EH}GrinCode}) export(identity)
identity :: GrModule -> GrModule
identity grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                    in grTrf_Syn_GrAGItf t
%%]

%%[8
type SubsEnv = [(GrExpr,GrExpr)]
-- matches a GrinExpr and substitutes for an available simpler GrinExpr

ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
ATTR GrAGItf [ | env: SubsEnv | ] -- environment (for a very small scope!) 
ATTR GrAGItf [ | reusable: Bool | ]
%%]

%%[8
-- replace with Unit operations
-- we are interested in the cases of: (see Boquist p. 149)
   -- function calls Call
   -- primitive operations FFI
   -- Unit operations
   -- memory Fetch, Store operations

data HeapMod = New
		 | Edit nm:GrId
		 | Unknown

SEM GrExpr
  | Unit    loc  .  reusable = False  -- (todo: reuse when other than Tag, Empty, LitInt?)
  | FFI     loc  .  reusable = True   -- @resTagL ??
  | Fetch   loc  .  reusable = True
  | Store   loc  .  reusable = True   
            loc  .  heapmod  = New      -- also produce corresponding Fetch substitution 
						    -- (we know no name yet! wait for Seq)
  | Update  loc  .  heapmod  = Edit @nm
  | Call    loc  .  reusable = True
		loc  .  heapmod  = Unknown


SEM GrExpr
  | Seq     loc  .  env	=  (modify_reuse @reuse @expr @pat) (modify_heap @heapmod @expr @pat) lhs@env


modify_heap :: HeapMod -> GrExpr -> GrPat -> SubsEnv -> SubsEnv
-- but mind: it must not be Update-d in between!
  -- (mind only closures: "if a whnf is ever updated it must be with an identical value", p. 150)
-- mind also "function Call-s that risk updating nodes in the environment"!
modify_heap New expr pat = Cons ((Fetch nm mbOffset mbTag), Unit val)
	where nm = pat -- todo? get from pat
-- compared to Fetch, has no offset
modify_heap Edit expr pat = -- TODO drop fetches
	where dropfetch x@((Fetch nm mbOffset mbTag'), (Unit val)) xs -- matching nm
			(mbTag == mbTag') = xs -- todo -- drop
			otherwise	  = x : xs
		dropfetch x xs = x : xs
modify_heap Unknown _ = -- TODO drop fetches
	where dropfetch ((Fetch _ _ _), _) xs = xs -- drop all Fetch-es, thus safe (todo)
		dropfetch x xs = x : xs

modify_reuse :: Bool -> GrExpr -> GrPat -> SubsEnv -> SubsEnv
modify_reuse True expr pat = Cons (expr, (Unit pat))
modify_reuse False _ _ = id


SEM GrExpr
  | Seq     loc  .  grTrf	=  lookup @expr lhs.@env

lookup :: GrExpr -> SubsEnv -> GrExpr
lookup x [] = x
lookup x (x,y):ys = y

%%]

% vim:ts=4:et:
