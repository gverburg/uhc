This transformation drops all not directly called functions. Because only
direct calls are counted, this should be used after inlining eval and apply
calls. (When no hidden function calls exists anymore.)

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.Inliner} import ({%{GRIN}GrinCode.Trf.SubstituteVars}, qualified Data.Set as Set , qualified Data.Map as Map , Data.Graph , qualified Data.List as List , Data.Array , qualified Data.Tree as Tree, qualified Control.Monad as Monad)
type EdgeF   = [Edge] -> [Edge]
type VertexF = [Vertex] -> [Vertex]

type CallCounter = Map.Map Vertex Int
type CallInfo = Map.Map Vertex CallType
data CallType = Call | TailCall | BothCall deriving (Eq, Show)

type NodeInfo  = (Vertex, CallInfo)
type NodeInfoF = [NodeInfo] -> [NodeInfo]

type GrExprBuilder = [HsName] -> Maybe GrExpr
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(inliner)

inliner :: HsName -> IdentNameMap -> GrModule -> (GrModule, String)
inliner e m grmod = 
  let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
            (Inh_GrAGItf { entry_Inh_GrAGItf = e, nameMap_Inh_GrAGItf = m })
  in (grTrf_Syn_GrAGItf t, dot_Syn_GrAGItf t)
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

ATTR GrAGItf GrModule [ entry: HsName nameMap: IdentNameMap | | dot: String ]
%%]

%%[8.graphInfo import({GrinCode/LastExpr})
ATTR AllBind            [ | | biggest USE {`max`} {minBound}: Int
                              smallest USE {`min`} {maxBound}: Int
                              nodes USE {.} {id}: NodeInfoF
                        ]
ATTR AllGrExpr          [ | calls: CallInfo | ]

SEM GrBind
  | Bind  loc   .  bindNr    = getNr @nm
          lhs   .  smallest  = @bindNr
                .  biggest   = @bindNr
                .  nodes     = ( (@bindNr, @expr.calls) :)
          expr  .  calls     = Map.empty

SEM GrExpr
  | Call  loc  .  mergeCall  =  (\p n -> if p == n then p else BothCall)
               .  callType   =  if @isLastExpr then TailCall else Call
               .  calls      =  Map.insertWith @mergeCall (getNr @nm) @callType @lhs.calls
%%]

%%[8.graph
SEM GrModule
  | Mod  loc  .  nodes  = @bindL.nodes []
              .  graph  = let buildNode prev outlist = Map.keys outlist
                          in accumArray buildNode [] (@bindL.smallest, @bindL.biggest) @nodes
%%]

%%[8.dropUnusedBindings
ATTR AllBind [ liveBindings: {Set.Set Int} | | ]

SEM GrModule
  | Mod  loc    .  liveBindings  =  Set.fromList $ reachable @graph (getNr @lhs.entry)
         
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  not (@bindNr `Set.member` @lhs.liveBindings)
  | Rec   lhs  . dropBinding  =  @bindL.count == 0


SEM GrBindL [ | | count: Int ]
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf
                            else @hd.grTrf : @tl.grTrf
               .  count  =  if @hd.dropBinding then @tl.count else 1 + @tl.count
  | Nil   lhs  .  count  =  0
%%]



%%[8.callCounter
ATTR AllBind AllGrExpr  [ | callCounter: CallCounter | ]

SEM GrExpr
  | Call  loc . callCounter = Map.insertWith (+) (getNr @nm) 1 @lhs.callCounter

SEM GrModule
  | Mod   loc . callCounter = Map.empty
%%]


%%[8.inline
ATTR AllBind [ inlineBindings : {Set.Set Int} | | ]

SEM GrModule
  | Mod   loc . inlineBindings = @singleCalls `Set.difference` @loopBreakers
          loc . singleCalls = Map.keysSet $ Map.filter (==1) @bindL.callCounter
          loc . loopBreakers = Set.fromList $ getLoopBreakers @graph @bindL.callCounter

SEM GrBind [ | | code : {Maybe (Int,GrExprBuilder)} ]
  | Rec   lhs . code = Nothing
  | Bind  loc . isInlined = @bindNr `Set.member` @lhs.inlineBindings
          lhs . code = if @isInlined then Just (@bindNr, @codeBuilder) else Nothing
          loc . codeBuilder = mkCodeBuilder @expr.grTrf @argNmL

{
mkCodeBuilder :: GrExpr -> [HsName] -> [HsName] -> Maybe GrExpr
mkCodeBuilder expr pars args = do
  slist <- maybezip pars args
  let smap = Map.fromList slist :: Map.Map HsName HsName
  return (substituteVars expr smap)

maybezip :: [a] -> [b] -> Maybe [(a,b)]
maybezip [] [] = Just []
maybezip (a:as) (b:bs) = fmap ((a,b):) (maybezip as bs)
maybezip _ _ = Nothing
}

SEM GrBindL [ | | inlineCode : {[(Int, GrExprBuilder)]} ]
  | Cons  lhs . inlineCode = maybe id (:) @hd.code @tl.inlineCode
  | Nil   lhs . inlineCode = []


ATTR AllBind AllGrExpr [ allInlineCode : {Map.Map Int GrExprBuilder} | | ]

SEM GrModule
  | Mod  bindL . allInlineCode = Map.fromList @bindL.inlineCode

SEM GrExpr
  | Call  lhs . grTrf = case Map.lookup (getNr @nm) @lhs.allInlineCode of
                          Nothing -> @self
                          Just c  -> maybe (@self) id (c @argL.listVars)
          loc . self = GrExpr_Call @nm @argL.grTrf

ATTR AllGrVal [ | | listVars USE {++} {[]} : {[HsName]} ]
SEM GrVal
  | Var     lhs . listVars = [@nm]

%%]



%%[8.loopBreakers
{
getLoopBreakers :: Graph -> CallCounter -> [Int]
getLoopBreakers graph cc =
  let loops = scc graph

      breakLoop :: [Int] -> [Int]
      breakLoop [] = []
      breakLoop [c] | not (isSelfRec c) = []
      breakLoop cs = breaker : (getLoopBreakers newGraph cc)
        where breaker = List.maximumBy orderByCallCnt cs 
              newGraph = delTermEdges graph breaker

      isSelfRec :: Int -> Bool
      isSelfRec c = c `elem` graph!c

      orderByCallCnt :: Int -> Int -> Ordering
      orderByCallCnt x y = compare (getCnt x) (getCnt y)
        where getCnt i = Map.findWithDefault 0 i cc
  
  in concatMap (breakLoop . Tree.flatten) loops

delTermEdges :: Graph -> Vertex -> Graph
delTermEdges graph vertex = array (bounds graph) tupleMap
  where tupleMap = [ (v, List.delete vertex vs) | (v, vs) <- assocs graph ]
}
%%]


%%[8.dot
SEM GrModule
  | Mod   loc  .  dot        = unlines (mkDot @lhs.entry
                                              (show @moduleNm) 
                                              (foldl (mkNodeEdges @lhs.nameMap @liveBindings)
                                                     id
                                                     @nodes
                                              )
                                       )
%%]

%%[8.dot hs
mkDot e n nodeEdges = let header     = (  (("digraph \"" ++ n ++ "\" {") :)
                                       .  ("margin = 0" :)
                                       )
                          entryNode  = ( (show e ++ " [ shape = diamond ]") :)
                          footer     = ( "}" :)
                      in (header . entryNode . nodeEdges . footer) []

mkNodeEdges nm lns sf (n,es) = 
    let  style  =  if n `Set.member` lns
                   then ""
                   else "color = gray, fontcolor = gray"
         node   =  ( (show n ++ " [ label = \"" ++ getName nm n ++ "\"" ++ style ++ "];") :)
    in Map.foldWithKey (mkEdge n) (sf . node) es

mkEdge from to callType sf = sf . ( (show from ++ " -> " ++ show to ++ style) :)
    where
    style = case callType of
               Call      ->  ";"
               TailCall  ->  " [style=\"dotted\"];"
               BothCall  ->  " [style=\"dashed\"];"
%%]

% vim:ts=4:et:ai:
