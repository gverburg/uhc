This transformation drops all not directly called functions. Because only
direct calls are counted, this should be used after inlining eval and apply
calls. (When no hidden function calls exists anymore.)

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.Inliner} import(qualified Data.Set as Set,qualified Data.Map as Map,Data.Graph,Data.List,Data.Array as Array)
type EdgeF   = [Edge] -> [Edge]
type VertexF = [Vertex] -> [Vertex]

type CallList = Map.Map Vertex CallInfo
type CallInfo = (CallType, Int, Int) -- type, use, occurences
data CallType = Call | TailCall | BothCall deriving (Eq, Show)

--type GlobalCallInfo = (Int, Int, Maybe (Int, Bool, GrExpr, [HsName])) -- use and occurences, sizeIncrease, knownReturns
data GlobalCallInfo = GlobalCallInfo
  { use :: Int
  , occ :: Int
  , privateInfo :: Maybe PrivateCallInfo
  }

data PrivateCallInfo = PrivateCallInfo
  { known :: Bool
  , code :: GrExpr
  , args :: [HsName]
  , size :: Int
  }

mkSimpleCallInfo u o = GlobalCallInfo { use = u, occ = o, privateInfo = Nothing }

type GlobalCallInfoMap = Map.Map Vertex GlobalCallInfo

type NodeInfo  = (Vertex, CallList)
type NodeInfoF = [NodeInfo] -> [NodeInfo]
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(inliner)
inliner :: HsName -> IdentNameMap -> GrModule -> (GrModule, String)
inliner e m grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                               (Inh_GrAGItf { entry_Inh_GrAGItf = e, nameMap_Inh_GrAGItf = m })
                    in (grTrf_Syn_GrAGItf t, dot_Syn_GrAGItf t)
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

ATTR GrAGItf GrModule [ entry: HsName  nameMap: IdentNameMap | | dot: String ]
%%]

%%[8.graphInfo import({GrinCode/LastExpr})
ATTR AllBind            [ | | biggest USE {`max`} {minBound}: Int
                              smallest USE {`min`} {maxBound}: Int
                              nodes USE {.} {id}: NodeInfoF
                        ]
ATTR AllGrExpr          [ | | calls USE {`undefined`} {Map.empty}: CallList ]

ATTR AllGrNT [ | | size USE {+1+} {1} : Int ]
SEM GrBind [ | | sizeIncrease: Int ]
  | Bind	loc . sizeIncrease = @expr.size - (1 + 1 + length @argNmL)
-- (Call nm argL): always saturated, so size = 1 for Call, 1 for nm


--
-- COPY from casehoisting

-- determine wether a case alternative has a known return tag
ATTR GrExpr GrAlt [ | | knownReturn USE {`constfalse`} {False} : Bool ]
SEM GrExpr
  | Seq   lhs.knownReturn = @body.knownReturn -- propagate
  | Case  lhs.knownReturn = False  --fixme: should we determine what a case's returns are?
  | Unit  lhs.knownReturn = @val.knownTag
          -- advanced would like listing of unknown-returns, then using local-hpt to calculate reduction

SEM GrVal [ | | knownTag USE {`constfalse`} {False} : Bool ]
  | Node   lhs.knownTag = True
  | LitInt lhs.knownTag = True
  | Tag    lhs.knownTag = True
  | Var    lhs.knownTag = True --TODO: lookup the possible tags

{
constfalse _ _ = False
}

--
--

ATTR AllGrNT [ globalCallInfo : GlobalCallInfoMap | | ]
SEM GrModule
  | Mod  bindL  .  globalCallInfoGath = Map.empty
                .  globalCallInfo = @globalCallInfo
         loc    .  globalCallInfo = @bindL.globalCallInfoGath

ATTR GrBindL GrBind [ | globalCallInfoGath : GlobalCallInfoMap | ]

SEM GrBind
  | Bind  loc   .  bindNr    = getNr @nm
                .  myInfo    = GlobalCallInfo { use = 0, occ = 0, privateInfo = Just @privInfo }
                .  privInfo  = PrivateCallInfo { size = @sizeIncrease, known = @expr.knownReturn, code = @expr.grTrf, args = @argNmL }
                .  globalCallInfoUpdate = Map.map (\(_,u,o) -> GlobalCallInfo { use = u, occ = o, privateInfo = Nothing }) @expr.calls -- FIXME efficiency?
          lhs   .  smallest  = @bindNr -- 'singleton' interval
                .  biggest   = @bindNr
                .  nodes     = ( (@bindNr, @expr.calls) :)
                .  globalCallInfoGath = Map.unionWith mergeGlobal @globalCallInfoUpdate
                                        (Map.insertWith mergeGlobal @bindNr @myInfo @lhs.globalCallInfoGath)

{
mergeGlobal :: GlobalCallInfo -> GlobalCallInfo -> GlobalCallInfo
mergeGlobal a b = GlobalCallInfo { use = use a `max` use b, occ = occ a + occ b, privateInfo = privateInfo a `some` privateInfo b }
    where some Nothing c = c
          some c Nothing = c
}

SEM GrAltL
  | Cons  lhs   .  calls     = Map.unionWith mergeBranches @hd.calls @tl.calls         
  | Nil   lhs   .  calls     = Map.empty

{
mergeType :: CallType -> CallType -> CallType
mergeType tp tp' = if tp == tp' then tp else BothCall
}

{
mergeBranches :: CallInfo -> CallInfo -> CallInfo
mergeBranches (tp,use,occ) (tp',use',occ') = (mergeType tp tp', max use use', occ + occ')
}

SEM GrExpr
  | Seq   lhs  .  calls	     =  Map.unionWith mergeSeq @expr.calls @body.calls
  | Call  loc  .  callType   =  if @isLastExpr then TailCall else Call
          lhs  .  calls      =  Map.singleton (getNr @nm) (@callType, 1, 1)

{
mergeSeq :: CallInfo -> CallInfo -> CallInfo
mergeSeq (tp,use,occ) (tp',use',occ') = (mergeType tp tp', use + use', occ + occ')
}
%%]

%%[8.graph
SEM GrModule
  | Mod  loc  .  nodes  = @bindL.nodes []
              .  graph  = let buildNode prev outlist = Map.keys outlist 
                          in accumArray buildNode undefined (@bindL.smallest, @bindL.biggest) @nodes -- map & array in one run :) efficiency
              . loopBreakers = findLoopBreakers @graph @globalCallInfo
         bindL . loopBreakers = @loopBreakers
         bindL . preInline    = Map.filter (preInlineUnconditionally @globalCallInfo) $ Map.keys @graph \\ @loopBreakers
%%]

%%[8
{
maxim :: (Ord b, Bounded b) => (a -> b) -> [a] -> a
maxim f [x] = x
maxim f (x:xs) | fx == maxBound = fx
	       | mxs > fx       = mxs
	       | otherwise      = fx
	where fx = f x
	      mxs = maxim xs

onceSafe :: GlobalCallInfo -> Bool
multiSafe :: GlobalCallInfo -> Bool
onceSafe  i = use i == 1 && occ i == 1
multiSafe i = use i == 1

findLoopBreakers :: Graph -> GlobalCallInfoMap -> [Vertex]
findLoopBreakers g info = concatMap (visit . Tree.flatten) forest
	where forest = scc g -- scc analysis, topologically ordered
	      -- the component is a [Vertex]
	      visit :: [Vertex] -> [Vertex]
	      visit c@[v] | not selfRecursive g v = []
		              | otherwise 			  = loopBreaker : findLoopBreakers g'
		where loopBreaker = maxim (heuristic g) c
		      selfRecursive g v = v `elem` g!v
		      heuristic g v | selfRecursive g v                 = maxBound -- we really don't want to inline v, so most high score for loop breaking
				            | preInlineUnconditionally g info v = minBound -- we really do want to inline v 
		      g' = deleteTerminatingEdges g loopBreaker
 
deleteTerminatingEdges :: Graph -> Vertex -> Graph
deleteTerminatingEdges g v = array (bounds g) [ (vertex, vertices \\ v) | (vertex, vertices) <- Array.elems g ]

noSizeIncrease :: GlobalCallInfo -> Bool
noSizeIncrease i = size (privateInfo i) <= 0

resultDiscount :: GlobalCallInfo -> Bool
resultDiscount i | known (privateInfo i) = knownResultDiscount
                 | otherwise   = 0

preInlineUnconditionally :: GlobalCallInfoMap -> Vertex -> Bool
preInlineUnconditionally info v
  | noSizeIncrease vInfo = True -- GRIN calls don't have environments that matter for this computation
  | otherwise            = onceSafe vInfo -- counts
     where vInfo = (Map.lookup v info)
}

-- ATTR AllGrExpr [ | | lookupArgs: {HsName} ]
-- ATTR AllGrExpr [ lookupArgs: {HsName} | | scoreArgs: Map.Map HsName Bool ]
%%]


%%[8
-- test
{
inlineTreshold = 7 
knownResultDiscount = 1
}

-- callSiteInline
ATTR AllGrNT [ loopBreakers: {Set.Set Vertex}  preInline: {Set.Set Vertex}  dynamicKnown: {Set.Set HsName} | | ]
SEM GrExpr
  | Call	loc . key            = (getNr @nm)
                . info           = Map.lookup @key @lhs.globalCallInfo
                . preInline      = Set.member @key @lhs.preInline
                . callSiteInline = ( (size @info) -- size of Call is constant in GRIN (ever saturated application)
                                      -- @argL.discount
                                      -- (resultDiscount @info)
                                      -- TODO for other trafo's  interesting: Int
                                   ) < inlineTreshold 
            lhs . grTrf  = if not (Set.member @key @lhs.loopBreakers) && ( @preInline || @callSiteInline )
                           then substituteVars (code @info) $ Map.union freshSubs (Map.fromList $ zip (args @info) @argL)
                           else (GrExpr_Call @nm @argL) -- self

-- ATTR GrValL [ | | discount: Int ]
-- SEM GrValL
%%]

%%[8.dropUnusedBindings
ATTR AllBind [ lifeBindings: {Set.Set Int} | | ]

SEM GrModule
  | Mod  loc    .  lifeBindings  =  Set.fromList $ reachable @graph (getNr @lhs.entry)
         
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  not (@bindNr `Set.member` @lhs.lifeBindings)
  | Rec   lhs  . dropBinding  =  @bindL.count == 0


SEM GrBindL [ | | count: Int ]
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf -- DROP!
                            else @hd.grTrf : @tl.grTrf
               .  count  =  if @hd.dropBinding then @tl.count else 1 + @tl.count
  | Nil   lhs  .  count  =  0
%%]

%%[8.dot
SEM GrModule
  | Mod   loc  .  dot        = unlines (mkDot @lhs.entry
                                              (show @moduleNm) 
                                              (foldl (mkNodeEdges @lhs.nameMap @lifeBindings)
                                                     id
                                                     @nodes
                                              )
                                       )
%%]

%%[8.dot hs
mkDot e n nodeEdges = let header     = (  (("digraph \"" ++ n ++ "\" {") :)
                                       .  ("margin = 0" :)
                                       )
                          entryNode  = ( (show e ++ " [ shape = diamond ]") :)
                          footer     = ( "}" :)
                      in (header . entryNode . nodeEdges . footer) []

mkNodeEdges nm lns sf (n,es) = 
    let  style  =  if n `Set.member` lns
                   then ""
                   else "color = gray, fontcolor = gray"
         node   =  ( (show n ++ " [ label = \"" ++ getName nm n ++ "\"" ++ style ++ "];") :)
    in Map.foldWithKey (mkEdge n) (sf . node) es

mkEdge from to (callType,_,_) sf = sf . ( (show from ++ " -> " ++ show to ++ style) :)
    where
    style = case callType of
               Call      ->  ";"
               TailCall  ->  " [style=\"dotted\"];"
               BothCall  ->  " [style=\"dashed\"];"
%%]

% vim:ts=4:et:ai:
