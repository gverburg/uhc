This transformation drops all not directly called functions. Because only
direct calls are counted, this should be used after inlining eval and apply
calls. (When no hidden function calls exists anymore.)

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.Inliner} import({%{GRIN}GrinCode.Trf.SubstituteVars}, qualified Data.Set as Set,qualified Data.Map as Map, Data.Graph,Data.Tree as Tree,Data.List,Data.Array as Array,Maybe,Data.List as List, Debug.Trace(trace))
type EdgeF   = [Edge] -> [Edge]
type VertexF = [Vertex] -> [Vertex]

type CallList = Map.Map Vertex CallInfo
type CallInfo = (CallType, Int) -- type, occurences
data CallType = Call | TailCall | BothCall deriving (Eq, Show)

data GlobalCallInfo = GlobalCallInfo
  { occ :: Int
  , privateInfo :: Maybe PrivateCallInfo
  }
    deriving Show

data PrivateCallInfo = PrivateCallInfo
  { known :: Bool
  , code :: GrExpr
  , args :: [HsName]
  , size :: Int
  }
    deriving Show

uPrivateInfo = fromJust . privateInfo
privateKnown = known . fromJust . privateInfo 
privateCode = code . fromJust . privateInfo
privateArgs = args . fromJust . privateInfo
privateSize = size . fromJust . privateInfo

mkSimpleCallInfo u o = GlobalCallInfo { occ = o, privateInfo = Nothing }

type GlobalCallInfoMap = Map.Map Vertex GlobalCallInfo

type NodeInfo  = (Vertex, CallList)
type NodeInfoF = [NodeInfo] -> [NodeInfo]
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(inliner)
inliner :: Int -> HsName -> IdentNameMap -> GrModule -> (Int, GrModule, String)
inliner uniq e m grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                              (Inh_GrAGItf { entry_Inh_GrAGItf = e, nameMap_Inh_GrAGItf = m, uniq_Inh_GrAGItf = uniq })
                    in (uniq_Syn_GrAGItf t, grTrf_Syn_GrAGItf t, dot_Syn_GrAGItf t)
%%]

%%[8
ATTR GrAGItf [ | uniq: Int | grTrf: GrModule ]
ATTR AllGrNT [ | uniq: Int | grTrf: SELF ]
--ATTR AllGrNT [ | | self: SELF ]

ATTR GrAGItf GrModule [ entry: HsName  nameMap: IdentNameMap | | dot: String ]
%%]

%%[8.graphInfo import({GrinCode/LastExpr})
ATTR AllBind            [ | | biggest USE {`max`} {minBound}: Int
                              smallest USE {`min`} {maxBound}: Int
                              nodes USE {.} {id}: NodeInfoF
                        ]
ATTR AllGrExpr          [ | | calls USE {`Map.union`} {Map.empty}: CallList ] -- TODO combine

ATTR AllGrNT [ | | size USE {+1+} {1}: Int ]
SEM GrBind [ | | sizeIncrease: Int ]
  | Bind    loc . sizeIncrease = @expr.size - (1 + 1 + length @argNmL)
-- (Call nm argL): always saturated, so size = 1 for Call, 1 for nm


--
-- COPY from casehoisting

-- determine wether a case alternative has a known return tag
ATTR GrExpr GrAlt [ | | knownReturn USE {`constfalse`} {False} : Bool ]
SEM GrExpr
  | Seq   lhs.knownReturn = @body.knownReturn -- propagate
  | Case  lhs.knownReturn = False  --fixme: should we determine what a case's returns are?
  | Unit  lhs.knownReturn = @val.knownTag
          -- advanced would like listing of unknown-returns, then using local-hpt to calculate reduction

SEM GrVal [ | | knownTag USE {`constfalse`} {False} : Bool ]
  | Node   lhs.knownTag = True
  | LitInt lhs.knownTag = True
  | Tag    lhs.knownTag = True
  | Var    lhs.knownTag = True --TODO: lookup the possible tags

{
constfalse _ _ = False
}

--
--

ATTR AllGrNT [ globalCallInfo : GlobalCallInfoMap | | ]
SEM GrModule
  | Mod  bindL  .  globalCallInfoGath = Map.empty
                .  globalCallInfo = @globalCallInfo
         loc    .  globalCallInfo = @bindL.globalCallInfoGath

ATTR GrBindL GrBind [ | globalCallInfoGath : GlobalCallInfoMap | ]

SEM GrBind
  | Bind  loc   .  bindNr    = getNr @nm
                .  myInfo    = GlobalCallInfo { occ = 0, privateInfo = Just @privInfo }
                .  privInfo  = PrivateCallInfo { size = @sizeIncrease, known = @expr.knownReturn, code = @expr.grTrf, args = @argNmL }
                .  globalCallInfoUpdate = Map.map (\(_,o) -> GlobalCallInfo { occ = o, privateInfo = Nothing }) @expr.calls -- FIXME efficiency?
          lhs   .  smallest  = @bindNr -- 'singleton' interval
                .  biggest   = @bindNr
                .  nodes     = ( (@bindNr, @expr.calls) :)
                .  globalCallInfoGath = Map.unionWith mergeGlobal @globalCallInfoUpdate
                                                                  (Map.insertWith mergeGlobal @bindNr @myInfo @lhs.globalCallInfoGath)

{
mergeGlobal :: GlobalCallInfo -> GlobalCallInfo -> GlobalCallInfo
mergeGlobal a b = GlobalCallInfo { occ = occ a + occ b, privateInfo = privateInfo a `some` privateInfo b }
    where some Nothing c = c
          some c Nothing = c
}

SEM GrAltL
  | Cons  lhs   .  calls     = Map.unionWith mergeInfo @hd.calls @tl.calls         
  | Nil   lhs   .  calls     = Map.empty

SEM GrExpr
  | Seq   lhs  .  calls      =  Map.unionWith mergeInfo @expr.calls @body.calls
  | Call  loc  .  callType   =  if @isLastExpr then TailCall else Call
          lhs  .  calls      =  Map.singleton (getNr @nm) (@callType, 1, 1)

{
mergeType :: CallType -> CallType -> CallType
mergeType tp tp' = if tp == tp' then tp else BothCall

mergeInfo :: CallInfo -> CallInfo -> CallInfo
mergeInfo (tp,occ) (tp',occ') = (mergeType tp tp', occ + occ')
}

%%]

%%[8.graph
SEM GrModule
  | Mod  loc   .  nodes  = @bindL.nodes []
               .  graph  = let buildNode prev outlist = Map.keys outlist 
                           in Array.accumArray buildNode [] (@bindL.smallest, @bindL.biggest) @nodes -- map & array in one run :) efficiency
               . findLoopBreakers = findLoopBreakers @graph @globalCallInfo
               . allBinds = map fst @nodes
         bindL . loopBreakers = Set.fromList @findLoopBreakers
         bindL . preInlines   = (\s -> trace ("PreInlineUnconditionally: " ++ show s) s) $ Set.filter (preInlineUnconditionally @globalCallInfo) $ Set.fromList (@allBinds \\ (\s -> trace ("Loopbreakers: " ++ show s) s) @findLoopBreakers)
%%]

%%[8
{
maxim :: (Ord b, Bounded b) => (a -> b) -> [a] -> (a, b)
maxim f [x] = (x, f x)
maxim f (x:xs) | fx == maxBound = (x, fx)
               | mfxs > fx      = m
               | otherwise      = (x, fx)
    where fx = f x
          m@(mxs, mfxs) = maxim f xs

findLoopBreakers :: Graph -> GlobalCallInfoMap -> [Vertex]
findLoopBreakers g info = concatMap (visit . Tree.flatten) forest
    where forest = scc g -- scc analysis, topologically ordered
          -- the component is a [Vertex]
          visit :: [Vertex] -> [Vertex]
          visit [] = [] -- never happens!
          visit c | length c == 1 && not (selfRecursive g (head c)) = []
                  | otherwise                                       = loopBreaker : (findLoopBreakers g' info)
            where loopBreaker = fst $ maxim (heuristic g) c
                  selfRecursive g v = v `elem` g!v
                  heuristic :: Graph -> Vertex -> Int
                  heuristic g v | selfRecursive g v               = maxBound -- we really don't want to inline v, so most high score for loop breaking
                                | preInlineUnconditionally info v = minBound -- we really do want to inline v 
                  g' = deleteTerminatingEdges g loopBreaker
 
deleteTerminatingEdges :: Graph -> Vertex -> Graph
deleteTerminatingEdges g v = array (bounds g) [ (vertex, List.delete v vertices) | (vertex, vertices) <- Array.assocs g ]

noSizeIncrease :: GlobalCallInfo -> Bool
noSizeIncrease i = privateSize i <= 0

resultDiscount :: GlobalCallInfo -> Int
resultDiscount i | privateKnown i = knownResultDiscount
                 | otherwise   = 0

preInlineUnconditionally :: GlobalCallInfoMap -> Vertex -> Bool
preInlineUnconditionally info v
  | noSizeIncrease vInfo = True -- GRIN calls don't have environments that matter for this computation
  | otherwise            = occ vInfo == 1 -- counts
     where vInfo = fromJust (Map.lookup v info)
}

-- ATTR AllGrExpr [ | | lookupArgs: {HsName} ]
-- ATTR AllGrExpr [ lookupArgs: {HsName} | | scoreArgs: Map.Map HsName Bool ]
%%]


%%[8
-- test
{
inlineTreshold = 7 
knownResultDiscount = 1
}

ATTR AllGrVal [ | listVars: {[HsName]} | ]
SEM GrVal
  | Var     lhs . listVars = @nm : @lhs.listVars

-- callSiteInline
ATTR AllGrNT [ loopBreakers: {Set.Set Vertex}  preInlines: {Set.Set Vertex}  dynamicKnown: {Set.Set HsName} | | ]
SEM GrExpr
  | Call    loc . key            = (getNr @nm)
                . info           = uPrivateInfo $ fromJust $ Map.lookup @key @lhs.globalCallInfo
                . preInline    = Set.member @key @lhs.preInlines
                . callSiteInline = ( (size @info) -- size of Call is constant in GRIN (ever saturated application)
                                      -- @argL.discount
                                      -- (resultDiscount @info)
                                      -- TODO for other trafo's  interesting: Int
                                   ) < inlineTreshold 
                . (freshSubs, unique) = freshSubs @lhs.uniq (code @info) --(GrExpr_Unit GrVal_Empty) works TODO
            argL.listVars = []
            lhs . grTrf  = if not (Set.member @key @lhs.loopBreakers) && ( @preInline || @callSiteInline )
                           then let argSubs = Map.fromList $ zip (args @info) @argL.listVars
                                in (\s -> trace ("Inlining: " ++ show @key ++ show s) s) $ substituteVars (code @info) $ Map.union @freshSubs argSubs
                           else (GrExpr_Call @nm @argL.grTrf) -- self

-- ATTR GrValL [ | | discount: Int ]
-- SEM GrValL
%%]

%%[8.dropUnusedBindings
ATTR AllBind [ lifeBindings: {Set.Set Int} | | ]

SEM GrModule
  | Mod  loc    .  lifeBindings  =  Set.fromList $ reachable @graph (getNr @lhs.entry)
         
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  not (@bindNr `Set.member` @lhs.lifeBindings)
  | Rec   lhs  . dropBinding  =  @bindL.count == 0


SEM GrBindL [ | | count: Int ]
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf -- DROP!
                            else @hd.grTrf : @tl.grTrf
               .  count  =  if @hd.dropBinding then @tl.count else 1 + @tl.count
  | Nil   lhs  .  count  =  0
%%]

%%[8.dot
SEM GrModule
  | Mod   loc  .  dot        = unlines (mkDot @lhs.entry
                                              (show @moduleNm) 
                                              (foldl (mkNodeEdges @lhs.nameMap @lifeBindings)
                                                     id
                                                     @nodes
                                              )
                                       )
%%]

%%[8.dot hs
mkDot e n nodeEdges = let header     = (  (("digraph \"" ++ n ++ "\" {") :)
                                       .  ("margin = 0" :)
                                       )
                          entryNode  = ( (show e ++ " [ shape = diamond ]") :)
                          footer     = ( "}" :)
                      in (header . entryNode . nodeEdges . footer) []

mkNodeEdges nm lns sf (n,es) = 
    let  style  =  if n `Set.member` lns
                   then ""
                   else "color = gray, fontcolor = gray"
         node   =  ( (show n ++ " [ label = \"" ++ getName nm n ++ "\"" ++ style ++ "];") :)
    in Map.foldWithKey (mkEdge n) (sf . node) es

mkEdge from to (callType,_) sf = sf . ( (show from ++ " -> " ++ show to ++ style) :)
    where
    style = case callType of
               Call      ->  ";"
               TailCall  ->  " [style=\"dotted\"];"
               BothCall  ->  " [style=\"dashed\"];"
%%]

% vim:ts=4:et:ai:
