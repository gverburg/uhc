This transformation drops all not directly called functions. Because only
direct calls are counted, this should be used after inlining eval and apply
calls. (When no hidden function calls exists anymore.)

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.DropUnusedBindings} import(qualified Data.Set as Set,qualified Data.Map as Map,Data.Graph,Data.List,Data.Array)
type EdgeF   = [Edge] -> [Edge]
type VertexF = [Vertex] -> [Vertex]

type CallList = Map.Map Vertex CallInfo
type CallInfo = (CallType, Int, Int)
data CallType = Call | TailCall | BothCall deriving (Eq, Show)


type NodeInfo  = (Vertex, CallList)
type NodeInfoF = [NodeInfo] -> [NodeInfo]
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(dropUnusedBindings)
dropUnusedBindings :: HsName -> IdentNameMap -> GrModule -> (GrModule, String)
dropUnusedBindings e m grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                    (Inh_GrAGItf { entry_Inh_GrAGItf = e, nameMap_Inh_GrAGItf = m })
                               in (grTrf_Syn_GrAGItf t, dot_Syn_GrAGItf t)
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

ATTR GrAGItf GrModule [ entry: HsName  nameMap: IdentNameMap | | dot: String ]
%%]

%%[8.graphInfo import({GrinCode/LastExpr})
ATTR AllBind            [ | | biggest USE {`max`} {minBound}: Int
                              smallest USE {`min`} {maxBound}: Int
                              nodes USE {.} {id}: NodeInfoF
                        ]
ATTR AllGrExpr          [ | | calls USE {`undefined`} {Map.empty}: CallList ]

ATTR AllGrNT [ | | size USE {+1+} {1} : Int ]
SEM GrBind [ | | sizeIncrease: Int ]
  | Bind	lhs . sizeIncrease = @expr.size - (1 + 1 + length @argNmL)
-- (Call nm argL): always saturated, so size = 1 for Call, 1 for nm

SEM GrBind
  | Bind  loc   .  bindNr    = getNr @nm
          lhs   .  smallest  = @bindNr -- 'singleton' interval
                .  biggest   = @bindNr
                .  nodes     = ( (@bindNr, @expr.calls) :)

SEM GrAltL
  | Cons  lhs   .  calls     = Map.unionWith mergeBranches @hd.calls @tl.calls         
  | Nil   lhs   .  calls     = Map.empty

{
mergeType :: CallType -> CallType -> CallType
mergeType tp tp' = if tp == tp' then tp else BothCall
}

{
mergeBranches :: CallInfo -> CallInfo -> CallInfo
mergeBranches (tp,use,occ) (tp',use',occ') = (mergeType tp tp', max use use', occ + occ')
}

SEM GrExpr
  | Seq   lhs  .  calls	     =  Map.unionWith mergeSeq @expr.calls @body.calls
  | Call  loc  .  callType   =  if @isLastExpr then TailCall else Call
          lhs  .  calls      =  Map.singleton (getNr @nm) (@callType, 1, 1)

{
mergeSeq :: CallInfo -> CallInfo -> CallInfo
mergeSeq (tp,use,occ) (tp',use',occ') = (mergeType tp tp', use + use', occ + occ')
}
%%]

%%[8.graph
SEM GrModule
  | Mod  loc  .  nodes  = @bindL.nodes []
              .  graph  = let buildNode prev outlist = Map.keys outlist -- map & array in one run :) efficiency
                          in accumArray buildNode undefined (@bindL.smallest, @bindL.biggest) @nodes
%%]

{
maxim :: (Ord b, Bounded b) => (a -> b) -> [a] -> a
maxim f [x] = x
maxim f (x:xs) | fx == maxBound = fx
	       | mxs > fx       = mxs
	       | otherwise      = fx
	where fx = f x
	      mxs = maxim xs

findLoopBreakers :: Graph -> [Vertex]
findLoopBreakers g = concatMap (visit . flatten) forest
	where forest = scc g
	      -- the component is a [Vertex]
	      visit :: [Vertex] -> [Vertex]
	      visit c | c == [v] && not selfRecursive g v = []
		      | otherwise 			  = loopBreaker : findLoopBreakers g'
		where loopBreaker = maxim (heuristic g) c
		      selfRecursive g v = v `elem` g!v
		      heuristic g v | selfRecursive g v = maxBound -- we really don't want to inline v, so most high score for loop breaking
				    | noSizeIncrease v  = minBound -- TODO -- we really do want to inline v 
		                    | otherwise         = ...counts... -- TODO
		      g' = deleteTerminatingEdges g v
 
deleteTerminatingEdges :: Graph -> Vertex -> Graph
deleteTerminatingEdges g v = array (bounds g) [ (vertex, vertices \\ v) | (vertex, vertices) <- Array.elems g ]
}

ATTR AllGrNT [ loopBreakers: [] | | doInline: Bool ]
SEM GrBind
  | Bind	lhs . 

%%[8.dropUnusedBindings
ATTR AllBind [ lifeBindings: {Set.Set Int} | | ]

SEM GrModule
  | Mod  loc    .  lifeBindings  =  Set.fromList $ reachable @graph (getNr @lhs.entry)
         
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  not (@bindNr `Set.member` @lhs.lifeBindings)
  | Rec   lhs  . dropBinding  =  @bindL.count == 0


SEM GrBindL [ | | count: Int ]
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf
                            else @hd.grTrf : @tl.grTrf
               .  count  =  if @hd.dropBinding then @tl.count else 1 + @tl.count
  | Nil   lhs  .  count  =  0
%%]

%%[8.dot
SEM GrModule
  | Mod   loc  .  dot        = unlines (mkDot @lhs.entry
                                              (show @moduleNm) 
                                              (foldl (mkNodeEdges @lhs.nameMap @lifeBindings)
                                                     id
                                                     @nodes
                                              )
                                       )
%%]

%%[8.dot hs
mkDot e n nodeEdges = let header     = (  (("digraph \"" ++ n ++ "\" {") :)
                                       .  ("margin = 0" :)
                                       )
                          entryNode  = ( (show e ++ " [ shape = diamond ]") :)
                          footer     = ( "}" :)
                      in (header . entryNode . nodeEdges . footer) []

mkNodeEdges nm lns sf (n,es) = 
    let  style  =  if n `Set.member` lns
                   then ""
                   else "color = gray, fontcolor = gray"
         node   =  ( (show n ++ " [ label = \"" ++ getName nm n ++ "\"" ++ style ++ "];") :)
    in Map.foldWithKey (mkEdge n) (sf . node) es

mkEdge from to (callType,_,_) sf = sf . ( (show from ++ " -> " ++ show to ++ style) :)
    where
    style = case callType of
               Call      ->  ";"
               TailCall  ->  " [style=\"dotted\"];"
               BothCall  ->  " [style=\"dashed\"];"
%%]

% vim:ts=4:et:ai:
