GRIN inlining falls apart in:
 - bind inlining (which subsumes removing unused bindings)
 - copy propagation (for non-function binds)

%%[8 import({GrinCode/AbsSyn}, Data.Graph)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.Inline} import({%{EH}Base.Common}, {%{EH}GrinCode}) export(inline)
inline :: GrModule -> GrModule
inline grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
               in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% strongly connected component analysis %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8

-- use scc from Data.Graph

ATTR GrExpr [ | | size: Int ]
-- this could be computed at GrInline!

ATTR GrVal [ | | dynamicKnown: Int]
-- use local hpt here
-- it is a score, not a Bool

%%]

-- because variables are never applied to arguments (because GRIN is no higher order language, thus functions are always known),
-- we leave out the interesting for Apps
-- veryBoring = (not interesting)
ATTR GrExpr [ | | interesting: Bool ]
SEM GrExpr
  | Case	@val . interesting = True

-- it turns out we do not need condition (b) of boring
-- because Apps will never be interesting by Case scrutinizing or App
