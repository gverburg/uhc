%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8_1 hs import(EHCode, EHCommon, EHTy, EHGhcCore) export(genGhcCore)
genGhcCore :: CModule -> GhcModule
genGhcCore m = sem_CodeAGItf_AGItf (sem_CModule m) 
%%]

%%[8_1.WRAPPER import(EHCodeAbsSyn)
WRAPPER CodeAGItf
%%]

%%[8_1
ATTR CModule CodeAGItf [ | | ghcmodule : GhcModule ]
ATTR CExpr  [ | | ghcexpr : Expression ]

SEM CModule
  | Mod lhs.ghcmodule = GhcModule_Module "Main" [] [] [createFunction "main" (convertType Ty_Any) @expr.ghcexpr ] 

SEM CExpr
  | Int    lhs.ghcexpr = undefined
  | Char   lhs.ghcexpr = undefined
  | Var    lhs.ghcexpr = Expression_Var (show @nm)
  | App    lhs.ghcexpr = createApplication Ty_Any @func.ghcexpr [@arg.ghcexpr]
  | Let    lhs.ghcexpr = Expression_Let @binds.ghcdefg @body.ghcexpr
  | Lam    lhs.ghcexpr = Expression_Lambda [Binder_Value $ ValueBinder_ValueBinder (show @arg) (convertType Ty_Any) ] @body.ghcexpr
  | Case   lhs.ghcexpr = undefined
  | Tup    lhs.ghcexpr = undefined
  | Sel    lhs.ghcexpr = undefined

ATTR CBind CBindL [ | | ghcdefg: ValueDefg ]
SEM CBindL
  | Cons lhs.ghcdefg = @hd.ghcdefg -- TODO: make lets work with this (use tail also)
SEM CBind 
  | Bind lhs.ghcdefg = ValueDefg_Value (ValueDef_ValueDef (show @nm) (convertType Ty_Any) @expr.ghcexpr)

%%]

%%[8_1 hs

createFunction :: VIdent -> Type -> Expression  -> ValueDefg
createFunction f t e = ValueDefg_Value (ValueDef_ValueDef f t e)

createApplication :: Ty -> Expression -> [Expression] -> Expression
createApplication t f as = Expression_App f (map Argument_Value as) -- TODO: if Type is polymorthic add type arguments

convertType = const $Type_BasicType (BasicType_Atom (AtomicType_TypeVar "a")) -- error "convert Type not implemented"
%%]
