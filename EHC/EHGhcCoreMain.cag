%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8_1 hs import(EHCode, EHCommon, EHTy, EHGhcCore, EHGam) export(genGhcCore)
genGhcCore :: CModule -> GhcModule
genGhcCore m = sem_CodeAGItf_AGItf (sem_CModule m) 
%%]

%%[8_1.WRAPPER import(EHCodeAbsSyn)
WRAPPER CodeAGItf
%%]

%%[8_1
ATTR CModule CodeAGItf [ | | ghcmodule : GhcModule ]
ATTR CExpr  [ | | ghcexpr : Expression caseAlts: {Maybe Alternatives} datatypes USE {++} {[]}: TypeDefs ]

SEM CModule
  | Mod lhs.ghcmodule = GhcModule_Module "Top"  @expr.datatypes [] [createMainFunction @ty @expr.ghcexpr]

SEM CExpr
  | Int    lhs   . ghcexpr  = Expression_ILit @int
  | Char   lhs   . ghcexpr  = Expression_CLit @char
  | Var    lhs   . ghcexpr  = (if hsnIsCon @nm then Expression_Cons else Expression_Var) (convertName @nm)
  | App    lhs   . ghcexpr  = createApplication Ty_Any @func.ghcexpr [@arg.ghcexpr]
  | Let    lhs   . ghcexpr  = case @binds.ghcdefg of
                                ValueDefg_RecValues [] -> @body.ghcexpr
                                _                      -> @ghcexpr
           loc   . ghcexpr  = case @categ of
                                CBindStrict -> Expression_Case @caseExpr @caseVarBind @caseAlts
                                _           -> Expression_Let @binds.ghcdefg @body.ghcexpr
           loc   . (caseVarBind,caseExpr) = let (ValueDefg_Value (ValueDef_ValueDef var ty e)) = @binds.ghcdefg
                                            in (ValueBinder_ValueBinder var ty, e)
           loc   . caseAlts               = maybe [Alternative_Default @body.ghcexpr] id @body.caseAlts
           binds . category = @categ
           binds . tyGam    = @tyGam
  | Lam    lhs   . ghcexpr  = Expression_Lambda [Binder_Value $ ValueBinder_ValueBinder (convertName @arg) @ty ] @body.ghcexpr
  | Case   lhs   . ghcexpr  = error "case without a let!" -- Expression_Case @expr.ghcexpr (ValueBinder_ValueBinder "_casebinder_" Ty_Any) @alts.ghcalts
  | Tup    lhs   . ghcexpr  = error "Tup rule ni" -- Expression_CLit 'T'
  | Sel    lhs   . ghcexpr  = error "Sel rule ni"
  | Case     lhs . caseAlts = Just @alts.ghcalts
  | * - Case lhs . caseAlts = Nothing

ATTR CBindL [ category: {CBindCateg} tyGam: {TyGam} | | ghcdefg: ValueDefg ]
SEM CBindL
  | Cons lhs.ghcdefg = if @hd.isDataBinding then @tl.ghcdefg else @ghcdefg
         loc.ghcdefg = case @lhs.category of
                         CBindPlain  -> ValueDefg_Value @hd.ghcdef
                         CBindRec    -> let ValueDefg_RecValues l = @tl.ghcdefg 
                                        in ValueDefg_RecValues (@hd.ghcdef : l)
                         CBindStrict -> ValueDefg_Value @hd.ghcdef
  | Nil  lhs.ghcdefg = ValueDefg_RecValues []
ATTR CBind [ tyGam: {TyGam} | | ghcdef: ValueDef  isDataBinding: {Bool}]
SEM CBind 
  | Bind lhs.ghcdef        = if @isDataBinding then @ghccreatedef else @ghcdef
         loc.ghcdef        = ValueDef_ValueDef (convertName @nm) @ty @expr.ghcexpr
            .ghccreatedef  = ValueDef_ValueDef "" Ty_Any (Expression_ILit 1) -- TODO: filter out nonsense
            .isDataBinding = hsnIsCon @nm

ATTR CAltL [ | | ghcalts : Alternatives ]
SEM CAltL
  | Cons  lhs . ghcalts = @hd.ghcalt : @tl.ghcalts
  | Nil   lhs . ghcalts = []

ATTR CAlt [ | | ghcalt : Alternative ]
SEM CAlt
  | Alt   lhs . ghcalt = Alternative_Alternative @pats.cname [] @pats.values @expr.ghcexpr

ATTR CPat CPatL [  | | cname: {DCon} values USE {++} {[]} : ValueBinders ]
SEM CPatL
  | Cons   lhs . cname = @hd.cname
  | Nil    lhs . cname = ""

SEM CPat
  | Var    lhs . cname = error "EHGhcCoreMain: Var pattern found"
           lhs . values = [ ValueBinder_ValueBinder (convertName . cpatNmNm $ @pnm) @ty ]
  | Undef  lhs . cname = error "EHGhcCoreMain: Undef in pattern found while requesting cname"
           lhs . values = error "EHGhcCoreMain: Undef in pattern found while requesting values"
  | Con    lhs . cname  = convertName @tagNm

ATTR CPatBindL CPatBind [ | | values USE {++} {[]} : ValueBinders ]

%%]

%%[8_1 hs import(Data.Char)

createMainFunction :: Ty -> Expression  -> ValueDefg
createMainFunction t e = ValueDefg_Value (ValueDef_ValueDef "top" t e)

createApplication :: Ty -> Expression -> [Expression] -> Expression
createApplication t f as = Expression_App f (map Argument_Value as) -- TODO: if Type is polymorthic add type arguments

convertName (HNm nm@(c:_ )) | isDigit c = "_" ++ nm
convertName (HNm nm@(c:cs)) | c == '!'  = "_bang_" ++ cs
convertName (HNPos p      )             = "_pos_" ++ show p
convertName nm                          = show nm
%%]

%%% DATATYPES %%%

%%[8_1 

SEM CExpr
  | Let lhs . datatypes = tyGam2DataTypes @tyGam
%%]

%%[8_1 hs
tyGam2DataTypes tg = let datas = gamToAssocL tg
                         ghcdata = map buildDataType datas
                         -- TODO: use type bindings for higher kinds
                         buildDataType (dt,ti) = TypeDef_Data (show dt) [] (buildAlternatives $ tgiData ti)
                         buildAlternatives structTy = let -- [(ConstrName,[(field,type)])]
                                                          vars :: [(HsName, [(HsName, Ty)])]
                                                          vars = assocLMapSnd (snd . tyRecExts) . snd . tyRecExts $ structTy
                                                          buildAlternative (cnm,fields) = ConsDef_ConsDef (show cnm) [] (map snd fields) 
                                                      in map buildAlternative vars
                     in ghcdata
%%]
