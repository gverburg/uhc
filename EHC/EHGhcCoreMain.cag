%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8_1 hs import(EHCode, EHCommon, EHTy, EHGhcCore) export(genGhcCore)
genGhcCore :: CModule -> GhcModule
genGhcCore m = sem_CodeAGItf_AGItf (sem_CModule m) 
%%]

%%[8_1.WRAPPER import(EHCodeAbsSyn)
WRAPPER CodeAGItf
%%]

%%[8_1
ATTR CModule CodeAGItf [ | | ghcmodule : GhcModule ]
ATTR CExpr  [ | | ghcexpr : Expression ]

SEM CModule
  | Mod lhs.ghcmodule = GhcModule_Module "Top" [] [] [createMainFunction @ty @expr.ghcexpr]

SEM CExpr
  | Int    lhs   . ghcexpr  = Expression_ILit @int
  | Char   lhs   . ghcexpr  = Expression_CLit @char
  | Var    lhs   . ghcexpr  = Expression_Var (show @nm)
  | App    lhs   . ghcexpr  = createApplication Ty_Any @func.ghcexpr [@arg.ghcexpr]
  | Let    lhs   . ghcexpr  = Expression_Let @binds.ghcdefg @body.ghcexpr
           binds . category = @categ
  | Lam    lhs   . ghcexpr  = Expression_Lambda [Binder_Value $ ValueBinder_ValueBinder (show @arg) @ty ] @body.ghcexpr
  | Case   lhs   . ghcexpr  = Expression_Case @expr.ghcexpr (ValueBinder_ValueBinder "casebinder" Ty_Any) @alts.ghcalts
  | Tup    lhs   . ghcexpr  = Expression_CLit 'T'
  | Sel    lhs   . ghcexpr  = error "Sel rule ni"

ATTR CBindL [ category: {CBindCateg} | | ghcdefg: ValueDefg ]
SEM CBindL
  | Cons
         lhs.ghcdefg = case @lhs.category of
                         CBindPlain  -> ValueDefg_Value @hd.ghcdef
                         CBindRec    -> let ValueDefg_RecValues l = @tl.ghcdefg 
                                        in ValueDefg_RecValues (@hd.ghcdef : l)
                         CBindStrict -> ValueDefg_Value @hd.ghcdef -- TODO: make a case out of it
  | Nil  lhs.ghcdefg = ValueDefg_RecValues []
ATTR CBind [ | | ghcdef: ValueDef ]
SEM CBind 
  | Bind lhs.ghcdef = ValueDef_ValueDef (show @nm) @ty @expr.ghcexpr

ATTR CAltL [ | | ghcalts : Alternatives ]
SEM CAltL
  | Cons  lhs . ghcalts = @hd.ghcalt : @tl.ghcalts
  | Nil   lhs . ghcalts = []

ATTR CAlt [ | | ghcalt : Alternative ]
SEM CAlt
  | Alt   lhs . ghcalt = Alternative_Alternative @pats.cname [] @pats.values @expr.ghcexpr

ATTR CPat CPatL [  | | cname: {DCon} values USE {++} {[]} : ValueBinders ]
SEM CPatL
  | Cons   lhs . cname = @hd.cname
  | Nil    lhs . cname = ""

SEM CPat
  | Var    lhs . cname = error "EHGhcCoreMain: Var pattern found"
           lhs . values = [ ValueBinder_ValueBinder (show @pnm) @ty ]
  | Undef  lhs . cname = error "EHGhcCoreMain: Undef in pattern found while requesting cname"
           lhs . values = error "EHGhcCoreMain: Undef in pattern found while requesting values"
  | Con    lhs . cname  = show @tagNm

ATTR CPatBindL CPatBind [ | | values USE {++} {[]} : ValueBinders ]
%%]

%%[8_1 hs import(Data.Char)

createMainFunction :: Ty -> Expression  -> ValueDefg
createMainFunction t e = ValueDefg_Value (ValueDef_ValueDef "top" t e)

createApplication :: Ty -> Expression -> [Expression] -> Expression
createApplication t f as = Expression_App f (map Argument_Value as) -- TODO: if Type is polymorthic add type arguments

moduleName (h:t) = toUpper h : t
functionName (h:t) = toLower h : t
%%]
