%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8_1

ATTR AGItf [ | | ghcmodule : GhcModule ]
ATTR Expr  [ | | ghcexpr : Expression ]

SEM AGItf
  | AGItf lhs.ghcmodule = GhcModule_Module "Main" [] [] [createFunction "main" (convertType @expr.ty) @expr.ghcexpr ] 

SEM Expr
  | IConst lhs.ghcexpr = undefined
  | CConst lhs.ghcexpr = undefined
  | Con    lhs.ghcexpr = undefined
  | Var    lhs.ghcexpr = Expression_Var (show @nm)
  | App    lhs.ghcexpr = createApplication @func.ty @func.ghcexpr [@arg.ghcexpr] -- TODO: use AppTop to make better applications
  | Let    lhs.ghcexpr = Expression_Let @decls.ghcdefg @body.ghcexpr
  | Lam    lhs.ghcexpr = Expression_Lambda [Binder_Value $ ValueBinder_ValueBinder @arg.name (convertType @body.ty) ] @body.ghcexpr
  | Parens lhs.ghcexpr = Expression_Nested @expr.ghcexpr
  | Case   lhs.ghcexpr = undefined
  | Rec    lhs.ghcexpr = undefined
  | Sel    lhs.ghcexpr = undefined

ATTR Decl Decls [ | | ghcdefg: ValueDefg ]
SEM Decl 
  | Val lhs.ghcdefg = ValueDefg_Value (ValueDef_ValueDef @patExpr.name (convertType @expr.ty) @expr.ghcexpr)

SEM Decls
  | Cons lhs.ghcdefg = @hd.ghcdefg -- TODO: Unroll Let expressions to fit in GhcCore let expressions (fold over a list)

SEM PatExpr [ | | name : VIdent ]
  | Var  lhs.name = show @nm
  | IConst lhs.name = undefined
  | CConst lhs.name = undefined
  | Con  lhs.name = undefined
  | VarAs  lhs.name = undefined
  | App  lhs.name = undefined
  | AppTop  lhs.name = undefined
  | Parens  lhs.name = @patExpr.name
  | Rec  lhs.name = undefined

%%] 

%%[8_1 hs
createFunction :: VIdent -> Type -> Expression  -> ValueDefg
createFunction f t e = ValueDefg_Value (ValueDef_ValueDef f t e)

createApplication :: Ty -> Expression -> [Expression] -> Expression
createApplication t f as = Expression_App f (map Argument_Value as) -- TODO: if Type is polymorthic add type arguments

convertType = const $Type_BasicType (BasicType_Atom (AtomicType_TypeVar "a")) -- error "convert Type not implemented"
%%]
