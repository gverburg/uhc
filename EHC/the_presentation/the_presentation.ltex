%%%%% THis document is expected to be preprocessed by lhs2TeX

\documentclass[a4]{seminar}
%include lhs2TeX.fmt
%include lhs2TeX.sty

\usepackage{pstcol}
\usepackage{graphicx}
\usepackage{semcolor}           % Seminar colored slides
\usepackage{semhelv}            % Seminar helvetica fonts
% \usepackage{semlayer}           % Seminar overlays
\usepackage{slidesec}           % Seminar sections and list of slides
\usepackage{pifont}		% Ding simbols
\usepackage{fancyhdr}           % Better headers
\usepackage{ifthen}		% Allow conditional choices

\input{seminar.bug}             % Fixing bugs
\input{seminar.bg2}             % Fixing even more bugs

%%%%%% Page Layout
%%% Footers
\def\Footers{
	\fancyfoot[L]{\tiny\thedate}
	\fancyfoot[C]{\tiny \thetitle}
	\fancyfoot[R]{\tiny Page \theslide}
}

%%% Two page layouts (one for the section slide, and one for the normal slides)
\newcommand{\NormalHeaders}{
	\fancyhead[C]{\large\textbf{\theslideheading}}
	\Footers
}
\newcommand{\NoHeaders}{
	\fancyhf{} % Clear all fields
	\Footers
}

%%% Setup the borders
\renewcommand{\headrulewidth}{2.2mm}
\renewcommand{\footrulewidth}{1.1mm}
\slideframe{none}

% To avoid that the headers be too close of the top of the page
\renewcommand{\slidetopmargin}{2cm}
\renewcommand{\slideleftmargin}{3cm}

% To center horizontally the headers and footers (see seminar.bug)
\renewcommand{\headwidth}{\textwidth}

% Do not center slides vertical 
\centerslidestrue

%%%%%% Some Environments
%%% ArrowList
\definecolor{DarkRed}   {rgb}{0.9,0.3,0.3}
\definecolor{DarkBlue}   {rgb}{0.3,0.3,0.9}
\newenvironment{List}
	{\begin{list}{\color{DarkBlue}\ding{228}}{}}
	{\end{list}}

%%% Slide (with optional section title)
\newenvironment{Slide}[1][]
	{
		\ifthenelse{\equal{#1}{}}
			{}
			{\NoHeaders}
		\begin{slide}
		\ifthenelse{\equal{#1}{}}
			{}
			{\slideheading{#1}\bigskip}
		\begin{List}
	}
	{
		\end{List}
		\end{slide}
		\NormalHeaders
	}

%%%%%% Document Info 

\title{EHC to GHC Core Backend}
\author{Presentation by Christof Douma \& Rodrigo Baptista}

% Formating of special haskell constructs
%format x1
%format x2
%format y1
%format y2
%format i1
%format i2
%format b1
%format b2
%format fb1
%format fb2
%format bs1
%format bs2

%format gen (a)      = a "^{\circ}"
%format forall (a)  = "\forall{" a "}"
%format .            = "\cdot"
%format %            = "\%"

\begin{document} 
\pagestyle{fancy}

%%%%%%%%%%%%% title slide %%%%%%%%%%%%%
\centerslidestrue
\fancyhf{}
\begin{slide}
\addtocounter{slide}{-1}
\maketitle
\bigskip
\begin{center}
http://www.cs.uu.nl/groups/ST/Eifl/EHCToGhcCore
\end{center}
\end{slide} 
\NormalHeaders
%\centerslidesfalse

%%%%%%%%%%%%% Project Overview %%%%%%%%%%%%%
\NoHeaders
\begin{slide} 
\slideheading{Project Overview}\bigskip
\input{overview1.latex}
\end{slide} 
\NormalHeaders

\begin{Slide}[Introduction]
\item What are we going to talk about?
\begin{itemize}
	\item EHCode vs GHC Core
	\item Incorporating the Backend in EHC
	\item Reintroducing Datatypes in GHC Core
	\item Generating GHC Core
	\item Type Arguments
	\item Conclusions
\end{itemize}

\end{Slide}

%%%%%%%%%%%%% EHCode vs GHC Core %%%%%%%%%%%%%
\begin{Slide}[EHCode vs GHC Core]
\item What are the main differences?
\begin{itemize}
	\item Types
	\item Datatypes
	\item Strict Let Binding
\end{itemize}
\end{Slide}

\begin{Slide}
\item Types
\begin{itemize}
	\item GHC Core Language requires type information in several places:
	\subitem Function aplications;
	\subitem Binding names to expressions;
	\subitem Pattern variables;
	\subitem All literals need to be typed explicit;
	\item EHCode language does not incorporate type information 
	\subitem So we need to incorporate types into EHCode
\end{itemize}
\end{Slide}

\begin{Slide}
\item Datatypes
\begin{itemize}
	\item EHCode converts Datatypes into records
	\item GHC Core defines Datatypes the same way as Haskell Datatypes
	\subitem We need to reintroduce them in GHC Core
\end{itemize}
\item Strict Let Binding
\begin{itemize}
	\item EHCode uses a strict let binding (let!) to force evaluation
	\item GHC Core forces evaluation only in case expressions
\end{itemize}
\item Top level bindings in GHCCore vs an expression in EHCode
\end{Slide}

%%%%%%%%%%%%% Incorporating the Backend in EHC %%%%%%%%%%%%%
\begin{Slide}[Incorportating the Backend in EHC]
\item The Main change in EHCode is to include type information to bindings specifically in:
\begin{itemize}
	\item Top Module
	\item Lambda Abstractions
	\item Pattern variables
	\item Let Bindings
	\item ...
\end{itemize}
\end{Slide}

%%%%%%%%%%%%% Reintroducing Data Types in GHC Core %%%%%%%%%%%%%
\begin{Slide}[Reintroducing Data Types in GHC Core]
	\item EH language defines datatypes in let bindings (scoped)
	\item GHC Core allows only one location for the bindings (global)
		\subitem consequence: every datatype should be renamed to a unique name
	\medskip
	\item In every let binding in EH an environment exits which contains new defined datatypes 
		\subitem Store these environments in |let| nodes of EHCode
\end{Slide}
	
\begin{slide}
\includegraphics{overview2.eps}
\end{slide}

%%%%%%%%%%%%% Examples %%%%%%%%%%%%%%%
\begin{Slide}[GhcCore transformation]
\item Examples
\end{Slide}

%%%%%%%%%%%%% Type arguments %%%%%%%%%%%%%%%
\begin{Slide}[Future work - Type arguments]
\item suppose we have
\begin{code}
let  skipInt :: forall a . Int -> a -> a
     skipInt i x = x
     twice x = skipInt x skipInt
in   ...
\end{code}

\item ghc core would be
\begin{code}
%let  skipInt :: %forall a . Int -> a -> a = 
          \@a (x::a) -> a
      twice :: %forall a . Int -> Int -> a -> a =
          \@t (x::Int) -> skipInt @(Int -> t -> t) x (skipInt @t)
%in   ...
\end{code}
\end{Slide}

%%%%%%%%%%%%% Conclusions %%%%%%%%%%%%%%
\begin{Slide}[Conclusions]
\item Lots of small changes need to be done 
	\subitem they eat up time
\item GHCCore can be used quite a long way with EHCode
	\subitem hardest point are type arguments
\item GHCCore as backend limits EH language extensions to whatever GHC has implemented
\end{Slide}

\end{document}
