%%[bodyForallUpDown
In the fourth EH version we deal, in the most general form possible,
with the presence of quantifiers in types:
we allow quantifiers, both universal (|forall|) and existential (|exists|),
everywhere in a type signature.
This offers great flexibility and richness when specifying type signatures,
but we can no longer rely on type inferencing to find these type signatures for us.
In general, it is impossible to infer types with universal quantifiers at arbitrary positions
in a type;
type inference for rank-2 is possible, but complex
\cite{jim95rank,kfoury94direct,kfoury99rank2-decid,kfoury03rank2-princ}.

In \thispaper\ we therefore tackle this problem not by a clever inferencing algorithm,
but by focussing on the propagation of explicit, programmer supplied type information to
the places in a program where this information is relevant.
We thus rely on the programmer to specify `difficult' type signatures.
Our implementation exploits these type signatures to type check and infer types
for those parts for which no type signature has been given,
similar to other approaches \cite{vytiniotis05boxy-impred,pierce00local-type-inference}.

We describe our solution in three parts:
\begin{Itemize}
\item
In \thischapt\ we start with motivating examples.
We then describe how we propagate type information, in particular the information related
to the |forall| quantifier,
`locally' through the AST,
where `locally' means neighbouring (parent and children) nodes in the AST.
\item
In \chapterRef{ehc4B} we propagate type information `globally' through the AST,
where `globally' means that we relax on the previous `neighbouring' condition\footnote{%
It has been implemented as a separate branch from EH4 of the sequence of EH compilers.
It is not yet part of the full sequence of compilers.}.
\item
In \chapterRef{ehc4C} we add existential quantification.
\end{Itemize}

We also use a notational convention that allows the omission of explicit introduction of
quantifiers in type expressions.
We will discuss this in \chapterRef{ehc-partial-sig-quant-guess}.

\subsection{Motivating examples}
\label{eh4motiv-ex}
The following is an example for demonstrating the usefulness of a universal quantifier at 
a higher-ranked position.

%%[[wrap=code
%%@[file:test/3-demo-rank.eh%%]
%%]

The \IxAsDef{rank position}
of an argument is defined to be one higher than the function type in which the argument occurs,
with rank 1 as the base case:
The |forall| quantifier in this example thus is in a rank-2 position.
The \IxAsDef{rank} of a type is the maximum of the rank positions of quantifiers in a type.
The advantage of a higher-ranked type is that inside |f|'s body the argument-bound function |i| can
be used polymorphically;
in the same way as the |let|-bound function |id| can be used polymorphically.

Rank-2 polymorphism allows argument-bound and |let|-bound functions to be treated in the same way:
both may be polymorphic.
This is not the case for pure Hindley-Milner type inference,
which excludes higher-ranked polymorphism.
The advantage of this restriction is that removal of explicitly specified type signatures from a program still
yields the same (or more general) typing of values (principal type property).
However, this advantage turns into a hindrance when a programmer needs higher-ranked types,
and is also willing to specify these types.

Shan \cite{shan04sexy-types} presents an overview of Haskell
examples gathered from literature
which exploit higher-ranked polymorphism.
The examples either implement generic behavior or encapsulation.
We repeat examples of both,
but do not discuss the examples any further in detail;
they are included to illustrate that higher-ranked types indeed are useful.

\Paragraph{Generic use of higher-ranked polymorphism}
Generic traversals can be implemented by a function with the following interface \cite{laemmel03boilerplate}:
%%[[wrap=code
gmapT :: (forall ^ a . Term a => a -> a) -> (forall ^ b . Term b => b -> b)
%%]
The idea is that, given a transformation function for any type belonging to the class |Term|,
another transformation can be constructed.
The parameter of this function is a universally quantified function;
hence |gmapT| is a higher-ranked (rank-2) function.

Another example of the use of rank-n types is
their use in the translation of type-indexed functions
with kind-indexed types used in generic programming \cite{loh04gener-hs-phd}.

\Paragraph{Higher ranked polymorphism used for encapsulation}
The previous use of higher-ranked types deals with polymorphic functions; encapsulation deals with polymorphic values.
For example, |runST| \cite{launchbury96state-haskell} runs a state thread,
where |s| represents the state thread being run:

%%@TopicImpred.runST

The implementation of |runST| cannot do anything with type |s|, since it cannot assume anything about it.
As far as |runST|'s implementation is concerned |s| is hidden, or encapsulated.
Haskell (confusingly) uses the |forall| quantifier for existential quantification.

This use of a higher-ranked value corresponds to existential quantification |exists|.
We allow the use of |exists| as a language construct in its own right (\chapterRef{ehc4C}).

\subsection{Design overview}
\label{ehc4B-design}

The previous version of EH uses two mechanisms for the propagation of type information:

\begin{Itemize}
\item
Expected types are passed top-to-bottom through the AST, whereas result (or inferred) types travel bottom-to-top.
\item
Unknown types are encoded by type variables.
Additional type information about these type variables is encoded in sets of
constraints which travel through the complete
AST.
\end{Itemize}

In this version of EH we do not change this strategy.
We extend the type language with universally quantified types and allow these types to participate in
the type inference process.
As a consequence, type variables can bind to quantified types;
allowing this is called \IxAsDef{impredicativity}.
Throughout this and subsequent chapters describing EH4, we will further discuss impredicativity and its propagation,
called \IxAsDef{quantifier propagation}.

\Paragraph{Type language}

The type language used in \thischapt\ is the same as the type language used by the previous EH version.
We repeat its definition:
%%[[wrap=code
%%@SharedTypeLang.ehc3
%%]

\begin{TabularCenterFigure}{}{EH terms}{eh4-lang-terms}%
%%@AppxNotation.termTableFormat
%%@AppxNotation.exprHeader
%%@AppxNotation.exprBasic
%%@AppxNotation.exprLamPat
%%@AppxNotation.termSeparator
%%@AppxNotation.declHeader
%%@AppxNotation.declBasic
%%@AppxNotation.declValPat
%%@AppxNotation.termSeparator
%%@AppxNotation.patexprHeader
%%@AppxNotation.patexprBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.tyexprHeader
%%@AppxNotation.tyexprBasic
%%@AppxNotation.tyexprTyVar
%%@AppxNotation.tyexprForall
%%@AppxNotation.termSeparator
%%@AppxNotation.identHeader
%%@AppxNotation.identBasic
\end{TabularCenterFigure}


\Paragraph{Participation of |forall| types in the type inference process}
Standard HM type inference assumes a separation between type schemes and (monomorphic) types.
A \IxAsDef{type scheme} is a (possibly) quantified type, with the quantifier at the outer level of the type;
a monomorphic type is completely quantifier free.
In |let| expressions,
type schemes are stored in environments |Gamma|,
whereas monomorphic types participate in the type inference process.

In this version of EH, we drop this restriction:
\begin{Itemize}
\item
Types with or without quantifiers may live in environments |Gamma|, and they may participate in the
type inference process.
\item
Types retrieved from an environment |Gamma| are no longer instantiated immediately after retrieval,
because we want to retain quantifier information as long as possible.
\end{Itemize}

Types are quantified either because a programmer has specified a type signature with a quantifier,
or because the type inferencer has decided that a monomorphic type may be universally
quantified over its (non-global) type variables.
These quantified types may now enter the type inferencing process when extracted from an environment |Gamma| or
when passed top-to-bottom through the AST as the expected type of an expression.

This has the following consequences:

\begin{Itemize}
\item
Equating two types (by means of fitting) must take into account the presence of quantifiers.
\item
Instantiation of types is postponed until the latest moment possible, that is,
until an uninstantiated type is to be matched with another type.
Hence fitting must deal with instantiation as well.
\item
Type variables can also be bound to quantified types
(called \IxAsDef{impredicativity}).
Here non-determinism arises because we can interchange binding and instantiation.
We may first instantiate a type and then bind it to a type variable,
or bind it directly to a type variable and delay its instantiation.
Both are allowed to happen.
\item
Because our strategy is to propagate polymorphism instead of reconstructing it,
our encoding of polymorphism places quantifiers at a position which guarantees that their instantiation happens as late
as possible.
We will come back to this in \chapterRef{ehc-partial-sig-quant-guess}.
\item
If a type signature is passed top-down into an expression as the expected type, the type of expression has to
match this type: this is type checking.
If no such type is available, we resort to type inferencing.
In both cases type matching fills in the gaps represented by type variables.
\end{Itemize}

Let us look at some examples to see how this works out in different contexts.
We repeat our initial example:

\begin{Example}
\ \label{eh4-ex-rank-arg}
%%[[wrap=code
%%@[file:test/3-demo-rank.eh%%]
%%]
\end{Example}

\Paragraph{Checking against specified type signature}
For |id| we have specified type signature |forall ^ a . a -> a|,
which will be the expected type of |\x -> x| in the value declaration for |id|.
Before proceeding with type inference for |\x -> x|
we need to match a fresh type |tvarv1 -> tvarv2| (representing the required type structure of the |lambda|-expression)
with the expected type,
in order to decompose the expected type into argument and result (for further use lower in the AST):

%%[[wrap=code
tvarv1 -> tvarv2 <= forall ^ a . a -> a
%%]

Because the signature for |id| states that we cannot choose the quantified type variable |a| freely in
the lambda expression |\x -> x| we need to instantiate ``|forall ^ a . a -> a|''
with a fixed type variable |tvarf3| for |a|:

%%[[wrap=code
tvarv1 -> tvarv2 <= tvarf3 -> tvarf3
%%]

\Paragraph{Use of polymorphic function as a function}
In |f|'s body, function |i| will be retrieved from the environment |Gamma| for use in application ``|i 3|''.
At the occurrence of |i| in ``|i 3|'',
we know that |i|'s expected type is a function type,
but we do not (yet) know
what its argument and result type are: ``|tvarv4 -> tvarv5|''.
|i|'s type (from the environment) must match the expected type ``|tvarv4 -> tvarv5|'':

%%[[wrap=code
forall ^ a . a -> a <= tvarv4 -> tvarv5
%%]

Type ``|forall ^ a . a -> a|'' fits in ``|tvarv4 -> tvarv5|'' if we instantiate ``|forall ^ a . a -> a|''
with the fresh type variable |tvarv6|:

%%[[wrap=code
tvarv6 -> tvarv6 <= tvarv4 -> tvarv5
%%]

HM type inference instantiates a type immediately after retrieval from the environment |Gamma|,
our approach postpones instantiation until it can no longer be avoided.

\Paragraph{Use of polymorphic value as an argument when the expected argument type is known}
Function |f| gets passed |id| as its argument; |id|'s type must fit in |f|'s argument type:

%%[[wrap=code
forall ^ a . a -> a <= forall ^ a . a -> a
%%]

This is treated as a combination of the previous two matches.

\Paragraph{Use of polymorphic value as an argument when the expected argument type is being inferred}
The real tricky point arises when the type of |f|'s argument is not known, for example if no type signature
is specified for |f|:

%%[[wrap=code
%%@[file:test/4-demo-rank.eh%%]
%%]

The argument type of |f| then still is a type variable |tvarv|:

%%[[wrap=code
forall ^ a . a -> a <= tvarv
%%]

Is |tvarv| to be bound to ``|forall ^ a . a -> a|'' (being impredicative) or to the instantiated ``|tvarv1 -> tvarv1|''?
There is no way to tell.
Only the context in which the matching takes place can specify how to bind: before or after instantiation.

As a general rule we bind impredicatively (that is, without instantiation).
However, for a function application
we instantiate the type of the argument
before binding because (as a design choice) we want to mimic Haskell's type inferencing behavior.
As a consequence of binding non-impredicatively
we cannot infer a type for |f| (from our example),
because |i| (|f|'s argument) is used monomorphically in the body of |f|.
Function |i| can not be applied polymorphically.
This, of course, can be remedied by putting back the type signature for |f| as in \exRef{eh4-ex-rank-arg}.

In \chapterRef{ehc4B} we will investigate how we can exploit the presence of quantified types even more.

\Paragraph{Soundness and completeness}
Although we make no (formally proven) claims about the type system(s) described in this thesis,
we intend our type systems to be sound and complete in the sense described by the remainder of this section.
We present our intent by means of the following definition and theorems.

\begin{Definition}
\IxAsDef{HM typing} types an expression |e| according to
Hindley-Milner type inference.
If an expression types according to HM rules,
we denote this by the following typing judgement,
which types |e| in context |Gamma| with type |sigma|:
\[
\rulerCmdUse{TheoremRules.hm.scheme}
\]
Similarly,
\IxAsDef{System F typing} and \IxAsDef{EH typing} respectively type an expression |e| according to
System F with
type annotations for all expressions
and the EH4 type inference algorithm described in this (and following chapters).
\[
\begin{array}{l}
\rulerCmdUse{TheoremRules.sysf.scheme}
\\
\rulerCmdUse{TheoremRules.ehv.scheme}
\end{array}
\]
|Transla| represents the translation of |e| with System F type annotations;
|Transl| represents the translation of |e| without additional System F type annotations.
\end{Definition}

The annotated translation |Transla| requires additional abstract syntax,
but otherwise its computation only consists of moving types to argument positions of function applications.
For this EH version |e| and |Transl| are syntactically equal.

These judgement forms are exclusively used
to relate EH's type system to the HM and system F
type system.
We intend EH's type system to be a conservative extension with respect to HM:

\begin{Theorem}
\emph{(Completeness with respect to HM, or, conservative extension)}
All expressions |e| which type according to HM typing also type according to
EH typing:
\begin{eqnarray*}
\rulerCmdUse{TheoremRules.hm.scheme}
&|=>|&
\rulerCmdUse{TheoremRules.ehv.scheme}
\end{eqnarray*}
\end{Theorem}

The other way around, when restricting EH expressions to those types HM can deal with, we claim: 

\begin{Theorem}
\label{eh4-th-hm-sound}
\emph{(Soundness with respect to HM)}
If the expression |e| types according to EH typing, |sigma| and all types participating in type inference are rank-1 types,
then its translation |Transl|
types according to HM typing:
\begin{eqnarray*}
\rulerCmdUse{TheoremRules.ehv.scheme}
&|=>|&
\rulerCmdUse{TheoremRules.hmv.scheme}
\end{eqnarray*}
\end{Theorem}

For EH without restrictions we claim:

\begin{Theorem}
\label{eh4-th-sysf-sound}
\emph{(Soundness with respect to System F)}
If the expression |e| types according to EH typing then its translation |Transla| (type annotated |e|)
types according to System F typing:
\begin{eqnarray*}
\rulerCmdUse{TheoremRules.ehv.scheme}
&|=>|&
\rulerCmdUse{TheoremRules.sysfv.scheme}
\end{eqnarray*}
\end{Theorem}

These theorems express the following:
\begin{Itemize}
\item
When no type signatures are specified, or only rank-1 type signatures are specified,
EH's type inference is as clever as HM type inference.
We do not invent higher-ranked polymorphism.
\item
When type signatures are specified for all value definitions and anonymous |lambda|-expressions,
EH is equivalent to System F.
\end{Itemize}


\subsection{It all boils down to fitting}

Fitting (|<=|) is the place where all these issues come together.
Type matching has to deal with |forall| quantifiers,
and allows for some control of its behavior by the context in which |<=| is used.
We first look at options we will provide as context to |<=|,
next we look at their use in previous and new typing rules.
In the implementation of |<=| (|fitsIn|) this corresponds to an additional parameter.

\figRef{rules3.I1.fit} shows, relative to the previous EH version,
an additional |fiopt| as context for |fitsIn =@= <=|.
In the implementation this will be represented by
a value of type |FIOpts| (\textbf{f}its\textbf{I}n \textbf{opt}ion\textbf{s}),
a set of boolean flags.
A |FIOpts =@= fiopt| uses the flags from
\figRef{eh-impredA-fit-options}
for obtaining the previously discussed desired behavior.
%%[[hide wrap=code impl.FIOpts="FIOpts"
%%@EHOpts.4.FIOpts.hd
%%@EHOpts.4.FIOpts.tl
%%@EHOpts.4.strongFIOpts.hd
%%@EHOpts.4.strongFIOpts.tl
%%@EHOpts.4.FIOpts.instLFIOpts
%%]
These options are used in specific combinations throughout the type rules
(see \figRef{eh-impredA-fit-option-combis} for an overview).
|True| and |False| values are denoted by an additional |+| or |-| respectively,
for example for |fioBindRFirst| with |fioBindRFirstY| and |fioBindRFirstN| respectively.

\rulerCmdUseExplain{rules3.I1.match.eh4}
{
%%@rules3Explain.match.I1.explain.scheme
}{
%%@rules3Explain.match.I1.explain.holes
}
\rulerCmdUseExplain{rules3.I1.fit}
{
%%@rules3Explain.fit.I1.explain.scheme
}{
%%@rules3Explain.fit.I1.explain.holes
}

\begin{TabularCenterFigure}{}{Options to |fitsIn =@= <=|}{eh-impredA-fit-options}
%%@SharedFIOpts.fiOptsTableHeader
%%@SharedFIOpts.fiOptsEH4
\end{TabularCenterFigure}

\begin{TabularCenterFigure}{}{Option combinations}{eh-impredA-fit-option-combis}
%%@SharedFIOpts.fiOptsCombisTableHeader
%%@SharedFIOpts.fiOptsCombisEH4forEH4
\end{TabularCenterFigure}

We use the named combinations of these flags during type inferencing
(\figRef{rules3.I1.expr.baseForEH4}).
The name of a combination also suggests a (intuitive) meaning.
For example, |strongFIOpts| stands for a strong context where the expected type is fully known.
The actual flags associated with |strongFIOpts| are used in the rules for matching
(\figRef{rules3.I1.match.eh4}).

The rules for type matching differ from their previous version in the following additions and
modifications:

\begin{Itemize}
\item
\RuleRef{m.forall.l} instantiates with fresh type variables,
for further binding during type matching and type inference.
\RuleRef{m.forall.r} instantiates with fresh fixed type variables,
for further use in type checking.
The fixed type variables, once again, simulate unknown types chosen by the user of the value with the quantified type.
\item
The rules for binding type variables are split into two groups to emphasize
the order in which the rules are to be used: \ruleRef{m.var.l1} and \ruleRef{m.var.r1},
textually precede the rules for quantified types; \RuleRef{m.var.l2} and \ruleRef{m.var.r2} are positioned after
the rules for quantified types.
These rules only differ in the value of |fioBindRFirst|.
The order in which the rules are textually ordered now is important because they overlap.
The idea is that |fioBindRFirstY| (in \ruleRef{m.var.r1}) triggers
binding before instantiation (in the quantifier related rules),
and |fioBindRFirstN| the other way around.
\item
\RuleRef{m.arrow} for function types matches the argument types with the binding flags set to |True|.
In this way higher-ranked type information will be propagated.
The binding flags thus only influence rank-1 quantifiers.
Only when a higher-ranked type is referred to by means of an identifier (in an expression) with that type,
it will be treated (by means of further matching) as a rank-1 type.
\item
Co- and contravariance now matters.
For 
%%[[wrap=code
sigma1a -> sigma1r <= sigma2a -> sigma2r
%%]
we match the result types |sigma1r| and |sigma2r|
in the same direction: |sigma1r <= sigma2r|.
The result type of a function type is called \IxAsDef{co-variant} because matching of the complete
type and its result part are matched in the same direction.
On the other hand, the argument types are matched in the opposite direction:
|sigma2a <= sigma1a|.
This is called \IxAsDef{contra-variance}.
For the argument part of a function type this translates to the intuition that |sigma1a -> sigma1r|
can be used where |sigma2a -> sigma2r| is expected, provided
that a use of |sigma2a -> sigma2r| passes an argument |sigma2a| that can be used where a |sigma1a|
is expected.
Here, this means that a polymorphic type |sigma2a| can be instantiated to the expected type |sigma1a|.
\end{Itemize}

\subsection{Type inference}
\label{eh4-type-inference}
Flags are passed to |<=| at a limited number of locations in the type rules for expressions
(\figRef{rules3.I1.expr.baseForEH4}, \figRef{rules3.I1.decl.base}).
\RuleRef{d.val} specifies that all expressions use |strongFIOpts| to do matching,
for example in \ruleRef{e.var}.
The exception is located in \ruleRef{e.app}.
For the argument of a function instantiating takes precedence over binding.
Hence |instLRFIOpts| is passed to the argument in \ruleRef{e.app}.

\rulerCmdUseExplain{rules3.I1.expr.baseForEH4}
{
%%@rules3Explain.expr.I1.explain.scheme
}{
%%@rules3Explain.expr.I1.explain.holes
}
\rulerCmdUse{rules3.I1.decl.base}

No further changes are required for type inference for expressions.
There is no need to adapt inference for pattern expressions: identifiers are bound to the types
extracted from the expected types that are passed to pattern expressions.

\Paragraph{Option tweaking}
It is possible to deviate from Haskell at a function application by
passing different flags to the argument:

\Paragraph{Pass |fioBindRFirstY| (instead of |fioBindRFirstN|)}
The effect of this modification can best be observed from the following example:

%%[[wrap=code
%%@[file:test/4-impred-demo5.eh%%]
%%]

First assume that we are still using |fioBindRFirstN|.
Then we can infer from the call `|g h|':

%%[[wrap=code
h :: tvarf -> tvarf
%%]

This will lead to errors at the applications `|h 3|' and `|h 'x'|'.
These errors could have been avoided by concluding at `|g h|' that:

%%[[wrap=code
h :: forall ^ a . a -> a
%%]

This is accomplished by using |fioBindRFirstY| instead of |fioBindRFirstN|.
This is the desirable behavior because |h| needs to have this type anyway to be accepted by |g|.
However, we run into problems when we swap the declaration of '|y = g h|' with the remaining declarations,
because we infer types in a specific (left to right) order.
We then conclude at the application `|h 3|':

%%[[wrap=code
h :: Int -> tvarv
%%]

This leads to an error at the application `|h 'x'|';
an error that could have been avoided if we would have known the inferencing results from `|g h|'.

We conclude that the order in which we infer (unfortunately) matters.
In \chapterRef{ehc4B} we will investigate an approach in which we infer twice: first to extract impredicativeness,
and subsequently to do normal type inference.

\Paragraph{Pass |fioBindLFirstY| (instead of |fioBindLFirstN|)}
The effect of this modification can best be observed from the following example:

%%[[wrap=code
%%@[file:test/4-choose.eh%%]
%%]

Again, first assume that we are still using |fioBindLFirstN|.
At the application `|choose id|', first |id| will be instantiated to |tvarv1 -> tvarv1|,
and subsequently this type is bound to the instantiated type variable |a| from |choose|'s type:

%%[[wrap=code
choose id :: (tvarv1 -> tvarv1) -> (tvarv1 -> tvarv1)
%%]

for which, after generalization, we obtain:

%%[[wrap=code
v1 :: forall ^ a . (a -> a) -> (a -> a)
%%]

Alternatively, we might have concluded:

%%[[wrap=code
v1 :: (forall ^ a . a -> a) -> (forall ^ b . b -> b)
%%]

This effect can be achieved by using |fioBindLFirstY| instead of |fioBindLFirstN|.
We then propagate the uninstantiated type.
This mechanism can be offered as a mechanism to the programmer.
We denote this by a tilde `|~|' in front of an argument to indicate System F like propagation of
the type of the argument,
that is, impredicatively, without instantiation.
The use of this notation is restricted to applications where the type of both function and argument
are known.

The following \ruleRef{e.app.f} describes this;
the difference with \ruleRef{e.app} lies in the passing of |strongFIOpts|:
\[
\rulerCmdUse{rules3.I1.expr.base.e.app.f}
\]

For example, the following program uses both variants:
%%[[wrap=code
%%@[file:test/4-impred-choose.eh%%]
%%]

This leads to the following bindings:

%%[[wrap=code
v1  ::  forall ^ a .  (              a -> a)  ->  (              a -> a)
v2  ::                (forall ^ a .  a -> a)  ->  (forall ^ b .  b -> b)
%%]

Alternatively, we could have provided an explicit type instead, but this is more verbose:

% from: test/4-impred-choose2.eh
%%[[wrap=code
let  v3      =   (choose :: (forall a . a -> a) -> (forall b . b -> b) -> (forall c . c -> c)) id
     v4      ::  (forall a . a -> a) -> (forall b . b -> b)
     v4      =   choose id
...
%%]

Both |v3| and |v4| have the same type as |v2|.

\subsection{Conclusion}

In \thischapt\ we have described part of the fourth version of EH,
that is, the use of type annotations for higher-ranked types.
Our approach is to pass these type annotations downwards through the AST of an expression.
Others have also exploited type annotation in a similar way,
but we postpone the discussion of related work to \secRef{ehc4B}.

In the next chapter we exploit type annotations even further by allowing type information to propagate
more globally throughout the AST.



%%]






%%[bodyForallNonLocal
In \chapterRef{ehc4} we added higher-ranked types to EH.
If a programmer specifies a type signature, then the system uses this signature for type checking.
The idea was to check against a known type signature by distributing
such a signature over the AST.
We call this \IxAsDef{local quantifier propagation} because locally available quantifier related information
is used: the expected type is provided by the parent node in the AST.
Occasionally we call quantifier propagation \IxAsDef{impredicativity inference},
because we allow type variables
to be bound to quantified types (called \IxAsDef{impredicativity}),
and we allow quantified types to participate in the type inference process.

However, we can exploit the presence of type signatures even further
by considering function applications as well.
The idea is that from the use of a value as an argument for a particular function
we can derive type information for that argument based on the (argument) type of the function.
Thus we can infer type information, which can be used elsewhere, non-locally, in the AST.
The local quantifier propagation from the previous chapter then becomes a special case of what we call
\IxAsDef{global quantifier propagation}.
The following example illustrates this idea:

\begin{Example}
\ \label{eh4B-ex-basic}
%%[[wrap=code
%%@[file:test/4-impred-demo1.eh%%]
%%]
\end{Example}

From the application `|g h|' we can conclude that |h| certainly must have the following type:

%%[[wrap=code
h :: forall ^ a . a -> a
%%]

A less general type would not be accepted by |g|.
At |h|'s call sites we now can use this inferred type for |h| to correctly type the
applications `|h 3|' and `|h 'x'|',
and to infer the higher-ranked type for |f|.
The basic idea behind this approach in \thischapt\ is:
\begin{quote}
If a type for an identifier |ident| has been ``touched by'', either directly or indirectly,
polymorphic type information,
then this type information can be used at use sites of |ident|.
\end{quote}

More precisely, ``touched by'' translates to:

\begin{Itemize}
\item
An identifier occurs in a position where a polymorphic type is expected (direct touching).
In particular, argument positions in function applications are used to detect this.
\item
An identifier has a type which comes from another touched identifier (indirect touching).
\end{Itemize}

So, in our example, |h| is touched by type ``|forall ^ a . a -> a|''.
If the application `|g h|' would be removed, no touching would take place and both applications `|h 3|' and `|h 'x'|' would
result in an error:
the idea is to propagate polymorphic type information, not invent it.

\Paragraph{Choosing the most general type}
For the following example the same type for |h| is inferred.
It differs from the previous example in that |h| is expected to be used in two different ways (instead of one),
because it is passed to both |g1| and |g2|.

\begin{Example}
\ \label{eh4B-ex-most-gen}
%%[[wrap=code
%%@[file:test/4-impred-demo3.eh%%]
%%]
\end{Example}

Function |h| is expected to be used as ``|forall ^ a . a -> a|'' and ``|Int -> Int|''.
The most general of these types, that is ``|forall ^ a . a -> a|'', is bound to |h|.
The relation ``more general'' is defined in terms of |<=|: ``|sigma1| is more general than |sigma2|''
is equivalent to |sigma1 <= sigma2|.

Generality is even further exploited in the following (somewhat contrived) example.
It differs from the previous example in that |h| is not chosen from the set of available expected types,
but is the greatest common instance \cite{pfenning91anti-unif}
(or least general anti-unification, defined later in \thischapt\ as the meet of two types).

%%[[wrap=code
%%@[file:test/4-impred-demo2.eh%%]
%%]

Here |h| is expected to be used as ``|forall ^ a . (Int,a) -> (Int,a)|''
and ``|forall ^ b . (b,Int) -> (b,Int)|''.
We choose the type of |h| (and consequently |f|) to be:

%%[[wrap=code
h ::    forall ^ a . forall ^ b . (a,b)  -> (a,b)
f :: (  forall ^ a . forall ^ b . (a,b)  -> (a,b)) -> Int
%%]


\Paragraph{Contravariance}
Contravariance, that is, the reversal of |<=| for the arguments of a function type,
implies that the ``more general'' means ``less general'' for arguments.
The following example demonstrates this:

\begin{Example}
\ \label{eh4B-ex-contravariance}
%%[[wrap=code
%%@[file:test/4-impred-demo4.eh%%]
%%]
\end{Example}

Function |h| now is expected to be used as ``|(forall ^ a . a -> a) -> Int|'' but also
as ``|(Int -> Int) -> Int|''.
This means that |h| is passed a ``|forall ^ a . a -> a|'' in |g1|'s context,
so it can use the passed function polymorphically as far as the context is concerned.
In |g2|'s context a ``|Int -> Int|'' is passed;
|g2| expects this function to be used on values of type |Int| only.
Hence we have to choose the least general for the type of the function passed by |g1| and |g2|,
that is, the argument of |h|:

%%[[wrap=code
h ::    (Int -> Int)  -> Int
f :: (  (Int -> Int)  -> Int) -> Int
%%]

Because of the contra-variance of function arguments,
the least general type for the function passed by |g1| and |g2|
coincides with the most general type for |f|'s argument |h|.

\subsection{Design overview}

The design of our solution for the propagation of quantifier related type information is a combination of
the following:

\begin{Itemize}
\item
Quantifier propagation, described in \thischapt, is the first stage of a two stage process.
The second stage consists of the previously described type inference,
which exploits expected type information,
and determines bindings for type variables.
The stage described in this chapter extracts as much as possible quantifier related type information for
type variables, to be used as expected type information by the next stage.
Fresh type variables are created once, in the first stage, and retained for use in the following stage,
so type variables act as placeholders for inferred types.
\item
For type variables which represent possibly polymorphic types,
we gather all bindings to the types they are expected to have.
This is encoded by means of a type holding type alternatives and constraint variants.
These types and constraints are computed by a variation of normal HM type inference.
Type alternatives resemble intersection types \cite{bakel93phd-intersection}.
However, our type alternatives are used only internally and are not available to
a programmer as a (type) language construct.
\item
For each introduced identifier we compute the most (or least, depending on contravariance) general type
based on its type alternatives.
This results in constraints (for type variables)
which are subsequently used by type inference as discussed in earlier versions
of EH.
For this to work, it is essential that all possible type alternatives are grouped together,
including the type information extracted from explicitly specified type signatures.
\item
The computation of most/least general types is based on the lattice induced by |<=|.
\figRef{fig-type-lattice} shows an example of such a lattice for the examples presented so far.
We propagate the result of this computation if the type alternatives used to compute the most/least general type
contains a type with a quantifier.
Otherwise there is no quantifier related information to propagate.
Although we do not discuss existential types in \thischapt\ yet, existential types are included for reasons of symmetry
in \figRef{fig-type-lattice}.
\end{Itemize}

We call the resulting strategy \IxAsDef{global quantifier propagation}.

\FigureXFigTex{}{type-lattice}{Type lattice (|exists| is discussed in \chapterRef{ehc4C})}{fig-type-lattice}

\subsection{Finding possible quantifiers}

The first step in our strategy for global quantifier propagation
is to find for a type variable not just one type, but all types it
can be matched with.
Remember that the reason for \thischapt's problem is a too early binding of a type variable to a type.
We need to delay that decision by gathering all possible bindings, and extract a polymorphic type from it, if any.
Actually, we also need to find out if polymorphism needs to be inhibited.
This is a consequence of the contravariance of function arguments.

For instance, in \exPageRef{eh4B-ex-most-gen} we conclude:

%%[[wrap=code
h :: forall ^ a . a -> a
%%]

This is based on the following type matches:

%%[[wrap=code
h       ::  tvarv1
tvarv1  <=  forall ^ a . a -> a
tvarv1  <=  Int -> Int
%%]

Our previous approach was to bind |tvarv1| to one of the righthand sides of |<=|.
Here we delay this binding by binding the type variable |tvarv1| to both |tvarv1| and its binding alternatives.
We use a \IxAsDef{type alternatives} to represent this (see \figRef{eh4-lang-types} and \figRef{eh4B-notation}):

%%@SharedTypeLang.ehc4B1

We denote types |sigma| which contain type alternatives by |isigma|.
Types |isigma| only participate in quantifier propagation.

Each type alternative |talt| corresponds to an alternative type |sigma|,
together with additional information about the context in which this type is used.
We need to know this context when type alternatives are reduced to a most/least general type.
First, we need to know at which side of |<=| a type occurred.
For example, in \exPageRef{eh4B-ex-contravariance} we conclude:

%%[[wrap=code
h :: (Int -> Int) -> Int
%%]

This is based on the following type matches:

%%[[wrap=code
h                    ::  tvarv2 -> Int
forall ^ a . a -> a  <=  tvarv2
Int -> Int           <=  tvarv2
%%]

Here two types have to fit in |tvarv2|.
In the previous example,
a type variable |tvarv1| had to fit the other way around, in two types.
We call this fitting direction the
\IxAsDef{type alternative need}, denoted by |tneed|.
The direction of the current example is marked
as a \IxAsDef{type alternative offering},
denoted by |tneedO|,
because the two types are offered to be fit in the type variable.
The direction of the previous example is marked as a \IxAsDef{type alternative requirement},
denoted by |tneedR|.
We encode this information in a type alternative:

%%@SharedTypeLang.ehc4B2

A type alternative also has to remember the \IxAsDef{type alternative hardness},
denoted by |thard|.
Hardness may be hard, denoted by |thardH|, or soft, denoted by |thardS|.
By default every type alternative is soft.
|thardH| is used internally by our quantifier propagation algorithm
to mark types without a quantifier to be propagated;
this is necessary to inhibit propagation of quantified types.
For example, for \exRef{eh4B-ex-contravariance} we have to conclude the constraint ``|tvarv2 :-> Int -> Int|'' on |tvarv2|,
the least general type, and inhibit the propagtion of ``|forall ^ a . a -> a|'' as a possible binding for |tvarv2|.

\begin{TabularCenterFigure}{}{Notation for quantifier propagation}{eh4B-notation}{ll}
Notation & Meaning \\
\hline
%%@AppxNotation.notationImpredB
\end{TabularCenterFigure}

\begin{TabularCenterFigure}{}{Type language}{eh4-lang-types}%
%%@AppxNotation.termTableFormat
%%@AppxNotation.typeHeader
%%@AppxNotation.typeBasic
%%@AppxNotation.typeTyVarFixed
%%@AppxNotation.termSeparator
%%@AppxNotation.impredHeader
%%@AppxNotation.impredBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.meetJoinHeader
%%@AppxNotation.meetJoinBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.tyaltHeader
%%@AppxNotation.tyaltBasic
\end{TabularCenterFigure}

For our respective examples we find the following constraints
(on |tvarv1| from \exRef{eh4B-ex-most-gen}, |tvarv2| from \exRef{eh4B-ex-contravariance}):

%%[[wrap=code
tvarv1  :->  tvarv1 [ forall ^ a . a -> a :: thardS / tneedR, Int -> Int :: thardS / tneedR ]
tvarv2  :->  tvarv2 [ forall ^ a . a -> a :: thardS / tneedO, Int -> Int :: thardS / tneedO ]
%%]

Collecting these constraints is relatively straightforward: if a type variable is to be bound to
a type during type matching, we bind it to a type alternative.
This behavior is enabled by an additional flag |fioBindToTyAlts| to type matching
(see \figRef{eh4B-impred-fit-options} and \figRef{eh4B-impred-fit-option-combis}).
For example, binding to a type alternative is disabled in \ruleRef{m.var.l1}
(\figRef{rules3.I2.match.eh4B}, used previously),
and enabled in \ruleRef{m.var.l3} (a new rule).
New bindings for type alternatives are combined, for example in \ruleRef{m.alt} and \ruleRef{m.alt.l1}.

\begin{TabularCenterFigure}{}{Options to fit}{eh4B-impred-fit-options}
%%@SharedFIOpts.fiOptsTableHeader
%%@SharedFIOpts.fiOptsEH4
%%@SharedFIOpts.fiOptsEH4B
\end{TabularCenterFigure}

\begin{TabularCenterFigure}{}{Option combinations}{eh4B-impred-fit-option-combis}
%%@SharedFIOpts.fiOptsCombisTableHeader
%%@SharedFIOpts.fiOptsCombisEH4forEH4B
%%@SharedFIOpts.fiOptsCombisEH4B
\end{TabularCenterFigure}


\rulerCmdUse{rules3.I2.match.eh4B}

This mechanism is used by quantifier propagation, preceding normal type inference.
We next discuss the computation of most/least general types,
and postpone the use of these mechanisms (in \figRef{rules3.I2.expr.eh4B1} and \figRef{rules3.I2.expr.eh4B2})
until later.


\subsection{Computing actual quantifiers}

After the gathering of type alternatives,
we compute most/least general types based on these type alternatives.
The result of this computation are constraints on type variables.
We compute either a most general (polymorphic) type or a least general (usually non-polymorphic) type.
These constraints are used by type checking and inferencing,
representing additional assumptions for some types.

We need the combination of the following mechanisms:

\begin{Itemize}
\item
The computation of \IxAsDef{type meet}'s and \IxAsDef{type join}'s for types,
using the ordering on types defined by |<=| and its induced lattice (\figRef{fig-type-lattice})
\cite{davey02lattices-order}.
\item
The elimination of type alternatives in a type,
and the simultaneous extraction of bindings for type variables to quantified types.
\end{Itemize}

These mechanisms are mutually recursive,
because type alternative elimination uses meet/join computation to find (and combine) quantifier information,
and meet/join computation may combine (deeper nested) type alternatives.

\Paragraph{Meet and join of types}
The \IxAsDef{type meet}, denoted by |<+>|, and \IxAsDef{type join}, denoted by |<->|,
of two types |sigma1| and |sigma2| are defined by \cite{davey02lattices-order}:

%%[[wrap=code
sigma1 <+> sigma2  ===  max  { sigma  |  sigma   <=  sigma1  &&  sigma   <=  sigma2  }
sigma1 <-> sigma2  ===  min  { sigma  |  sigma1  <=  sigma   &&  sigma2  <=  sigma   }
%%]

The relation |<=| on types is assymetrical due to the presence of a universal quantifier |forall| in a type.
We have |forall ^ tvarv . sigma1 <= sigma2| if we can instantiate |tvarv| to some type for which |sigma1 <= sigma2|.
In case of absence of a quantifier in |sigma1 <= sigma2|, both types must match: |sigma1 <=> sigma2|.
Therefore |sigma1 <+> sigma2| represents the type which can be instantiated to both |sigma1| and |sigma2|;
|sigma1 <-> sigma2| represents the type which is an instantiation of both |sigma1| and |sigma2|.

The following use of meet and join constitutes a key part of our algorithm.
The type meet |<+>| is used to extract ``|forall ^ a . a -> a|'' from the following example constraint:

%%[[wrap=code
tvarv1  :->  tvarv1 [ forall ^ a . a -> a :: thardS / tneedR, Int -> Int :: thardS / tneedR ]
%%]

The type variable |tvarv1| represents a type which must fit (because tagged by |tneedR|) into both
``|forall ^ a . a -> a|'' and ``|Int -> Int|''.
The type for |tvarv1| (from \exPageRef{eh4B-ex-most-gen})
must be the most general of these two types so it can be instantiated to both the
required types.
This type for |tvarv1|
is defined as follows:

%%[[wrap=code
forall ^ a . a -> a === forall ^ a . a -> a  <+> Int -> Int
%%]

On the other hand, for |tvarv2|
(from \exPageRef{eh4B-ex-contravariance})
we know it represents a type of a value in which both
a value with type ``|forall ^ a . a -> a|'' and ``|Int -> Int|'' will flow.

%%[[wrap=code
tvarv2  :->  tvarv2 [ forall ^ a . a -> a :: thardS / tneedO, Int -> Int :: thardS / tneedO ]
%%]

The type for |tvarv2| must be the least general of these two types so both contexts can coerce
their value to a value of type |tvarv2|:

%%[[wrap=code
Int -> Int === forall ^ a . a -> a  <-> Int -> Int
%%]

The implementation of fit |<=|, meet |<+>|, and join |<->| are much alike,
so we define their implementation as variations on type matching |<=>|.
The rules in \figRef{rules3.I2.fit}, \figRef{rules3.I2.meet}, and \figRef{rules3.I2.join} dispatch to |<=>|,
and pass the variant by means of additional (mutually exclusive) flags: |fioFitY|, |fioMeetY|, and |fioJoinY|.
When the rules for |<=>| are meant to be used only by a particular variant we either require the presence of
the corresponding flag or we use the corresponding denotation (|<=|, |<+>|, or |<->|) in the rules,
as is done in the rules dealing with the meet and join of |forall| quantified types
in \figRef{rules3.I2.match.eh4Bmeetjoin}.


\rulerCmdUse{rules3.I2.fit}
\rulerCmdUseExplain{rules3.I2.meet}
{
%%@rules3Explain.meet.I2.explain.scheme
}{
%%@rules3Explain.meet.I2.explain.holes
}
\rulerCmdUseExplain{rules3.I2.join}
{
%%@rules3Explain.join.I2.explain.scheme
}{
%%@rules3Explain.join.I2.explain.holes
}

\Paragraph{Type alternative elimination}
The computation of the most/least general type from type alternatives,
presented in \figRef{rules3.I2.tyAltTyElim},
may look overwhelming at first,
but basically selects specific subsets from a set of type alternatives and combines
their types by meeting or joining,
where the choice between meet and join depends on the (contra)variance.
The computation is described by \ruleRef{ty.ae.alts};
the remaining rules deal with default cases.
In \ruleRef{ty.ae.alts} we slightly stretch the notation for matching (|<=>|)
by allowing a vector of types to be matched: |Vec(sigma) <=> sigmar|.
This means ``|foldr (<=>) sigmar ^^ Vec(sigma)|''.

\RuleRef{ty.ae.alts} starts with extracting type alternatives:
type alternatives with a quantifier (|Vec(sigmaQu)|),
without a quantifier (|Vec(sigmaSoft)|),
and those marked as hard (|Vec(sigmaHard)|).
These sets are further restricted by their need |tneed|, selecting |tneedR|
in a meet context (flag |fioMeetY|), selecting |tneedO| otherwise.
Only when quantified or hard types are present we first compute their meet (or join),
so we obtain all quantifier related information.
Then we combine the result with the remaining types.
The result may still contain type alternatives,
because we only eliminate the top level type alternatives.
We recursively eliminate these nested type alternatives and finally bind the result
to the type variable for this set of type alternatives.

\rulerCmdUseExplain{rules3.I2.tyAltTyElim}
{
%%@rules3Explain.tyAltTyElim.I2.explain.scheme
}{
%%@rules3Explain.tyAltTyElim.I2.explain.holes
}
\rulerCmdUseExplain{rules3.I2.valElimExprAlts}
{
%%@rules3Explain.valElimExprAlts.I2.explain.scheme
}{
%%@rules3Explain.valElimExprAlts.I2.explain.holes
}

We walk through our initial example (\exRef{eh4B-ex-basic}), which we repeat here:

%%[[wrap=code
%%@[file:test/4-impred-demo1.eh%%]
%%]

Our implementation finds the following information for |h|
(the fragments are edited bits of internal administration):

%{
%format S = thardS
%format H = thardH
%format R = tneedR
%format O = tneedO

%%[[wrap=code
h :: v_23_0
v_23_0 :-> v_23_0  [ forall ^ a .  a                      -> a       :: S/R
                   ,               (v_38_0[Int :: S/O])   -> v_35_0  :: S/R
                   ,               (v_47_0[Char :: S/O])  -> v_44_0  :: S/R
                   ]
%%]

Function |h| is used in three different contexts, of which one requires |h| to be a polymorphic type,
and the remaining two require |h| to be a function which can accept an |Int| and a |Char| argument respectively.
Because |h| must be the most general type we eliminate type alternatives in a |fioMeetY| context.
\RuleRef{ty.ae.alts} then extracts type alternative subsets:

%%[[wrap=code
Vec(sigmaQu)     ===  [ forall ^ a .  a                      -> a      ]
Vec(sigmaNQu)    ===  [               (v_38_0[Int :: S/O])   -> v_35_0
                      ,               (v_47_0[Char :: S/O])  -> v_44_0
                      ]
Vec(sigmaHard)   ===  []
%%]

The solution |forall ^ a . a -> a| does not contain nested type alternatives, so we end with the constraint:

%%[[wrap=code
v_23_0 :-> forall ^ a . a -> a
%%]

In the remainder of the type inference process we can now use |h| polymorphically.
%}

\Paragraph{Meet/join computation}
The computation of the meet |<+>| and join |<->| of two types is similar to the introduction
and elimination of type alternatives:

\begin{Itemize}
\item
Quantified type variables are instantiated with type variables |tvarv| which remember both the type variable
and the type |sigma| (if any) bound (by matching)
to the type variable:

%%@SharedTypeLang.ehc4B3

The instantiation with these types is (for example)
done as part of \RuleRef{m.forall.l2} (\figRef{rules3.I2.match.eh4Bmeetjoin}).

\item
After instantation and further matching (\figRef{rules3.I2.match.tyBt})
we end with a type which encodes both a type variable and its binding.
We then either forget or use these bindings, depending on the context (meet or join).
\end{Itemize}

\rulerCmdUse{rules3.I2.match.eh4Bmeetjoin}
\rulerCmdUse{rules3.I2.match.tyBt}

For example, in \ruleRef{m.forall.l2} (\figRef{rules3.I2.match.eh4Bmeetjoin})
the meet of

%%[[wrap=code
forall ^ a . a -> a
Int -> Int
%%]

gives |sigmam|:

%%[[wrap=code
a /=/ Int ^^ -> ^^ a /=/ Int
%%]

The rules in \figRef{rules3.I2.tyBtTyElim} then split this type into a type with type variables, and constraints for
those type variables:

%%[[wrap=code
sigma   ===  a -> a
Cnstre  ===  a :-> Int
%%]

In case of a meet |<+>| the constraints |Cnstre| are forgotten for the result type.
The constraints |Cnstre| are still propagated,
because other type variables may still be further constrained as a `side effect' of the meet |<+>|.
For a join |<->| (\ruleRef{m.forall.l3}) the constraints are not forgotten but applied to |sigmam|.

Finally, \ruleRef{m.alt.l2} and \ruleRef{m.alt.l3} (\figRef{rules3.I2.match.eh4Bmeetjoin})
add a type computed by a meet or join as a hard |thardH| type to type alternatives.
For types with quantifiers this does not make a difference, but for types without (like |Int -> Int|) it does.
Being marked as hard |thardH|, we ensure the triggering of type alternative elimination (\ruleRef{ty.ae.alts})
and subsequent propagation of
the resulting type.
If a type variable is bound by this process to a (non-polymorphic) type we effectively inhibit its further binding to
a polymorphic type.

\rulerCmdUseExplain{rules3.I2.tyBtTyElim}
{
%%@rules3Explain.tyBtTyElim.I2.explain.scheme
}{
%%@rules3Explain.tyBtTyElim.I2.explain.holes
}

\subsection{Impredicativity inference}

Impredicativity inference uses type alternatives and their elimination to respectively gather and extract
polymorphism,
to be used by subsequent normal type inference.
The algorithm (\figRef{rules3.I2.expr.eh4B1}, \figRef{rules3.I2.expr.eh4B2}, and \figRef{rules3.I2.decl.base})
uses two constraint threads.
The first constraint thread, denoted by |ICnstr|, gathers type alternatives, and the second, denoted by |Cnstr|,
participates in normal type inference.
Both inference stages return a type.
The type returned by quantifier propagation may contain type alternatives and is therefore denoted by |isigma|;
the type returned by normal inference is denoted by |sigma|.
We focus on quantifier propagation and its integration with normal type inference
(and postpone the discussion of the judgements for constraints superscripted with |ex| required for existential types):

\begin{Itemize}
\item
The complete inference process is split in two stages: quantifier propagation and (normal) type inference.
\item
Bindings for value identifiers are gathered and propagated via environments.
Each binding binds to a type variable, a placeholder for type information,
about which specific type information is stored in constraints |C|.
We separate placeholders and actual type information because
the two inference stages infer different types for a type variable.
\item
Constraints for the first stage are denoted by |ICnstr|,
for the second stage by |Cnstr|.
\item
Only the result of type alternative elimination is propagated to the second stage.
\end{Itemize}

Impredicativity inference in isolation follows a similar strategy as type inference for previous versions of EH,
in that we gather and match type information, partially bottom-up, partially top-down:

\begin{Itemize}
\item
Expected types are still used, but their matching now is done at those places in the AST where
we expect the need for type alternatives: \ruleRef{e.app} and \ruleRef{e.lam}.
\item
At some places in the AST we 'fix' type alternatives by extracting polymorphism;
we use the elimination of type alternatives.
\end{Itemize}

For example, in \ruleRef{e.app} we match the impredicative function type |isigmaf| with |tvarv -> sigmak|,
with the flag |fioBindToTyAltsY| passed to |<=|.
Any known information about the function's argument is thus bound as a type alternative to |tvarv|.
The argument type is matched similarly, so we end up with all information about the argument bound to |tvarv|
as a set of type alternatives.

\rulerCmdUseExplain{rules3.I2.expr.eh4B1}
{
%%@rules3Explain.expr.I2.explain.scheme
}{
%%@rules3Explain.expr.I2.explain.holes
}

Fixating type information is done at two places: at the introduction of identifiers in |let|-bindings and |lambda|-bindings.
Similar to the generalisation of HM type inference,
these places limit the scope of an identifier.
If a type variable is not accessed outside this boundary, we can close the reasoning about such
a type by eliminating type alternatives (or quantify, in the case of HM type inference).
The restriction on eliminating type alternatives for a pattern, to be used as the known type
for the pattern,
arises from our combination of type inference and type checking.
We hope to remove this restriction in a future version of our algorithm as it complicates \ruleRef{e.lam};
we will come back to this later with some examples.

\rulerCmdUse{rules3.I2.expr.eh4B2}

The intricacy of \ruleRef{e.lam} is caused by the combination of the following:
\begin{Itemize}
\item
Type variables act as placeholders for (future) type information.
Hence we must take care to avoid inconsistencies between constraints.
Inconsistencies arise as the result of double instantiation (during each inference stage),
and instantiated type variables are not constrained to be equal when the semantics require this.
\item
We assume that all known type information is available during the first inference stage,
so we can include this information into type alternatives.
\item
For patterns, only a single `pass' is used to extract type information.
As a consequence we require its types and constraints,
used in the first stage,
to remain consistent with results from the second stage.
\end{Itemize}

\RuleRef{e.lam} first extracts possibly polymorphic information from the known type |sigmak|,
which may contain type alternatives (introduced as part of \ruleRef{e.app}).
The resulting type |Dot(sigma)(e)(k)| is used to extract the possible polymorphic (higher ranked)
type of the argument.
We need this type to ensure the invariant that all available known type information is used
as part of the first stage,
and becomes bound in a type alternative.
After being combined with pattern constraints and being threaded through the body,
emerging as |Dot(ICnstr)(e)()|, the set of constraints is used to eliminate type alternatives for each introduced
identifier.

The tricky part is the combination with the next stage. We need to match with the known type a second time
as we may have found new polymorphic types for arguments.
%%[[hide wrap=code impl.impredBLam="Impredicativity + type inference for \ruleRef{e.lam}"
%%@EHRulerRules.42.expr.e.lam
%%@EHCnstr.4.cnstrDel
%%@EHSubstitutable.4.2.partialSubstApp
%%]
However, this match may result in fresh instantiated type variables or fixed type variables.
Constraint |Dot(Cnstr)(3)()| requires some careful constraint manipulation.
New constraints for |tvarv1| (and |tvarv2|) are avoided;
old bindings for |tvarv1| (and |tvarv2|) are updated with new constraints.

\rulerCmdUseExplain{rules3.I2.decl.base}
{
%%@rules3Explain.decl.I2.explain.scheme
}{
%%@rules3Explain.decl.I2.explain.holes
}

In a |let|-expression type alternatives are eliminated for locally introduced bindings.
\RuleRef{e.let} shows how this is done.
Although the propagation of |Gamma|'s and constraints specified by \ruleRef{e.let} is
complete it also has become complex.
This is mainly the consequence of the use of multiple |Gamma|'s and constraints being threaded through
all declarations,
and being tied together at \ruleRef{e.let}.
\FigRef{fig-let-I2-flow} therefore provides a graphical summary.

\FigureXFigTex{}{let-I2-flow}{Constraint flow for let expression}{fig-let-I2-flow}

Additional complexity arises from the presence of existential types,
which we will discuss in \chapterRef{ehc4C}.
Existential types are part of this version of EH.

\FigRef{fig-let-I2-flow} shows how \ruleRef{e.let} first gathers bindings for value identifiers,
in parallel with constraints for type variables bound to identifiers.
Type signatures are gathered in |Dot(Gamma)(t)()|,
bindings from patterns are gathered in |Dot(Gamma)(p)()|.
The corresponding constraints (|Dot(Cnstr)(t)()|, and |Dot(Cnstr)(p)()|) are propagated
to the quantifier propagation constraint thread |Dot(ICnstr)()()|.
Similar to \ruleRef{e.lam} these constraints are used to eliminate type alternatives.
The result of elimination is propagated to normal type inference.

\subsection{Related work, discussion}

\Paragraph{Literature}
Higher-ranked types have received a fair amount of attention.
Type inference for higher-ranked types in general is undecidable \cite{wells98undec-type-sysf};
type inference for rank-2 types is possible, but complex \cite{kfoury94direct}.
The combination of intersection types \cite{bakel93phd-intersection} and higher-rankedness
\cite{kfoury99rank2-decid,kfoury03princ-intersect}
appears to be implementable
\cite{www03church-project}.

In practice, requiring a programmer to provide type annotations for higher-ranked
types for use by a compiler turns out to be a feasible approach
\cite{odersky97putting-ann}
with many practical applications
\cite{shan04sexy-types,launchbury96state-haskell,jones96paramsig-mod}.
Some form of distribution of known type information is usually employed
\cite{pierce00local-type-inference,odersky01col-loc-infer,peytonjones04pract-inf-rank}.
Our implementation distributes type information in a top-down manner (\chapterRef{ehc4}),
and, additionally, distributes type information non-locally (in \thischapt).

\Paragraph{Quantifier propagation}
Our approach is to rely on explicitly provided type annotations,
and the propagation of this type information.
Internally, our implementation uses type alternatives, similar to intersection types.
We rely on `classical' style type inference,
with types which can incorporate constraints,
and are applied as greedily as possible.

The quantifier propagation described in this chapter is algorithmic of nature.
Recent work by Pottier and R\'emy \cite{pottier05stratif-gadt,remy05sysf-tycont} takes a similar approach
(although in a constraint based setting),
calling the propagations process elaboration.
Theirs and our approach share the two-pass nature in which the first pass infers missing type annotations.
Although we make no claims about the correctness of our algorithm,
quantifier propagation only propagates that which is already available in the first place,
thus being true to our conservative ``don't invent polymorphism'' design starting point.
We are confident that this approach does not `break' normal type inference and checking.

Constraint-based approaches provide an alternative point of view where the `difficult' part of a type
is encoded as a constraint, treated separately from type inference
\cite{sulzmann97constrained-type}.
Botlan's extension to ML \cite{botlan03ml-power-f} uses (explicitly specified)
constraints to allow polymorphic type information
to be propagated impredicatively.
Both approaches also allow the integration of qualified types \cite{stuckey02theory-overloading,leijen05qual-mlf}.

Whatever the approach taken, the availability of higher-ranked types in a programming language
complicates the implementation;
this is the price to pay for a bit of System F functionality.
Our approach provides such an implementation and, additionally,
stretches the exploitation of type annotations even further by propagating impredicativity globally throughout
and expression.

For this thesis we have chosen the `classical' approach as a starting point to keep matters (relatively) simple.
Only recently new extensions are expressed using a constraint approach.
We expect to use a constraint based approach,
because of this and the prospect of better error message \cite{heeren05phd-errormsg}.

Finally, \thischapt\ reflects an experiment which has not (yet) been integrated into
the final of our series of compilers.
The combination with a class system (\chapterRef{ehc9})
and partial type signatures (\chapterRef{ehc-partial-sig-quant-guess})
requires further investigation.
%%]





%%[bodyExists
In \chapterRef{ehc4} universal quantification of types was introduced.
A universally quantified type expresses that a value of such a type can be used with any type subsituted
for the universally quantified part.
In \thischapt\ we extend EH with its counterpart: the \IxAsDef{existentially quantified type},
(or \IxAsDef{existential type})
\cite{mitchell88absty-exist,laufer94poly-absdata}.
First, we look at examples, then we look at the implementation issues.

The difference between a universally and existentially quantified type can be characterized by the following
observation:
\begin{Itemize}
\item
The \emph{use} of a value with a |forall| quantified type determines the type
to choose for the instantiation of the quantified type variable.
For example, the caller of the identity function ``|id :: forall ^ a . a -> a|''
determines the type to choose for the type variable |a| for this particular application of |id|.
For the function application ``|id 3|'' this type equals |Int|.
\item
The \emph{creation} of a value with a |exists| quantified type determines,
and hides,
the type of the quantified type variable.
For example, a creator of a ``|exists ^ a . (a,a->Int)|'' may have constructed a value of that type from ``|(3,\x->x)|'';
another creator has constructed a value with the same type from ``|('x',\x -> ord x)|''.
From a users point of view both values have the same type and are thus
interchangeable.
The value has a specific type chosen for type variable |a|,
but we do not know which type, so this information can no longer be exploited.
This value specific type information has been `forgotten'; we only know it exists.
\end{Itemize}

Existential types are available in Haskell \cite{www04ghc},
be it in a slightly disguised form.
If type variables occur in a constructor of a data type, but not in the type itself,
they are assumed to be existentially quantified.
The keyword @forall@ (confusingly) is used to specify this explicitly:

%%[[wrap=code
data Hide = forall^  a . Hide a
%%]

In EH we prefer to denote this as |exists ^ a . a|.
We do not restrict the occurrences of |exists| quantifiers to data declarations.

As pointed out in \secRef{eh4motiv-ex} the univeral quantifier is also used in Haskell for encapsulation,
we repeat the example:

%%@TopicImpred.runST

This is also slightly confusing because a universal quantifier has a useful meaning when used for functions.
A function can be passed and return values without knowing their type.
For ``|forall ^ s . ST s a|'', the body of |runST| can choose |s|,
but this is a rather useless choice because no value can be created by the caller of |runST| that still allows
the body of |runST| to choose the type |s|.
The effect therefore is that the type of |s| is hidden.
In EH we would encode this directly:

%%@TopicImpred.runSTexists

We summarize the use of quantifiers in EH:

\begin{Itemize}
\item
A universal quantifier |forall| is used for functions which (polymorphically) accept an unknown type and return a
value of this same unknown type.
\item
An existential quantifier |exists| is used for values for which type information has been forgotten. 
\end{Itemize}

In \chapterRef{ehc-partial-sig-quant-guess} we will exploit this use further.

\subsection{Motivating examples}

Existential types are a necessary ingredient for encapsulation, abstract data types,
and modules, because existential types allow us to hide type information.
The following example uses a minimal abstract data type ``|exists ^ a . (a,a->Int)|'':
a value tupled with an observer function for that value.
Note that for all practical purposes this type is isomorphic to |Int|.

\begin{Example}
\ \label{eh4C-ex-basic}
%%[[wrap=code
%%@[file:test/4-demo1.eh%%]
%%]
\end{Example}

Value |xy| holds an ``|exists ^ a . (a,a->Int)|''.
An ``|(Int,Int->Int)|'' has been bound to in |xy|, but the signature for |xy| only 
reflects that the value and function argument have the same type,
so we can apply this function to the value (via |ixy|).
Value |pq| is similarly typed, but the assignment of a value is erroneous.

\Paragraph{Opening an existential type}
When we create a value by an existential type,
we forget (part of) its type and represent this with an existentially quantified type variable.
We call this the \IxAsDef{closing} of a type,
as opposed to the \IxAsDef{opening} of an existential type.
The use of an existential type requires a concrete type instead of a (existentially quantified)
type variable.
The creation of such a concrete type is called \IxAsDef{opening}.
Ideally, opening would give us back the original type,
but this requires some form of dependent types.
In EH, we merely create a fresh type constant.
For example, the type of |xy| from \exRef{eh4C-ex-basic} is the following (instead of |exists ^ a . (a,a->Int)|):

%%[[wrap=code
xy :: (C_0_2_0,C_0_2_0 -> Int)
%%]

The opening of an existential type is often tied up to special syntax,
usually a variation of a |let|-expression.
In EH, the opening is associated with the binding of a type to a value identifier.
This (design decision) follows the intuition that a value is a concrete object with a concrete type.

Opening an existential type by binding
also means that the following example does not type check\footnote{Case expressions are introduced together with data types, \chapterEHVRef.}:

%%[[wrap=code
%%@[file:test/5-demo1.eh%%]
%%]

Function |f| returns |(2,id)| when passed |2| and |('a',ord)|
otherwise.
EH creates the following bindings; the creation of type constants guarantees that |fx| cannot be applied to |yy|:

%%[[wrap=code
fy  ::  C_35_1_0 -> Int
yy  ::  C_35_1_0
fx  ::  C_31_1_0 -> Int
xx  ::  C_31_1_0
%%]

The opening of an existential for a value binding is only done for a top-level existential quantifier.
If an existential quantifier is nested inside a composite type, then the opening is not done:

%%[[wrap=code
%%@[file:test/4-ex-extr4.eh%%]
%%]

The opening is delayed until the binding of |v1|'s components:

%%[[wrap=code
v1  ::  (exists a . a,exists b . b)
v2  ::  (exists a . a,exists b . b)
a   ::  C_1_2_0
b   ::  C_1_3_0
c   ::  C_1_4_0
d   ::  C_1_5_0
%%]

These types are pessimistic.
We know (for example) that |a| and |c| refer to the same value.

EH is also pessimistic when an value with an existential type is passed through a function.
For example, the following extends our simplistic abstract data type with an additional observer function:

%%[[wrap=code
%%@[file:test/4-demo6.eh%%]
%%]

We do not preserve type equality through |f|;
additional information about |f|'s implementation would be required to say something about this.

\subsection{Design overview}
Relative to the type language for the previous EH version,
the type language has to be extended with existential quantification,
which is similar to universal quantification,
and type constants |tcon|:

%%[[wrap=code
%%@SharedTypeLang.ehc4C
%%]

Universal and existential types are each at their end of an extreme:
A |forall ^ a . a| can be instantiated to any desired type,
whereas a |exists ^ a . a| can be obtained from any type by forgetting (its type).
In terms of the type lattice (\figPageRef{fig-type-lattice}) induced by |<=|,
|forall ^ a . a| represents the bottom |Bot|, and |exists ^ a . a| represents the top |Top|.

\subsection{Type matching}

Universal and existential types are dual when used in type matching.
For

%%[[wrap=code
forall ^ a . a <= sigma
sigma <= exists ^ a . a
%%]

we can freely choose |a|,
whereas for

%%[[wrap=code
sigma <= forall ^ a . a
exists ^ a . a <= sigma
%%]

we can not:
in case of universal type,
|a| is chosen by the context,
whereas |a| is chosen by the creator of the existential type.
|a| is chosen by the context of the expected universal type.
In both case we emulate this ``choice from outside'' by instantiating |a| to
a fixed type variable during type matching (\figPageRef{rules3.I1.match.eh4}).

\rulerCmdUse{rules3.I1.match.eh4C}

The type matching rules (\figRef{rules3.I1.match.eh4C}) for existential types
therefore resemble the rules for
universal types;
they differ in the instantiation with (fixed) type variables.

Type matching required for quantifier propagation requires additional rules for the meet and join
of two types.
The forgetting, respectively propagation, of found constraints is swapped
(\secRef{rules3.I2.match.eh4Cmeetjoin});
this is a consequence of the dualistic relationship between universal and existential types (and meet and join).

\rulerCmdUse{rules3.I2.match.eh4Cmeetjoin}

The effect of this duality can be seen in the example type lattice (\figPageRef{fig-type-lattice}),
and in the following example:

%%[[wrap=code
%%@[file:test/4-impred24.eh%%]
%%]

|h| is expected to be used as ``|exists ^ a . (a,a->Int)|'' and as ``|(Int,Int->Int)|''.
The most general of these two is ``|(Int,Int->Int)|'',
reflected by the following signature for |f|:

%%[[wrap=code
f :: (Int,Int -> Int) -> Int
%%]

During quantifier propagation we find for |h| the following type alternatives:

%%[[wrap=code
h :: v_13_0
v_13_0 :-> v_13_0[exists a . (a,a -> Int) :: thardS/tneedR, (Int,Int -> Int) :: thardS/tneedR]
%%]

From this, we compute ``|v_13_0:->(Int,Int -> Int)|''.

Again, a contravariant position requires us to compute the least general type (instead of the most general):

%%[[wrap=code
%%@[file:test/4-impred26.eh%%]
%%]

Functions |g1| and |g2| provide the context in which |h| will be used,
that is, |g1| only knows |h|'s argument will be an existential, |g2| knows |h|'s argument
is ``|(Int,Int -> Int)|''.
|h| can only make the least of the assumptions both |g1| and |g2| offer, so the following signature is
inferred for |f|:

%%[[wrap=code
f :: ((exists ^ a . (a,a -> Int)) -> Int) -> Int
%%]

\subsection{Impredicativity inference and type inference}

Type matching takes care of most of the implementation of existential types.
We only need to ensure the opening of an existential type when bound to an identifier:

\begin{Itemize}
\item
Inside patterns, when an expected type is bound to an identifier
(\figRef{rules3.I1.patexpr.eh4}).
\item
In a let expression, for explicitly introduced type signatures,
and for inferred type signatures
(\figPageRef{rules3.I2.expr.eh4B2}).
\end{Itemize}

\rulerCmdUse{rules3.I1.patexpr.eh4}

\subsection{Related work, discussion}
\label{eh4Cdiscuss}

By opening an existential type when bound to a value,
we deviate from most treatments of existential types
\cite{macqueen86dep-ty-module,mitchell88absty-exist,laufer94poly-absdata},
which leave existential types closed,
to be opened by special language constructs when the need arises.
We can see the following benefits and drawbacks of both approaches,
in which the scope of the identity of the hidden type plays a crucial role:

\begin{Itemize}
\item
Opening an existential type by need creates a problem with
the following example, using some fantasy syntax for opening:
%{
%format open = "\mathbf{open}"
%%[[wrap=code
let  v    ::  exists ^ a . (a,a->Int)
     fst  ::  forall ^ a . forall ^ b . (a,b)->a
     v1   =   open v' = v in fst v'
     v2   =   open v' = v in fst v'
in   ...
%%]
%}
The field access to |v| opens |v| twice.
The consequence is that |v1| and |v2| have different types,
because each opening introduces a new type.

A solution to this problem is to treat field access (usually denoted by a dot notation) in a special way
by using the same type for the opening of the same value.
Laufer (et.al.) \cite{laufer94poly-absdata} observe that existential types,
in practical settings, have to be opened for a large scope,
losing some of the benefits of abstraction.

By opening an existential type once when bound to a value identifier, we partially solve this problem.
We achieve encapsulation, avoid the clutter of opening, but only do so for toplevel existential quantification.
Existentials which are nested in a composite type only will be opened when bound to an identifier, so in order to
preserve type identity across multiple nested selections, we would have to open all fields of a composite value in this way.

%\item
%Opening a nested existential type is done when bou

\item
In our solution we open a type by creating fresh type constants for the existentially quantified type variables.
We allow these constants to escape to a larger scope.
This is not a problem because only functions accepting such a constant can do something with it
that is particular to the type constant.
However, as freshness of a type constant is guaranteed by means of uniqueness,
we must also ensure uniqueness in the context of separatedly compiled modules;
as we do not discuss modules in this thesis we merely point this out.

\item
If the need arises to (again) forget a type constant,
this can be done by an explicit type annotation.
\end{Itemize}

Existential types are a necessary ingredient for abstract data types \cite{mitchell88absty-exist}.
However, using existential types to construct a module mechanism requires additional mechanisms for
preserving the type identity of modules \cite{leroy94manif-ty-mod,leroy95appl-func-mod,lillibridge97phd-translucent},
easily leading to forms of dependent typing \cite{macqueen86dep-ty-module}.

%%]











%%[scratch
\subsection{Introduction}
\label{eh-impred-intro}

Basic idea: polymorphism for all values bound to identifiers, irrespective of their |let| or |lambda| bound introduction:
%%[[wrap=code
id  ::  forall a . a -> a
v1  =   (id 3, id 'x')
f   ::  (forall a . a -> a) -> (Int,Char)
f   =   \i -> (i 3, i 'x')
v2  =   f id
%%]

Problem: for |let| bound identifiers polymorphism can be inferred; for |lambda| bound in general not
\cite{kfoury93recursivetype,hallet04polyrec-ex,vasconcellos03polyrec-impl,henglein91polyrec-infer,figueiredo01polyrec-princ}.

Repeat some motivating examples \cite{shan04sexy-types,peytonjones04pract-inf-rank,vytiniotis05boxy-impred} showing usefulness.

\subsection{What we want}
\label{eh-impred-reqm}

\begin{TabularCenterFigure}{}{EH terms}{eh-impred-lang-terms}
%%@AppxNotation.termTableFormat
%%@AppxNotation.exprHeader
%%@AppxNotation.exprBasic
%%@AppxNotation.exprLamPat
%%@AppxNotation.exprTup
%%@AppxNotation.exprAppImpred
%%@AppxNotation.termSeparator
%%@AppxNotation.declHeader
%%@AppxNotation.declBasic
%%@AppxNotation.declValPat
%%@AppxNotation.termSeparator
%%@AppxNotation.identHeader
%%@AppxNotation.identBasic
\end{TabularCenterFigure}

\FigRef{eh-impred-lang-terms} shows the term language we use.

Basic (introductory example): type signature information bound to identifier

Polymorphism can be deduced from occurrences at parameter positions:
%%[[wrap=code
%%4_2srcfile(test/4-impred-demo1.eh%%)
%%]

Type for |f :: (forall ^ a . a -> a) -> Int|,
but absence of |g h| gives `normal' type error.

Most general type:
%%[[wrap=code
%%4_2srcfile(test/4-impred-demo3.eh%%)
%%]

Type for |f :: (forall ^ a . a -> a) -> Int|.

Which in contravariant position is least general:
%%[[wrap=code
%%4_2srcfile(test/4-impred-demo4.eh%%)
%%]

Type for |f :: %%4_2file(test/4-impred-demo4.eh%%)|.

Partial polymorphism can be combined:
%%[[wrap=code
%%4_2srcfile(test/4-impred-demo2.eh%%)
%%]

Type for |f :: (forall ^ a . forall ^ b . (a,b) -> (a,b)) -> Int|.

Yes/no propagation (or: System F/Haskell):
%%[[wrap=code
%%4_2srcfile(test/4-impred-choose.eh%%)
%%]

Type of |v1 :: forall a . (a -> a) -> a -> a|, |v2 :: (forall a . a -> a) -> forall b . b -> b|.

\Paragraph{Outline of our contribution}

Design starting point:
\begin{Itemize}
\item
Stick to Hindley-Milner
\item
Allow the programmer to explicitly specify (higher-rank) polymorphism
\item
Employ a two-stage inferencing strategy:
 \begin{Itemize}
 \item
 Impredicativity inferencing: propagate explicitly provided polymorphism
 \item
 Standard type inferencing: 
 \end{Itemize}
\end{Itemize}

\Paragraph{Outline of this paper}

Point out what we can do extra relative to Vytiniotis \cite{vytiniotis05boxy-impred}: meet/join combination, propagation not only top-down through AST but also more globally.

\subsection{Implementation}
\label{eh-impred-impl}

\begin{TabularCenterFigure}{}{EH types}{eh-impred-lang-types}
%%@AppxNotation.termTableFormat
%%@AppxNotation.typeHeader
%%@AppxNotation.typeBasic
%%@AppxNotation.typeTyVarFixed
%%@AppxNotation.typeExists
%%@AppxNotation.typeRecBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.impredHeader
%%@AppxNotation.impredBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.meetJoinHeader
%%@AppxNotation.meetJoinBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.tyaltHeader
%%@AppxNotation.tyaltBasic
\end{TabularCenterFigure}

\begin{TabularCenterFigure}{}{Notation and abbreviation legenda}{eh-impred-legenda-notation}
%%@AppxNotation.notationTableFormat
%%@AppxNotation.notationTableHeader
%%@AppxNotation.notationBasic
%%@AppxNotation.notationImpredA
%%@AppxNotation.notationImpredB
\end{TabularCenterFigure}

An environment |Gamma|
binds value identifiers to types and predicates to translations (dictionary evidence) paired with their type:

%%[[wrap=code
bind   =  ident :-> sigma |  pi :> Transl : sigma
Gamma  =  Vec(bind)
%%]

We use vector notation for any ordered collection, denoted with a horizontal bar on top.
Concatenation of vectors and pattern matching on a vector is denoted by a comma ','.

Constraints:
%%[[wrap=code
bindv  =  tvarv :-> sigma
Cnstr  =  Vec(bindv)
%%]



\rulerCmdUse{rules2.exprE.baseImpredE}
\FigRef{rules2.exprE.baseImpredE} shows the basic equational type rules.

\rulerCmdUse{rules2.declE}
\FigRef{rules2.declE} shows the equational rules for declarations, to be used by |let| expressions.

%\rulerCmdUse{rules2.expr2.base}

\rulerCmdUse{rules2.expr4.base}
\rulerCmdUse{rules2.expr4.prog}
\FigRef{rules2.expr4.base} shows the inference rules combining known (checkable) type and inferred type.
The environment is set up in \FigRef{rules2.expr4.prog}.

\rulerCmdUse{rules2.decl4}
\FigRef{rules2.decl4} shows the inference rules for declarations, to be used by |let| expressions.

\rulerCmdUse{rules2.exprIm.base}
\FigRef{rules2.exprIm.base} shows the propagation of quantified types.
Type alternatives are introduced in this stage.
Idea: application is where polymorphism matters, so there binding of type variables is to type alternatives.
These are not introduced at variable introduction places (an obvious alternative as we want to find polymorphism is tied up to identifier occurrences)
because intermediate/anonymous functions also must be allowed to participate in this process.
A second reason is the mixture of yes/no quantified, i.e. holes in a type may have type alternatives.

\rulerCmdUse{rules2.exprIm4.base}
\FigRef{rules2.exprIm4.base} shows the use of inferenced impredicativity, overriding \figRef{rules2.expr4.base}.

\rulerCmdUse{rules2.taltGamIm}
\FigRef{rules2.taltGamIm} shows the elimination of type alternatives, used in between impredicativity inferencing and normal inferencing.

\rulerCmdUse{rules2.taltIm}
\FigRef{rules2.taltIm} is used as part of \figRef{rules2.taltGamIm}.

\rulerCmdUse{rules2.fit4.baseImpred4part1}
\rulerCmdUse{rules2.fit4.baseImpred4part2}
\FigRef{rules2.fit4.baseImpred4part1} and \FigRef{rules2.fit4.baseImpred4part2} show the rules for fitting (subsumption).
The order in which the rules appear is important. Of two matching rules the textually preceding one takes precedence.
In case of commutativity only a `left' variant has been included (perhaps an explicit summary where this applies).

\begin{TabularCenterFigure}{}{Quantified type instantiation variants}{eh-impred-legenda-inst}{l@@{=}ll}
\multicolumn{2}{l}{Variant} & instantiate |Vec(alpha)| with fresh \\
\hline
|(Vec(tvarv),sigma') | & | instWith(tvarv)(Qu ^ Vec(alpha) . sigma)|
 &  type variables |Vec(tvarv)|
 \\
|(Vec(tvarf),sigma') | & | instWith(tvarf)(Qu ^ Vec(alpha) . sigma)|
 &  fixed type variables |Vec(tvarf)|
 \\
|(Vec(tvarv),sigma') | & | instWith(<+>)(Qu ^ Vec(alpha) . sigma)|
 &  `both' types |Vec(tvarv /=/ ANY)|
 \\
%if False
|(sigma') | & | instWith(exists)(exists ^ Vec(alpha) . sigma)|
 &  non reproducible type constants |Vec(identc)|
 \\
%endif
\end{TabularCenterFigure}
\FigRef{eh-impred-legenda-inst} shows how quantified types can be instantiated.
All instantiation variants only instantiate top level quantified type variables.
instWith(exists)(Gamma) is defined in the obvious way.

\begin{TabularCenterFigure}{}{Options to fit}{eh-impred-fit-options}
%%@SharedFIOpts.fiOptsTableHeader
%%@SharedFIOpts.fiOptsEH4
%%@SharedFIOpts.fiOptsEH4B
%%@SharedFIOpts.fiOptsEH5
\end{TabularCenterFigure}
\FigRef{eh-impred-fit-options} shows the options which can be passed to |<=| (and |<+>|, |<->|, |<=>|).
Often used combinations of these options are found in \FigRef{eh-impred-fit-option-combis}.
|True| and |False| values are denoted by a an additional |+| or |-| respectively,
for example for |fioLeaveRInst| with |fioLeaveRInstY| and |fioLeaveRInstN| respectively.

\begin{TabularCenterFigure}{}{Option combinations}{eh-impred-fit-option-combis}
%%@SharedFIOpts.fiOptsCombisTableHeader
%%@SharedFIOpts.fiOptsCombisEH4forEH4B
%%@SharedFIOpts.fiOptsCombisEH4B
\end{TabularCenterFigure}
\FigRef{eh-impred-fit-option-combis} shows combinations |fiopt| of options to |fit|.

\rulerCmdUse{rules2.meetIm}
\FigRef{rules2.meetIm} shows the rules for the meet of types.
The `meet' |sigma1 <+> sigma2| is defined to be the greatest (w.r.t. |<=|) |sigma| which satisfies
|sigma <= sigma1| and |sigma <= sigma2|.
Default behavior is specified by the rules for fit.
Meet is commutative and associative.
The notation |sigma <+> sigma| is extended in the obvious way to |Vec(sigma) <+> sigma|.

\rulerCmdUse{rules2.joinIm}
\FigRef{rules2.joinIm} shows the rules for the join of types.
The `join' |sigma1 <-> sigma2| is defined to be the smallest (w.r.t. |<=|) |sigma| which satisfies
|sigma1 <= sigma| and |sigma2 <= sigma|.
As the dual of meet, similar remarks apply.
Default behavior is specified by the rules for fit and meet.

\rulerCmdUse{rules2.matchIm}
\FigRef{rules2.matchIm} shows the general purpose match which dispatches based on options |fiopt|.

\rulerCmdUse{rules2.tbothIm}
\FigRef{rules2.tbothIm} shows the elimination of temporary `both' assumptions used by meet/join.

\Paragraph{Omissions}
Rules for |qu|, |quGam| (insertion of quantifiers, just assume explicit quantification and no partial type signatures) and |pat| (obvious :-)).

\subsection{Existential types}
\label{eh-impred-existential}

Trouble:

%%[[wrap=code
%%4_2srcfile(test/4-impred9.eh%%)
%%]

Too forgetful w.r.t. |v1 :: %%4_2file(test/4-impred9.eh%%)|.
The algorithm is pessimistic and takes the least general type (i.e. |<->|) of the existential and the actual value.
This is ok for identifiers in parameter positions because we do not say anything about their actual value.
It is not ok when actual values are involved because we do not want to forget types there.
To remedy this problem it is likely that some additional administration in this area must be kept.
Not (yet) sorted out.


\subsection{Interaction with implicit parameters}
\label{eh-impred-implparam}

\Paragraph{Subsumption and coercion}

\subsection{Discussion, related work}
\label{eh-impred-relwork}

\Paragraph{When to report errors}

\Paragraph{Related work}
\cite{vytiniotis05boxy-impred}

\subsection{Conclusion}
\label{eh-impred-concl}
%%]


%%[scratch3
\subsection{Propagation of impredicativity}

Our solution for the use of higher-ranked types is based on:
\begin{Itemize}
\item The obligation for a programmer to specify the type information the type inferencer is not capable of inferring.
\item The obligation of the type inferencer to not forget this information.
\end{Itemize}

The type inferencer uses standard Hindley-Milner type inferencing extended with the possibility to bind type variables to
quantified types, usually named \IxAsDef{impredicativity}.
This allows the type inferencer to propagate quantified types instead of instantiating these types to a monomorphic type
for which it is then impossible to find back forgotten polymorphism.
This idea works well for the examples encountered so far, for example:

%%[[wrap=code
%%@[file:test/3-demo-rank.eh%%]
%%]

Polymorphism for |i| has been declared explicitly before any use of this information in de type checking of the body of |f| is done or any parameter is
passed to |f|.
Because we allow type variables to be bound to quantified types the following example also infers |f :: (forall a . a -> a) -> Int| correctly:

%%[[wrap=code
%%@[file:test/4-impred2.eh%%]
%%]

This works because initially we assign a type variable to the type of |h| which is later bound to |forall a . a -> a| when it is used as an argument of |g|.
However, the following example breaks because we first bind the type of |h| to a monomorphic type:

%%[[wrap=code
%%@[file:test/4-impred-demo1.eh%%]
%%]

This example breaks at three different places:
\begin{Itemize}
\item
The first use of |h| for the computation of |x1| concludes |h :: Int -> v_7|. This conflicts with the second use in the computation of |x2| where
|h| is expected to accept a |Char|.
\item
|h| is also not polymorphic enough to be passed as a parameter to |g|.
\item
The type inferencer will conclude |f :: (Int -> forall a . a) -> Int| (or something similar) which is not polymorphic enough in its argument
to be able to accept |id| as its parameter.
\end{Itemize}

These problems are caused by the interaction of the following design choices:
\begin{Itemize}
\item
If the type inferencer finds more information about a type variable it immediately applies this knowledge to all types.
This is done in a left-to-right order through the abstract syntax tree.
\item
No polymorphism for parameters is inferred. See ... for the a discussion of the reasons to avoid the complexity of ... .
\end{Itemize}

In other words, once a type is monomorphic we don't allow it to become polymorphic, not even if we encounter the `right' to do so elsewhere in
a program.
We will not introduce inferencing polymorphism for parameters in our inferencing machinery because of its complexity, so we cannot repair the problem
by inventing polymorphism whenever it would be convenient to do so.
However, the problem could be fixed because in our example program the use of |h| as a parameter to |g| tells us that |h| must be polymorphic anyway.
If only this information could be available in an earlier stage of type inferencing,
or alternatively, if only the decision to let |h| be monomorphic could be delayed for a while!
We choose the latter, that is, we introduce a way of delaying a binding decision for a type variable.

In order to be able to rebind a type variable to a more polymorphic we may not forget to which type variable a type was assigned.
This can be remembered by just relating the type variable to its type(s):

%%[[wrap=code
sigma  =  ...
       |  tvarv//Vec(sigma)
%%]

The notation |tvarv//Vec(sigma)| associates to a set of types |Vec(sigma)|.
The type variable |tvarv| is bound to each of them during type inferencing, hence the name \IxAsDef{bind type} for this type variant.
The idea is that as soon as an attempt is made to bind |tvarv| to a polymorphic
type we check if all types in |Vec(sigma)| are an instance of the polymorphic type.
If this is the case we can forget all types |Vec(sigma)| and go on with the polymorphic type.

The rules for |<=| in \figRef{rules.fit4.bind} make this more precise.
A bind type is introduced in \ruleRef{f-var-l1}.
The introduction is also influenced by the context in which |<=| is used; this is expressed by
the boolean flag |fioBindToTyAltsY|, part of the set of options |fiopt|.
The modified \ruleRef{e-ident4B} \figRef{rules.expr4.B} for checking the type of an identifier sets this flag.

A bind type can only be introduced when checking an identifier.
Traditionally, this is the place where a quantified type is instantiated when it is extracted from an environment |Gamma|.
Quantified types usually live in an environment |Gamma| as a so called \IxAsDef{type scheme} and are introduced into the type checking/inferencing world
by instantiating the type scheme to a monomorphic type.
Here, in a similar manner, if nothing is known about an identifier, its type variable will be bound to a bind type which will hold
all possible instantiations found during type inferencing.
The remaining rules of \figRef{rules.fit4.bind} specify what should be done if a bind type is encountered in |<=|.

Some additional notation for manipulating vectors is used as well.
A vector |Vec(x)| of |x|'s is alternatively notated as |VecI(x)(i)| where |i| implicitly ranges over all indices referring to
an element of the vector. Any predicate referring to |i| has an implicit quantifier |forall ^ i| in front of it.
Extraction of an individual element of the array with index |i| is notated by |VecI(x)(..,i,..)|.
A predicate referring to this |i| has an implicit |exists ^ i| in front of it.

Some additional options need to be passed as well:

%%@EHTyFitsIn.6.2.FIOpts.defaults wrap=code

\rulerCmdUse{rules.fit4.bind}
\rulerCmdUse{rules.expr4.bind}
\rulerCmdUse{rules.elimb4}
\rulerCmdUse{rules.elimbGam4}

The following example really is responsible for delaying subsumption checks:

%%[[wrap=code
%%@[file:test/4-impred4.eh%%]
%%]

There is no single usage of |h| which enforces |h :: forall a . forall b . (a,b) -> (a,b)|,
the meet of |forall a . (Int,a) -> (Int,a)| and |forall a . (a,Int) -> (a,Int)| done at the generalization of |f|
computes this type.
Newfound polymorphism (as in |g1 h|) can be used to deduce a more general type for (e.g.) |(Int,Int) -> v| found in |h (3,4)|...

???? Meet instead of subsumption

\subsection{Propagation of impredicativity + predicates + coercions}

Some examples:

%%[[wrap=code
let  g  ::  (forall a . A a => a -> a) -> Int
     f  =   \h ->  let  x1 = g h
                        x2 = h 3
                   in   ...
in   ...
%%]

Function |h| has type |h :: forall a . A a => a -> a|.
However, it cannot be instantiated immediately in its use in |h 3| because later on |h| might turn out
to be more polymorphic. Here it does not matter because |h| already is polymorphic enough...
%%]

%%[scratch2
%if inclOmitted
\subsection{Omitted, more of the same}
Substitution, error gathering, pretty printing, uniq, common
%endif

%if not omitLitDiscuss
\subsection<article>{Literature}

\TBD{}

Higher ranked types, \cite{peytonjones04pract-inf-rank,botlan03ml-power-f}

Cannot do inference for rank3, \cite{jim95rank,kfoury94direct,kfoury99rank2-decid,kfoury03rank2-princ}

Existentials, via universal \cite{laufer96class-existential}

%endif %% not omitLitDiscuss
%%]

%%[scratch4

\rulerCmdUse{rules3.I1.expr.base}
\rulerCmdUse{rules3.I1.decl.base}

\rulerCmdUse{rules3.I2.expr.base}
\rulerCmdUse{rules3.I2.decl.base}

\rulerCmdUse{rules3.I1.match.base}
\rulerCmdUse{rules3.I1.match.forall}
\rulerCmdUse{rules3.I1.match.exists}
\rulerCmdUse{rules3.I1.fit}
\rulerCmdUse{rules3.I2.meet}
\rulerCmdUse{rules3.I2.join}
\rulerCmdUse{rules3.I2.tyAltTyElim}

%\rulerCmdUse{rules3.K.match.all}
\rulerCmdUse{rules3.I2.match.meet}
\rulerCmdUse{rules3.I2.match.join}
\rulerCmdUse{rules3.I2.match.tyAlt}
\rulerCmdUse{rules3.I2.match.tyBt}


%%]

%%[runST
%%[[wrap=code
runST :: forall ^ a . (forall ^ s . ST s a) -> a
%%]
%%]

%%[runSTexists
%%[[wrap=code
runST :: forall ^ a . (exists ^ s . ST s a) -> a
%%]
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

