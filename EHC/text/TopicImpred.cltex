%%[scratch
\subsection{Introduction}
\label{eh-impred-intro}

Basic idea: polymorphism for all values bound to identifiers, irrespective of their |let| or |lambda| bound introduction:
\begin{code}
id  ::  forall a . a -> a
v1  =   (id 3, id 'x')
f   ::  (forall a . a -> a) -> (Int,Char)
f   =   \i -> (i 3, i 'x')
v2  =   f id
\end{code}

Problem: for |let| bound identifiers polymorphism can be inferred; for |lambda| bound in general not
\cite{kfoury93recursivetype,hallet04polyrec-ex,vasconcellos03polyrec-impl,henglein91polyrec-infer,figueiredo01polyrec-princ}.

Repeat some motivating examples \cite{shan04sexy-types,peytonjones04pract-inf-rank,vytiniotis05boxy-impred} showing usefulness.

\subsection{What we want}
\label{eh-impred-reqm}

%%@AppxNotation.termTableFigBeginImpred
%%@AppxNotation.termTableFormat
%%@AppxNotation.exprHeader
%%@AppxNotation.exprBasic
%%@AppxNotation.exprTup
%%@AppxNotation.exprAppImpred
%%@AppxNotation.termSeparator
%%@AppxNotation.declHeader
%%@AppxNotation.declBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.identHeader
%%@AppxNotation.identBasic
%%@AppxNotation.termTableFigEnd

\FigRef{eh-impred-lang-terms} shows the term language we use.

Basic (introductory example): type signature information bound to identifier

Polymorphism can be deduced from occurrences at parameter positions:
\begin{code}
%%4_2srcfile(test/4-impred-demo1.eh%%)
\end{code}

Type for |f :: (forall ^ a . a -> a) -> Int|,
but absence of |g h| gives `normal' type error.

Most general type:
\begin{code}
%%4_2srcfile(test/4-impred-demo3.eh%%)
\end{code}

Type for |f :: (forall ^ a . a -> a) -> Int|.

Which in contravariant position is least general:
\begin{code}
%%4_2srcfile(test/4-impred-demo4.eh%%)
\end{code}

Type for |f :: %%4_2file(test/4-impred-demo4.eh%%)|.

Partial polymorphism can be combined:
\begin{code}
%%4_2srcfile(test/4-impred-demo2.eh%%)
\end{code}

Type for |f :: (forall ^ a . forall ^ b . (a,b) -> (a,b)) -> Int|.

Yes/no propagation (or: System F/Haskell):
\begin{code}
%%4_2srcfile(test/4-choose.eh%%)
\end{code}

Type of |v1 :: forall a . (a -> a) -> a -> a|, |v2 :: (forall a . a -> a) -> forall b . b -> b|.

\paragraph{Outline of our contribution}

Design starting point:
\begin{itemize}
\item
Stick to Hindley-Milner
\item
Allow the programmer to explicitly specify (higher-rank) polymorphism
\item
Employ a two-stage inferencing strategy:
 \begin{itemize}
 \item
 Impredicativity inferencing: propagate explicitly provided polymorphism
 \item
 Standard type inferencing: 
 \end{itemize}
\end{itemize}

\paragraph{Outline of this paper}

Point out what we can do extra relative to Vytiniotis \cite{vytiniotis05boxy-impred}: meet/join combination, propagation not only top-down through AST but also more globally.

\subsection{Implementation}
\label{eh-impred-impl}

%%@AppxNotation.typeTableFigBeginImpred
%%@AppxNotation.termTableFormat
%%@AppxNotation.typeHeader
%%@AppxNotation.typeBasic
%%@AppxNotation.typeTyVarFixed
%%@AppxNotation.typeExists
%%@AppxNotation.typeRecBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.impredHeader
%%@AppxNotation.impredBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.meetJoinHeader
%%@AppxNotation.meetJoinBasic
%%@AppxNotation.termSeparator
%%@AppxNotation.tyaltHeader
%%@AppxNotation.tyaltBasic
%%@AppxNotation.termTableFigEnd

\begin{TabularFigure}{Notation and abbreviation legenda}{eh-impred-legenda-notation}{ll}
Notation & Meaning \\
\hline
%%@AppxNotation.notationBasic
%%@AppxNotation.notationImpredA
%%@AppxNotation.notationImpredB
\end{TabularFigure}

An environment |Gamma|
binds value identifiers to types and predicates to translations (dictionary evidence) paired with their type:

\begin{code}
bind   =  ident :-> sigma |  pi :> Transl : sigma
Gamma  =  Vec(bind)
\end{code}

We use vector notation for any ordered collection, denoted with a horizontal bar on top.
Concatenation of vectors and pattern matching on a vector is denoted by a comma ','.

Constraints:
\begin{code}
bindv  =  tvarv :-> sigma
Cnstr  =  Vec(bindv)
\end{code}



\rulerCmdUse{rules2.exprE.baseImpredE}
\FigRef{rules2.exprE.baseImpredE} shows the basic equational type rules.

\rulerCmdUse{rules2.declE}
\FigRef{rules2.declE} shows the equational rules for declarations, to be used by |let| expressions.

%\rulerCmdUse{rules2.expr2.base}

\rulerCmdUse{rules2.expr4.base}
\rulerCmdUse{rules2.expr4.prog}
\FigRef{rules2.expr4.base} shows the inference rules combining known (checkable) type and inferred type.
The environment is set up in \FigRef{rules2.expr4.prog}.

\rulerCmdUse{rules2.decl4}
\FigRef{rules2.decl4} shows the inference rules for declarations, to be used by |let| expressions.

\rulerCmdUse{rules2.exprIm.base}
\FigRef{rules2.exprIm.base} shows the inferencing of impredicativity.
Type alternatives are introduced in this stage.
Idea: application is where polymorphism matters, so there binding of type variables is to type alternatives.
These are not introduced at variable introduction places (an obvious alternative as we want to find polymorphism is tied up to identifier occurrences)
because intermediate/anonymous functions also must be allowed to participate in this process.
A second reason is the mixture of yes/no quantified, i.e. holes in a type may have type alternatives.

\rulerCmdUse{rules2.exprIm4.base}
\FigRef{rules2.exprIm4.base} shows the use of inferenced impredicativity, overriding \figRef{rules2.expr4.base}.

\rulerCmdUse{rules2.taltGamIm}
\FigRef{rules2.taltGamIm} shows the elimination of type alternatives, used in between impredicativity inferencing and normal inferencing.

\rulerCmdUse{rules2.taltIm}
\FigRef{rules2.taltIm} is used as part of \figRef{rules2.taltGamIm}.

\rulerCmdUse{rules2.fit4.baseImpred4part1}
\rulerCmdUse{rules2.fit4.baseImpred4part2}
\FigRef{rules2.fit4.baseImpred4part1} and \FigRef{rules2.fit4.baseImpred4part2} show the rules for fitting (subsumption).
The order in which the rules appear is important. Of two matching rules the textually preceding one takes precedence.
In case of commutativity only a `left' variant has been included (perhaps an explicit summary where this applies).

\begin{TabularFigure}{Quantified type instantiation variants}{eh-impred-legenda-inst}{l@@{=}ll}
\multicolumn{2}{l}{Variant} & instantiate |Vec(alpha)| with fresh \\
\hline
|(Vec(tvarv),sigma') | & | instWith(tvarv)(Qu ^ Vec(alpha) . sigma)|
 &  type variables |Vec(tvarv)|
 \\
|(Vec(tvarf),sigma') | & | instWith(tvarf)(Qu ^ Vec(alpha) . sigma)|
 &  fixed type variables |Vec(tvarf)|
 \\
|(Vec(tvarv),sigma') | & | instWith(<+>)(Qu ^ Vec(alpha) . sigma)|
 &  `both' types |Vec(tvarv /=/ ANY)|
 \\
%if False
|(sigma') | & | instWith(exists)(exists ^ Vec(alpha) . sigma)|
 &  non reproducible type constants |Vec(identc)|
 \\
%endif
\end{TabularFigure}
\FigRef{eh-impred-legenda-inst} shows how quantified types can be instantiated.
All instantiation variants only instantiate top level quantified type variables.
instWith(exists)(Gamma) is defined in the obvious way.

\begin{TabularFigure}{Options to fit}{eh-impred-fit-options}{lll}
Option & meaning & default \\
\hline
|fioBindRFirst|
 & prefer binding of a rhs tvar over instantiating
 & |fioBindRFirstY|
 \\
|fioBindLFirst|
 & prefer binding of a lhs tvar over instantiating
 & |fioBindLFirstY|
 \\
|fioLeaveRInst|
 & leave rhs (of fitsIn) instantiated
 & |fioLeaveRInstN|
 \\
|fioMeet|
 & meet
 & |fioMeetN|
 \\
|fioJoin|
 & join
 & |fioJoinN|
 \\
\end{TabularFigure}
\FigRef{eh-impred-fit-options} shows the options which can be passed to |<=| (and |<+>|, |<->|, |<=>|).
Often used combinations of these options are found in \FigRef{eh-impred-fit-option-combis}.
|True| and |False| values are denoted by a an additional |+| or |-| respectively,
for example for |fioLeaveRInst| with |fioLeaveRInstY| and |fioLeaveRInstN| respectively.

\begin{TabularFigure}{Option combinations}{eh-impred-fit-option-combis}{ll}
Combination & options (relative to the default) \\
\hline
|strongFIOpts|
 &  
 \\
|instLFIOpts|
 &  |fioBindRFirstN|
 \\
|instFIOpts|
 &  |fioBindRFirstN|, |fioBindLFirstN|, |fioLeaveRInstY|
 \\
|weakFIOpts|
 &  |fioBindRFirstN|, |fioLeaveRInstY|
 \\
|impredFIOpts|
 &  |fioBindToTyAltsY|
 \\
|meetFIOpts|
 &  |fioMeetY|
 \\
|joinFIOpts|
 &  |fioJoinY|
 \\
\end{TabularFigure}
\FigRef{eh-impred-fit-option-combis} shows combinations |fiopt| of options to |fit|.

\rulerCmdUse{rules2.meetIm}
\FigRef{rules2.meetIm} shows the rules for the meet of types.
The `meet' |sigma1 <+> sigma2| is defined to be the greatest (w.r.t. |<=|) |sigma| which satisfies
|sigma <= sigma1| and |sigma <= sigma2|.
Default behavior is specified by the rules for fit.
Meet is commutative and associative.
The notation |sigma <+> sigma| is extended in the obvious way to |Vec(sigma) <+> sigma|.

\rulerCmdUse{rules2.joinIm}
\FigRef{rules2.joinIm} shows the rules for the join of types.
The `join' |sigma1 <-> sigma2| is defined to be the smallest (w.r.t. |<=|) |sigma| which satisfies
|sigma1 <= sigma| and |sigma2 <= sigma|.
As the dual of meet, similar remarks apply.
Default behavior is specified by the rules for fit and meet.

\rulerCmdUse{rules2.matchIm}
\FigRef{rules2.matchIm} shows the general purpose match which simply dispatches based on options |fiopt|.

\rulerCmdUse{rules2.tbothIm}
\FigRef{rules2.tbothIm} shows the elimination of temporary `both' assumptions used by meet/join.

\paragraph{Omissions}
Rules for |qu|, |quGam| (insertion of quantifiers, just assume explicit quantification and no partial type signatures) and |pat| (obvious :-)).

\subsection{Existential types}
\label{eh-impred-existential}

Trouble:

\begin{code}
%%4_2srcfile(test/4-impred9.eh%%)
\end{code}

Too forgetful w.r.t. |v1 :: %%4_2file(test/4-impred9.eh%%)|.
The algorithm is pessimistic and takes the least general type (i.e. |<->|) of the existential and the actual value.
This is ok for identifiers in parameter positions because we do not say anything about their actual value.
It is not ok when actual values are involved because we do not want to forget types there.
To remedy this problem it is likely that some additional administration in this area must be kept.
Not (yet) sorted out.


\subsection{Interaction with implicit parameters}
\label{eh-impred-implparam}

\paragraph{Subsumption and coercion}

\subsection{Discussion, related work}
\label{eh-impred-relwork}

\paragraph{When to report errors}

\paragraph{Related work}
\cite{vytiniotis05boxy-impred}

\subsection{Conclusion}
\label{eh-impred-concl}
%%]

%%[storyAFP
This version of EH adds explicit types with quantifiers at all positions in a type,
existential quantification and an interpretation of unquantified types to
quantified types.

\paragraph{Higher ranked explicit polymorphism.}
For example in
\begin{code}
%%4srcfile(test/3-poly-rank.eh%%)
\end{code}
|f| has type |f :: %%4file(test/3-poly-rank.eh%%)|,
which means that |i| has type |forall a. a ->a| in the body of |f|.
Therefore |i| can be used polymorphically in the body of |f|.

%{
%format forall1
%format forall2
%format forall3
%format forall4
%format forall5

The quantifier |forall| in the type of |f| is on a so called higher ranked position
in the type, rank 1 being in front of the type or in front of a result of a function type.
A rank 2 position is in front of the argument of a function type.
Higher ranked positions are defined recursively by the same definition.
So, in
\begin{code}
forall1 a . a -> (forall2 b . b -> b) -> ((forall3 c . c -> c) -> (forall4 d . d -> d)) -> forall5 e . e -> e -> a
\end{code}
|forall1| and |forall5| are on a rank 1 position, |forall2| and |forall4| on rank 2 and |forall3| on rank 3.
%}

Standard Hindley-Milner inferencing as described for the previous version of EH can infer rank 1 universal quantifiers.
We will not do better than that, but the inferencer described for this version of EH will
not throw away any type information about higher ranked quantifiers defined via a type signature.
No attempt is made to be smart in reconstructing higher ranked types, only smartness is
implemented by not forgetting higher ranked type information.

\paragraph{Existentially quantified types.}
Quantifiers on higher ranked positions are also necessary to make existential types useful

\begin{code}
%%4srcfile(test/4-demo1.eh%%)
\end{code}

An existentially quantified type \Ix{existential quantification}
is specified with keyword @exists@, or |exists|.
The type variable which is existentially quantified represents a type but we
do not know which one.
Existential quantification hides, or forgets, more specific type information.
In the given example |xy| is a tuple for which we have forgotten
that its first component is an |Int|.
All we know is that we can apply the second component to the first component
(as done by |ixy|).
This constraint is not upheld for |pq|, so an error is produced:

\begin{TT}
%%4ppfile(test/4-demo1.eh%%)
\end{TT}

\paragraph{Opening an existentially quantified type.}
The inverse of existential quantification of a type variable is often called `opening'.
It means that we get to know the original type.
This of course cannot \TBD{(???? type carrying code, analysis, etc)} be done
as this information was forgotten in the first place.
Instead, the compiler `invents' a fresh new type, a type constant,
which acts as a placeholder for the opened type variable.
This fresh type is guaranteed to be different from any type the programmer can construct.
Only if functions accepting parameters of this type are available anything useful can be done with it,
as in the example.

It also means that we can create values with which we cannot do much useful.
For example

\begin{code}
%%4srcfile(test/4-ex-extr3.eh%%)
\end{code}

gives

\begin{TT}
%%4ppfile(test/4-ex-extr3.eh%%)
\end{TT}

Both examples also demonstrate the place where opening an existentially quantified type is done.
Opening an existential type is done when the type is bound to an identifier.
However, only the type variables for the top level existential quantifiers are opened.
If an existentially quantified type is buried in a composite type it will only be opened if
bound to a value identifier.
For example:

\begin{code}
%%4srcfile(test/4-ex-extr4.eh%%)
\end{code}

gives

\begin{TT}
%%4ppfile(test/4-ex-extr4.eh%%)
\end{TT}

Also, opening the same type twice, as done in the given example for |v1|,
will twice give fresh type constants too.

This behavior simplifies the use of existential types in that no additional
language construct for opening is necessary.
%if not omitTBD
More about this in \TBD{[literature ...]}.
%endif

\paragraph{Guessing locations for quantifiers.}
Quantifiers need not always be specified.
For example in

\begin{code}
%%4srcfile(test/4-ex-extr2.eh%%)
\end{code}

no quantifiers are specified in the type signatures, for |ixy| a type signature is even absent.
The following interpretation of the meaning of a type is used to determine
where a quantifier should be inserted when a type is quantified.

\begin{itemize}
\item
If a type variable |a| occurs somewhere in |sigma1| and |sigma2| in |sigma1 -> sigma2| but not outside the function type,
|a| will be universally quantified, i.e. with |forall|.
\item
If a type variable |a| occurs somewhere in |sigma1| and |sigma2| in |(sigma1,sigma2)| but not outside the tuple type,
|a| will be existentially quantified, i.e. with |exists|.
\end{itemize}

The idea is that the first rule covers the notion that if an |a| is passed in and comes out a function,
this function will work for all |a|, hence the universal quantification.
On the other hand, the second rule covers the notion that if an |a| is stored together with another and nothing
more is known about |a| we might as well hide |a|, hence the existential quantification.
More rules are needed but we will look into this further when we look at the implementation.

For the given example the following will be concluded

\begin{TT}
%%4ppfile(test/4-ex-extr2.eh%%)
\end{TT}

Note that an explicit type is needed to hide type information (as for |xy|),
but is not required to pass it to a function expecting an existential.

\paragraph{Outline of the rest.}
First we will look at the type structure (\secRef{ehc4-type-lang}).
The |fitsIn| function will have to be redesigned almost completely (\secRef{ehc4-fitsin}),
partly because of the presence of quantifiers everywhere,
partly because |fitsIn| now really is asymmetric because (e.g.)
forgetting type information is one-way only.
Quantification as well as instantiation become more complicated because
of the presence of quantifiers anywhere in a type (\secRef{ehc4-quant}, \secRef{ehc4-inst}).
Finally type inferencing expressions and patterns will have to be modified (\secRef{ehc4-ty-infer}),
luckily not much because the hard work is done in |fitsIn|.

\subsection{Type language}
\label{ehc4-type-lang}

The type language for this version of EH adds quantification with the existential quantifier |exists|
\begin{code}
sigma  =  Int | Char | tcon
       |  (sigma,...,sigma)
       |  sigma -> sigma
       |  tvar
       |  Qu alpha . sigma, Qu `elem` {forall, exists}
tvar   =  tvarv | tvarf
\end{code}
We also need an infinite supply of type constants |tcon|.
Quantifiers |Qu| may now appear anywhere in a type.

The |Quant| alternative of the type structure has to made more general
to be able to encode |exists| too.

\chunkCmdUseMark{EHTyAbsSyn.4}

Some additional functions on quantifiers |TyQu| are defined here too.
These may seem unnecessary but the extra layer of abstraction
is convenient when the range of quantifiers is extended
%if not incl06
later on (not included in \thispaper):
%else
in \chapterRef{ehc6}:
%endif

\chunkCmdUseMark{EHTy.4.tyquMisc}

These functions inquire the kind of quantifier and flip between universal and existential quantifier.

\subsection{Fitting, subsumption}
\label{ehc4-fitsin}

First we will look at the issues arising with the presence of quantifiers in a type.
Next we will look at the implementation.

\subsubsection{Issues}

\paragraph{|<=| is a partial ordering.}
With the presence of quantifiers during type inferencing,
the function |fitsIn|, implementating the so called \IxAsDef{subsumption}
relation |<=| between types, now
becomes a partial ordering on types.
For example,
\label{ehc4-exists-sub}
\begin{code}
%%srcfile(test/4-exists-sub.eh%%)
\end{code}

makes the type inferencer check |Int <= exists a . a|,
if the type of the actual value |3| fits in the specified type |exists a . a|.
This corresponds to the flow of |3| into some location, which in turn is then later on used elsewhere.
This checks out well, but not the other way around because we cannot
assume that some unknown type is an |Int|.

Similarly for universal quantification
the check |forall a . a -> a <= Int -> Int|
holds as we can use a more generally applicable function |id|
in the more restricted required setting |Int -> Int|.
\label{ehc4-forall-sub}
\begin{code}
%%srcfile(test/4-forall-sub.eh%%)
\end{code}

Losing generality, or specialization/instantiation to a specific type is ok,
but the other way around, for the definition of |id| it is not.

So, in a nutshell
\[
|forall a . a <= sigma <= exists a . a|
\]
meaning that a universally quantified type can be used at
a place where any other type is expected, say some type |sigma| (e.g. an |Int|),
which in turn can be used at a place where all is forgotten about a type.
Or, in other words, first we choose some type for |a|, then we forget this choice.

Let us look at some other examples to get a better idea of what |fitsIn =@= <=|
has to deal with.

\paragraph{Impredicativeness.}
The following example (from Botlan \cite{botlan03ml-power-f})

\label{ehc4-choose}
\begin{code}
%%srcfile(test/4-choose.eh%%)
\end{code}

demonstrates a choice we can make.
This choice coincides with the question what the type of |v| is.
\begin{itemize}
\item
|v :: forall b . (b -> b) -> b -> b|.
This is Haskell's answer.
This answer is given because all types are monomorphic, that is,
without quantifiers during inferencing.
The type variable |a| of the type of |choose| is bound to the instantiated
type if |id|.
So, |id| is instantiated to |tvarv1 -> tvarv1|, giving |choose id :: (tvarv1 -> tvarv1) -> tvarv1 -> tvarv1|
resulting in the given quantified type.
Function |v| can safely be applied to a function of type |Int -> Int|.
\item
|v :: (forall c . c -> c) -> (forall d . d -> d)|.
This is system-F's answer \cite{reynolds74type-struct-sysF}.
This answer is given because the type variable |a| of |choose|
is bound to the type of the parameter as it is known, with quantifiers, in its
uninstantiated original form.
Now |v| cannot be applied to a function of type |Int -> Int| because this function is
not general enough to be used as if it were of type |forall a . a -> a|.
Paradoxically enough a more general function will be returned;
this relates to a phenomenon called \IxAsDef{contravariance} which we will discuss later.
\end{itemize}

Allowing type variables to be bound to, or instantiated with,
quantified types is called \IxAsDef{impredicativeness} \TBD{[cite...]}.

The critical observation for this version of EH is that it is difficult \TBD{[cite...]} to
infer that a type variable should be bound to
a quantified type,
but that it is relatively easy not to forget that a type is quantified if
we already knew in the first place that it was quantified.
The latter is what we do except in situations where it would break Haskell's choice,
thereby still inferring types in a standard Hindley-Milner way but
using |fitsIn =@= <=| to allow richer types still to match properly.

\paragraph{Subsumption |<=| needs to instantiate types.}
These examples also demonstrate that |fitsIn| needs to instantiate types.
In the previous version of EH all types partaking in the inference process
were expected to be fully instantiated.
By definition this can no longer be done if as much as possible type information
is to be retained.
Still, at some point instantiation has to be done,
at the latest moment possible.
This latest moment is the place where a type
really is compared with another one, in |fitsIn|.

\paragraph{Subsumption |<=| depends on context.}
|fitsIn| is used as a tool to enforce the |<=| relation between types.
It is used to check the type of an actual parameter with its expected one,
as in the previous example for |choose| (\pageRef{ehc4-choose}).
It is also used to check the type of a value against its known type as in
the earlier example with |ii| and |id| (\pageRef{ehc4-forall-sub}).
However, the precise use of |fitsIn| in these contexts differs slightly
in the way instantiation is done.

\begin{itemize}
\item
For an application |f a| of |f :: sigma2 -> ...| to |a :: sigma1|
we have
to check the type |sigma1| of an actual argument against 
the type |sigma2| of an expected
via |sigma1 <= sigma2|.
As we learned from looking at the |choose| example, Haskell's convention
is to instantiate |sigma1| before binding it to a type variable |tvarv|
in the case |sigma2 == tvarv|.
This information is passed as an additional parameter to |fitsIn|, notated
by |instLFIOpts|, named an \IxAsDef{instantiating context}.
\item
For checking an expression |e :: sigma2| of a declaration |v :: sigma1; v = e| to its known type
|sigma1|
we check |sigma2 <= sigma1|.
In this case we want to avoid instantiating |sigma2|.
The necessity of avoiding this becomes clear if we look at a situation where
|sigma2 == (exists a . a, ...)| and |sigma1 == (tvarv,...)|,
coinciding with a situation where an explicit type signature is absent.
Now, if |exists a . a| is instantiated with type constants before it is bound to |tvarv|
all information about the existential is irretrievably lost,
something we do only when an existential is bound to an identifier.
So, in this case we say that |fitsIn| needs to told
it is checking types in a \IxAsDef{strong context}, notated by |strongFIOpts|.
\item
A third context will also be mentioned here for completeness,
a so called \IxAsDef{weak context} |weakFIOpts|.
It is used whenever an expression can have |>1| alternative expressions as a result,
which is the case for |case|-expressions,
to be dealt with no sooner than the introduction of datatypes in the next version of EH
%if not incl05
(not included in \thispaper).
%else
(\chapterRef{ehc5}).
%endif
\end{itemize}

\label{ehc4-fitsIn-strength}
|fitsIn =@= <=| therefore needs an option |fiopt| to describe these variations
\begin{code}
fiopt  =  strongFIOpts  ^^ -- strong context
       |  instLFIOpts   ^^ -- instantiating context, for expr |App|
       |  instFIOpts    ^^ -- instantiating context, for patterns
\end{code}

These contextual variations actually are
configurations of lowlevel boolean flags for |fitsIn|

\begin{code}
fioBindRFirst   =   fioBindRFirstY       ^^ -- prefer binding of a rhs tvar over instantiating
                |   fioBindRFirstN
fioBindLFirst   =   fioBindLFirstY       ^^ -- prefer binding of a lhs tvar over instantiating
                |   fioBindLFirstN
fioLeaveRInst   =   fioLeaveRInstY       ^^ -- leave rhs (of fitsIn) instantiated
                |   fioLeaveRInstN
\end{code}

where the |+| variants stand for |True|.
A |True| value for the flag |fioBindRFirst| states that in case of |sigma <= tvarv|
a constraint |(tvarv :-> sigma)| will result,
otherwise first |sigma| will be instantiated and |tvarv| be bound to
the instantiated |sigma|.
Similary we have |fioBindLFirst| for |tvarv <= sigma|.
Finally, |fioLeaveRInst| determines if an instantiation done for |sigma|
in |... <= sigma| will return the instantiated |sigma| or |sigma| itself.
Summarizing, |fioBindRFirst| and |fioBindLFirst| turn off greedy
instantiating and |fioLeaveRInst| leaves visible what has been instantiated.

Context variations and these flags relate as follows

\begin{tabular}{llll}
 & |fioBindRFirst| & |fioBindLFirst| & |fioLeaveRInst| \\
\hline
|strongFIOpts| & |fioBindRFirstY| & |fioBindLFirstY| & |fioLeaveRInstN| \\
|instLFIOpts| & |fioBindRFirstN| & |fioBindLFirstY| & |fioLeaveRInstN| \\
|instFIOpts| & |fioBindRFirstN| & |fioBindLFirstN| & |fioLeaveRInstY| \\
\end{tabular}

So, for example the |instFIOpts| context variant used for an expression application
has as its effect that instantiation will be done a la Hindley-Milner.

Finally, all of this is encoded as follows

\savecolumns
\chunkCmdUseMark{EHCommon.4.FIOpts.hd}
\restorecolumns
\chunkCmdUseMark{EHCommon.4.FIOpts.tl}
\chunkCmdUseMark{EHCommon.4.FIOpts.defaults}

\paragraph{Co- and contravariance.}
For tuples the check |(sigma1,sigma2) <= (sigma3,sigma4)|
will break down into |sigma1 <= sigma3| and |sigma2 <= sigma4|
because conceptually a tuple value can be put into
a location if that location expects a tuple and
the elements of the tuple also fit.

For functions this works differently.
Checking |sigma1 -> sigma2 <= sigma3 -> sigma4| means that
a |f :: sigma3 -> sigma4| is expected but a |g :: sigma1 -> sigma2| is available.
This happens for example in

\begin{code}
let  g :: sigma1 -> sigma2
     f :: sigma3 -> sigma4
     f = g
     a :: sigma3
in   f a
\end{code}

So, what happens when |f| is called and what does it mean in terms of types |sigma|?
The caller of |f| in the application |f a| expects that the function |f|
accepts a |sigma3|.
However, |g| is invoked instead, so a value of type |sigma3| is passed to a function
expecting a |sigma1|, which in terms of fitting means |sigma3 <= sigma1|.
The observation here is that the direction of |<=| for fitting the
argument types of |f| and |g| is opposite to the direction
of fitting |f| and |g|.
This behavior is called \IxAsDef{contravariance}.

In general, fitting a composite type breaks down into fitting the components of the composite type.
If the direction of |<=| for fitting a component is the same as for the composite type,
it is said that that component of the type is \IxAsDef{covariant},
if the direction is opposite the component is
\IxAsDef{contravariant}.

The following notation is used to denote this variance

\begin{code}
coco                =   CoVariant           ^^ -- CoVariant
                    |   ContraVariant       ^^ -- ContraVariant
                    |   CoContraVariant     ^^ -- CoContraVariant (both co/contra)
\end{code}

with a corresponding Haskell definition

\chunkCmdUseMark{EHCommon.4.CoContraVariance}

in which the same notation is used for the alternatives of |CoContraVariance|.

\subsubsection{Implementation}

\paragraph{Typing rules.}
Let us look more precisely at |<=| which we now also will
describe with rules,
in \figRef{rules.fit4.quant} and \figRef{rules.fit4.app}.
\RuleRef{f-prod4} and \ruleRef{f-arrow4} both follow the discussion about co- and
contravariance.
These rules are both instances of the by now usual |App| structure which will
be used by |fitsIn|.

The fine detail here lies with \ruleRef{f-arrow4} which specifies
a strong context |strongFIOpts| for fitting its arguments.
This means that for higher ranked positions in a type any implicit
instantiation of types is inhibited, that is, it is not visible
for the inference process.
\TBD{more explanation why...}

\rulerCmdUse{rules.fit4.app}
\rulerCmdUse{rules.fit4.quant}

The rules for quantified types also deserve a bit more attention.

\begin{itemize}
\item
\RuleRef{f-forall-r2} applies in
\begin{code}
%%srcfile(test/4-forall-sub.eh%%)
\end{code}
to the check |Int -> Int <= forall a . a -> a| which has to be done for |id = ii|.
If |forall a . a -> a| is instantiated with type variables |tvarv|,
the check would succeed with a constraint |(tvarv :-> Int)|.
This is not correct.
Recall that by succesfully passing this check |Int -> Int| will be used
as if it were a |forall a . a -> a|, which definitely will not work for
all types.
So, in order to let this check fail we instantiate with the fixed variant |tvarf|
of type variables, indicated by |instf|.
These fixed type variables cannot be further constrained but quantification
over them is allowed (see ...).

\item
Dually, \ruleRef{f-exists-r2} applies in
\begin{code}
let  f :: (exists a . a) -> Int
     v = f 3
in   v
\end{code}
to the check |Int <= exists a . a| for the application |f 3|.
The body of |f| only knows it gets passed a value of some unknown type,
no assumptions about it are made in the body of |f|.
Consequently, type variable may be instantiated with any type by the caller of
|f|.
This is simulated by instantiating with fresh constrainable type variables |tvarv|,
via |instv|.
In that case we also are not interested in any found constraints
concerning the fresh type variables, so these are removed.
\end{itemize}

\paragraph{Co- and contravariance.}
The encoding of co- and contravariance behavior is solved a bit more general then really
is required at this point. The idea is that for a type application |tcon a b ...|
the |tcon| determines how the fitting of its arguments should be done.
For example, for |tcon == ->|,
the first argument should be fitted with the opposite variance and
options |fiopt| should be made strong. This is described via a environment
encoding this information

\chunkCmdUseMark{EHTyFitsInCommon.4.AppSpine}
\chunkCmdUseMark{EHOpts.4.fioMkStrong}
\chunkCmdUseMark{EHGam.4.AppSpineGam}
\chunkCmdUseMark{EHGam.4.appSpineGam}

It also shows that only for function and tuple types we know what to do in such a situation.
Complications in this area will arise with the introduction of datatypes
%if not incl05
later on (not included in \thispaper).
%else
in \chapterRef{ehc5}.
%endif

\paragraph{|fitsIn| parameters and result.}
So, let us know finally look at the implementation of |<=|,
and redo the implementation of |fitsIn|.
First, |fitsIn| needs to pass information both up and downwards.
Upwards was already implemented via

\savecolumns
\chunkCmdUseMark{EHTyFitsInCommon.4.FIOut}
\restorecolumns
\chunkCmdUseMark{EHTyFitsInCommon.4.FIOut.tl}

which is extended with |CoContraVariant| information and threads a UID value
needed for instantiating types together with the downward information stored in

\savecolumns
\chunkCmdUseMark{EHTyFitsIn.4.FIIn.hd}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.FIIn.tl}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.FIIn.emptyFI.hd}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.FIIn.emptyFI.tl}

The parameter |fiCoContra| is used to indicate if the comparison |<=| is flipped.

Finally, an environment is passed to |fitsIn|:

\chunkCmdUseMark{EHTyFitsIn.4.FIEnv}

In this version |FIEnv| acts as a placeholder for use in later versions.
The intention of a |FIEnv| is to pass environmental information needed by |fitsIn|,
usually stored in |Gamma|'s throughout the type rules and attribute grammar implementation.

\paragraph{The fitting.}
The preliminaries of |fitsIn| have not changed much compared to
the previous version (\pageRef{EHTyFitsIn.2.fitsIn.Base}).
All internally defined functions now take an additional top-down |fi :: FIIn|
parameter and some work has to be done for extracting and passing variance information
(in function |res|).

\savecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.Prelim}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.bind}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.allowBind}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.allowImpredTVBind}

The fitting of quantified types uses |unquant| which removes all top level quantifiers.

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.unquant}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.FOUtils}

The instantiation is parameterized a flag |hide|
telling if any found constraints for the fresh
type variables |rtvs| should be hidden.
A second parameter |howToInst :: HowToInst|
specifies how to instantiate.
When discussing the implementation
for quantifiers we will look at this further.

The first cases of the actual implementation of |<=| are similar
to the previous version with the exception
of an alternative for flipping
|t1 <= t2| into |t2 <= t1| if the variance is |ContraVariant|,
and
an additional guard on |fioBindLFirst| and |fioBindRFirst|.

Finally, before looking at the case analysis, some convenience functions for
updating the output |FIOut| are introduced:

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.foCmb}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.foCmbApp}

These functions straightforwardly combine fields from two different |FIOut|'s.
These combination functions specify how aspects of |fitsIn| should be combined
for |Ty_App|. For example |foCmbCnstr| applies the constraints resulting
from fitting the second subtype |afo| (of |Ty_App|) to the constraints coming out
of the first subtype |ffo|.
The overal combination |foCmbApp| used by the fitting of
two |Ty_App|'s is the composition of all the smaller combinations.

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.Base}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.Var1}

The order in which all these case are listed is now important
as the cases for |fioBindLFirstN| and |fioBindRFirstN| will
be executed only after types are stripped of their top level quantifiers.

Compared to the rules in \figRef{rules.fit4.quant}
an additional case has been included for an exact match of
two quantified types when we want |t1 <= t2| and |t2 <= t1| both
to hold. We will postpone discussion until
%if not incl05
later (not included in \thispaper).
%else
\chapterRef{ehc5}.
%endif

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.QLR}

The function |unquant| has to be told how to do the instantiation,
this is specified by a function which creates a type from a type
variable and a quantifier.

\chunkCmdUseMark{EHTyInstantiate.4.HowToInst}

The rules in \figRef{rules.fit4.quant} indicate for different combinations of options
and quantifiers how to instantiate type variables.
For example,
the first case of

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.QR}

implements \ruleRef{f-forall-r1} and \ruleRef{f-exists-r1}.
The behavior with respect to the different ways of instantiating is encoded
in |instCoConst| which tells us that the universally quantified types
should be instantiated with type variables,
and existentially quantified types with type constants.
The second case similarly covers \ruleRef{f-forall-r2} and \ruleRef{f-exists-r2}
while

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.QL}

covers the remaining \ruleRef{f-forall-l} and \ruleRef{f-exists-l}.

Checking two application of types, implementing both \ruleRef{f-prod4} and \ruleRef{f-arrow4},
has changed with respect to the handling of co- and contravariance.
From the resulting |foCoContraL| the first element describes the
co- and contravariance behavior, as such it is used to update
the |fi :: FIIn| accordingly.

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.App}

All is left of |fitsIn| are the remaining cases for type variables, now for the
|fioBindLFirstN| and |fioBindRFirstN| cases

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.Var2}

and starting it all

\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.DefaultCase}
\chunkCmdUseMark{EHTyFitsIn.4.fitsIn.SetupAndResult}

\subsection{Instantiation}
\label{ehc4-inst}

Function |fitsIn| is
now one of the two places
where instantiation of a type occurs.

\begin{itemize}
\item
In |fitsIn| the
instantiation of a quantified type now is entangled with
matching two types.
|fitsIn| peels off top level quantifiers layer by layer during
the matching of types.
\item
When a type is bound to an identifier,
we have to instantiate top level |exists|'s to
open the type.
\end{itemize}

These variants are implemented by |tyInst1Quants|
and |tyInst1Exists| respectively:

\chunkCmdUseMark{EHTyInstantiate.4.tyInst}

An additional |onlyExists :: Bool| is passed to the more general function |tyInst|
to inhibit quantification of |forall|'s.

Note that in  the previous version of EH instantiation was done explicitly,
as indicated by type rules.
In this version instantiation is done implicitly by |fitsIn|.

\subsection{Quantification}
\label{ehc4-quant}

Quantification is more complicated because the place of omitted quantifiers
has to be guessed.
This guessing is done according to the rules in
\figRef{rules.qu4}.
The structure of a type and the occurrences of
type variables are used to determine where which quantifier is inserted
during the quantification of a type.

\rulerCmdUse{rules.qu4}
\rulerCmdUse{rules.quGam4}

Informally, the following rules are obeyed
\begin{itemize}
\item
The first step is to find for a type variable |a| the smallest part of a type
where |a| occurs.
For example, for |a -> (a,b,b,b->c->(b,c))| this is the complete
type for |a|, |(a,b,b,b->c->(b,c))| for |b| and |c->(b,c)| for |c|.
\item
If this smallest part is a function type it is assumed
that universal quantification is the right choice (\ruleRef{q-arrow}).
\item
If this smallest part is a tuple type
the type variable is existentially quantified (\ruleRef{q-prod}).
\item
For the remaining cases the position of the smallest part as part
of a function type determines which quantifier is put in front.
For example, in |a -> b| the type variable |a| occurs in a contravariant
(argument) position, |b| in a covariant position.
Here the observation is that |a| apparently is not used at all by
the corresponding function because it does not show up in the result type.
So, we might as well hide |a|, hence the |exists| in \ruleRef{q-var-contra}.
Conversely, the choice of what |b| is apparently is up to the caller of
the function, hence the |forall| in \ruleRef{q-var-co}.
\item
The \ruleRef{q-app} covers remaining type constructors,
which is irrelevant for this version of EH as there are no other type constructors.
It becomes relevant for the next version of EH,
when datatypes are introduced
%if not incl05
later on (not included in \thispaper).
%else
(\chapterRef{ehc5}).
%endif
\end{itemize}

Because these rules represent a form of syntactic sugar they always
can be overruled by explicit quantifiers, as indicated by \ruleRef{q-quant}.
The quantification is lifted to a |Gamma| in a straightforward way as
specified by \figRef{rules.quGam4}.

The implementation, in terms of AG, follows the rules with the exception of
some details. First all free type variables are gathered:

\chunkCmdUseMark{EHTyQuantify.4.frTvLL}
\chunkCmdUseMark{EHCommon.4.listCombineUniq}

At the top of a type application, say |App (App (Con "->") (Var 1)) (Var 1)| representing
|a -> a| we need to be able to determine which type variables occur in both arguments of
the type constructor |->|.
Therefore a list |frTvLL: [TyVarIdL]| of type variables is gathered, each element corresponding
with the free type variables of an argument.
This list corresponds to the |fv|'s in the rules in \figRef{rules.qu4}.
For the given example this would be |[[1],[1]]|.

Next we determine which locations in the type structure are a candidate
for quantification:

\chunkCmdUseMark{EHTyQuantify.4.coco}
\chunkCmdUseMark{EHTyQuantify.4.isQuLoc}

Quantifiability of a location is based
on co- and contravariance information as passed from top to bottom,
as prescribed by the rules in \figRef{rules.qu4}.
We also need to know what an |App| represents, that is, if
it is a function type (|appIsArrow|) or tuple type (|appIsLikeProd|):

\chunkCmdUseMark{EHTyCommonAG.4.whereIAm}

If a location in the type structure is a place where
quantification may take place, the candidate free type
variables |qHereTvL| are computed:

\chunkCmdUseMark{EHTyQuantify.4.qHereTvL}
\chunkCmdUseMark{EHTyQuantify.4.tvarOccurCount}

The auxiliary function |tvarOccurGE2| selects those
type variables which occur at least twice in the arguments
of a type constructor.

From the top of the type downwards then the function |tvIsBound|
is constructed,
ensuring that candidate free type variables are not in the
|bv| of the rules in \figRef{rules.qu4}.

\chunkCmdUseMark{EHTyQuantify.4.tvIsBound}
\chunkCmdUseMark{EHTyQuantify.4.tvarsToQuant}

The resulting selection of type variables |qBndTvL|
is then used with the quantifier |hereQu|
which in turn is based on |qExists|,
telling us if it is a location where |exists| is to be used:

\chunkCmdUseMark{EHTyQuantify.4.hereQu}

Finally the quantified type |quTy| is constructed:

\chunkCmdUseMark{EHTyQuantify.4.quTy}

concluding with wrapping the AG functionality in the
function |tyQuantify| which can be used in
the Haskell world:

\chunkCmdUseMark{EHTyQuantify.4.tyQuantify}

\subsection{Type inference}
\label{ehc4-ty-infer}

Type inferencing for this version of EH and the previous version are very
similar.
\FigRef{rules.expr4} holds the adapted rules for expressions,
\figRef{rules.pat4} for patterns.
The main differences are as follows:

\rulerCmdUse{rules.expr4}
\rulerCmdUse{rules.pat4}

\begin{itemize}
\item
All rules are passed an additional context parameter indicating
the way |<=| has to be done with respect to strength |fiopt|.
See \pageRef{ehc4-fitsIn-strength} for the relevant discussion.
\item
The |fiopt| is mostly passed on unchanged, except in the argument
of an expression application (\ruleRef{e-app4}) and a pattern
|Con| (\ruleRef{p-con4}).
The latter is due to a different way of handling tuple constructors.
Instantiation in a pattern \ruleRef{p-con4} instantiates as greedily as possible.
\TBD{needs more discussion}
\item
Types of tuple constructors (and destructors) are now stored in the |Gamma| for
types, |valGam|.
The lookup for types in |valGam| (|valGamLookup|) now takes care of
returning a proper quantified type for tuples, thereby resembling more the
normal retrieval of types from a |Gamma|.
The \ruleRef{p-var4} now covers the case for (tuple)constructors too.
This change also prepares for the introduction of datatypes in the next version of EH.
\item
A |let|-expression in \ruleRef{e-let4} and \ruleRef{e-let-tysig4} quantify
bindings via the rules in \figRef{rules.quGam4} and \figRef{rules.qu4}.
Additionaly, to take care of always opening existentially quantified types
bound by a value identifier, a function |instE| is used.
Function |instE| corresponds to |tyInst1Exists|.
\end{itemize}

Changes in the implementation are also small, mostly to take care
of the additional parameters to |fitsIn| (|fiopt|, a |UID| for instantiations)
and the previous remarks.

\subsubsection{Handling of tuples}

The alternative for |Con| looks up the value associated with
the tuple constructor name in |valGam|.

\chunkCmdUseMark{EHInferExpr.4.Con}

Previously, the type was constructed in situ,
now it is delegated to |valGamLookup|:

\chunkCmdUseMark{EHGam.4.valGamLookup}

This modification also introduces a new convention where |valGam|
contains for a value constructor |X| a binding for the type
of the function which constructs the value,
and a type of the function which dissects the value into
a tuple of all fields of the value.
The convention is that the constructor has name |X|, the dissector/deconstructor
has name |unX|.
For tuples these bindings are created on the fly.
For example,for a 3-tuple the following
bindings are simulated to be present in |valGam|:

\begin{code}
,3    :: forall a . a -> forall b . b -> forall c . c -> (a,b,c)
un,3  :: forall a b c . (a,b,c) -> (a,b,c)
\end{code}

The |unX| binding corresponds to the type created in the \ruleRef{p-con2} (\figPageRef{rules.pat2}).
The |Con| alternative now also uses the |valGam| to find a binding for a tuple dissector/destructor:

\chunkCmdUseMark{EHInferPatExpr.4.patFunTy}

\subsubsection{Declarations and options}

Declarations als need some modifications to take care of the quantification and instantiation
of toplevel existential quantifiers as specified in \ruleRef{e-let4} and \ruleRef{e-let-tysig4}:

\chunkCmdUseMark{EHInfer.4}

Setting up proper values for the ``strength'' |fiopt| is also done here.

\subsubsection{Type expressions}

Type signatures may include quantifiers.
This requires additional abstract syntax for type expressions:

\chunkCmdUseMark{EHAbsSyn.4}

and additional parsing

\chunkCmdUseMark{EHParser.4.pTyExprPrefix}
\chunkCmdUseMark{EHParser.4.pTyExpr}

The parser |pTyExpr| is slightly complicated because of the right associativity of 
the function type constructor |->| in combination with quantifiers.
For example, the type
\[
|forall a . a -> forall b . b -> (a,b)|
\]
parses to an abstract syntax fragment corresponding to
\[
|forall a . (a -> (forall b . (b -> (a,b))))|
\]

Rewriting to a form similar to the parser for expressions, with a prefix would lead
to a parser with common prefixes (the |pTyExprBase|) in its alternatives.
For LL(k) parsers such as the parser combinators used here this is not a good idea.
Hence the construction where the quantifier is parsed as a prefix of
the parts between |->| but still applies right associatively.

\chunkCmdUseMark{EHInferExpr.4.Var}
\chunkCmdUseMark{EHInferExpr.4.Const}

\chunkCmdUseMark{EHInferPatExpr.4.Rest}


\TBD{previous should be redone.}
%%]

%%[scratch3
\subsection{Propagation of impredicativity}

Our solution for the use of higher ranked types is based on:
\begin{itemize}
\item The obligation for a programmer to specify the type information the type inferencer is not capable of inferring.
\item The obligation of the type inferencer to not forget this information.
\end{itemize}

The type inferencer uses standard Hindley-Milner type inferencing extended with the possibility to bind type variables to
quantified types, usually named \IxAsDef{impredicativity}.
This allows the type inferencer to propagate quantified types instead of instantiating these types to a monomorphic type
for which it is then impossible to find back forgotten polymorphism.
This idea works well for the examples encountered so far, for example:

\begin{code}
%%4srcfile(test/3-poly-rank.eh%%)
\end{code}

Polymorphism for |i| has been declared explicitly before any use of this information in de type checking of the body of |f| is done or any parameter is
passed to |f|.
Because we allow type variables to be bound to quantified types the following example also infers |f :: (forall a . a -> a) -> Int| correctly:

\begin{code}
%%4srcfile(test/4-impred2.eh%%)
\end{code}

This works because initially we assign a type variable to the type of |h| which is later bound to |forall a . a -> a| when it is used as an argument of |g|.
However, the following example breaks because we first bind the type of |h| to a monomorphic type:

\begin{code}
%%4srcfile(test/4-impred-demo1.eh%%)
\end{code}

This example breaks at three different places:
\begin{itemize}
\item
The first use of |h| for the computation of |x1| concludes |h :: Int -> v_7|. This conflicts with the second use in the computation of |x2| where
|h| is expected to accept a |Char|.
\item
|h| is also not polymorphic enough to be passed as a parameter to |g|.
\item
The type inferencer will conclude |f :: (Int -> forall a . a) -> Int| (or something similar) which is not polymorphic enough in its argument
to be able to accept |id| as its parameter.
\end{itemize}

These problems are caused by the interaction of the following design choices:
\begin{itemize}
\item
If the type inferencer finds more information about a type variable it immediately applies this knowledge to all types.
This is done in a left-to-right order through the abstract syntax tree.
\item
No polymorphism for parameters is inferred. See ... for the a discussion of the reasons to avoid the complexity of ... .
\end{itemize}

In other words, once a type is monomorphic we don't allow it to become polymorphic, not even if we encounter the `right' to do so elsewhere in
a program.
We will not introduce inferencing polymorphism for parameters in our inferencing machinery because of its complexity, so we cannot repair the problem
by inventing polymorphism whenever it would be convenient to do so.
However, the problem could be fixed because in our example program the use of |h| as a parameter to |g| tells us that |h| must be polymorphic anyway.
If only this information could be available in an earlier stage of type inferencing,
or alternatively, if only the decision to let |h| be monomorphic could be delayed for a while!
We choose the latter, that is, we introduce a way of delaying a binding decision for a type variable.

In order to be able to rebind a type variable to a more polymorphic we may not forget to which type variable a type was assigned.
This can be remembered by just relating the type variable to its type(s):

\begin{code}
sigma  =  ...
       |  tvarv//Vec(sigma)
\end{code}

The notation |tvarv//Vec(sigma)| associates to a set of types |Vec(sigma)|.
The type variable |tvarv| is bound to each of them during type inferencing, hence the name \IxAsDef{bind type} for this type variant.
The idea is that as soon as an attempt is made to bind |tvarv| to a polymorphic
type we check if all types in |Vec(sigma)| are an instance of the polymorphic type.
If this is the case we can forget all types |Vec(sigma)| and go on with the polymorphic type.

The rules for |<=| in \figRef{rules.fit4.bind} make this more precise.
A bind type is introduced in \ruleRef{f-var-l1}.
The introduction is also influenced by the context in which |<=| is used; this is expressed by
the boolean flag |fioBindToTyAltsY|, part of the set of options |fiopt|.
The modified \ruleRef{e-ident4B} \figRef{rules.expr4.B} for checking the type of an identifier sets this flag.

A bind type can only be introduced when checking an identifier.
Traditionally, this is the place where a quantified type is instantiated when it is extracted from an environment |Gamma|.
Quantified types usually live in a |Gamma| as a so called \IxAsDef{type scheme} and are introduced into the type checking/inferencing world
by instantiating the type scheme to a monomorphic type.
Here, in a similar manner, if nothing is known about an identifier, its type variable will be bound to a bind type which will hold
all possible instantiations found during type inferencing.
The remaining rules of \figRef{rules.fit4.bind} specify what should be done if a bind type is encountered in |<=|.

Some additional notation for manipulating vectors is used as well.
A vector |Vec(x)| of |x|'s is alternatively notated as |VecI(x)(i)| where |i| implicitly ranges over all indices referring to
an element of the vector. Any predicate referring to |i| has an implicit quantifier |forall ^ i| in front of it.
Extraction of an individual element of the array with index |i| is notated by |VecI(x)(..,i,..)|.
A predicate referring to this |i| has an implicit |exists ^ i| in front of it.

Some additional options need to be passed as well:

\chunkCmdUseMark{EHTyFitsIn.6.2.FIOpts.defaults}

\rulerCmdUse{rules.fit4.bind}
\rulerCmdUse{rules.expr4.bind}
\rulerCmdUse{rules.elimb4}
\rulerCmdUse{rules.elimbGam4}

The following example really is responsible for delaying subsumption checks:

\begin{code}
%%4srcfile(test/4-impred4.eh%%)
\end{code}

There is no single usage of |h| which enforces |h :: forall a . forall b . (a,b) -> (a,b)|,
the meet of |forall a . (Int,a) -> (Int,a)| and |forall a . (a,Int) -> (a,Int)| done at the generalization of |f|
computes this type.
Newfound polymorphism (as in |g1 h|) can be used to deduce a more general type for (e.g.) |(Int,Int) -> v| found in |h (3,4)|...

???? Meet instead of subsumption

\subsection{Propagation of impredicativity + predicates + coercions}

Some examples:

\begin{code}
let  g  ::  (forall a . A a => a -> a) -> Int
     f  =   \h ->  let  x1 = g h
                        x2 = h 3
                   in   ...
in   ...
\end{code}

Function |h| has type |h :: forall a . A a => a -> a|.
However, it cannot be instantiated immediately in its use in |h 3| because later on |h| might turn out
to be more polymorphic. Here it does not matter because |h| already is polymorphic enough...
%%]

%%[scratch2
%if inclOmitted
\subsection{Omitted, more of the same}
Substitution, error gathering, pretty printing, uniq, common
%endif

%if not omitLitDiscuss
\subsection<article>{Literature}

\TBD{}

Higher ranked types, \cite{peytonjones04pract-inf-rank,botlan03ml-power-f}

Cannot do inference for rank3, \cite{jim95rank,kfoury94direct,kfoury99rank2-decid,kfoury03rank2-princ}

Existentials, via universal \cite{laufer96class-existential}

%endif %% not omitLitDiscuss
%%]

%%[scratch4
%\rulerCmdUse{rules3.E.expr.base}
%\rulerCmdUse{rules2.exprE.base}

%\rulerCmdUse{rules3.K.expr.base}
%\rulerCmdUse{rules2.exprK.base}

%\rulerCmdUse{rules3.C.expr.base}
%\rulerCmdUse{rules2.expr2.base}

%\rulerCmdUse{rules3.HM.expr.base}
%\rulerCmdUse{rules2.expr3.base}

blabla

%\rulerCmdUse{rules3.E.expr.base}
%\rulerCmdUse{rules3.E.decl.base}

%\rulerCmdUse{rules3.E.decls.base}

%\rulerCmdUse{rules3.K.expr.base}
%\rulerCmdUse{rules3.K.decl.base}

%\rulerCmdUse{rules3.C.expr.base}
%\rulerCmdUse{rules3.C.decl.base}

%\rulerCmdUse{rules3.HM.expr.base}
%\rulerCmdUse{rules3.HM.decl.base}


\rulerCmdUse{rules3.I1.expr.base}
\rulerCmdUse{rules3.I1.decl.base}

\rulerCmdUse{rules3.CG.expr.base}
\rulerCmdUse{rules3.CG.decl.base}

\rulerCmdUse{rules3.P.expr.base}
%\rulerCmdUse{rules2.expr4.base}

%\rulerCmdUse{rules3.I2.expr.base}
%\rulerCmdUse{rules2.exprIm.base}
%\rulerCmdUse{rules2.exprIm4.base}

---------------------

---------------------

%\rulerCmdUse{rules2.decl4}

%\rulerCmdUse{rules3.I2.decl.base}
%\rulerCmdUse{rules2.declIm}
%\rulerCmdUse{rules2.declIm4}

%\rulerCmdUse{rules3.I1.match.base}
%\rulerCmdUse{rules3.I1.match.forall}
%\rulerCmdUse{rules3.I1.match.exists}
%\rulerCmdUse{rules3.I1.fit}
%\rulerCmdUse{rules3.I2.meet}
%\rulerCmdUse{rules3.I2.join}
%\rulerCmdUse{rules3.I2.tyAltTyElim}

%\rulerCmdUse{rules3.K.match.all}
%\rulerCmdUse{rules3.I2.match.meet}
%\rulerCmdUse{rules3.I2.match.join}
%\rulerCmdUse{rules3.I2.match.tyAlt}
%\rulerCmdUse{rules3.I2.match.tyBt}

---------------------

%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

