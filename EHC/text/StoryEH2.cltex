%%[eh2
The next version of EH drops the requirement that all value definitions
need to be accompanied by an explicit type signature.
For example, the example from the introduction:

\begin{code}
%%2srcfile(test/1-sig-fail.eh%%)
\end{code}
is accepted by this version of EH:
\begin{TT}
%%2ppfile(test/1-sig-fail.eh%%)
\end{TT}

The idea is that the type system implementation has an internal representation
for ``knowing it is a type, but not yet which one'' which can be replaced
by a more specific type if that becomes known.
The internal representation for a yet unknown type
is called a \IxAsDef{type variable}, similar to mutable variables
for (runtime) values.

The implementation attempts to gather as much information as possible
from a program
to reconstruct (or infer) types for type variables.
However, the types it can reconstruct are limited to those allowed by
the used type language, that is, basic types, tuples and functions.
All types are assumed to be monomorphic, that is, polymorphism is not yet allowed.
The next version of EH deals with polymorphism.

So
\begin{code}
%%2srcfile(test/2-demo1.eh%%)
\end{code}
will give
\begin{TT}
%%2ppfile(test/2-demo1.eh%%)
\end{TT}

If the use of |id| to define |v| would be omitted,
less information (namely the argument of |id| is an int) to infer a type for |id| is available.
Because no more specific type information for the argument (and result) of |id| could be retrieved 
the representation for ``not knowing which type'', that is, a type variable, is shown:

\begin{TT}
%%2ppinline(let id = \x -> x in id%%)
\end{TT}

On the other hand, if contradictory information in case of a monomorphic |id| applied to values of different type, we will obtain the following error:
\begin{TT}
%%2ppfile(test/2-id-intchar.eh%%)
\end{TT}

The next version of EH dealing with Haskell style polymorphism
(\chapterRef{ehc3}) accepts this program.

Partial type signatures are also allowed.
A partial type signature specifies a type only for a part, allowing
a co\"operation between the programmer who specifies what is (e.g.) already
known about a type signature and the type inferencer filling in the unspecified details.
For example:

\begin{code}
%%2srcfile(test/2-ty-wild.eh%%)
\end{code}

The type inferencer pretty prints the inferred type instead of the explicity type signature:

\begin{TT}
%%2ppfile(test/2-ty-wild.eh%%)
\end{TT}

The discussion of this feature is postponed until
\chapterRef{ehc-partial-sig}.

\subsection{Type variables}

In order to be able to represent yet unknown types the type language needs
\IxAsDef{type variable}s to represent this:

\begin{code}
sigma  =  Int | Char
       |  (sigma,...,sigma)
       |  sigma -> sigma
       |  tvarv
\end{code}

The corresponding type structure |Ty| needs to be extended with an alternative for a variable.
Note that the AG system allow us to define this additional type variant independent of the previous definition,
thus allowing an isolated explanation:

\chunkCmdUseMark{EHTyAbsSyn.2}

%if incl01TopicPP

The AG system allows us to separately describe the extension with a new variant as well
as describe separately the additionaly required attribution,
for example the pretty printing of the type

\chunkCmdUseMark{EHTyPretty.2}

%endif %% incl01TopicPP

A type variable is identified by a unique identifier, a |UID|:

\chunkCmdUseMark{EHCommon.2.UID.Base}
\chunkCmdUseMark{EHTy.2.TyVarId.Base}
%%[[hide impl.UID="UID basics"
\chunkCmdUseMark{EHCommon.2.UID.UIDL}
\chunkCmdUseMark{EHCommon.2.UID.Show}
\chunkCmdUseMark{EHTy.2.TyVarId.Rest}
%%]

The idea is to thread a counter as global variable through the AST,
incrementing it whenever a new unique value is required.
The implementation used throughout all EH compiler versions is more complex because
an |UID| actually is a hierarchy of counters, each level counting in the context of an outer level.
This is not discussed any further;
we will ignore this aspect and just assume a unique |UID| can be obtained.
Its use is visible whenever we need a so called fresh type variable in a type rule.
%if False
However, a bit of its implementation is visible in the pretty printed representation as a underscore separated
list of integer values,
occasionaly visible in sample output of the compiler.
%endif

\subsection{Constraints}

Although the typing rules at \figPageRef{rules3.K.expr.baseForEH1} still hold
we need to look at the meaning of |<=| (or |fitsIn|) in the presence of
type variables.
The idea here is that what is unknown may be replaced by that which is known.
For example, when the check |tvarv <= sigma| is encountered,
the easiest way to make |tvarv <= sigma| true
is to state that the (previously) unknown type |tvarv| equals |sigma|.
An alternative way to look at this is that |tvarv <= sigma| is true under the
constraint that |tvarv| equals |sigma|.

\subsubsection{Remembering and applying constraints}

As soon as we have determined that a type variable |tvarv| equals a type |sigma|,
we must remember this and propagate it to wherever |tvarv| is used.
We use constraints |Cnstr| to remember such a binding of a type variable to a type:

\begin{code}
Cnstr                       =  [tvarv :-> sigma]
\end{code}

A set of \IxAsDef{constraint}s |Cnstr| (appearing in its non pretty printed form as @Cnstr@ in the source text)
is a set of bindings for type variables,
represented as an association list:

\chunkCmdUseMark{EHCnstr.2.Cnstr.Base}
\chunkCmdUseMark{EHCnstr.2.Cnstr.emptyCnstr}
\chunkCmdUseMark{EHCnstr.2.Cnstr.cnstrTyUnit}

If |cnstrTyUnit| is used as an infix operator it is printed as |`cnstrTyUnit`| in
the same way as used in type rules.

Different strategies can be used to cope with constraints
\cite{heeren02hm-constr,sulzmann97constrained-type}.
Here
constraints |Cnstr| are used to replace all other
references to |tvarv| by |sigma|,
for this reason often named a \IxAsDef{substitution}.
In this version of EH the replacement of type variables
with newly types is done immediately after constraints are obtained as
to avoid finding a new and probably conflicting constraint for
a type variable.
Applying constraints means substituting type
variables with the bindings in
the constraints, hence the class
|Substitutable|
for those structures which have references to type
variables hidden inside and can replace, or substitute those type variables:

\chunkHideRef{impl.UID}
\chunkCmdUseMark{EHSubstitutable.2.Substitutable}

The operator | ||=>| applies constraints |Cnstr| to a
|Substitutable|.
Function |ftv| extracts the free type variable references as a set (implemented as a list) of
|TVarId|'s.

A |Cnstr| can be applied to a type:

\chunkCmdUseMark{EHSubstitutable.2.SubstitutableTy}

This is another place where we use the AG notation and the automatic propagation of values
as attributes throughout the type representation to make the description of the application of
a |Cnstr| to a |Ty| easier.
The function |tyAppCnstr| is defined in terms of the following AG.
The plumbing required to provide the value of attribute |repl| (|tvs|) available as
the result of Haskell function |tyAppCnstr| (and |tyFtv|)
has been omitted:

%%[[hide impl.tyFtvSubst="Haskell wrapping for tyFtv, tyAppCnstr; cnstrTyLookup"
\chunkCmdUseMark{EHTySubst.2.tyAppCnstr}
\chunkCmdUseMark{EHTyFtv.2.tyFtv}
\chunkCmdUseMark{EHCnstr.2.cnstrTyLookup}
%%]
\chunkCmdUseMark{EHTySubst.2.TySubst}
\chunkCmdUseMark{EHTyFtv.2.TyFtv}

%{

%format < 		= "{\langle}"
%format > 		= "{\rangle}"

\begin{AGFeature}{ag-self-attr}{Attribute of type SELF}
The type of an attribute of type |SELF| depends on the node in which a rule is defined for
the attribute.
The generated type of an attribute |<attr>| for |<node>| is equal to the generated Haskell datatype
of the same name |<node>|.
The AG compiler inserts code for building |<node>|'s from the |<attr>| of the children and other fields.
Insertion of this code can be overridden by providing a definition ourselves.
In this way a complete copy of the AST can be built as a Haskell value.
For example, via attribute |repl| a copy of the type is built which only differs (or, may differ) in the original
in the value for the type variable.
\end{AGFeature}

%if False
\begin{AGFeature}{ag-use-attr}{Attribute together with USE}
A synthesized attribute |<attr>| may be declared together with |USE {<op>} {<zero>}|.
The |<op>| and |<zero>| allow the insertion of copy rules which behave similar to Haskell's |foldr|.
The first piece of text |<op>| is used to combine the attribute values of two children by textually placing this text as an
operator between references to the attributes of the children.
If no child has an |<attr>|, the second piece of text |<zero>| is used as a default value for |<attr>|.
For example, @tvs USE {`union`} {[]}@ (appearing in pretty printed form as |tvs USE {`union`} {[]}|)
gathers bottom-up the free type variables of a type.
\end{AGFeature}
%endif

%}

The application of a |Cnstr| is straightforwardly lifted to lists:

\chunkCmdUseMark{EHSubstitutable.2.SubstitutableList}
%%[[hide impl.unions="unions"
\chunkCmdUseMark{EHCommon.2.unions}
%%]

A |Cnstr| can also be applied to another |Cnstr|:

\chunkCmdUseMark{EHSubstitutable.2.SubstitutableCnstr}

Substituting a substitution is non-commutative as constraints |s1| in |s1 ||=> s2| take precedence
over |s2|.
To make this even clearer all constraints for type variables in |s1| are removed from |s2|,
even though for a list implementation this would not be required.

\subsubsection{Computing constraints}

The only source of constraints is the check |fitsIn| which determines
whether one type can flow into another one.
The previous version of EH could only do one thing in case a type could not fit
in another: report an error.
Now,
if one of the types is unknown, which means that it is a type variable, we have the additional possibility of
returning a constraint on that type variable.
The implementation |fitsIn| of |<=| additionaly has to return constraints:

\savecolumns
\chunkCmdUseOnPrev{EHTyFitsInCommon.1.FIOut}{EHTyFitsInCommon.2.FIOut}
\restorecolumns
\chunkCmdUseMark{EHTyFitsInCommon.2.FIOut.empty}

Computation and proper combination of constraints necessitates
|fitsIn| to be rewritten in order to deal with type variables and constraints.
The rules describing the desired behavior are shown in
\figRef{rules3.C.match.all} and \figRef{rules3.C.fit}.
We show the changed part of the full implementation for this version.
The function |comp| deals with the proper combination of constraints for composite types:

%%[[hide impl.fitsinEH2="fitsIn for EH2"
\savecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.Base}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.Bind}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.app}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.BotCon}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.Var}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.AppRest}
%%]
\savecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.Base}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.Bind}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.app}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.2.fitsIn.Var}

\rulerCmdUse{rules3.C.match.all}
\rulerCmdUse{rules3.C.fit}

Although this version of the implementation of |fitsIn| resembles the previous one
it differs in the following aspects:

\begin{itemize}
\item
The datatype |FIOut| returned by |fitsIn| has an additional field |foCnstr| holding found constraints.
This requires constraints to be combined for composite types
like the |App| variant of |Ty|.
The constraints returned by |fitsIn| further participate in type inferencing.
\item
The function |bind| creates a binding for a type variable to a type.
The use of |bind| is shielded by |occurBind| which checks if the type variable for
which a binding is created does not occur free in the bound type too.
This is to prevent (e.g.) |a <= a -> a| to succeed.
This is because it is not clear if |a :-> a -> a| should be the resulting constraint
or |a :-> (a -> a) -> (a -> a)| or one of infinitely many other possible solutions.
A so called \IxAsDef{infinite type}
like this is inhibited by the so called \IxAsDef{occurs check}.
\item
An application |App| recursively fits its components with components of another |App|.
The constraints from the first fit |ffo| are applied immediately to the following component
before fitting that one.
This is to prevent |a -> a <= Int -> Char| from finding two conflicting
constraints
|[a :-> Int,a :-> Char]| instead of properly reporting an error.
\end{itemize}

\subsection{Type inference for expressions (Expr)}

Constraints are used to make knowledge found about previously unknown
types explicit.
The typing rules in \figRef{rules3.K.expr.baseForEH1}
and \figRef{rules3.K.decl.base}
in principle do not need to be changed.
The only reason to adapt some of the rules to the variant in
\figRef{rules3.C.expr.baseForEH2}
is to clarify the way constraints are used.

%\rulerCmdUse{rules.expr2}
\rulerCmdUse{rules3.C.expr.baseForEH2}
\rulerCmdUse{rules3.C.decl.base}

The type rules in \figRef{rules3.C.expr.baseForEH2} enforce an order in which
checking and inferring types has to be done.
Constraints are threaded through the type rules.
The flow of these constraints defines the computation order.
In AG the threading of constraints is expressed by the following declaration of
|tyCnstr|:

\chunkCmdUseMark{EHInferExpr.2.tyCnstr}

For a type rule the (already) known constraints |Cnstrk| correspond to the use of |lhs.tyCnstr| and the result constraints
(like |Cnstra| for \ruleRef{e.app}) are assigned to |lhs.tyCnstr|.
For \ruleRef{e.app} this translates to the following implementation:

\chunkCmdUseMark{EHRulerRules.2.expr.e.app}

The freshness of a type variable is guaranteed by threading a seed |gUniq|
for unique values (|UID|'s)
through the AST:

\chunkCmdUseMark{EHUniq.2.gUniq}

%%[[hide impl.UID="UID"
\chunkCmdUseMark{EHCommon.2.UID.Base}
\chunkCmdUseMark{EHCommon.2.UID.UIDL}
\chunkCmdUseMark{EHCommon.2.UID.Show}
\chunkCmdUseMark{EHCommon.2.UID.mkNewLevUID}
%%]
When a unique value is needed we use |gUniq|'s current value as the `fresh' UID,
and pass the adapted seed
onwards to the first child which requires unique values as well.



%if False
\begin{AGFeature}{ag-redef-rule}{Redefining an attribute value}
Normally a value for an attribute may be associated with an attribute only once,
using |=| in a rule.
It is an error if multiple rules for an attribute are present.
If |:=| is used instead, any previous definition is overridden and no error message is generated.
In this context previous means ``textually occurring earlier''.
Because the AG system's flexibility finds its origin in the independence of textual locations of
declarations and definitions, |:=| should be used with care.
For \thispaper\ the order in which redefinitions appear is the same as their textual appearance
in \thispaper, which again is the same as the sequence of versions of EH.
\end{AGFeature}

This definition builds on top of the previous version by
redefining some attributes (indicated by |:=| instead of |=|).
If this happens a reference to the location (in \thispaper) of the code on top of which
the new code is added can be found\footnote{This is not an ideal solution to display combined fragments.
A special purpose editor would probably do a better
job of browsing textually separated but logically related pieces of code.}.
%endif

%if False
The flow of constraints is made explicit as they are passed through the rules,
from the context (left of |:-|) to a result (right of |~>|).
We feel this does not benefit clarity, even though it is correct.
It is our opinion that
typing rules serve their purpose best by providing a basis for proof as well
as understanding and discussion.
An AG description serves its purpose best by showing how it really is implemented.
Used in tandem they strengthen each other.
%endif

Our type rules and their corresponding
AG description preserve the following invariant:
\begin{itemize}
\item
A resulting type has all known constraints applied to it, here |ty|.
\end{itemize}

This invariant is not preserved for |knTy| and |valGam|, which also can contain type variables.
The application of constraints to these attributes is postponed until the following places (in the AST or other code):

\begin{itemize}
\item
The value
is used in a setting which may yield new constraints, that is, it is used by |<= =@= fitsIn|.
\item
The value is used to return a type of an expression, for example in \ruleRef{e.var}.
We apply known constraints to the type extracted from |Gamma =@= valGam|.
\end{itemize}

\paragraph{Variable occurrences |Var|.}
This is illustrated by the AG code for \ruleRef{e.var} in which |lhs.tyCnstr| is applied to both the expected type |knTy|
and the type |ty_g_| extracted from |valGam|:

\chunkCmdUseMark{EHRulerRules.2.expr.e.var}

Newly found constraints (from |<= =@= fitsIn|) are combined with the already known constraints (|lhs.tyCnstr|).

\paragraph{Tuples.}
The construction of tuples is handled by the combination of \ruleRef{e.con} and \ruleRef{e.app}.
It is now the responsibility of \ruleRef{e.con} to return the proper function type for constructing a tuple.
In the previous version we could use the expected type, which was guaranteed to be available in |knTy|.
This information is no longer available, so we use the arity |n| encoded in the name `|,n|' of the constructor
to compute the constructor function type.
This function is polymorphic,
this is the only place where we need to deal with polymorphism for this version of EH.
We compute the function type using fresh type variables:

\chunkHideRef{impl.SemAppFull}
\chunkCmdUseMark{EHRulerRules.2.expr.e.con}

%%[[hide impl.eh2RemRules="EH2, AG for \ruleRef{e.int}, \ruleRef{e.lam} and \ruleRef{e.ann}"
\chunkCmdUseMark{EHRulerRules.2.expr.e.int}
\chunkCmdUseMark{EHRulerRules.2.expr.e.lam}
\chunkCmdUseMark{EHRulerRules.2.expr.e.ann}
%%]
The remaining rules follow the same strategy of applying constraints to types,
matching types and propagating the resulting constraints.
We omit their implementation, except for \ruleRef{e.let} which we discuss later in \thischapt.

Some observations are in place:
\begin{itemize}
\item
The main difference with the previous implementation is the use
of type variables to represent unknown knowledge.
Previously |ANY| was used for that purpose, for example,
the \ruleRef{e-lam2} and its implementation show that fresh
type variables |tvari| in |tvar1 -> tvar2| are used instead
of |ANY -> ANY| to enforce a |.. -> ..| structure.
If |ANY| still would be used, for example in:
\begin{code}
let  id = \x -> x
in   id 3
\end{code}
the conclusion would be drawn that |id :: ANY -> ANY|,
whereas |id :: tvarv -> tvarv| would later on have bound |tvarv :-> Int| (at the application |id 3|).
So, |ANY| represents ``unknown knowledge'',
a type variable |tvarv| represents ``not yet known knowledge''
to which the inferencing process later has to refer to make it ``known knowledge''.
\item
Type variables are introduced under the condition that they are
\Ix{fresh type variable}``fresh''.
For a typing rule this means that these type
variables are not in use elsewhere,
often more concretely specified with a condition |tvarv `notElem` ftv(Gamma)|.
%Freshness in the implementation is implemented via unique identifiers UID.
\end{itemize}

\subsection{Type inference for pattern expressions (PatExpr)}

In the previous version of EH we were only interested in bindings for
identifiers in a pattern.
The type of a pattern was already known via a corresponding type signature.
For this version this is no longer the case.
We now have to use the occurrence of an identifier in a pattern or expression
to infer type information about the identifier.
The structure of a pattern
reveals already some type structure.
Hence we compute types for patterns too and use this type as the known type
if no type signature is available (\figRef{rules3.C.patexpr.base}).
Again, constraints are threaded through the pattern to accumulate information about type variables.

%\rulerCmdUse{rules.pat2}
\rulerCmdUse{rules3.C.patexpr.base}

Computation of the type of a pattern is similar to and yet more straightforward than
for expressions.
The \ruleRef{p.var} from \figRef{rules3.C.patexpr.base} binds the identifier
to the known type and if no such known type is available it invents a fresh one,
by means of |tyEnsureNonAny|:

%%[[hide impl.pIntCharVaras2="\ruleRef{p.varas}, \ruleRef{p.int}, \ruleRef{p.char}, tyEnsureNonAny"
\chunkCmdUseMark{EHTy.2.tyEnsureNonAny}
\chunkCmdUseMark{EHRulerRules.2.patexpr.p.varas}
\chunkCmdUseMark{EHRulerRules.2.patexpr.p.int}
\chunkCmdUseMark{EHRulerRules.2.patexpr.p.char}
%%]
\chunkCmdUseMark{EHRulerRules.2.patexpr.p.var}

For tuples we again make use of the fact that the |Con| alternative will always
represent a tuple.
%if not incl05
When datatypes are introduced (not part of \thispaper) this will no longer be the case.
%else
Starting at \chapterRef{ehc5}, in which datatypes are introduced,
and onwards this will no longer be the case.
%endif
We already make the required \ruleRef{p.con} more general
than is required here,
in preparation for datatypes.

A pattern can be represented by a \IxAsDef{pattern function} |sigma -> (sigma1,...)|.
Conceptually this function takes the value (of type |sigma|) to be dissected by the pattern into its constituents,
which can always be represented by a tuple |(sigma1,...)|.
For now, because we have only tuples to dissect, the
function returned by the |Con| alternative is just the identity
on tuples of the correct size:

\chunkCmdUseMark{EHRulerRules.2.patexpr.p.con}

At the top of a pattern, in \ruleRef{p.apptop}, this function |sigmapf =@= patFunTy| is dissected into
the argument |sigmaa =@= ty_a_| and
result |sigma_r =@= ty_r_|:

\chunkCmdUseMark{EHRulerRules.2.patexpr.p.apptop}

The argument |sigmaa|, representing the value ``going in the pattern'', is matched with the expected type of the pattern;
the result |sigma_r| is dissected in \ruleRef{p.app} as in the previous EH version:

\chunkCmdUseMark{EHRulerRules.2.patexpr.p.app}

The pattern function type |sigmapf =@= patFunTy| is constructed from fresh type variables.
Each occurrence of a tuple pattern deals with different unknown types; hence fresh type variables are needed.
The availability of polymorphism in later versions of EH allows us to describe this in a more general way.

The careful reader may have observed that the direction of |<=|
for fitting actual (synthesized, bottom-up) and known type (inherited, top-down)
is the opposite of the direction used for expressions.
This is a result of a difference in the meaning of an expression and a pattern.
An expression builds a value from bottom to top as seen in the context of an abstract syntax
tree.
A pattern dissects a value from top to bottom.
The flow of data is opposite, hence the direction of |<=| too.

\subsection{Declarations (Let, Decl)}

Again, at the level of declarations all is tied together
(\figRef{rules3.C.expr.baseForEH2}
and \figRef{rules3.C.decl.base}).
We can no longer assume that type signatures are specified for all value expressions.
The basic strategy for declarations (see \secPageRef{eh1-let-strategy}) must be changed as follows:

\begin{itemize}
\item
Parallel to |patValGam| and |valGam| we need to gather information about introduced type variables.
|Cnstrp =@= patTyCnstr| gathers information about the types of type variables for identifiers introduced as part of pattern expressions;
|Cnstr =@= tyCnstr| gathers information from the use of those identifiers in expressions.
\item
If a type signature is defined for the toplevel identifier of a pattern in a value declaration
(\ruleRef{d.val}) we use that type as the known type for both pattern and expression.
Otherwise, a fresh type variable is used for the pattern and the pattern type for the value expression.
\item
The pattern constraints |patTyCnstr| is threaded independently through all declarations, only
to be used as the starting point for |tyCnstr| in \ruleRef{e.let}.
\end{itemize}

Here we omit the corresponding AG code: it follows the type rules faithfully.
%%[[hide impl.declEH2
\chunkCmdUseMark{EHInfer.2.tyCnstr}
\chunkCmdUseMark{EHRulerRules.2.decl.d.val}
\chunkCmdUseMark{EHRulerRules.2.expr.e.let}
%%]


%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

