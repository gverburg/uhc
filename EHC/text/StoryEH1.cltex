%%[eh1
In this section we build the first version of our series of compilers:
the typed |lambda|-calculus packaged in Haskell syntax in which
all values need to explicitly be given a type.
The compiler checks if the specified types are in agreement with actual
value definitions.
For example

\begin{code}
%%1srcfile(test/1-demo2.eh%%)
\end{code}

is accepted, whereas

\begin{code}
%%1srcfile(test/1-all-fail2.eh%%)
\end{code}
produces a pretty printed version of the erroneous program,
annotated with errors.
Type errors are reported in terms of a failed 'fit' (@<=@) which is our mechanism
for matching, or fitting, two types:
\begin{TT}
%%1ppfile(test/1-all-fail2.eh%%)
\end{TT}

Type signatures have to be specified for identifiers bound in a |let| expression.
For |lambda|-expressions the type of the parameter can be extracted from
these type signatures unless a |lambda|-expression occurs at the position of an applied function.
In that case a type signature for the |lambda|-expression is required in the expression itself.
This program will not typecheck because this EH version does not allow polymorphic types in general and
on higher ranked (that is, parameter) positions in particular.

\begin{code}
%%1srcfile(test/1-polylam1.eh%%)
\end{code}

%if incl01TopicPP

Although the implementation of a type system will be the main focus of this section,
any such implementation
lives in co-existence with the complete environment/framework needed to build a compiler.
Therefore, aspects conveniently omitted from subsequent sections \cite{dijkstra04thag-part1}, like parsing, connection with
the abstract syntax, the use of the AG system and error reporting will also be
touched upon here.

First we start with the EH language elements implemented and how they correspond to
abstract syntax, followed by the translation done by parsing from concrete syntax to abstract syntax.
Our first aspect described using the AG notation will be a pretty printed representation of the abstract syntax tree,
reflecting the original input sufficiently close.
The second aspect concerns type checking, which involves the introduction of
several attributes for computing a type 
associated with parts of the abstract syntax tree.

%else %% incl01TopicPP

The implementation of a type system will be the main focus of this and following sections.
As a consequence the full environment/framework needed to build a compiler will not be discussed.
This means that error reporting, generation of a pretty printed annotated output,
parsing and the compiler driver are not described.

We start with the definition of the AST and how it relates to concrete syntax,
followed by the introduction of several attributes required for the implementation
of the type system.

%endif %% incl01TopicPP

\subsection{Concrete and abstract syntax}
The \IxAsDef{concrete syntax} of a (programming) language describes the structure of acceptable
sentences for that language, or more down to earth, it describes what a compiler for that language
accepts with respect to the textual structure.
On the other hand, \IxAsDef{abstract syntax} describes the structure used by the compiler itself for
analysis and code generation.
Translation from the more user friendly concrete syntax to the machine friendly abstract syntax is done by a
parser; from the abstract to the concrete representation is done by a pretty printer.

Let us focus our attention first on the abstract syntax for EH1, in particular the part
defining the structure for expressions (the remaining syntax can be found in \figRef{abs-syn-eh1}).
%if not incl00TopicAGPrimer
A |DATA| definition in the AG (Attribute Grammar) language corresponds closely to a Haskell |data| definition,
and defines a part of the abstract syntax.
%endif

\chunkCmdUseMark{EHAbsSyn.1.Expr}


%if incl00TopicAGPrimer
Integer constants are represented by |IConst|, lowercase (uppercase) identifier occurrences by |Var| (|Con|),
an |App| represents the application of a function to its argument, |Lam| and |Let| represent lambda expressions and
let expressions.
%else
The notation of the AG system is used to define an expression |Expr|
to be a range of alternatives (or productions);
for example a single variable |Var| represents the occurrence of an identifier
(referring to a value introduced by
a declaration),
or |App| represents the application of a function to an argument.
%endif

%{
%format < 		= "{\langle}"
%format > 		= "{\rangle}"
\begin{AGFeature}{ag-type-syn}{Type synonyms (for lists)}
The AG notation allows type synomyms for one special case, AG's equivalent
of a list (e.g |Decls| in \figRef{abs-syn-eh1}).
It is an often occurring idiom to encode a list of nodes, say |DATA L| with elements |<node>| as:
\begin{code}
DATA L
  | Cons  hd  :  <node>
          tl  :  L
  | Nil
\end{code}
AG allows the following notation as a shorthand:
\begin{code}
TYPE L = [<node>]
\end{code}
\end{AGFeature}
%}

The EH following fragment (which is incorrect for this version of because type signatures are missing):

\begin{code}
%%1srcfile(afp-eh/02.eh%%)
\end{code}

is represented by the following piece of abstract syntax tree:

\begin{TT}
%%1astfile(afp-eh/02.eh%%)
\end{TT}

The example also demonstrates the use of patterns, which is the same as in Haskell,
except for a simplifying restriction which
does not allow a type signature for the elements of a tuple.

\begin{CodeFigure}{Abstract syntax for EH (without Expr)}{abs-syn-eh1}
\savecolumns
\chunkCmdUse{EHAbsSyn.1.AGItf}
\restorecolumns
\chunkCmdUse{EHAbsSyn.1.Decl}
\restorecolumns
\chunkCmdUse{EHAbsSyn.1.PatExpr}
\restorecolumns
\chunkCmdUse{EHAbsSyn.1.AllPatExpr}
\restorecolumns
\chunkCmdUse{EHAbsSyn.1.TyExpr}
\restorecolumns
\chunkCmdUse{EHAbsSyn.1.AllTyExpr}
\restorecolumns
\chunkCmdUse{EHAbsSyn.1.AllExpr}
\restorecolumns
\chunkCmdUse{EHAbsSyn.1.AllNT}
\end{CodeFigure}

Looking at this example and the rest of the abstract syntax in \figRef{abs-syn-eh1} we can make several
observations of what one is allowed to write in EH and what can be expected from the implementation:
\begin{itemize}
\item
There is a striking similarity between the structure of expressions |Expr|
and patterns |PatExpr| (and as we will see later type expressions |TyExpr|):
they all contain |App| and |Con| variants.
This similarity will sometimes be exploited to factor out common code, and, if
factoring out cannot be done, leads to similarities between pieces of code.
This is the case with the construction of application-like structures
(by the parser and the type checker) and pretty printing%
%if not incl01TopicPP
 (not included in \thispaper)%
%endif
, which is quite similar for the different kinds of
constructs.
%if not incl00TopicAGPrimer
\item
In the abstract syntax an alternative belongs to a nonterminal (or |DATA|), for
example ``|App| of |Expr|''.
On request the AG system generates corresponding Haskell data types with
the same name as the |DATA| defined, alternatives are mapped to constructors
with the name of the |DATA| combined with the name of the alternative,
separated by an underscore `|_|' as in |Expr_App|.
If necessary, the same convention will be used when referring to an
alternative\footnote{In this way we overcome a problem in Haskell,
where it is required that all constructors for all data types to be different.}.
%endif
\item
Type signatures (|Decl_TySig|) and value definitions (|Decl_Val|) may be freely mixed.
However, type signatures and value definitions for the same identifier are still related.
%if False
For this version of EH, each identifier introduced by means of a value definition must
have a corresponding type signature specification.
%endif
\item
Because of the textual decoupling of value definitions and type signatures,
a type signature may specify the type for an identifier occurring inside a pattern:
\begin{code}
let  a      ::  Int
     (a,b)  =   (3,4)
in   ...
\end{code}
Currently we do not allow this, but the following however is:
\begin{code}
let  ab        ::  (Int,Int)
     ab@(a,b)  =   (3,4)
in   ...
\end{code}
because the specified type for |ab| corresponds to the top of a pattern of a value definition.
\item
In EH composite values are created by tupling, denoted by |(..,..)|.
The same notation is also used for patterns (for unpacking a composite value) and
types (describing the structure of the composite).
In all these cases the corresponding AST consists of a |Con| applied to the elements
of the tuple.
For example, the value |(2,3)| corresponds to
\begin{code}
Expr_App (Expr_App (Expr_Con ",2") (Expr_IConst 2)) (Expr_IConst 3)
\end{code}
\item
For now there is only one value constructor: for tuples.
The EH constructor for tuples also is the one which needs special treatment because it
actually stands for a infinite family of constructors.
This can be seen in the encoding of the name of the constructor which is composed of
a |","| together with the arity of the constructor.
For example, the expression |(3,4)| is encoded as an application |App| of |Con ",2"|
to the two |Int| arguments: (,2 3 4).
In our examples we will follow the Haskell convention, in which we write (,) instead of `,2'.
By using this encoding we also get the unit type |()| as it is encoded
by the name |",0"|.
\item
The naming convention for tuples and other naming conventions are available through the following abstraction
of Haskell names |HsName|.

\chunkCmdUseMark{EHCommon.1.HsName.type}
\chunkCmdUseMark{EHCommon.1.HsName.Base.itf}
%%[[hide impl.hsnImpl="Implementation for HsName functions"
\chunkCmdUseMark{EHCommon.1.HsName.Base.impl}
%%]

\item
Each application is wrapped on top with an |AppTop|.
This has no meaning in itself but
%if incl01TopicPP
as we will see in section~\ref{sec-pretty1}
%else
it
%endif
simplifies the pretty printing of expressions.
We need |AppTop| for patterns and later EH versions, but for the rest it can be ignored.
\item
The location of parentheses around an expression is remembered by a |Parens| alternative.
We need this for the reconstruction of the parentheses in the input.
\item
|AGItf| is the top of a complete abstract syntax tree.
%if incl00TopicAGPrimer
As noted in the AG primer this is the place where interfacing with the `outside' Haskell world takes place.
%else
The top of an abstract syntax tree is the place where interfacing
(hence the convention |Itf|)
with the outside, that is, the Haskell world takes place.
At |AGItf| 
  \begin{itemize}
  \item Initialization of inherited attributes takes place.
  \item Synthesized attributes are routed back into the tree as inherited attributes.
  \item Synthesized attributes are passed to the outside, to the Haskell world.
  \end{itemize}
%endif
It is a convention in \thispaper\ to give all nonterminals in the abstract syntax a
name with |AGItf| in it,
if it plays a similar role (for this and more naming conventions see \appRef{appx-ag-hs-namingconventions}).
%if not incl00TopicAGPrimer
\item
The remaining alternatives for the non-terminal |Expr|
stand for their EH counterparts, for example |IConst| for an |Int| constant,
and |Lam| for a |lambda|-expression.
\item
In the AG system sets of nonterminals may be given a name through the |SET| directive.
For example, |AllNT| (All NonTerminals) is the name for all nonterminals occurring in the abstract syntax.
This provides an indirection when referring to nonterminals in attribute definitions (|ATTR|).
Later compiler versions can change the definition for |AllNT| without the need to
also modify the list of nonterminals for which an attribute definition |ATTR| is
declared.
%endif
\end{itemize}

%if incl01TopicParsing
%%@parsing
%endif %% incl01TopicParsing

%if incl01TopicPP

\subsection{Pretty printing: from abstract to concrete}
\label{sec-pretty1}
The first aspect we define is |pp| that constructs the pretty printed representation
for the abstract syntax tree, starting with the definition for |Expr|:

\savecolumns
\chunkCmdUseMark{EHPretty.1.Base.ExprSimple}
\restorecolumns
\chunkCmdUseMark{EHPretty.1.ExprExtra}
\restorecolumns
\chunkCmdUseMark{EHPretty.1.Base.ExprComplex}

The |pp| attribute is defined (via |ATTR|)
as a synthesized (because it is preceded by two | || | symbols) attribute for all nonterminals of the abstract syntax.
This output attribute will also be passed to ``the outside world'' (because it is also defined for |AGItf|).
If a rule for |pp| for an alternative of a nonterminal is missing, the default definition
is based on |USE| which provides a default value for alternatives without nonterminals as children (here: |empty|)
and a function used to compose new values based on the values of the children (here: |>-<|).

\begin{CodeFigure}{Pretty printing combinators}{pretty-printing-combinators}
\begin{center}
\begin{tabular}{ll}
Combinator & Result
\\ \hline
|p1 >||< p2| & |p1| besides |p2|, |p2| at the right \\
|p1 `ppBesideSp` p2| & same as |>||<| but with an additional space in between \\
|p1 >-< p2| & |p1| above |p2| \\
|pp_parens p| & |p| inside parentheses \\
|text s| & string |s| as |PP_Doc| \\
|pp x| & pretty print |x| (assuming instance |PP x|) resulting in a |PP_Doc| \\
\end{tabular}
\end{center}
\end{CodeFigure}

The attribute |pp| is defined as a local (to a production alternative)
attribute (by means of the |loc| keyword) so it can be referred to by
other attribute computations.
The copy rules of the AG system automatically insert code to copy the local attribute to
the |pp| synthesized attribute; the definition |lhs.pp = @pp| is inserted by the AG system.

Attributes can be referred to using the notation |@nt.attr|.
|nt| can refer to a child node in the syntax tree (e.g. |decls|) or to
a parent node (by means of keyword |lhs|).
If |nt| is omitted as in |@attr| the |attr| refers to a locally defined attribute (e.g. |lValGam|)
or a value embedded in a node (e.g. |nm|).

The computation of the |pp| attribute is straightforward in the sense that
only a few basic pretty printing combinators are needed
(see \cite{uust04www} and \figRef{pretty-printing-combinators}).
The additional complexity arises from
the encoding for applications.
The problem is that
straightforward printing prints |(2,3)| as |,2 2 3|.
This is solved at the
|AppTop| alternative by gathering all arguments (here: |[2,3]|)
for a function (here: tuple constructor |,2|, or |(,)|) into |appArgPPL|:

\chunkCmdUseMark{EHPretty.1.Expr.ConNm}

The attributes |appArgPPL| and |appFunNm| only are relevant for the |Con| and |App| alternatives.
For the remaining alternatives a default definition is provided.
The AG system allows to refer to all alternatives by means of a set notation where `|*|' means all alternatives and
`|-|' means set subtraction.
Juxtapositioning of alternatives means set union.
Hence |* - Con App| stands for all alternatives except |Con| and |App|.
The use of this notation is convenient as it relieves us from the obligation to specify default values for
new alternatives that will be added in the future.

The |appArgPPL| and the two other required attributes |appFunNm| for the name and
|appFunPP| for the pretty printing of the applied function
are all used to gather information from deeper within the syntax tree
for further processing higher up in the tree by |ppAppTop|:

\chunkCmdUseMark{EHCommon.1.PP.ppAppTop}
\chunkCmdUseMark{EHCommon.1.PP.NeededByExpr}

The value for |pp| defined in |App| is not directly used for the pretty printed output
as result of the definition of |pp| at |AppTop|.
However, because the |pp| defined in |App| more closely resembles the structure of
the syntax tree it is used for producing error messages
%if incl01TopicErr
(see section~\ref{sec-error1})%
%endif
.

We will not look into the pretty printing for
patterns and type expressions because it is almost an exact replica of the code for expressions.
The remainder of the |pp| related attribute computations is also omitted as
they are rather straightforward uses of |>||<| and |>-<|.

%endif %% incl01TopicPP

\subsection{Types}

We will now turn our attention to the way the type system is incorporated into EH1.
We focus on the pragmatics of the implementation and less on the corresponding type theory.

\TBD{better intro here}

\subsubsection{What is a type}

Compiler builders consider a \IxAsDef{type} to be a description of the interpretation of a value
whereas a value is to be understood as a bitpattern.
This means that machine operations such as integer addition,
are only applied to patterns that are to be interpreted as integers.
More generally, we want to prevent unintended interpretations of bitpatterns,
which might
likely lead to the crash of a program.

The flow of values, that is, the copying between memory locations,
through the execution of a program may
only be such that a copy is allowed only if the corresponding types
relate to each other in some proper fashion.
A compiler uses a type system to analyse this flow and to make sure that built-in functions are only
applied to patterns that they are intended to work on.
The idea is
that if a compiler cannot find an erroneous flow of values, with the notion of
erroneous defined by the type system, the program is guaranteed not to crash
because of unintended use of bitpatterns.

\def\EHCOneTyLangA{%
\begin{code}
sigma  =  Int | Char
       |  (sigma,...,sigma)
       |  sigma -> sigma
\end{code}
}
\def\EHCOneTyLangB{%
\begin{code}
sigma  =  Int | Char | ^^ -> ^^ | ^^ , ^^ | ^^ ,, ^^ | ^^ ...
       |  sigma ^^ sigma
\end{code}
}

In this section we start by introducing a type language in a more formal setting 
as well as a more practical setting.
The formal setting uses
typing rules to specify the static semantics of EH whereas in the practical setting the AG system is used, providing an implementation.
In the following section we discuss the typing rules, the mechanism for enforcing the equality of types (called \IxAsDef{fitting})
and the checking itself.
Types will be introduced informally,
instead of taking a more formal approach
\cite{fp:type-theory:func-prog,wadler89theorems-for-free,typing:types-prog-lang:pierce,ipt:theory-of-objects}.

Types are described by a type language.
The type language for EH1
allows some basic types and two forms of composite types, functions and tuples,
and is described by the following grammar:
\EHCOneTyLangA
The following definition however is closer to the one used in our implementation:

\EHCOneTyLangB

The latter definition also introduces the possibility of describing types like |Int Int|.
We nevertheless use this one since it is 
used in the implementation of later versions
of EH where it will prove useful in expressing the application of type constructors to types.
Here we just have to make sure no types like |Int Int| will be created;
in a (omitted) later version of EH we perform kind inferencing/checking to prevent the creation of such types from showing up.
We use several convenience functions for the construction of types,
but postpone their discussion until they are needed.

The corresponding encoding using AG notation differs in the
presence of an |Any| type, also denoted by |ANY|.
In \secRef{sec-check-type} we will say more about this.
It is used to smoothen the type checking by (e.g.) limiting the propagation of
erroneous types:

\savecolumns
\chunkCmdUseMark{EHTyAbsSyn.1.TyAGItf}
\restorecolumns
\chunkCmdUseMark{EHTyAbsSyn.1.Ty}

The formal system and implementation of this system use different symbols to refer to the same concept.
For example, |Any| in the implementation is the same as |ANY| in the typing rules.
Not always is such a similarity pointed out explicitly but instead a notation |name1 =@= name2|
is used to simultaneously refer to both symbols |name1| and |name2|,
for example |Any =@= ANY|.
The notation also implies that the identifiers and symbols separated by '|=@=|' are referring
to the same concept.

The definition of |Ty| will be used in both the Haskell world and the AG world.
In Haskell we use the corresponding |data| type generated by the AG compiler,
for example in the derived type |TyL|:

\chunkCmdUseMark{EHTy.1.TyL}

The data type is used to construct type representations.
In the AG world we define computations over the type structure in terms of attributes.
The corresponding semantic functions generated by the AG system can then be applied to Haskell values.

%if incl01TopicPP

\subsubsection{Type pretty printing}
As before, |TyAGItf| is the place where interfacing with the Haskell world takes place.
The AG system also introduces proper data types to be used in the Haskell world and the following
data type is generated by the AG system:
\begin{TT}
-- Ty ----------------------------
data Ty = Ty_Any 
        | Ty_App (Ty) (Ty)
        | Ty_Con (String)
        deriving ( Eq,Show)
-- TyAGItf -----------------------
data TyAGItf = TyAGItf_AGItf (Ty)
             deriving ( Eq,Show)
\end{TT}
This allows us to create types as plain Haskell values, and to define functionality
in the AG world which uses types represented by Haskell data type values.
As a demonstration of how this is done, pretty printing is used once again.
Using the same design and tools as used for pretty printing |Expr| (and pattern/type expressions)
abstract syntax we can define pretty printing for a type:

\chunkCmdUseMark{EHTyPretty.1.pp}

Previously, |AppTop| was used to remember where in the abstract syntax tree (of EH) the
top of an application could be found.
Here we need an additional local attribute |isSpineRoot| holding the boolean value telling us whether we are
at the top of the spine of |App|'s.
It uses its position |appSpinePos| in the spine to determine if this is the case:

\savecolumns
\chunkCmdUseMark{EHTyCommonAG.1.ConNm}
\restorecolumns
\chunkCmdUseMark{EHTyCommonAG.1.ConNm.ConApp}
\restorecolumns
\chunkCmdUseMark{EHTyCommonAG.1.ConNm.Ty}
\chunkCmdUseMark{EHTyCommonAG.1.appSpinePos}

\paragraph{Parenthesis.}
Because no explicit |Parens| alternative is present in the type structure,
appropriate places to insert parentheses have to be computed.
This is solved by passing the need for parentheses
as contextual information using the inherited attribute |parNeed|.
However, as this part is not necessary for understanding
the implementation of a type system its reading can safely be
skipped.

\chunkCmdUseMark{EHTyPretty.1.ParNeed}

And supporting Haskell definitions:

\chunkCmdUseMark{EHCommon.1.ParNeed}

The idea here is that a |Ty| and its context together determine whether parentheses are needed.
This is encoded in |ParNeed|, the contextual need is passed to |ppParNeed| as the parameter |globNeed|
and the local need as |locNeed|.
In |ppParNeed| parentheses are added if the contextual need is higher than the local need.
For example, at |AppTop| the printing of a tuple always adds parentheses via function |ppAppTop|,
so no additional parentheses are needed.
This is reflected in the result of |parNeedApp| which gives us the following information back in the order of the elements of
the returned tuple:
\begin{itemize}
\item The local need for parentheses, that is `here' in the alternative.
\item The need for parentheses for the arguments of a type.
\end{itemize}

The structure of the solution, that is, gather information bottom to top (e.g. |appArgPPL|) and use it higher up in the tree,
is a recurring pattern.
The other way around, for example |parNeedL| distributing the need for parentheses over the
arguments of an application, is also a recurring pattern.

\paragraph{Tying in with the Haskell world.}
What remains, is the way the functionality is made available to the Haskell world:

\chunkCmdUseMark{EHTyPretty.1.ppTy}

To make this work, we need to tell the AG system to generate a wrapper function
and datatypes |Inh_TyAGItf| and |Syn_TyAGItf| with selector functions for
defined attributes to pass inherited and synthesized attributes respectively:
\TBD{Update AG manual, pg 21 w.r.t. wrap}

\chunkCmdUseMark{EHTyPretty.1.WRAPPER}

In the code that is generated by the AG system
inherited attributes become function arguments and
synthesized attributes components of a cartesian
product; in both cases they are identified by position.
This makes interfacing to the Haskell world cumbersome.
In order to overcome these problems so-called wrapper
functions can be generated, which make it possible to
access result e.g. by using functions generated
according to a fixed naming convention. An example of
such a fuction is |pp_Syn_TyAGItf|, which, when applied to |t|,
accesses the
synthesized |pp| attribute at an attributed non-terminal
|t| of type |TyAGItf|.

%endif %% incl01TopicPP


\subsection{Checking types}
\label{sec-check-type}
The type system of a programming language is described by typing rules.
A \IxAsDef{typing rule}
\begin{itemize}
\item
Relates language constructs to types.
\item
Constrains the types of these language constructs.
\end{itemize}

\subsubsection{Type rules}
We start with a simplified set of equational type rules (\figRef{rules3.E.expr.baseForEH1}).
The full algorithmic version (\figRef{rules3.K.expr.baseForEH1}) of \thischapt\ differs in
the explicit handling of known type information, the use of patterns and uncoupling of type signatures
and corresponding value declarations.

For example, the following is the typing rule
(taken from \figRef{rules3.E.expr.baseForEH1})
for function application:
\[
\rulerCmdUse{rules3.E.expr.baseForEH1.e.app}
\]

It states that an application of |e1| to |e2| has type |sigma|
provided that the argument has type |sigmaa| and
the function has a type |sigmaa -> sigma|.

\rulerCmdUse{rules3.E.expr.baseForEH1}
\rulerCmdUse{rules3.E.decl.base}
%%[[hide rules.tyExprEH1="Type rules for type expressions"
\rulerCmdUse{rules3.E.tyexpr.base}
%%]

All rules we will use are of the form
\[
\ehinfruleB{ast.rulename}{view}{prerequisite_1 \\ prerequisite_2 \\ ...}{consequence}
\]
with the meaning that if all $prerequisite_i$ can be proven we may conclude the $consequence$.
By convention rule names are typeset in \textsc{small caps} font,
and have the form \textsc{ast.rulename} where \textsc{ast} refers to the language element
about which the rules states something (here expressions: \textsc{e}).
The suffix |view|, typeset in |italic|, indicates the view on the rule (here the equational view: |E|).
We usually omit the view when referring to a rule.

A |prerequisite| can take the form of any logical predicate or has 
a more structured form, usually called a \IxAsDef{judgement}:
\[
|context |\stackrel{|judgetype|}{|:-|}| construct : property ~> more ^^ results |
\]
The part ``|~> more ^^ results|'' needs not always be present if there are no more results for
a judgement.
The division between ``|property|'' and ``|more ^^ results|'' is somewhat arbitrary as both are results and
properties.
However, we consider ``|property|'' to be the most important result;
for example, the type in the context of type checking.
The notation reads as
\begin{quote}
In the interpretation |judgetype| the |construct| has property |property| assuming
|context| and with optional additional |more ^^ results|.
\end{quote}

If the |context| or |more ^^ results| itself consists of multiple parts, these parts are separated by
a semicolon '|;|'.
An underscore '|_|' has a similar role as in Haskell to indicate a property is not relevant for a type rule
(see \ruleRef{e.app}, \figRef{rules3.K.expr.baseForEH1})

Although a rule formally is to be interpreted purely equational, it may help to realise
that from an implementors point of view this (more or less)
corresponds to an implementation template, either in the form of a function |judgetype|:

\begin{code}
judgetype =  \construct ->
             \context -> ... (property,more_results)
\end{code}
or a piece of AG:
\begin{code}
ATTR judgetype [  context: ... | |
                  property: ...  more_results: ... ]

SEM judgetype
  |  construct
       lhs.(property,more_results) = ... @lhs.context ...
\end{code}
Typing rules and implementation templates
differ in that the latter prescribes the order in which the computation of
a property takes place, whereas the former simply postulates
relationships between parts of a rule.
In general, typing rules presented
throughout \thispaper\ will be rather explicit in the flow of information
and thus be close to the actual implementation.
In \chapterRef{ruler} we will exploit the similarity between type rules and their AG counterpart further
when discussing the |Ruler| system used for describing the type rules in \thispaper.

\subsubsection{Environment}
The rules in \figRef{rules3.E.expr.baseForEH1} refer to |Gamma|,
which is often called \IxAsDef{assumptions}, \IxAsDef{environment} or
\IxAsDef{context} because it provides information about what may
be assumed about identifiers.
Identifiers |ident| are distinguished on the case of the first character,
capitalized |I|'s starting with an uppercase, uncapitalized |i|'s otherwise
\begin{code}
ident  =  identv
       |  identc
\end{code}
For type constants we will use capitalized identifiers |identc|,
whereas for identifiers bound to an expression in a |let|-expression
we will use lower case identifiers like |identv|.

An environment |Gamma| is a vector of bindings, a partial finite map from identifiers to types (or any other kind of information):
\begin{code}
Gamma = Vec(ident :-> sigma)
\end{code}

Concatenation of such collections as well as scrutinizing a collection is denoted with a comma '|,|'.
For example, `|identv :-> sigma, Gamma|' represents a concatenation as well as a pattern match.
For rules this does not make a difference, for the implementation there is a direction involved as we either construct
from smaller parts or deconstruct (pattern match) into smaller parts.

If shadowing is involved, that is duplicate entries are added, left/first (w.r.t. to the comma '|,|') entries shadow right/later entries.
When we locate some variable in a |Gamma| the first occurrence will be taken.

If convenient we will also use a list notation:
\begin{code}
Gamma = [ident :-> sigma]
\end{code}
This will be done if specific properties of a list are used or if we borrow from Haskell's repertoire of list functions.
For simplicity we also use (assocation) lists in our implementation of a |Gamma|, or more precisely,
a stack of lists.
A list structure suffices to encode the presence of an identifier in a |Gamma|, but it
cannot be used to detect multiple occurrences caused by duplicate introductions.
Thus in our implementation we use a stack of lists instead.
We will use the stack-like behavior by adding newly declared identifiers in the top list of the stack,
which then can be separately treated from the rest of the stack:

\chunkCmdUseMark{EHCommon.1.AssocL}
\chunkCmdUseMark{EHGam.1.Base.type}
\chunkCmdUseMark{EHGam.1.Base.sigs}
%%[[hide impl.gamAsList="Implementation of Gam"
\chunkCmdUseMark{EHGam.1.Base.funs}
\chunkCmdUseMark{EHGam.1.Rest.sigs}
\chunkCmdUseMark{EHGam.1.Rest.funs}
%%]

Entering and leaving a scope is implemented by means of pushing and popping a |Gamma|.
Extending an environment |Gamma| will take place on the top of the stack only.
A |gamUnit| used as an infix operator will print as |`gamUnit`|.
Left operands are added to right operands, possibly overwriting or hiding entries in the right operand.
For example |gamAddGam g1 g2| adds |g1|'s entries to |g2|, possibly hiding (overwriting) entries of |g2|
unless they appear in an outer level.

A specialization |ValGam| of |Gam| is used to store and lookup the type of value identifiers.

\chunkCmdUseMark{EHGam.1.ValGam.Base}

The type is wrapped in a |ValGamInfo|.
Later versions of EH can add additional fields to this data type.

\chunkCmdUseMark{EHGam.1.valGamLookup}
\chunkCmdUseMark{EHGam.1.valGamLookupTy}

Later (in \chapterRef{ehc4}) the variant |valGamLookup| will do additional work, but for now it
does not differ from |gamLookup| except for the return of an error in case no entry is found in the |ValGam|.
The additional variant |valGamLookupTy| is specialized further to produce
an error message in case the identifier is missing from the environment.

\subsubsection{Checking expressions (Expr)}

The rules in \figRef{rules3.E.expr.baseForEH1} do not provide much information about how
the type |sigma| in the consequence of a rule
is to be computed; it is just stated that it should relate in some way
to other types.
However, type information can be made available to parts of the abstract syntax tree, either
because the programmer has supplied it somewhere or because the compiler can reconstruct it.
For types given by a programmer the compiler has to check if such a type correctly
describes the value of an expression for which the type is given.
This is called \IxAsDef{type checking}.
If no type information has been given for a value,
the compiler needs
to reconstruct or infer this type based on the structure of the abstract syntax
tree and the semantics of the language as defined by the typing rules.
This is called \IxAsDef{type inferencing}.
In EH1 we exclusively deal with type checking.

\rulerCmdUse{rules3.K.expr.baseForEH1}
\rulerCmdUse{rules3.K.decl.base}

We now can tailor the type rules in \figRef{rules3.E.expr.baseForEH1} towards an implementation
which performs type checking, in \figRef{rules3.K.expr.baseForEH1}.
\figRef{rules3.K.expr.baseForEH1} differs from \figRef{rules3.E.expr.baseForEH1} in the following aspects:
\begin{itemize}
\item
The use of an expected, or known type |sigmak|.
Known type information is forwarded from the place it becomes known to where it is needed.
Here it travels from the top to the bottom of the AST.
In a type rule it travels from the consequence to the prerequisites.
For this reason it is (by convention) placed at the left side of the turnstyle `|:-|'.
\item
The uncoupling of type signatures and corresponding value declarations.
The single joint declaration for signature and value is split into two separate ones.
Additional |Gamma|'s are required to make the type signature available at the value declaration.
This complicates the type rules but it facilitates extension with different kinds of declarations in later EH versions.
\item
Patterns may be used in |let| and |lambda| expressions instead of single identifiers.
\end{itemize}
We emphasize this difference by the use of colors:
blue for changes relative to the previous set of rules,
grey for the unchanged part.
This (of course) is better seen through media which support color.

We also start with the discussion of
the corresponding AG implementation.
The rules now take an additional context, the expected (or known) type |sigmak|
(attribute |knTy|, simultaneously referred to by |sigmak =@= knTy|)
as specified by the programmer, defined in terms of AG as follows:

\chunkCmdUseMark{EHInferExpr.1.knTy}

%{
%format lhs = "lhs"
The basic idea underlying this implementation for type checking, as well as in later versions of EH also
for type inferencing, is that
\begin{itemize}
\item
A \IxAsDef{known} (or \IxAsDef{expected})
type |sigmak =@= knTy| is passed top-down through the syntax tree of an expression,
representing the maximal type (in terms of |<=|, see \figRef{rules3.K.fit}, \figRef{rules3.K.match.onlyK} and discussion below) the type of an expression can be.
%At all places where this expression is used it also is assumed that the type of this expression equals |sigmak|.
\item
A result type |sigma =@= ty| is computed bottom-up for each expression,
representing the minimal type (in terms of |<=|) the expression can have.
\item
At each node in the abstract syntax tree it is checked whether |sigma <= sigmak| holds.
The result of |lhs <= rhs| is |rhs| which is subsequently used by the type checker,
for example to simply return or use in constructing another, usually composite, type.
\item
In general, for |lhs <= rhs| the |rhs| is an expected type whereas |lhs| is the bottom-up computed result type.
\end{itemize}
%}

\rulerCmdUse{rules3.K.fit}
\rulerCmdUse{rules3.K.match.onlyK}

An additional judgement type named |fit| (\figRef{rules3.K.fit}) is needed to check an actual type against an expected (known) type.
The judgement specifies the matching |sigma1 <= sigma2| of two types |sigma1| and |sigma2|.
The meaning of |<=| is that the left hand side (lhs) type |sigma1| of |<=| can be used where the right hand side (rhs)
type |sigma2| is expected.
Expressed differently, |<=| checks whether a value of type |sigma1| can flow (that is, be stored) into a memory location
of type |sigma2|.

The relation |<=| is asymmetric because ``a value flowing into a location'' does not imply that it can flow
the other way,
so |<=| conceptually has a direction, even though the current version of |<=| is symmetric.
To emphasize this, the rule for |<=| (in \figRef{rules3.K.fit}) delegates to the rules in \figRef{rules3.K.match.onlyK}.
The rules in \figRef{rules3.K.match.onlyK} test the equality of two types by matching their structure.
Matching is denoted by |<=>|.

The rules for |<=| also specify a result type.
Strictly this result is not required for the |fit| judgement to hold but in the implementation it is convenient
to have the implementation |fitsIn| of |<=| return the smallest type |sigma| for which of |sigma1 <= sigma| and |sigma2 <= sigma| hold.
This is useful in relation to the use of |ANY| in
in \ruleRef{m.any.l} and \ruleRef{m.any.r}; we will come back to this later. 

For example, |<=| is used in \ruleRef{e.int} which checks that its actual |Int| type matches the
known type |sigmak|.
The implementation of \ruleRef{e.int} performs this check and returns the type |sigma| in attribute |ty|:

\chunkCmdUseMark{EHInferExpr.1.ty}
\chunkCmdUseMark{EHRulerRules.1.expr.e.int}

The implementation for \ruleRef{e.char} is defined similarly\overlayChunks{EHRulerRules.1.expr.e.char}.
The constant |tyInt| represents the |Int| type constant.
%%[[hide impl.echarRl="EH1, AG for \ruleRef{e.char}, type constants"
\chunkCmdUseMark{EHRulerRules.1.expr.e.char}
\chunkCmdUseMark{EHTy.1.tyInt}
\chunkCmdUseMark{EHTy.1.tyChar}
%%]


%if False
\begin{AGFeature}{ag-set-notation}{Set notation for variants}
The rule for (e.g.) attribute |fo| is specified for |IConst| and |CConst| together.
Instead of specifying only one variant a whitespace separated list of variant names
may be specified after the vertical bar '| || |'.
It is also allowed to specify this list relative to all declared variants by specifying for which
variants the rule should \emph{not} be declared.
For example: |* - IConst CConst| if the rule was to be defined for all variants except |IConst| and |CConst|.
\end{AGFeature}
%endif

\begin{AGFeature}{ag-loc-attr}{Local attributes}
Attribute |fo| and |ty| are declared locally.
In this context `local' means that the scope is limited to the variant of a node.
For example, |fo| (explained further below) also holds a (possibly empty) list of errors used
by other attribute equations.
|fo| is only available for attribute equations for variant |IConst| of |Expr|.

%if False
Note that no explicit rule for synthesized attribute |ty| is required;
a copy rule is inserted to use the value of the locally declared attribute |ty|.
This is a common AG idiom when a value is required for later use as well or
needs to be redefined in later versions of EH.
%endif
\end{AGFeature}

%if False
The local attribute |ty_| (by convention) holds the type
as computed on the basis of the abstract syntax tree.
This type |ty_| is subsequently compared to the expected type |lhs.knTy|
via the implementation |fitsIn| of the rules for |fit =@= <=|.
In infix notation |fitsIn| prints as |<=|.
%endif
The function |fitsIn| (printing as |<=| in infix notation) returns a |FIOut|
(\textbf{f}its\textbf{I}n \textbf{out}put) data structure in attribute |fo|.
|FIOut| consists of a record containing amongst other things field |foTy|:

\chunkCmdUseMark{EHTyFitsInCommon.1.FIOut}
\chunkCmdUseMark{EHTyFitsInCommon.1.foHasErrs}

%if False
Using a separate attribute |ty_| instead of using its value directly has been
done in order to prepare for a redefinition of |ty_| in later versions\footnote{This will happen with other attributes as well.}.
%endif

|Ty_Any =@= Any =@= ANY| plays a special role.
This type appears at two places in the implementation of the type system
as a solution to the following problems:

\begin{itemize}
\item
Invariant to our implementation is the top-down passing of an expected type.
However, this type is not always fully known in a top-down order.
For example, in \ruleRef{e.app} (\figRef{rules3.K.expr.baseForEH1}) the argument of the expected function type
|ANY -> sigmak| is not known because this information is only available from the environment |Gamma| which is
used further down in the AST via \ruleRef{e.var}.
In this use of |ANY| it represents a ``dont't know'' of the type system implementation.
As such |ANY| has the role of a type variable (as introduced for type inferencing in \secRef{ehc2}).
\item
An error occurs at a place where the implementation of the type system needs a type to continue (type checking) with.
In that case |ANY| is used to prevent further errors from occurring.
In this use of |ANY| it represents a ``dont't care'' of the type system implementation.
As such |ANY| will be replaced by more a more specific type as soon as it matches (via |<=|) such a type.
\end{itemize}

In both cases |ANY| is a type exclusively used by the implementation to smoothen type checking.
The rules for |<=| for |ANY| in \figRef{rules3.K.match.onlyK} state that |ANY| is equal to any type.
The effect is that the result of |<=| is a more specific type.
This suits our ``dont't know'' and ``dont't care'' use.
Later, when discussing the AG implementation for these rules this issue reappears.
In later EH versions we will split the use of |ANY| into the proper use of a type lattice,
and will it thus disappear.

The role of |ANY| may appear to be similar to |Top| and |Bot| known from type theory.
However, |ANY| is used only as a mechanism for the type system implementation.
It is not offered as a feature to the user (i.e. the EH programmer) of the type system.


|Ty_Any =@= Any =@= ANY| is also used at the top level where the actual expected type of the expression neither is
specified nor matters
because it is not used:

\chunkCmdUseMark{EHInferExpr.1.knTy.AGItf}

The \ruleRef{m.arrow} in \figRef{rules3.K.match.onlyK} for comparing function types compares the
types for arguments in the opposite direction.
Only in
%if storyAFP04Notes
later versions of EH
%else
\secPageRef{ehc4-fitsin}
%endif
when |<=| really behaves asymmetrically we will discuss this aspect
of the rules which is named \IxAsDef{contravariance}.
In the rules in \figRef{rules3.K.match.onlyK} the direction makes no difference;
the correct use of the direction for now only anticipates issues yet to come.

The Haskell counterpart of \(\rulerCmdUse{rules3.K.fit.scheme}\)
is implemented by |fitsIn|:

\savecolumns
\chunkCmdUseMark{EHTyFitsIn.1.fitsIn.Base}
\restorecolumns
\chunkCmdUseMark{EHTyFitsIn.1.fitsIn.AppRest}


The function |fitsIn| checks whether the |Ty_App| structure
and all type constants |Ty_Con| are equal.
If not, a non-empty list of errors is returned as well as type |Ty_Any =@= Any =@= ANY|.
Matching a composite type is split in two cases for |Ty_App|, one for function types (the first case),
and one for the remaining type applications
(the second case).
For the current EH version the second case only concerns tuple types.
Both matches for composite types use |comp| wich performs multiple |<=|'s and combines the results.
The difference lies in the treatment of contravariant behavior as discussed earlier.

The type rules leave in the open how to handle a situation when a required
constraint is broken.
For a compiler this is not good enough, being the reason |fitsIn| gives a ``will-do'' type
|Ty_Any| back together with an error for later processing%
%if incl01TopicErr
 (in section~\ref{sec-error1})%
%endif
.
Errors themselves are also described via AG:

\chunkCmdUseMark{EHErrorAbsSyn.1.UnifyClash}
\chunkCmdUseMark{EHErrorAbsSyn.1.NamesNotIntrod}
\chunkCmdUseMark{EHErrorAbsSyn.1.ErrL}

The |Err| datatype is available as a datatype in the same way |Ty| is.

\paragraph{Variable occurrences |Var|.}
The error datatype is also used for signalling undeclared identifiers when a type for an identifier is retrieved
from a |Gamma|: 

%\chunkCmdUseMark{EHInferExpr.1.Var}
\chunkCmdUseMark{EHRulerRules.1.expr.e.var}

%{

%format < 		= "{\langle}"
%format > 		= "{\rangle}"
\begin{AGFeature}{ag-lhs-pat}{Left hand side patterns}
The simplest way to define a value for an attribute is to define one value for one attribute
at a time.
However, if this value is a tuple, its fields are to be extracted and assigned to individual attributes
(as in |tyArrowArgRes|).
AG allows a pattern notation of the form(s) to make the notation for this situation more concise:
\begin{code}
| <variant>  ^^^^  <node> . ( <attr1>   , <attr2>            , ...  )  = 
| <variant>  ^^^^  ( <node1> . <attr1>  , <node1> . <attr2>  , ...  )  = 
\end{code}
\end{AGFeature}
%}

Again, the error condition is signalled by a non empty list of errors
if a lookup in |Gamma| fails.
%if incl01TopicErr
Later, in \secRef{sec-error1}, these
%else
These
%endif
errors are gathered so they can be incorporated into an annotated pretty printed
version of the program.


Typing \ruleRef{e.var} uses the environment |Gamma| to retrieve the type
of an identifier.
This environment |valGam| for types of
identifiers simply is declared as an inherited attribute,
initialized at the top of the abstract syntax tree.
It is only extended with new bindings for identifiers at a declaration of an identifier.

\chunkCmdUseMark{EHInfer.1.valGam}

\paragraph{Function application |App|.}
Type checking for \ruleRef{e.app} constructs |ANY -> sigmak| as the expected type for the function to be applied.
The resulting type |func.ty| is decomposed into argument and result type, of which the argument type is used
as the known type for the argument child of the |App| node:

%\chunkCmdUseMark{EHInferExpr.1.App}
\chunkHideRef{impl.tyDissect}
\chunkCmdUseMark{EHRulerRules.1.expr.e.app}

This further clarifies the need for |ANY|.
To see why, assume we do not use |ANY|.
Then, in the following example, what would be the |knTy| against which |3| will be checked?

\begin{code}
let  id :: Int -> Int
     id = \x -> x
 in  id 3
\end{code}

The value for |knTy| can only be determined from the type of the function,
which is a value traveling bottom-to-top through the AST.
The idea here is to encode the partially
known function type as |ANY -> sigmak| (passed to |func.knTy|) and let
|fitsIn| fill in the missing details, that is to find a type for |ANY|.
This is the place where it is convenient to have |fitsIn| return a type in which
|ANY =@= Ty_Any|'s are replaced by a more concrete type.
From that result the known/expected type of the argument can be extracted.

Note that we are already performing a little bit of type inferencing.
This is however only done locally to |App| as the |ANY| in
|ANY -> sigmak| is guaranteed to have disappeared in the result type of |fitsIn|.
If this is not the case, the EH program contains an error.
This is a mechanism we repeatedly use, so we summarize it here:

\begin{itemize}
\item
Generally, the semantics of the language requires a type |sigma| to be of a specific form.
Here |sigma| equals the type of the function (not known at the |App| location in the AST)
which should have the form |ANY -> sigmak|.
\item
The specific form may contain types about which we know nothing, here encoded by
|ANY|, in later EH versions by type variables.
\item
|fitsIn =@= <=| is used to enforce |sigma| to have the right form.
Here this is done by pushing the form as |sigmak| down the AST for the function (attribute |func.knTy|).
The check |sigma `fitsIn` sigmak| is then performed in the |Var| variant of |Expr|.
\item
Enforcing may or may not succeed.
In the latter case error messages are generated and the result of
enforcing is |ANY|.
\chunkHideRef{impl.tyDissect}
Dissection functions like |tyArrowArgRes| must be able to cope with |ANY|.
\end{itemize}

The type construction and inspection done in the |App| variant of |Expr|
requires some additional type construction functions, for example |mkArrow| used in |App|.
The function is part of the class |SemApp| defining (semantic) functions related to building application |App| like structures:

\chunkCmdUseMark{EHCommon.1.SemApp}
%%[[hide impl.SemAppFull="Class SemApp and defaults"
\savecolumns
\chunkCmdUseMark{EHCommon.1.SemApp}
\restorecolumns
\chunkCmdUseMark{EHCommon.1.SemApp.default}
\chunkCmdUseMark{EHTy.1.mkTyCon}
\chunkCmdUseMark{EHTy.1.mkTyVar}
%%]

The instance for |SemApp Ty| is defined by:

\chunkCmdUseMark{EHTy.1.SemApp}

Class |SemApp| defines four functions (|semApp|, ...), for constructing a value similar to |App|, |AppTop|, |Con| and |Parens| respectively.
These functions are used by |mkApp| to build an |App| like structure and by |mkArrow| to build function like structures.
The code for (e.g.) parsers also
uses these functions parameterized with the proper four semantics functions as generated by the AG system.
%%[[hide parse.SemAppRelated="EH1 parser"
\savecolumns
\chunkCmdUseMark{EHParser.1.parserSigs}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pAGItf}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pApp}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pParenProd}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExprBase}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExprBaseParenProd}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExpr}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExprApp}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExprPrefix}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExprPrefixLam}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pDecl}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pPatExprBase}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pPatExprBase.prod}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pPatExpr}
%%]
So this additional layer of abstraction improves code reuse.
Similarly, function |mkProdApp| constructs a tuple type out of types for the elements.

The functions used for scrutinizing a type are given names in which (by convention)
the following is encoded:

\begin{itemize}
\item
What is scrutinized.
\item
What is the result of scrutinizing.
\end{itemize}

For example, |tyArrowArgRes| dissects a function type into its argument and result type.
If the scrutinized type is not a function, ``will do'' values are returned:

\chunkCmdUseMark{EHTy.1.unMkTy.sigs.tyArrow}
\chunkCmdUseMark{EHTy.1.unMkTy.tyArrowArgRes}

Similarly |tyProdArgs| is defined to return the types of the elements of a tuple type.
The code for this and other similar functions have been omitted for brevity.
%%[[hide impl.tyDissect="Type dissection"
\chunkCmdUseMark{EHTy.1.unMkTy.sigs.Rest}
\chunkCmdUseMark{EHTy.1.unMkTy.tyArrowArgsRes}
\chunkCmdUseMark{EHTy.1.unMkTy.tyAppFunArgs}
\chunkCmdUseMark{EHTy.1.unMkTy.funs}
\chunkCmdUseMark{EHTy.1.unMkTy.tyProdArgs}
\chunkCmdUseMark{EHTy.1.unMkTy.tyLHdAndTl}
\chunkCmdUseMark{EHCommon.1.Misc.hdAndTl}
\chunkCmdUseMark{EHTy.4.unMkTy.tyConNm}
\chunkCmdUseMark{EHTy.4.unMkTy.tyVar}
%%]

\paragraph{Constructor |Con|, tuples.}

Apart from constructing function types only tupling allows us
to build composite types.
The \ruleRef{e.prod} for tupling
has no immediate counterpart in the implementation
because a tuple |(a,b)| is encoded as the application |(,) a b|.
We need a \ruleRef{e.con} (replacing \ruleRef{e.con}) to produce a type for |(,)|:
\[
\rulerCmdUse{rules3.K.expr.base.e.con}
\]

The expected type |sigma_r| of the complete tuple can be constructed from |knTy =@= sigmak|,
which by definition
has the form |ANY -> ANY -> (a,b)| (for this example).
The result type of this function type is taken apart and used to produce
the desired type |a -> b -> (a,b)|.
The |Con| alternative implements this:

%\chunkCmdUseMark{EHInferExpr.1.Con}
\chunkCmdUseMark{EHRulerRules.1.expr.e.con}
\chunkHideRef{impl.tyDissect}

Note that, despite the fact that the cartesian product constructors are
essentially polymorphic, we do not have to do any kind of unification
here, since they either appear in the right hand side of a declaration
where the type is given by an explcit type declaration, or they occur at
an argument position where the type has been implicitly specified by the
function type.
Therefore we indeed can use the |a| and |b| from type |ANY -> ANY -> (a,b)|
to construct the type |a -> b -> (a,b)| for the constructor |(,)|.

\paragraph{|lambda|-expression |Lam|.}

For \ruleRef{e.lam} the check whether |knTy| has the form |sigma1 -> sigma2|
is done by letting |fitsIn| match the |knTy| with |ANY -> ANY|.
The result (forced to be a function type) is split up by
|tyArrowArgRes| into argument and result type.

%\chunkCmdUseMark{EHInferExpr.1.Lam}
\chunkCmdUseMark{EHRulerRules.1.expr.e.lam}

\paragraph{Type annotations (for |lambda|-expression).}

In order to make |lambda|-expressions typecheck correctly it is the responsibility of
the EH programmer to supply the correct type signature.
The |TypeAs| variant of |Expr| (for \ruleRef{e.ann}) takes care of this by simply passing the type signature as the expected type
and checking whether the type signature matches the expected type of the annotation:

%\chunkCmdUseMark{EHInferExpr.1.TypeAs}
\chunkCmdUseMark{EHRulerRules.1.expr.e.ann}

The obligation for the EH programmer to specify a type is dropped in later versions of EH.

\subsubsection{Checking pattern expressions (PatExpr)}

Before we can look into more detail at the way new identifiers are
introduced in |let|- and |lambda|-expressions
we take a look at patterns.
The rules in \figRef{rules3.K.patexpr.baseForEH1} demonstrate the basic idea: gather bindings for identifiers given
an expected type of the pattern.
For example, the following fragment specifies the type of |p| whereas we also need to know the types of |a| and |b|:

\begin{code}
let  p        ::  (Int,Int)
     p@(a,b)  =   (3,4)
in   a
\end{code}

%\rulerCmdUse{rules.expr1B.C}
\rulerCmdUse{rules3.K.patexpr.baseForEH1}


The expected type of a pattern is distributed over the pattern
by dissecting it into its constituents.
Patterns do not return a type but
type bindings for the identifiers inside a pattern.
The new bindings are subsequently used in
|let|- and |lambda|-expressions bodies.

The typing for a tuple pattern is expressed as a combination of \ruleRef{p.app}
and \ruleRef{p.apptop} (\figRef{rules3.K.patexpr.baseForEH1}).
A tuple pattern is encoded in the same way
as tuple expressions; that is, pattern |(a,b)| is encoded as
an application |(,) a b| with an |AppTop| on top of it.


We dissect the known type of a tuple into its element types
at |AppTop| using function |tyProdArgs|.
For this version of EH
we only have tuple patterns; we indeed can assume that we are dealing with a tuple type.
Instead of manipulating the expected tuple type over the |App| spine of the pattern,
we directly decompose the tuple type into a list |knTyL| of constituent types.
We also require the arity of the pattern in order to check (at |AppTop|) if the pattern is fully saturated:

\chunkCmdUseMark{EHInferPatExpr.1.knTy}
%\chunkCmdUseMark{EHInferPatExpr.1.knTy.App}
\chunkCmdUseMark{EHRulerRules.1.patexpr.p.apptop}
\chunkCmdUseMark{EHRulerRules.1.patexpr.p.app}
\chunkHideRef{impl.tyDissect}

The list of these elements is passed through attribute |knTyL| to all |App|'s of the pattern.
At each |App| one element of this list is taken as the |knTy| of the element AST.
In case the arities of pattern and its expected type do not match, an error is produced and
the tuple components are given |ANY| as their expected type (by |tyLHdAndTl|).

Finally, for the distribution of the known type throughout a pattern we
need to properly initialize |knTyL|.
Because a pattern occurs in other contexts, that is as a child of other AST nodes, other than an |AppTop|,
we need to specify a default value.

\chunkCmdUseMark{EHInferPatExpr.1.knTy.Init}

The arity of the patterns is needed as well:

\chunkCmdUseMark{EHInferPatExpr.1.arity}

As a result of this unpacking, at a
|Var| alternative attribute |knTy| holds the type of the variable name introduced.
The type is added to attribute |valGam| that is threaded through the pattern for gathering
all introduced bindings:

\chunkCmdUseMark{EHInferPatExpr.1.valGam}
\chunkCmdUseMark{EHRulerRules.1.patexpr.p.var}
%%[[hide impl.pvaras="AG for \ruleRef{p.varas}"
\chunkCmdUseMark{EHRulerRules.1.patexpr.p.varas}
%%]

A new entry is added if the variable name is not equal to an underscore '|_|'
and
has not been added previously via a type signature for the variable name, signalled
by attribute |inclVarBind|.
%%[[hide impl.inclVarBind="AG for inclVarBind"
\chunkCmdUseMark{EHInfer.1.inclVarBind}
%%]
Because our check on duplicate introductions is based on duplicate entries in |valGam|,
we inhibit addition if an entry has already been added via a type signature.
This condition is indicated by |inclVarBind|.
\chunkHideRef{impl.dupErrs}


\subsubsection{Checking declarations (Let, Decl)}

In a |let|-expression type signatures, patterns and expressions do meet.
The algorithmic version of \ruleRef{e.let} in \figRef{rules3.K.expr.baseForEH1} is more complex than
the equational version in \figRef{rules3.E.expr.baseForEH1} because of the presence of mutual recursive definitions and the 
uncoupling of type signatures and their corresponding value definition:

\begin{itemize}
\item
Mutually recursive value definitions.
\begin{code}
let  f :: ...
     f = \x -> ... g ...
     g :: ...
     g = \x -> ... f ...
in   ...
\end{code}
In the body of |f| the type |g| must be known and vice-versa.
There is no ordering of what can be defined and checked first.
In Haskell |f| and |g| together would be in the same binding group.
\item
Textually separated signatures and value definitions.
\begin{code}
let  f :: ...
     ...
     f = \x -> ...
in   ...
\end{code}
Syntactically the signature and value definition for an identifier need not be defined
adjacently or in any specific order.
\end{itemize}

In Haskell dependency analysis determines that |f| and |g| form a so-called
\IxAsDef{binding group},
which contains declarations that have to be subjected to type analysis together.
However, due to the obligatory presence of the type signatures in this version of EH
it is possible to first gather all signatures
and only then type check the value definitions.
Therefore, for this version of EH it is not really an issue as we always require a signature to be defined.
For later versions of EH it actually will become an issue, so for simplicity all bindings
in a |let|-expression are analysed together as a single (binding) group.

Our AG implementation follows the strategy of \ruleRef{e.let} (\figRef{rules3.K.expr.baseForEH1}),
\ruleRef{d.tysig} and \ruleRef{d.val} (\figRef{rules3.K.decl.base}):
\label{eh1-let-strategy}

\begin{itemize}
\item
First extract all type signatures in:
\chunkCmdUseMark{EHInfer.1.gathTySigGam}

\item
Then distribute these gathered signatures in:
\chunkCmdUseMark{EHInfer.1.tySigGam}

This attribute and |gathTySigGam| correspond to |Gammat| in the type rules.
\item
Use the signature as the known type of a pattern in order to extract bindings inside a pattern in:
\chunkCmdUseMark{EHInfer.1.patValGam}

This attribute corresponds to |Gammap| in the type rules.
\item
Finally distribute all previously gathered information (for use by identifier occurrences in expressions) in:
\chunkCmdUseMark{EHInfer.1.valGam}

This attribute corresponds to |Gamma| in the type rules.
\end{itemize}

\begin{AGFeature}{ag-use-attr}{Attribute together with USE}
A synthesized attribute |<attr>| may be declared together with |USE {<op>} {<zero>}|.
The |<op>| and |<zero>| allow the insertion of copy rules which behave similar to Haskell's |foldr|.
The first piece of text |<op>| is used to combine the attribute values of two children by textually placing this text as an
operator between references to the attributes of the children.
If no child has an |<attr>|, the second piece of text |<zero>| is used as a default value for |<attr>|.
For example, |USE {`gamAddGam`} {emptyGam}|
gathers bottom-up the type signature bindings.
\end{AGFeature}

This flow of information is described by the following AG fragment:

\chunkCmdUseMark{EHRulerRules.1.expr.e.let}

Attribute |gathTySigGam| is populated with bindings in a type signature |TySig|:

\chunkCmdUseMark{EHRulerRules.1.decl.d.tysig}

Bindings from patterns are gathered in a value declaration |Val|.
The type signature for the topmost variable of the pattern is used as the expected type (|knTy|) of the pattern.
|tySigGam| has to be queried for the type signature:

\chunkCmdUseMark{EHRulerRules.1.decl.d.val}
%%[[hide impl.mbTopNm="AG for mbTopNm"
\chunkCmdUseMark{EHInfer.1.mbTopNm}
%%]

The actual bindings are added inside a patterns at variable occurrences.

We allow patterns of the form `|ab@(a,b)|' to have a type signature associated with |ab|.
No type signatures are allowed for `|(a,b)|' without the `|ab@|' alias (because there is no way to refer to the
anonymous tuple) nor is it allowed to specify type signature for the fields of the tuple (because of simplicity,
additional plumbing would be required).

Extracting the top of the stack |patValGam| gives all the locally introduced
bindings in |lValGam|.
An additional error message is produced
if any duplicate bindings are present.
%%[[hide impl.dupErrs="Check on duplicate introductions"
\chunkCmdUseMark{EHExtraChecks.1.dupErrs}
\chunkCmdUseMark{EHGam.1.gamToDups}
%%]

\subsubsection{Checking type expressions (TyExpr)}

All that is left to do now is to use the type expressions to extract type signatures
(type rules for type expressions in\figRef{rules3.K.tyexpr.base}).
This is straightforward as type expressions (abstract syntax for what the programmer specified)
and types (as internally used by the compiler) have almost the same structure (\secPageRef{abs-syn-eh1}:

\chunkCmdUseMark{EHInferTyExpr.1.ty}

\rulerCmdUse{rules3.K.tyexpr.base}

Actually, we need to do more because we also have to check whether a type is defined.
A variant of |Gam| is used to hold type constants:

\chunkCmdUseMark{EHGam.1.TyGamInfo}
\chunkCmdUseMark{EHGam.1.TyGam}
\chunkCmdUseMark{EHGam.1.tyGamLookup}

This |Gamma| is threaded through |TyExpr|:

\chunkCmdUseMark{EHInferTyExpr.1.tyGam}

At the root of the AST |tyGam| is initialized with the fixed set of types available
in this version of the compiler:

\chunkCmdUseMark{EHInfer.1.initTyGam}

Finally, at the |Con| alternative of |TyExpr| we need to check if a type is defined:

\chunkCmdUseMark{EHInferTyExpr.1.check}

%if incl01TopicErr

\subsection{Reporting program errors}
\label{sec-error1}

Errors too are defined using AG%
%if storyAFP04Notes
.
%else
(see also \pageRef{EHErrorAbsSyn.1.UnifyClash}).
%endif

\chunkCmdUseMark{EHErrorAbsSyn.1.Rest}

Errors are gathered, grouped at convenient places and made part of the
pretty printing attribute |pp|.
This is only shown for expressions:

\chunkCmdUseMark{EHGatherError.1.GatherExpr}
\chunkCmdUseMark{EHError.1.mkNestErr}

Pretty printed collected errors are made available for
inclusion in the pretty printing of the abstract syntax tree%
%if storyAFP04Notes
.
%else
(see \pageRef{EHPretty.1.Base.ExprSimple}).
%endif
We have chosen to only report the collected errors at
the end of a group of declarations or at a specific
declaration. Many different choices are possible here,
depending on the output medium.

\chunkCmdUseMark{EHGatherError.1.PP}

Errors themselves also need to be pretty printed, but we have omitted this part.
The issue here is to keep the generated output reasonably compact because the nesting
can give a long trace of locations where the error did occur.

%endif %% incl01TopicErr

%if not incl00TopicAGPrimer

\subsection{Tying it all together}

Finally, all needs to be tied together to obtain a working program.
This involves a bit of glue code to (for example) combine scanner (not discussed here),
parser, semantics, passing compiler options and the generation of output.
For brevity, these details are omitted.

%endif %% incl00TopicAGPrimer

%%]

%%[scratch
%if not omitLitDiscuss
\subsection<article>{Literature}

\TBD{}

Local type inference \cite{pierce00local-type-inference} also has top-down, bottom-up mixing.
%endif
%%]

%%[parsing
\subsection{Parsing: from concrete to abstract (syntax)}
An abstract syntax tree is obtained as the result of parsing.
The parser combinator library used (see \cite{uust04www} and \figRef{parser-combinators}) to specify the parser for EH allows
us to simultaneously define the syntactic structure and the connection to
the abstract syntax.
For example, the parser for the simplest of expressions

\savecolumns
\chunkCmdUse{EHParser.1.pExprBase}
\restorecolumns
\chunkCmdUse{EHParser.1.pExprBaseParenProd}

recognises variables via |pVar| and integer constants via |pInt|.
These parsers are based on parsers defined in a general purpose scanner library \cite{uust04www}
about which
we will say no more than that it provides basic parsers tailored towards the recognition
of Haskell lexical elements:

\chunkCmdUse{EHParser.1.scanWrappers}

All parsers from this library return their result as a string,
which,
after additional postprocessing,
can conveniently be passed as an argument to the semantic function.
For example, for a variable, the semantic function |sem_Expr_Var| is applied to the result of |pVarid| packaged as a |HsName|.
The semantic function is generated by the AG system from the attribute grammar.

The use of semantic functions deserves some closer inspection.
The attribute grammar associates semantics with each abstract syntax
tree, which is represented by a function from inherited to synthesized
attributes. The semantic functions correspondings to alternatives in the
grammar map the semantics of the non-terminals occuring in the right
hand side of the production to the semantics of the nonterminal in the
left hand side.






For each of the alternatives of a non-terminal the AG system generates a
\IxAsDef{semantic function},
that takes as argument the semantic functions corresponding to its right hand side,
and constructs a function mapping inherited to synthesized attributes.
The structure of such a function, that is, its type is similar to its related and also to its
generated datatype.
Similar in the sense that both take their components as their first arguments.
For example, both |Expr_Var| as a data constructor and |sem_Expr_Var| take
a string as their first argument.
It is this similarity we exploit:
instead of first building the abstract syntax tree and subsequently analysing
it we directly map semantics associated with the children onto the
semantics of the father.
For all practical purposes, for now, this is all we need in order to be able to use
these functions
(see also \cite{swierstra99comb-lang}).

\begin{CodeFigure}{Parser combinators}{parser-combinators}
\begin{tabular}{lll}
\ParserCombTableHead
\ParserCombTableA
\ParserCombTableB
\end{tabular}
\end{CodeFigure}

From |pExprBase| the parser |pExpr| for the more complex expressions is built.

\savecolumns
\chunkCmdUseMark{EHParser.1.exprAlg}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExpr}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExprApp}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExprPrefix}
\restorecolumns
\chunkCmdUseMark{EHParser.1.pExprPrefixLam}

An application |pExprApp| is a juxtapositioning of a non empty series
of |pExprBase|'s.
A |pExprApp| itself can be prefixed with parsers making the expression
into a |let|- or |lambda|-expression.
The parser |pExprPrefix| recognizes this prefix
and returns a function
that maps the semantics of the expression that follows it into the
semantics of the corresponding construct.
The result of |pExprPrefix| is a function and can therefore be applied immediately to |pExprApp| by the
sequencing combinator |<*>|.

Parser |pExprApp| is defined in terms of an algebra |exprAlg| and an
abstract parser recognising applications

\chunkCmdUse{EHParser.1.pApp}

First, let us look at the \IxAsIs{algebra} |exprAlg|, again referring to
Swierstra \cite{swierstra99comb-lang} for a more thorough
treatment.
The abstract syntax of EH (see \figPageRef{abs-syn-eh1})
has |Con|, |App| and |AppTop| alternatives for |Expr|, |TyExpr| and |PatExpr|.
For all three kinds of expressions an application |f x y| maps
to the same structure |AppTop (App (App f x) y)|,
where for a 2-tuple pattern |f == Con ",2"|,
and for a function type |f == Con  "->"| (representing |x -> y|).
The |Con|, |App| and |AppTop| depend on the particular kind
of expression.
The following function |mkApp| does this job of
creating the application given a list of elements (here [f,x,y]) to make
the application from, and the specific variants for |Con|, |App| and |AppTop|.
Note that no |AppTop| is placed around a singleton list since this is not an application
and the function |mkApp| is never used on an empty list.

\chunkCmdUseMark{EHCommon.1.MkConApp}
\chunkCmdUseMark{EHCommon.1.SemApp}
%%[[hide impl.SemAppFull="Class SemApp and defaults"
\savecolumns
\chunkCmdUseMark{EHCommon.1.SemApp}
\restorecolumns
\chunkCmdUseMark{EHCommon.1.SemApp.default}
%%]

It is precisely the group of functions specifying what should be done
for |Con|, |App| and |AppTop| which is called an algebra.

Parsing parenthesized constructs deserves some special attention: in the
case of expresssions () stands for a single value, in the case of (expr)
parentheses just tell us how to parse a more complicated expression, and
in the case of (expr, expr, ...) they correspond to the constructor for a
cartesian product. Since this parttern also pops up in the case of types
the parser |pParenProd| which recognises these three alternatives is also 
parameterized with the algebra:

\chunkCmdUse{EHParser.1.pParenProd}

The definition for |pParenProd| quite literally follows this enumeration of alternatives.
Note that the parser is in a left factorized form
in order to make parsing take linear time.

The parsers for patterns and type expressions also use these abstractions,
for example, the parser for type expressions:

\savecolumns
\chunkCmdUse{EHParser.1.tyExprAlg}
\restorecolumns
\chunkCmdUse{EHParser.1.pTyExprBase}
\restorecolumns
\chunkCmdUse{EHParser.1.pTyExpr}

defines a |tyExprAlg| to be used to recognise parenthesized and tupled type expressions.
The parser for |pTyExpr| uses |pChainr| to recognise a list
of more elementary types separated by |->|.

The parser for patterns is, because of its similarity with the previous expression
parsers, given without further explanation:

\savecolumns
\chunkCmdUse{EHParser.1.patExprAlg}
\restorecolumns
\chunkCmdUse{EHParser.1.pPatExpr}
\restorecolumns
\chunkCmdUse{EHParser.1.pPatExprBase}
\restorecolumns
\chunkCmdUse{EHParser.1.pPatExprBase.prod}

Finally, the parsers for the program itself and declarations should have few surprises by now,
except for the use of |pBlock| recognising a list of more elementary parsers
where the offside rule of
Haskell applies.
We will not look at this any further.

\chunkCmdUse{EHParser.1.pDecl}
\chunkCmdUse{EHParser.1.pAGItf}

Once all parsing results are passed to semantic functions we enter the world of attributes
as offered by the AG system.
The machinery for making the compiler actually produce some output is not explained here but
can be found in the sources.
From this point onwards we will forget about that and just look at computations performed on
the abstract syntax tree through the separate views as provided by the AG system.
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

