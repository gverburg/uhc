% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gamma's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllFuncDep [ | tyGam: TyGam | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
tyPrLToSupNmL :: TyL -> [HsName]
tyPrLToSupNmL = zipWith (\i p -> hsnSuffix (tyPredNm p) (show i)) [1..]
%%]

%%[9
SEM Decl
  | Class       tyPrExpr        .   tyGam           =   gamPushNew @lhs.patTyGam
                loc             .   (ctxtPrTyL,hdPrTy)
                                                    =   tyArrowArgsRes @tyPrExpr.ty
                decls           .   gathTySigGam    =   gamPushNew @lhs.gathTySigGam
                loc             .   (lSigGam,_)     =   gamPop @decls.gathTySigGam
                                .   clsTySigGam     =   valGamMapTy (\t -> [@hdPrTy] `mkTyArrow` t) @lSigGam
                                .   supClsNmL       =   tyPrLToSupNmL @ctxtPrTyL
                                .   clsFldL         =   assocLMapSnd vgiTy (gamToAssocL @clsTySigGam)
                                .   clsTyRec        =   mkTyRec (@clsFldL ++ zip @supClsNmL (repeat Ty_Any))
                                .   pigi            =   let  k =  mkNewTyVar @lUniq
                                                             n =  uidHNm @lUniq
                                                             r =  Rule
                                                                    { rulRuleTy    = tyQuantifyClosed @tyPrExpr.ty
                                                                    , rulMkEvid    = \_ -> CExpr_Var n
                                                                    , rulNmEvid    = n
                                                                    , rulId        = @lUniq
                                                                    , rulCost      = CostInt 10
                                                                    , rulFuncDeps  = @funcDeps.funcDeps
                                                                    }
                                                        in   PrIntroGamInfo (tyQuantifyClosed ([@hdPrTy] `mkTyArrow` @clsTyRec)) k r
                                .   elimRules       =   let  mkR sub sup supNm
                                                               =  Rule
                                                                    { rulRuleTy    = tyQuantifyClosed ([sub] `mkTyArrow` sup)
                                                                    , rulMkEvid    = let  o = (CExpr_Int . tyRecOffset supNm $ @clsTyRec)
                                                                                     in   \[sub] -> mkCExprSelCase emptyRCEEnv (hsnSuffix supNm "!") sub CTagRec supNm supNm o
                                                                    , rulNmEvid    = hsnUnknown
                                                                    , rulId        = uidStart
                                                                    , rulCost      = CostInt (2 * costBase)
                                                                    , rulFuncDeps  = []
                                                                    }
                                                        in   zipWith (\p n -> (tyPredMatchNm p,mkR @hdPrTy p n)) @ctxtPrTyL @supClsNmL
                lhs             .   patTyGam        =   @lhs.patTyGam
                                .   tyGam           =   @lhs.tyGam
                                .   gathTySigGam    =   gamAddGam (valGamMapTy tyQuantifyClosed @clsTySigGam) @lhs.gathTySigGam
                                .   patPrIntroGam   =   gamAdd (tyPredMatchNm @hdPrTy) @pigi @lhs.patPrIntroGam
                                .   patPrElimGam    =   foldr (uncurry peGamAdd) @lhs.patPrElimGam @elimRules
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Functional dependency
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllFuncDep [ clsTyArgs: TyL | | funcDeps USE {++} {[]} : {[ClsFuncDep]} ]

SEM FuncDep
  | Dep         lhs             .   funcDeps        =   let  l v = maybe (-1) id . elemIndex v $ @lhs.clsTyArgs
                                                        in   [(map l @fromTvs.tyL, map l @toTvs.tyL)]

SEM Decl
  | Class       loc             .   clsTyArgs       =   tyAppArgs . predTy . tyPred $ @hdPrTy
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
SEM Decl
  | Instance    tyPrExpr        .   tyGam           =   gamPushNew @lhs.patTyGam
                loc             .   prTyFix         =   tyFixTyVars . tyQuantifyRank [2..] $ @tyPrExpr.ty
                                .   (ctxtPrTyFixL,hdPrTyFix)
                                                    =   tyArrowArgsRes @prTyFix
                                .   instClsNm       =   tyPredMatchNm @hdPrTyFix
                                .   ctxtClsNmL      =   map tyPredMatchNm @ctxtPrTyFixL
                                .   instId          =   @lUniq
                                .   (dictNm,inclForElim)
                                                    =   maybe (uidHNm @instId,True) id @mbNmElim
                                .   pigi            =   fromJust (gamLookup @instClsNm @lhs.prIntroGam)
                                .   supPrTyL        =   let  t      =  rulRuleTy . pigiRule $ @pigi
                                                             st     =  mkNewTyVarL (tyArrowArity . tyQuant $ t) @lUniq4 `mkTyArrow` @hdPrTyFix
                                                             fo     =  fitsIn predFIOpts emptyFE @lUniq3 t st
                                                        in   tyArrowArgs . foTy $ fo
                                .   supClsNmL       =   tyPrLToSupNmL @supPrTyL
                                .   ctxtPrFixL      =   map tyPred @ctxtPrTyFixL
                                .   recTy           =   tyFixTyVars . tyQuantifyRank [2..] . tyArrowRes $ @tyPrExpr.evTy
                decls           .   tySigGam        =   assocLToGam . assocLMapSnd ValGamInfo . snd . tyRecExts $ @recTy
                loc             .   elimRule        =   mkInstElimRule @dictNm @instId (length @ctxtPrTyFixL) (tyQuantifyClosed @prTyFix)
                lhs             .   patTyGam        =   @lhs.patTyGam
                                .   tyGam           =   @lhs.tyGam
                                .   gathTySigGam    =   (maybe id (\(n,_) g -> gamAdd n (ValGamInfo (tyQuantifyClosed @tyPrExpr.evTy)) g) @mbNmElim) @lhs.gathTySigGam
                                .   patValGam       =   @lhs.patValGam
                                .   patPrElimGam    =   (if @inclForElim then peGamAdd @instClsNm @elimRule else id) @lhs.patPrElimGam
  | InstanceIntro
                loc             .   instClsNm       =   tyPredMatchNm @prExpr.ty
                                .   instId          =   @lUniq
                                .   dictNm          =   uidHNm @instId
                                .   elimRule        =   mkInstElimRule @dictNm @instId 0 @prExpr.ty
                lhs             .   patPrElimGam    =   peGamAdd @instClsNm @elimRule @lhs.patPrElimGam
                loc             .   foPr            =   fitPredToEvid @lUniq @prExpr.ty @lhs.prIntroGam
                expr            .   knTy            =   foTy @foPr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Names, yes/no introduced, gamma entries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTyExpr [ | | clNmS USE {`Set.union`} {emptySet}: {Set HsName} ^^ clMissNmS USE {`Set.union`} {emptySet}: {Set HsName} ]

SEM PrExpr
  | Class       loc             .   (pigi,clNmS,clMissNmS)
                                                    =   case gamLookup @nm @lhs.prIntroGam of
                                                            Just p   -> (p          ,unitSet @nm  ,emptySet     )
                                                            Nothing  -> (emptyPIGI  ,emptySet     ,unitSet @nm  )
                                .   nmIsDef         =   isEmptySet @clMissNmS
                lhs             .   clNmS           =   @clNmS      `Set.union`  @tyExprs.clNmS
                                .   clMissNmS       =   @clMissNmS  `Set.union`  @tyExprs.clMissNmS
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Evidence type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR TyExpr PrExpr [ | | evTy: Ty ]

SEM PrExpr
  | Class       lhs             .   evTy            =   let  fo = fitsIn  (predFIOpts {fioDontBind = ftv @ty}) emptyFE @lUniq3
                                                                          (pigiPrToEvidTy @pigi) ([@ty] `mkTyArrow` mkNewTyVar @lUniq2)
                                                        in   snd (tyArrowArgRes (foTy fo))
  | Arrow       lhs             .   evTy            =   [@arg.evTy] `mkTyArrow` @res.evTy

SEM TyExpr
  | App         loc             .   evTy            =   Ty_App @func.evTy @arg.evTy
  | * - App AppTop Parens Pred
                lhs             .   evTy            =   @ty
%%]

