imports
{
import Network.URI
import IO
import Monad
import Array
import Data.List
import qualified Data.Map as Map
-- import Utils (tr, trp, wordsBy)
import Common
import CDoc
import CDocCommon
import CDocSubst
import CDocInline
import qualified Data.Set as Set
import qualified UU.DData.Seq as Seq
}

-------------------------------------------------------------------------
-- Inferfacing
-------------------------------------------------------------------------

WRAPPER AGItf

{
wrapAG_T :: Opts -> FPath -> XRefExcept -> NmChMp -> T_AGItf -> Syn_AGItf
wrapAG_T opts fp xr nmChMp pres
  = wrap_AGItf pres
      (Inh_AGItf
         { opts_Inh_AGItf = opts {optBaseName = maybe (Just (fpathBase fp)) Just (optBaseName opts), optBaseFPath = fp}
         , xrefExcept_Inh_AGItf = xr
         , nmChMp_Inh_AGItf = nmChMp
         })
}

{
cdocSubstInline :: NmChMp -> CDoc -> IO (CDoc,Set.Set Nm,ErrM)
cdocSubstInline m d
  = do { let (d2,s,e) = cdocSubst m d
       ; if Map.null e
         then do { let (d3,il) = cdocInlineCDocIO d2
                 ; (im,ie) <- il (Map.empty,Map.empty)
                 ; if Map.null ie
                   then do { let (d4,_,es) = cdocSubst im d3
                           ; return (d4,s,es)
                           }
                   else return (d3,s,ie)
                 }
         else return (d2,s,e)
       }
}

INCLUDE "ChunkAbsSyn.ag"
-- INCLUDE "CDocAbsSyn.ag"

-------------------------------------------------------------------------
-- Global info
-------------------------------------------------------------------------

ATTR AGItf AllChunk AllLine [ opts: Opts | | ]

-------------------------------------------------------------------------
-- Common. Version
-------------------------------------------------------------------------

{
mkVerFromInt :: Int -> Version
mkVerFromInt r = if r == 0 then VPre else VRef r

mkVerFromIntL :: [Int] -> Version
mkVerFromIntL (0:_)  = mkVerFromInt 0
mkVerFromIntL (i:is) = foldl VNest (VRef i) is

instance NM Version where
  mkNm VPre           = mkNm "pre"
  mkNm VAll           = mkNm "*"
  mkNm VNone          = mkNm "-"
  mkNm (VRef r)       = mkNm r
  mkNm (VNest n r)    = mkNm n `nmApd` mkNm r

instance CD Version where
  cd = cd . mkNm

verMatch :: Version -> Version -> Bool
verMatch VAll           _               = True
verMatch _              VAll            = True
verMatch (VRef r1)      (VRef r2)       = r1 == r2
verMatch (VNest n1 r1)  (VNest n2 r2)   = r1 == r2 && n1 == n2
verMatch VPre           VPre            = True
verMatch _              _               = False

cmpByVersionOrder :: VersionOrder -> Version -> Version -> Ordering
cmpByVersionOrder vo v1 v2
  = maybe EQ id . listToMaybe . catMaybes . map c $ vo
  where  c o = do { i1 <- elemIndex v1 o
                  ; i2 <- elemIndex v2 o
                  ; return (compare i1 i2)
                  }

voAllLE :: VersionOrder -> Version -> [Version]
voAllLE vo v
  = sortBy (cmpByVersionOrder vo)
  . nub . sort . concat
  . (case v of
      VAll -> id
      _    -> map (\o -> maybe [] (\i -> take (i+1) o) (elemIndex v o))
    )
  $ vo

voAllLE' :: VersionOrder -> Version -> [Version]
voAllLE' vo v
  = let voPrefixes
          = map (\p@((v,_):_) -> (v,map snd p))
          . groupBy (\(v1,_) (v2,_) -> v1 == v2)
          . sortBy (\(v1,_) (v2,_) -> compare v1 v2)
          . concat . map (\o -> zip o (inits o))
          $ vo
        all
          = case v of
              VAll -> concat vo
              _    -> maybe [] concat (lookup v voPrefixes)
     in sortBy (cmpByVersionOrder vo) . nub . sort $ all

voAllLE'' :: VersionOrder -> Version -> [Version]
voAllLE'' vo v
  = let allN = nub . sort . concat $ vo
        nrN = length allN
        nsN = [(0::Int)..nrN-1]
        ixOf' v = elemIndex v allN
        ixOf v = maybe 0 id (ixOf' v)
        voPrefixes
          = map (\p@((v,_):_) -> (ixOf v,map ixOf . nub . sort . (v:) . concat . map snd $ p))
          . groupBy (\(v1,_) (v2,_) -> v1 == v2)
          . sortBy (\(v1,_) (v2,_) -> compare v1 v2)
          . concat . map (\o -> zip o (inits o))
          $ vo
        m1 = map
                (\(n,ns)
                    -> map snd . sort $ (zip (ns) (repeat True) ++ zip (nsN \\ ns) (repeat False))
                )
                voPrefixes
        m2 = array (0,nrN-1) (zip nsN (map (\r -> array (0,nrN-1) (zip nsN r)) m1))
        m3 = foldr
                (\n m
                    -> foldr
                        (\i m -> m // [(i,m ! i // [ (j,m ! i ! n && m ! n ! j || m ! i ! j) | j <- nsN ])])
                        m nsN
                )
                m2 nsN
        nsV = maybe [] (\i -> assocs (m3 ! i)) (ixOf' v)
        allN' = case v of
                  VAll -> allN
                  _    -> [ allN !! i | (i,b) <- nsV, b ]
     in sortBy (cmpByVersionOrder vo) . nub . sort $ allN'

voDefault :: VersionOrder
voDefault = [take 100 (map VRef [1..])]

}

-------------------------------------------------------------------------
-- Chunk id
-------------------------------------------------------------------------

{
type ChunkId = (Version,Nm)
}

-------------------------------------------------------------------------
-- Sequence nr (for ordering when printing)
-------------------------------------------------------------------------

ATTR AllChunk AllLine [ | seqNr: Int | ]

SEM AGItf
  | AGItf       dumLines    .   seqNr       =   1

SEM Chunks
  | Cons        hd          .   seqNr       =   @lhs.seqNr + 1

SEM Line
  | Group       lines       .   seqNr       =   @lhs.seqNr + 1

-------------------------------------------------------------------------
-- Line counting, column counting
-------------------------------------------------------------------------

ATTR AllChunk AllLine [ | lineNr: Int | ]
ATTR AllWord [ | colNr: Int | ]

SEM AGItf
  | AGItf       dumLines    . lineNr    = 1

SEM Chunk
  | Ver Named   loc         . chunkLineNr
                                        = @lhs.lineNr
                lines       . lineNr    = @chunkLineNr + 1
                dumLines    . lineNr    = @lines.lineNr {- + 1 -}

SEM Line
  | AsIs        words       . colNr     = 1
                lhs         . lineNr    = @lhs.lineNr + 1
  | Named       lhs         . lineNr    = @lhs.lineNr + 1
  | Group       loc         . groupLineNr
                                        = @lhs.lineNr
                lines       . lineNr    = @groupLineNr + @extraLine
                lhs         . lineNr    = @lines.lineNr + @extraLine

SEM Word
  | White Black loc         . wordColNr = @lhs.colNr
                lhs         . colNr     = @lhs.colNr + length @chars

-------------------------------------------------------------------------
-- Left + right context
-------------------------------------------------------------------------

ATTR Words [ lCtxt: {[String]}  lAllCtxt: {[String]} | | rCtxt: {[String]} ]
ATTR Word [ | lCtxt: {[String]}  lAllCtxt: {[String]}  rCtxt: {[String]} | ]

SEM Line
  | AsIs        words       . lCtxt     = []
                            . lAllCtxt  = []

SEM Words
  | Nil         lhs         . rCtxt     = []
  | Cons        hd          . rCtxt     = @tl.rCtxt
                lhs         . rCtxt     = @hd.rCtxt

SEM Word
  | Black       lhs         . rCtxt     = @chars : @lhs.rCtxt
                            . lCtxt     = @chars : @lhs.lCtxt
                            . lAllCtxt  = @chars : @lhs.lAllCtxt
  | White       lhs         . lAllCtxt  = @chars : @lhs.lAllCtxt

-------------------------------------------------------------------------
-- Cross ref
-------------------------------------------------------------------------

{
data XRefKind = XRHsDef | XRAgAttrDef | XRAgAltDef | XRAgSemDef | XRHsUse | XRAgAttrUse deriving Show
data XRef = XRef { xrKind :: XRefKind, xrKeyL :: [String] } deriving Show

xrMainKey :: XRef -> String
xrMainKey = head . xrKeyL

xrKindIsDefining :: XRefKind -> Bool
xrKindIsDefining XRHsDef = True
xrKindIsDefining XRAgAttrDef = True
xrKindIsDefining XRAgAltDef = True
xrKindIsDefining XRAgSemDef = True
xrKindIsDefining _ = False

xrIsDefining :: XRef -> Bool
xrIsDefining = xrKindIsDefining . xrKind

type XRefL = Seq.Seq XRef
type XRefExcept = Set.Set String

passXR :: XRefExcept -> String -> ([XRef],Int) -> ([XRef],Int)
passXR exc r xr = if Set.member r exc then ([],0) else xr
}

ATTR AGItf AllNT [ xrefExcept: XRefExcept | | ]
ATTR AllWord AllLine [ | | xrefL USE {`Seq.append`} {Seq.empty} : XRefL ]
ATTR Word [ | rCtxtUsed: Int | ]
ATTR Words [ rCtxtUsed: Int | | ]

SEM Word
  | Black       (loc.xrefL,lhs.rCtxtUsed)
                                        = let ctxtHuge = 10000000
                                              loclhs = ["lhs","loc"]
                                              none = ([],@lhs.rCtxtUsed - 1)
                                              def nms k cUsed
                                                   = if any (flip Set.member @lhs.xrefExcept) nms then ([],0) else ([XRef k nms],cUsed)
                                           in if @lhs.rCtxtUsed <= 0 && isAlpha (head @chars)
                                              then case (@lhs.lAllCtxt,@lhs.lCtxt,@chars,@lhs.rCtxt) of
                                                     (_,("@":_),nm1,(".":nm2:_))
                                                       | nm1 `elem` loclhs          -> def [nm2] XRAgAttrUse 2
                                                     (_,("@":_),nm1,(".":nm2:_))    -> def [nm2,nm1] XRAgAttrUse 2
                                                     (_,("@":_),nm1,_)              -> def [nm1] XRAgAttrUse 0
                                                     (_,("|":_),nm1,_)              -> def [nm1] XRAgAltDef 0
                                                     (_,(".":ll:_),nm1,("=":_))
                                                       | ll `elem` loclhs           -> def [nm1] XRAgAttrDef 1
                                                     (_,(".":nm2:_),nm1,("=":_))    -> def [nm1,nm2] XRAgAttrDef 1
                                                     (_,_,nm1,([sep]:nm2:_))
                                                       | sep `elem` "._"            -> def [nm2,nm1] XRHsUse 2
                                                       | otherwise                  -> none
                                                     (_,["SEM"],nm1,_)              -> def [nm1] XRAgSemDef ctxtHuge
                                                     (_,["data"],nm1,_)             -> def [nm1] XRHsDef 0
                                                     (_,["type"],nm1,_)             -> def [nm1] XRHsDef 0
                                                     ([],_,nm1,_)                   -> def [nm1] XRHsDef ctxtHuge
                                                     (_,_,nm1,_)
                                                       | nm1 `notElem` loclhs       -> def [nm1] XRHsUse 0
                                                     _                              -> none
                                              else none
                lhs         . xrefL     = Seq.fromList @xrefL
  | White       lhs         . rCtxtUsed = 0

SEM Line
  | AsIs        words       . rCtxtUsed = 0

-------------------------------------------------------------------------
-- Named chunks
-------------------------------------------------------------------------

ATTR AllChunk AllLine AGItf [ | | gathNmChMp USE {`Map.union`} {Map.empty}: NmChMp ]
ATTR AllChunk AllLine AGItf [ nmChMp: NmChMp | | ]

SEM Chunk
  | Ver         loc         .   nmChInfo    =   NmChInfo @chFullNm ChHere @lines.mbCD
                lhs         .   gathNmChMp  =   Map.insert @chFullNm @nmChInfo @lines.gathNmChMp
  | Named       loc         .   nmChInfo    =   NmChInfo @cref ChHere @lines.mbCD
                lhs         .   gathNmChMp  =   Map.insert @cref @nmChInfo @lines.gathNmChMp

SEM Line
  | Group       loc         .   gathNmChMp  =   case @userRef of
                                                  Just (r,_) -> Map.singleton r (NmChInfo r ChHere @mbCD)
                                                  _          -> Map.empty
                lhs         .   gathNmChMp  =   Map.union @lines.gathNmChMp @gathNmChMp

SEM AGItf
  | AGItf       chunks      .   nmChMp      =   @chunks.gathNmChMp `Map.union` @lhs.nmChMp
                dumLines    .   nmChMp      =   Map.empty

-------------------------------------------------------------------------
-- Adm for hideable groups of lines
-------------------------------------------------------------------------

{
data HideInfo
  = HideInfo
      { hiNm        :: Nm
      , hiDescr     :: CDoc
      , hiSeqNr     :: Int
      , hiChDest    :: ChDest
      , hiMbCD      :: Maybe CDoc
      , hiChFullNm  :: Nm
      }

type HideMp = Map.Map Nm HideInfo
}

-------------------------------------------------------------------------
-- Content replica, CDoc
-------------------------------------------------------------------------

ATTR AllLine [ | | mbCD : {Maybe CDoc} ]

SEM Line
  | AsIs        loc         .   cdoc        =   if cdIsEmpty @words.cdoc then CDoc_Str "" else @words.cdoc
  | Named       loc         .   cdoc        =   CDoc_Ref @cref ChHere
  | AsIs Named  lhs         .   mbCD        =   Just (CDoc_Pos (CPos (optBaseFPath @lhs.opts) @lhs.lineNr) @cdoc)
  | Group       loc         .   mbCD        =   fmap (chWrap @chWrap) @lines.mbCD
                (lhs.mbCD,loc.gathHideMp)   =   case @chDest of
                                                  ChHere -> (@mbCD,Map.empty)
                                                  h      -> (Just (mkHideNmRef (cd n)),Map.singleton n (HideInfo n i @lhs.seqNr @chDest @mbCD @lhs.chFullNm))
                                                         where (n,i) = case @userRef of
                                                                         Just (r,Just i ) -> (r,cd i)
                                                                         Just (r,Nothing) -> (r,cd r)
                                                                         _                -> (mkNm (show h) `nmApd` mkNm @lhs.seqNr,CDoc_Emp)

SEM Lines
  | Nil         lhs         .   mbCD        =   Nothing
  | Cons        lhs         .   mbCD        =   maybe (@hd.mbCD) (Just . (maybe CDoc_Emp id @hd.mbCD `CDoc_Ver`)) @tl.mbCD

ATTR AllWord [ | | cdoc USE {.|.} {CDoc_Emp} : CDoc ]

SEM Word
  | White Black lhs         .   cdoc        =   cd @chars

SEM Inline
  | URI         lhs         .   cdoc        =   CDoc_Inl @str

-------------------------------------------------------------------------
-- Gathering of hidden text
-------------------------------------------------------------------------

ATTR AllChunk AllLine [ | | gathHideMp USE {`Map.union`} {Map.empty}: HideMp ]

SEM Line
  | Group       lhs         .   gathHideMp  =   @gathHideMp `Map.union` @lines.gathHideMp

-------------------------------------------------------------------------
-- Chunks
-------------------------------------------------------------------------

{
data VerChunkInfo
  = VerChunkInfo
      { vciLineNr   :: Int
      , vciSeqNr    :: Int
      , vciVer      :: Version
      , vciSubNm    :: Nm
      , vciMinusL   :: [ChunkId]
      , vciChKind   :: ChKind
      , vciChDest   :: ChDest
      , vciMbModNm  :: Maybe String
      , vciImps     :: [String]
      , vciExps     :: [String]
      , vciMbCD     :: Maybe CDoc
      , vciXRefL    :: [XRef]
      }
type VerChunkInfoM = [(Version,[VerChunkInfo])]

vciMToL :: VerChunkInfoM -> [VerChunkInfo]
vciMToL = concat . map snd

vciFullNm :: VerChunkInfo -> Nm
vciFullNm i = mkNm (vciVer i) `nmApd` vciSubNm i

instance Eq VerChunkInfo where
  i1 == i2 = vciVer i1 == vciVer i2

instance Ord VerChunkInfo where
  compare i1 i2 = vciVer i1 `compare` vciVer i2

vciSortBySeqNr :: [VerChunkInfo] -> [VerChunkInfo]
vciSortBySeqNr = sortBy (\v1 v2 -> vciSeqNr v1 `compare` vciSeqNr v2)

vciVerFilter :: (Version -> Bool) -> [VerChunkInfo] -> [VerChunkInfo]
vciVerFilter f = filter (f . vciVer)

vciVerGroup :: [VerChunkInfo] -> [[VerChunkInfo]]
vciVerGroup = groupBy (\i1 i2 -> vciVer i1 == vciVer i2)

vciHasImpExp :: VerChunkInfo -> Bool
vciHasImpExp i = not (null (vciImps i) && null (vciExps i))

vciIsPre :: VerChunkInfo -> Bool
vciIsPre = (==VPre) . vciVer

vciIsHS :: VerChunkInfo -> Bool
vciIsHS = (==ChHS) . vciChKind

vciCD :: VerChunkInfo -> CDoc
vciCD = maybe CDoc_Emp id . vciMbCD

vciHasCD :: VerChunkInfo -> Bool
vciHasCD = isJust . vciMbCD

vciSplitPre :: [VerChunkInfo] -> ([VerChunkInfo],[VerChunkInfo])
vciSplitPre = partition vciIsPre

vciTakePre :: VerChunkInfoM -> ([VerChunkInfo],VerChunkInfoM)
vciTakePre is
  = case is of
        ((VPre,p):r) -> (p,r)
        _            -> ([],is)

selectChunks :: Bool -> Opts -> [VerChunkInfo] -> [(Version,[VerChunkInfo])]
selectChunks appMinus opts agl
  = let (pre,nonPre)    = vciSplitPre agl
        availVersions   = nub . sort . map vciVer $ nonPre
        v               = optGenVersion opts
        vo              = optVerOrder opts
        allowedVersions = voAllLE'' (if optsHasNoVerOrder opts then voDefault else vo) v
        vAndVciL        = map (\v -> (v,vciSortBySeqNr . vciVerFilter (==v) $ nonPre)) allowedVersions
        isNotMinused
          = let minuses = if appMinus then [ m | (_,vciL) <- vAndVciL, ml <- map vciMinusL vciL, m <- ml ] else []
             in \i -> (vciVer i,vciSubNm i) `notElem` minuses
     in filter
          ( not.null.snd )
          ( (VPre,pre)
          : map (\(v,vciL) -> (v,filter isNotMinused vciL)) vAndVciL
          )

data Build
  = Build
      { bldBase     :: String
      , bldVer      :: Version
      , bldCD       :: CDoc
      , bldHideCD   :: [(Nm,CDoc)]
      , bldNmChMp   :: NmChMp
      }
}

-------------------------------------------------------------------------
-- Gathering chunk info
-------------------------------------------------------------------------

ATTR AllChunk [ | | verChInfoL USE {++} {[]} : {[VerChunkInfo]} ]

SEM Chunk
  | Ver         loc         .   chInfo      =   VerChunkInfo
                                                    @chunkLineNr @lhs.seqNr
                                                    @version @subNm @minusL
                                                    @chKind @chDest @mbModNm @imports @exports
                                                    @lines.mbCD (Seq.toList @lines.xrefL)
                lhs         .   verChInfoL  =   [@chInfo]

-------------------------------------------------------------------------
-- Line context, in chunks
-------------------------------------------------------------------------

ATTR AllLine AllChunk [ chFullNm: Nm | | ]

SEM Chunk
  | Ver         loc         .   chFullNm    =   vciFullNm @chInfo
  | Named       loc         .   chFullNm    =   nciNm @nmChInfo

SEM AGItf
  | AGItf       loc         .   chFullNm    =   NmEmp

-------------------------------------------------------------------------
-- Selecting and building
-------------------------------------------------------------------------

SEM AGItf
  | AGItf       loc         . selChunks = selectChunks True @lhs.opts @chunks.verChInfoL
                            . selLaTeXChunks
                                        = selectChunks False (@lhs.opts {optGenVersion=VAll}) @chunks.verChInfoL
                            . wrapLhs2tex
                                        = \doWr -> if doWr then chWrap (optWrapLhs2tex @lhs.opts) else id
                            . build     = \bld chunks
                                               -> let fileBase = fromJust (optBaseName @lhs.opts)
                                                      v = optGenVersion @lhs.opts
                                                      d = bld @lhs.opts @wrapLhs2tex fileBase chunks
                                                      m = Map.fromList [ (vciFullNm i,NmChInfo (vciFullNm i) (vciChDest i) (vciMbCD i)) | (_,l) <- chunks, i <- l ]
                                                      h = [ (hiChFullNm h,mkHideNmDef (cd n) (hiDescr h) (cd (hiMbCD h)))
                                                          | (n,h) <- sortBy (\(_,h1) (_,h2) -> hiSeqNr h1 `compare` hiSeqNr h2) . Map.toList $ @chunks.gathHideMp
                                                          ]
                                                   in [Build fileBase v d h m]

-------------------------------------------------------------------------
-- Gen AG
-------------------------------------------------------------------------

{
buildAGImps :: VerChunkInfo -> CDoc
buildAGImps = cdVer . map (\imp -> "INCLUDE \"" .|. imp .|. ".ag\"") . vciImps

buildAG :: Opts -> (Bool -> CDoc -> CDoc) -> String -> VerChunkInfoM -> CDoc
buildAG opts wrap fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        h p  = "{" .-. p .-. "}"
        mk i = if vciIsHS i
               then h (vciCD i)
               else buildAGImps i .-. vciCD i
        ish  = filter vciIsHS noPre'
        pph  = if any vciHasImpExp ish
               then wrap True (h (buildHSModImpExp fileBase ish))
               else CDoc_Emp
        cds  =   map (\i -> let vnm = vciFullNm i
                            in  (wrap (not (vciIsPre i)) (mk i)
                                )
                     )
               . vciSortBySeqNr
               $ noPre'
        d = (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
            .-. pph
            .-. (cdVer cds)
     in d
}

ATTR AGItf [ | | bldAG: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldAG     = @build buildAG @selChunks

-------------------------------------------------------------------------
-- Gen LaTeX
-------------------------------------------------------------------------

{
mkCmdNmDef :: CDoc -> CDoc -> CDoc
mkCmdNmDef = mkTexCmdDef "chunkCmdDef"

mkHideNmDef :: CDoc -> CDoc -> CDoc -> CDoc
mkHideNmDef = mkTexCmd3 "chunkHideDef"

mkHideNmRef :: CDoc -> CDoc
mkHideNmRef = mkTexCmdUse "chunkHideRef"

mkCmdNmUse :: CDoc -> CDoc
mkCmdNmUse = mkTexCmdUse' "chunkCmdUse"

mkCmdInx :: CDoc -> CDoc
mkCmdInx = mkTexCmdUse' "chunkIndex"

mkLabel :: CDoc -> CDoc
mkLabel = mkTexCmdUse' "label"

mkMetaInfo :: CDoc -> String -> CDoc
mkMetaInfo lab fileBase = mkLabel lab -- .-. mkTexCmdDef "chunkMetaDef" lab (cd fileBase)

buildLaTeX :: Opts -> (Bool -> CDoc -> CDoc) -> String -> VerChunkInfoM -> CDoc
buildLaTeX opts wrap fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        versions = nub . map (verRef.vciVer) $ noPre'
        missing = if null versions then []
                                   else [minimum versions .. maximum versions] \\ versions
        mkInx
          = let styleFmt = if optWrapLhs2tex opts == ChWrapCode then "||" else "|"
             in \ix
                 -> let n = foldr1 (\x y -> y ++ "!" ++ x) . xrKeyL $ ix
                        dfmt = CDoc_Emp -- if xrIsDefining ix then text (styleFmt ++ "emph") else CDoc_Emp
                     in mkCmdInx (n .|. dfmt)
        mkContent = let mk = wrap True . vciCD
                     in if optIndex opts
                        then \i -> cdVer (map mkInx (vciXRefL i)) .-. mk i
                        else mk
        ppNoPreL
          =   map (\is -> let vnm = mkNm (vciVer (head is))
                              nm = mkNm fileBase `nmApd` vnm
                              cnm = cd nm
                              (nms,pps)
                                  = unzip
                                    . map (\(nr,i) -> let cn = cd (nm `nmApd` mkNm nr)
                                                          content = mkContent i
                                                       in ( cn
                                                          , mkCmdNmDef cn (mkMetaInfo cn fileBase .-. content)
                                                            .-. (let cna = cd (nm `nmApd` vciSubNm i)
                                                                 in  mkCmdNmDef cna (mkMetaInfo cna fileBase .-. mkCmdNmUse cn)
                                                                )
                                                          )
                                          )
                                    . zip [(0::Int)..]
                                    $ is
                              content = cdVer pps .-. mkCmdNmDef cnm (mkMetaInfo cnm fileBase .-. cdVer (map mkCmdNmUse nms))
                           in (content)
                  )
            . vciVerGroup
            $ noPre'
        d = (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
            .-. cdVer ppNoPreL
            .-. cdVer (map (\v -> mkCmdNmDef (cdDots [cd fileBase,cd v]) CDoc_Emp) missing)
     in d
}

ATTR AGItf [ | | bldLaTeX: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldLaTeX  = @build buildLaTeX @selLaTeXChunks

-------------------------------------------------------------------------
-- Gen Haskell
-------------------------------------------------------------------------

{
mkModNm :: [CDoc] -> CDoc
mkModNm = cdHor

buildHSImps :: [VerChunkInfo] -> CDoc
buildHSImps = cdVer . map (cdVer . map ("import" .#.) . vciImps)

buildHSModuleHead :: String -> [VerChunkInfo] -> CDoc
buildHSModuleHead fileBase is
  = let ise = [ i | i <- is, not (null (vciExps i) && null (vciImps i))]
        e = filter (not.null) . map vciExps $ ise
        m = catMaybes . map vciMbModNm $ ise
        exps = if null e then CDoc_Emp
                         else cdListSepV "( " " )" ", " . map (cdListSep "" "" ", ") $ e
        modNm = if null m then fileBase else head m
     in "module" .#. modNm .-. {- indent 2 -} (exps .-. "where")

buildHSModImpExp :: String -> [VerChunkInfo] -> CDoc
buildHSModImpExp fileBase is = buildHSModuleHead fileBase is .-. buildHSImps is

buildHS :: Opts -> (Bool -> CDoc -> CDoc) -> String -> VerChunkInfoM -> CDoc
buildHS opts wrap fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        ppMod = buildHSModImpExp fileBase (vciMToL is)
        ppNoPreL
          =   map   (\is@(i:_)
                        -> let (pbs)
                                 =   map (\i -> let vnm = vciFullNm i
                                                in  (wrap (vciHasCD i) (vciCD i)
                                                    )
                                         )
                                   $ is
                            in (cdVer pbs)
                    )
            . vciVerGroup . vciSortBySeqNr
            $ noPre'
        isEmpty = all (isNothing.vciMbCD) noPre'
        ppNoPre = cdVer ppNoPreL
        d = if isEmpty
            then CDoc_Emp
            else if optPlain opts
            then ppNoPre
            else (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
                 .-. wrap True ppMod
                 .-. ppNoPre
     in d
}

ATTR AGItf [ | | bldHS: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldHS     = @build buildHS @selChunks

