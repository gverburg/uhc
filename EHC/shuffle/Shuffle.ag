imports
{
import System
import System.Console.GetOpt
import Data.Maybe
import Data.Char
import IO
import Monad
import Array
import Data.List
import qualified Data.Map as Map
import FPath
import Nm
import Utils (tr, trp, wordsBy)
import ParseUtils
{-
import PPUtils
import UU.Pretty
-}
import UU.Parsing
import UU.Parsing.CharParser
import UU.Scanner.Position( initPos, Pos )
import qualified Data.Set as Set
import qualified UU.DData.Seq as Seq
}

-------------------------------------------------------------------------
-- Main
-------------------------------------------------------------------------

{
main :: IO ()
main
  = do { args <- getArgs
       ; let oo@(o,n,errs)  = getOpt Permute cmdLineOpts args
             opts           = foldr ($) defaultOpts o
       ; if optHelp opts
         then putStrLn (usageInfo "Usage shuffle [options] [file|-]\n\noptions:" cmdLineOpts)
         else if null errs
              then  let (f,frest) = if null n then (emptyFPath,[]) else if head n == "-" then (emptyFPath,tail n) else (mkFPath (head n),tail n)
                    in  doCompile f (map mkFPath frest) opts
              else  putStr (head errs)
       }

readShFile :: FPath -> Opts -> IO (String,T_AGItf)
readShFile fp opts
  = do { (fn,fb,fh)
             <- if fpathIsEmpty fp
                then return ("<stdin>","<stdin>",stdin)
                else do { let fn = fpathToStr fp
                        ; h <- openFile fn ReadMode
                        ; return (fn,fpathBase fp,h)
                        }
       ; txt <- hGetContents fh
       ; let toks = scan shuffleScanOpts ScSkip txt
       ; let (pres,perrs) = parseToResMsgs pAGItf toks
       ; if null perrs
         then return (fb,pres)
         else do { mapM_ (hPutStrLn stderr . show) perrs
                 ; exitFailure
                 }
       }

doCompile :: FPath -> [FPath] -> Opts -> IO ()
doCompile fp fpRest opts
  = do { xrefExceptFileContent
           <- case optMbXRefExcept opts of
                Just f -> do c <- readFile f
                             return (Set.unions . map (Set.fromList . words) . lines $ c)
                Nothing -> return Set.empty
       ; allPRes@((fb,pres):restPRes) <- mapM (\f -> readShFile f opts) (fp:fpRest)
       ; let (nmChMp,hdL) = allNmChMpOf allPRes
             res = wrapSem fb xrefExceptFileContent Map.empty pres
             bld = selBld opts res
             topChNmS = Set.unions [ Set.map (mkFullNm fb) . Map.keysSet . bldNmChMp $ b | b <- bld ]
       ; subsChNmS <- putBld nmChMp bld
       ; let allChNmS = subsChNmS `Set.union` topChNmS
             hdL' = [ h | (n,h) <- hdL, n `Set.member` allChNmS ]
       ; putHideBld opts fb nmChMp hdL'
       }
  where mkFullNm b n = mkNm b `nmApd` n
        selBld opts res
          = if optAG opts then bldAG_Syn_AGItf res
            else if optHS opts || optPlain opts then bldHS_Syn_AGItf res
            else bldLaTeX_Syn_AGItf res
        putBld nmChMp b
          = if not (null b)
            then do { let (bs,nms) = unzip . map (cdocSubst nmChMp . bldCD) $ b
                    ; mapM_ (cdPut stdout) bs
                    ; return (Set.unions nms)
                    }
            else return Set.empty
        putHideBld opts fb nmChMp hdL
          = case optChDest opts of
              (ChHere,_) -> return ()
              (ChHide,f) -> do { h <- openFile f' WriteMode
                               ; let d = fst . cdocSubst nmChMp . cdVer $ hdL
                               ; cdPut h d
                               ; hClose h
                               }
                         where f' = if null f then (fb ++ ".hide") else f
        wrapSem fb xr nmChMp pres = wrapAG_T opts fb fp xr nmChMp pres
        allNmChMpOf pres
          = (Map.unions m1,concat m2)
          where (m1,m2)
                  = unzip
                       [ (Map.mapKeys mkN (Map.unions (nMp:bMpL)) `Map.union` nMp,concat hdLL)
                       | (b,pr) <- pres
                       , let mkN = let bn = mkNm b in mkFullNm bn
                             r = wrapSem b Set.empty Map.empty pr
                             nMp = gathNmChMp_Syn_AGItf r
                             (bMpL,hdLL) = unzip [ (bldNmChMp b,[ (mkN n,h) | (n,h) <- bldHideCD b]) | b <- selBld opts r ]
                       ]
}

-------------------------------------------------------------------------------------------
-- Scanning
-------------------------------------------------------------------------------------------

{
data ScanOpts
  =  ScanOpts
        {   scoKeywordsTxt      ::  Set.Set String
        ,   scoSpecChars        ::  Set.Set Char
        ,   scoOpChars          ::  Set.Set Char
        }

type ScanOptsMp = Map.Map ScState ScanOpts

chKindMp = Map.fromList [ ("hs",ChHS), ("ag",ChAG), ("plain",ChPlain) ]
chDestMp = Map.fromList [ ("here",ChHere), ("hide",ChHide) ]

kwTxtAsVarTooA
  = [ "module", "import", "export" ]
    ++ Map.keys chKindMp

kwTxtAsVarTooB
  = kwTxtAsVarTooA
    ++ Map.keys chDestMp

shuffleScanOpts :: ScanOptsMp
shuffleScanOpts
  = Map.fromList
        [ ( ScLexMeta 0
          , ScanOpts
              { scoKeywordsTxt      =   Set.fromList (kwTxtAsVarTooB ++ [ "_", "-", ".", "<", "=" ])
              , scoSpecChars        =   Set.fromList "(),"
              , scoOpChars          =   Set.fromList "+-=*&^%$#@!\\|><~`;:?/_."
              }
          )
        ]

data ScState
  = ScChunk Int | ScLexMeta Int | ScSkip
  deriving Show

instance Eq ScState where
  ScChunk   _ == ScChunk   _ = True
  ScLexMeta _ == ScLexMeta _ = True
  ScSkip      == ScSkip      = True
  _           == _           = False

instance Ord ScState where
  ScChunk   _ < ScLexMeta _ = True
  ScLexMeta _ < ScSkip      = True
  ScChunk   _ < ScSkip      = True
  _           < _           = False

data TokPos
  = TokPos { tkpLine, tkpColumn :: Int }
  deriving (Eq,Ord)

instance Show TokPos where
  show (TokPos l c) = if l < 0 || c < 0 then "" else "(" ++ show l ++ ":" ++ show c ++ ")"

tkpStart :: TokPos
tkpStart = TokPos 1 1

tkpNone :: TokPos
tkpNone = TokPos (-1) (-1)

data TokKind
  = TKBegChunk | TKBegGroup | TKEndChunk | TKNameRef | TKNl | TkText | TkInt | TkStr | TkEOF | TkReserved
  deriving (Show,Eq,Ord)

data Tok
  = Tok { tokKind :: TokKind, tokWhite :: String, tokBlack :: String, tokPos :: TokPos, tokState :: ScState }

instance Eq Tok where
  (Tok k1 _ b1 _ _) == (Tok k2 _ b2 _ _) = k1 == k2 && (k1 /= TkReserved || b1 == b2)

instance Ord Tok where
  (Tok k1 _ b1 _ _) `compare` (Tok k2 _ b2 _ _)
    = if ck == EQ
      then if k1 == TkReserved then b1 `compare` b2 else ck
      else ck
    where ck = k1 `compare` k2

instance Show Tok where
  show t = show (tokPos t) ++ show (tokBlack t)

instance Symbol Tok

isVarStart :: Char -> Bool
isVarStart c = c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'

isVarRest :: Char -> Bool
isVarRest c = isVarStart c || isDigit c || c `elem` "'_"

isWhite :: Char -> Bool
isWhite = (`elem` " \t")

isLF :: Char -> Bool
isLF = (`elem` "\n\r")

isBlack :: Char -> Bool
isBlack c = not (isWhite c || isLF c)

isStrQuote :: Char -> Bool
isStrQuote c = c == '"'

isStr :: Char -> Bool
isStr c = not (isStrQuote c || isLF c)

scan :: ScanOptsMp -> ScState -> String -> [Tok]
scan scoMp st s
  = takeWhile ((/=TkEOF) . tokKind) (sc tkpStart st s)
  where sc p st             ""                      = [Tok TkEOF "" "" p st]
        sc p st@(ScChunk _) s@(c:_)
          | isWhite c                               = t {tokWhite = w} : ts
                                                    where (w,s') = span isWhite s
                                                          (t:ts) = sc (a w p) st s'
        sc p st@(ScLexMeta _) s@(c:_)
          | isWhite c                               = sc (a w p) st s'
                                                    where (w,s') = span isWhite s
        sc p st             s@(c:s')
          | isLF c                                  = Tok TKNl       ""   [c] p st : sc (al p) st' s'
                                                    where st' = case st of
                                                                  ScLexMeta l -> ScChunk l
                                                                  _           -> st
        sc p st@(ScLexMeta _) s@(c:s')
          | isSpec st c                             = Tok TkReserved ""   [c] p st : sc (ai 1 p) st s'
        sc p st@(ScLexMeta _) s@(c:_)
          | isVarStart c                            = scKw isVarRest p st s
        sc p st@(ScLexMeta _) s@(c:_)
          | isDigit c                               = Tok TkInt      ""   w   p st : sc (a w p) st s'
                                                    where (w,s') = span isDigit s
        sc p st@(ScLexMeta _) s@(c:s')
          | isStrQuote c                            = Tok TkStr      ""   w   p st : sc (a w . ai 2 $ p) st s3
                                                    where (w,s2) = span isStr s'
                                                          s3 = case s2 of
                                                                 (c:s) | isStrQuote c -> s
                                                                 _                    -> s2
        sc p st@(ScLexMeta _) s@(c:_)
          | isOpch st c                             = scKw (isOpch st) p st s
        sc p@(TokPos _ 1) st@(ScChunk l)    s@('%':'%':'[':'[':s')
                                                    = Tok TKBegGroup "" "%%[[" p st : sc (ai 4 p) (ScLexMeta (l+1)) s'
        sc p@(TokPos _ 1) ScSkip            s@('%':'%':'[':s')
                                                    = Tok TKBegChunk "" "%%["  p ScSkip  : sc (ai 3 p) (ScLexMeta 0) s'
        sc p@(TokPos _ 1) st@(ScChunk l)    s@('%':'%':']':s')
          | l == 0                                  = Tok TKEndChunk "" "%%]"  p st : sc (ai 3 p) ScSkip s'
          | l >  0                                  = Tok TKEndChunk "" "%%]"  p st : sc (ai 3 p) (ScChunk (l-1)) s'
        sc p@(TokPos _ 1) st@(ScChunk l)    s@('%':'%':'@':s')
                                                    = Tok TKNameRef  "" "%%@"  p st : sc (ai 3 p) (ScLexMeta l) s'
        sc p st@(ScChunk _) s@(c:_)
          | isBlack c                               = Tok TkText     ""   b   p st : sc (a b p) st s'
                                                    where (b,s') = span isBlack s
        sc p st             s@(c:s')                = sc (ai 1 p) st s'
        scKw f p st s                               = Tok tk         ""   w   p st  : sc (a w p) st s'
                                                    where (w,s') = span f s
                                                          tk = if isKeyw st w then TkReserved else TkText
        a s                                         = ai (length s)
        ai i p                                      = p {tkpColumn = i + tkpColumn p}
        al   p                                      = p {tkpLine = 1 + tkpLine p, tkpColumn = 1}
        opt st p                                    = maybe False p $ Map.lookup st scoMp
        isSpec st c                                 = opt st (\o -> c `Set.member` scoSpecChars o)
        isOpch st c                                 = opt st (\o -> c `Set.member` scoOpChars o)
        isKeyw st w                                 = opt st (\o -> w `Set.member` scoKeywordsTxt o)

pBegChunk, pBegGroup, pEndChunk, pBegNameRef, pNl :: (IsParser p Tok) => p Tok
pBegChunk   = pSym (Tok TKBegChunk "" "%%["  tkpNone ScSkip)
pBegGroup   = pSym (Tok TKBegGroup "" "%%[[" tkpNone ScSkip)
pEndChunk   = pSym (Tok TKEndChunk "" "%%]"  tkpNone ScSkip)
pBegNameRef = pSym (Tok TKNameRef  "" "%%@"  tkpNone ScSkip)
pNl         = pSym (Tok TKNl       "" "LF"   tkpNone ScSkip)

pKey :: (IsParser p Tok) => String -> p String
pKey k = tokBlack <$> pSym (Tok TkReserved "" k tkpNone ScSkip)

pVar :: (IsParser p Tok) => p String
pVar = tokBlack <$> pSym (Tok TkText "" "<ident>" tkpNone ScSkip)

pInt :: (IsParser p Tok) => p String
pInt = tokBlack <$> pSym (Tok TkInt "" "0" tkpNone ScSkip)

pInt' :: (IsParser p Tok) => p Int
pInt' = read <$> pInt

pStr :: (IsParser p Tok) => p String
pStr = tokBlack <$> pSym (Tok TkStr "" "<string>" tkpNone ScSkip)

pBlack :: (IsParser p Tok) => p (Maybe String,String)
pBlack = (\(Tok _ w b _ _) -> (if null w then Nothing else Just w,b)) <$> pSym (Tok TkText "" "<text>" tkpNone ScSkip)
}


-------------------------------------------------------------------------
-- Parsing
-------------------------------------------------------------------------

{
parseHandle :: ShPr a -> FilePath -> Handle -> IO a
parseHandle p fn fh
  = do { txt <- hGetContents fh
       ; let toks = scan shuffleScanOpts ScSkip txt
       ; parseIOMessage show p toks
       }
}

-------------------------------------------------------------------------
-- New Parser
-------------------------------------------------------------------------

{
type ShPr  c = (IsParser p Tok) => p c
type ShPr2 c = (IsParser p Tok) => p c -> p c
type ShPr3 c = (IsParser p Tok) => p c -> p c -> p c

mkNmForP :: String -> [String] -> Nm
mkNmForP h t = nmFromL . concat . map (wordsBy (=='.')) $ (h : t)

pAGItf :: ShPr T_AGItf
pAGItf = sem_AGItf_AGItf <$> (sem_Lines_Nil <$ pList pNl) <*> pChunks

pVersion            ::  ShPr Version
pVersion            =   mkVerFromIntL <$> pList1Sep (pKey "_") pInt'

pVerOrder           ::  ShPr VersionOrder
pVerOrder           =   pListSep (pKey ",") (pList1Sep (pKey "<") pVersion)

pNm2                ::  ShPr Nm
pNm2                =   mkNmForP <$> p <*> pList (pKey "." *> (p <|> pInt))
                    where p = foldl1 (<|>) (map pKey kwTxtAsVarTooA) <|> pVar

pNm                 ::  ShPr Nm
pNm                 =   mkNmForP <$> pVar <*> pList (pKey "." *> (pVar <|> pInt))

pId, pIdNest, pIdNest2, pIdNestPart :: ShPr String
pId                 =   (\h t -> concat . intersperse "." $ h : t) <$> pVar <*> pList (pKey "." *> (pVar <|> pInt))
pIdNest             =   (concat . intersperse " ") <$> pList1 pIdNestPart
pIdNest2            =   (concat . intersperse " ") <$> pList1 (pIdNestPart <|> foldl1 (<|>) (map pKey kwTxtAsVarTooB))
pIdNestPart         =   pId
                    <|> (\l -> "(" ++ concat (intersperse "," l) ++ ")") <$> pParens pIdNests2
                    <|> pStr

pIdNests, pIdNests2 ::  ShPr [String]
pIdNests            =   pListSep (pKey ",") pIdNest
pIdNests2           =   pListSep (pKey ",") pIdNest2

pChunkId            ::  ShPr ChunkId
pChunkId            =   pVersion <+> (pKey "." *> pNm)

pParens             ::  ShPr2 p
pParens p           =   pKey "(" *> p <* pKey ")"

pChunks             ::  ShPr T_Chunks
pChunks             =   pFoldr (sem_Chunks_Cons,sem_Chunks_Nil) pChunk

pChunk              ::  ShPr T_Chunk 
pChunk              =   pBegChunk
                         *> ((   sem_Chunk_Ver
                                 <$> pVersion
                                 <*> pMaybe NmEmp id (pKey "." *> pNm)
                                 <*> (pKey "-" *> ((:[]) <$> pChunkId <|> pParens (pList1 pChunkId)) <|> pSucceed [])
                                 <*> pMaybe ChAG id pChKind
                                 <*> pMbChDest
                                 <*> (Just <$ pKey "module" <*> pId <|> pSucceed Nothing)
                                 <*> (pKey "import" *> pParens pIdNests2 <|> pSucceed [])
                                 <*> (pKey "export" *> pParens pIdNests2 <|> pSucceed [])
                             <|> sem_Chunk_Named
                                 <$> pNm
                             )
                             <*  pNl
                             <*> pLines
                             <*  pEndChunk
                             <*> pLines
                            )
                    <?> "a chunk"

pChKind             ::  ShPr ChKind
pChKind             =   pAnyFromMap pKey chKindMp

pChDest             ::  ShPr ChDest
pChDest             =   pAnyFromMap pKey chDestMp

pMbChDest           ::  ShPr ChDest
pMbChDest           =   pMaybe ChHere id pChDest

pLines              ::  ShPr T_Lines
pLines              =   pFoldr (sem_Lines_Cons,sem_Lines_Nil) pLine

pLine               ::  ShPr T_Line
pLine               =   sem_Line_AsIs  <$> pLineChars  <*  pNl
                    <|> (\n (d,r) -> sem_Line_Group d r (sem_Lines_Cons (sem_Line_Named n) sem_Lines_Nil))
                                       <$  pBegNameRef <*> pN <*> pD <* pNl
                    <|> (\(d,r) l -> sem_Line_Group d r l)
                                       <$  pBegGroup   <*> pD <* pNl <*> pLines <* pEndChunk <* pNl
                    <?> "a line"
                    where pN =   pNm
                             <|> (\v n -> mkNm v `nmApd` n) <$> pVersion <*> pMaybe NmEmp id (pKey "." *> pNm)
                          pD =   pMbChDest <+> pMaybe Nothing Just ((pNm2 <|> mkNm <$> pStr) <+> pMaybe Nothing Just (pKey "=" *> pMaybe "" id pStr))

pLineChars          ::  ShPr T_Words
pLineChars          =   (foldr sem_Words_Cons sem_Words_Nil . concat)
                        <$> pList ((\(mw,b) -> maybe [] (\w -> [sem_Word_White w]) mw ++ [sem_Word_Black b]) <$> pBlack)
}

-------------------------------------------------------------------------
-- Parser
-------------------------------------------------------------------------

{
parseAndGetRes :: ShPr a -> String -> a
parseAndGetRes p s
  = case evalSteps (parse p toks) of {Pair v _ -> v}
  where toks = scan shuffleScanOpts (ScLexMeta 0) s
}

-------------------------------------------------------------------------
-- Options
-------------------------------------------------------------------------

{
data Opts 
  = Opts
      { optAG           :: Bool
      , optHS           :: Bool
      , optPlain        :: Bool
      , optLaTeX        :: Bool
      , optPreamble     :: Bool
      , optIndex        :: Bool
      , optHelp         :: Bool
      , optChDest       :: (ChDest,String)
      , optGenVersion   :: Version
      , optBaseName     :: Maybe String
      , optWrapLhs2tex  :: Bool
      , optMbXRefExcept :: Maybe String
      , optVerOrder     :: VersionOrder
      }

defaultOpts
  = Opts
      { optAG           =  False
      , optHS           =  False
      , optLaTeX        =  False
      , optPreamble     =  True
      , optPlain        =  False
      , optIndex        =  False
      , optHelp         =  False
      , optChDest       =  (ChHere,"")
      , optGenVersion   =  VNone
      , optBaseName     =  Nothing
      , optWrapLhs2tex  =  True
      , optMbXRefExcept =  Nothing
      , optVerOrder     =  [[]]
      }

optsHasNoVerOrder :: Opts -> Bool
optsHasNoVerOrder = null . head . optVerOrder

cmdLineOpts  
  =  [  Option "a"  ["ag"]              (NoArg oAG)
          "generate code for ag, default=no"
     ,  Option "h"  ["hs"]              (NoArg oHS)
          "generate code for haskell, default=no"
     ,  Option "l"  ["latex"]           (NoArg oLaTeX)
          "generate code for latex, default=no"
     ,  Option ""   ["preamble"]        (OptArg oPreamble "yes|no")
          "include preamble (marked by version=0), default=yes"
     ,  Option "p"  ["plain"]           (NoArg oPlain)
          "generate plain code, default=no"
     ,  Option ""   ["index"]           (NoArg oIndex)
          "combined with latex, generate index entries, default=no"
     ,  Option "g"  ["gen"]             (ReqArg oGen "all|<nr>")
          "generate for version, default=none"
     ,  Option ""   ["hidedest"]        (ReqArg oHideDest "here|appx=<file>")
          "destination of text marked as 'hide', default=here"
     ,  Option ""   ["order"]           (ReqArg oVerOrder "<order-spec>")
          "version order"
     ,  Option "b"  ["base"]            (ReqArg oBase "<name>")
          "base name, default=derived from filename"
     ,  Option ""   ["xref-except"]     (ReqArg oXRefExcept "<filename>")
          "file with list of strings not to be cross ref'd"
     ,  Option ""   ["help"]            (NoArg oHelp)
          "output this help"
     ,  Option ""   ["lhs2tex"]         (OptArg oLhs2tex "yes|no")
          "wrap chunks in lhs2tex's code environment, default=yes"
     ]
  where  oAG             o =  o {optAG = True}
         oHS             o =  o {optHS = True}
         oPreamble   ms  o =  yesno (\f o -> o {optPreamble = f}) ms o
         oLaTeX          o =  o {optLaTeX = True}
         oPlain          o =  o {optPlain = True}
         oIndex          o =  o {optIndex = True}
         oLhs2tex    ms  o =  yesno (\f o -> o {optWrapLhs2tex = f}) ms o
         oBase        s  o =  o {optBaseName = Just s}
         oVerOrder    s  o =  o {optVerOrder = parseAndGetRes pVerOrder s}
         oXRefExcept  s  o =  o {optMbXRefExcept = Just s}
         oGen         s  o =  case s of
                                "all"               -> o {optGenVersion = VAll}
                                (c:_) | isDigit c   -> o {optGenVersion = parseAndGetRes pVersion s}
                                _                   -> o {optGenVersion = VAll}
         oHideDest    s  o =  case s of
                                "here"                  -> o
                                ('a':'p':'p':'x':'=':f) -> o {optChDest = (ChHide,f)}
                                _                       -> o
         oHelp           o =  o {optHelp = True}
         yesno updO  ms  o =  case ms of
                                Just "yes"  -> updO True o
                                Just "no"   -> updO False o
                                _           -> o


}

-------------------------------------------------------------------------
-- Inferfacing
-------------------------------------------------------------------------

WRAPPER AGItf

{
wrapAG_T :: Opts -> String -> FPath -> XRefExcept -> NmChMp -> T_AGItf -> Syn_AGItf
wrapAG_T opts fb fp xr nmChMp pres
  = wrap_AGItf pres
      (Inh_AGItf
         { opts_Inh_AGItf = opts {optBaseName = maybe (Just fb) Just (optBaseName opts)}
         , fpath_Inh_AGItf = fp
         , xrefExcept_Inh_AGItf = xr
         , nmChMp_Inh_AGItf = nmChMp
         })
}

WRAPPER AGCDocItf

{
wrapAGCDoc_T :: NmChMp -> T_AGCDocItf -> Syn_AGCDocItf
wrapAGCDoc_T nmChMp d
  = wrap_AGCDocItf d
      (Inh_AGCDocItf
         { nmChMp_Inh_AGCDocItf = nmChMp
         })

wrapCDoc :: NmChMp -> CDoc -> Syn_AGCDocItf
wrapCDoc m d = wrapAGCDoc_T m (sem_AGCDocItf (AGCDocItf_AGItf d))

cdocSubst :: NmChMp -> CDoc -> (CDoc,Set.Set Nm)
cdocSubst m d
  = (sbRepl_Syn_AGCDocItf r,sbCRefS_Syn_AGCDocItf r)
  where r = wrapCDoc m d
}

-------------------------------------------------------------------------
-- AST
-------------------------------------------------------------------------

-- Outside itf
DATA AGItf
  | AGItf               dumLines    : Lines
                        chunks      : Chunks

DATA AGCDocItf
  | AGItf               cdoc        : CDoc

-- Chunk
DATA Chunk
  | Ver                 version     : {Version}
                        subNm       : {Nm}
                        minusL      : {[ChunkId]}
                        chKind      : {ChKind}
                        chDest      : {ChDest}
                        mbModNm     : {Maybe String}
                        imports     : {[String]}
                        exports     : {[String]}
                        lines       : Lines
                        dumLines    : Lines
  | Named               cref        : {CRef}
                        lines       : Lines
                        dumLines    : Lines

TYPE Chunks     = [Chunk]

SET AllChunk    = Chunk Chunks

-- Single line
DATA Line
  | AsIs                words       : Words
  | Named               cref        : {CRef}
  | Group               chDest      : {ChDest}
                        userRef     : {Maybe (Nm,Maybe String)}
                        lines       : Lines

TYPE Lines      = [Line]

SET AllLine     = Line Lines

-- Single word
DATA Word
  | White               chars       : {String}
  | Black               chars       : {String}

TYPE Words      = [Word]

SET AllWord     = Word Words

-- Chunk doc
DATA CDoc
  | Emp
  | Ref                 cref        : {CRef}
                        chDest      : {ChDest}
  | Str                 str         : {String}
  | Hor                 ldoc        : CDoc
                        rdoc        : CDoc
  | Ver                 ldoc        : CDoc
                        rdoc        : CDoc

-- Sets
SET AllNT       = AllWord AllLine AllChunk

-------------------------------------------------------------------------
-- Global info
-------------------------------------------------------------------------

ATTR AGItf [ opts: Opts  fpath: FPath | | ]

-------------------------------------------------------------------------
-- Chunk ref
-------------------------------------------------------------------------

{
type CRef = Nm
}

-------------------------------------------------------------------------
-- Common. Version
-------------------------------------------------------------------------

{
data Version    = VAll
                | VPre
                | VNone
                | VRef {verRef :: Int}
                | VNest {verNest :: Version, verRef :: Int}
                deriving (Show,Eq,Ord)

type VersionOrder = [[Version]]

mkVerFromInt :: Int -> Version
mkVerFromInt r = if r == 0 then VPre else VRef r

mkVerFromIntL :: [Int] -> Version
mkVerFromIntL (0:_)  = mkVerFromInt 0
mkVerFromIntL (i:is) = foldl VNest (VRef i) is

instance NM Version where
  mkNm VPre           = mkNm "pre"
  mkNm VAll           = mkNm "*"
  mkNm VNone          = mkNm "-"
  mkNm (VRef r)       = mkNm r
  mkNm (VNest n r)    = mkNm n `nmApd` mkNm r

instance CD Version where
  cd = cd . mkNm

verMatch :: Version -> Version -> Bool
verMatch VAll           _               = True
verMatch _              VAll            = True
verMatch (VRef r1)      (VRef r2)       = r1 == r2
verMatch (VNest n1 r1)  (VNest n2 r2)   = r1 == r2 && n1 == n2
verMatch VPre           VPre            = True
verMatch _              _               = False

cmpByVersionOrder :: VersionOrder -> Version -> Version -> Ordering
cmpByVersionOrder vo v1 v2
  = maybe EQ id . listToMaybe . catMaybes . map c $ vo
  where  c o = do { i1 <- elemIndex v1 o
                  ; i2 <- elemIndex v2 o
                  ; return (compare i1 i2)
                  }

voAllLE :: VersionOrder -> Version -> [Version]
voAllLE vo v
  = sortBy (cmpByVersionOrder vo)
  . nub . sort . concat
  . (case v of
      VAll -> id
      _    -> map (\o -> maybe [] (\i -> take (i+1) o) (elemIndex v o))
    )
  $ vo

voAllLE' :: VersionOrder -> Version -> [Version]
voAllLE' vo v
  = let voPrefixes
          = map (\p@((v,_):_) -> (v,map snd p))
          . groupBy (\(v1,_) (v2,_) -> v1 == v2)
          . sortBy (\(v1,_) (v2,_) -> compare v1 v2)
          . concat . map (\o -> zip o (inits o))
          $ vo
        all
          = case v of
              VAll -> concat vo
              _    -> maybe [] concat (lookup v voPrefixes)
     in sortBy (cmpByVersionOrder vo) . nub . sort $ all

voAllLE'' :: VersionOrder -> Version -> [Version]
voAllLE'' vo v
  = let allN = nub . sort . concat $ vo
        nrN = length allN
        nsN = [(0::Int)..nrN-1]
        ixOf' v = elemIndex v allN
        ixOf v = maybe 0 id (ixOf' v)
        voPrefixes
          = map (\p@((v,_):_) -> (ixOf v,map ixOf . nub . sort . (v:) . concat . map snd $ p))
          . groupBy (\(v1,_) (v2,_) -> v1 == v2)
          . sortBy (\(v1,_) (v2,_) -> compare v1 v2)
          . concat . map (\o -> zip o (inits o))
          $ vo
        m1 = map
                (\(n,ns)
                    -> map snd . sort $ (zip (ns) (repeat True) ++ zip (nsN \\ ns) (repeat False))
                )
                voPrefixes
        m2 = array (0,nrN-1) (zip nsN (map (\r -> array (0,nrN-1) (zip nsN r)) m1))
        m3 = foldr
                (\n m
                    -> foldr
                        (\i m -> m // [(i,m ! i // [ (j,m ! i ! n && m ! n ! j || m ! i ! j) | j <- nsN ])])
                        m nsN
                )
                m2 nsN
        nsV = maybe [] (\i -> assocs (m3 ! i)) (ixOf' v)
        allN' = case v of
                  VAll -> allN
                  _    -> [ allN !! i | (i,b) <- nsV, b ]
     in sortBy (cmpByVersionOrder vo) . nub . sort $ allN'

voDefault :: VersionOrder
voDefault = [take 30 (map VRef [1..])]

}

-------------------------------------------------------------------------
-- Chunk id
-------------------------------------------------------------------------

{
type ChunkId = (Version,Nm)
}

-------------------------------------------------------------------------
-- Chunk kind, purpose/destination
-------------------------------------------------------------------------

{
data ChKind
  = ChAG | ChHS | ChPlain
  deriving (Show,Eq,Ord)

data ChDest
  = ChHere | ChHide
  deriving (Show,Eq,Ord)
}

-------------------------------------------------------------------------
-- Chunk doc utils
-------------------------------------------------------------------------

{
cdHor :: CD a => [a] -> CDoc
cdHor = foldr CDoc_Hor CDoc_Emp . map cd

cdVer :: CD a => [a] -> CDoc
cdVer = foldr CDoc_Ver CDoc_Emp . map cd

{-
-}
cdLines :: CDoc -> [String]
cdLines d
  = lns d
  where ln l CDoc_Emp = (l,CDoc_Emp)
        ln l (CDoc_Str s) = (s:l,CDoc_Emp)
        ln l (CDoc_Hor d1 d2)
          = case ln l d1 of
              (l1,CDoc_Emp) -> ln l1 d2
              r             -> r
        ln l (CDoc_Ver d1 d2)
          = case ln l d1 of
              (l1,CDoc_Emp) -> (l1,d2)
              (l1,dr)       -> (l1,CDoc_Ver dr d2)
        lns CDoc_Emp = []
        lns d = let (l,d') = ln [] d in concat (reverse l) : lns d'

cdPut' :: Handle -> CDoc -> IO ()
cdPut' h = mapM_ (hPutStrLn h) . cdLines

cdPut :: Handle -> CDoc -> IO ()
cdPut h d
  = case d of
      CDoc_Emp              -> return ()
      CDoc_Str s            -> hPutStr h s
      CDoc_Ref r d          -> hPutStr h ("<<<<" ++ show r ++ ">>>>")
      CDoc_Hor d1 d2        -> do cdPut h d1
                                  cdPut h d2
      CDoc_Ver CDoc_Emp d2  -> cdPut h d2
      CDoc_Ver d1 CDoc_Emp  -> cdPut h d1
      CDoc_Ver d1 d2        -> do cdPut h d1
                                  hPutStrLn h ""
                                  cdPut h d2

class CD a where
  cd :: a -> CDoc

instance CD String where
  cd "" = CDoc_Emp
  cd s  = CDoc_Str s

instance CD Int where
  cd = CDoc_Str . show

instance CD CDoc where
  cd = id

instance CD Nm where
  cd = cdDots . nmToL

instance CD a => CD (Maybe a) where
  cd = maybe CDoc_Emp cd

infixr 2 .-.
infixr 3 .|. , .#.

(.|.) :: (CD a, CD b) => a -> b -> CDoc
(.|.) a b = cd a `CDoc_Hor` cd b

(.-.) :: (CD a, CD b) => a -> b -> CDoc
(.-.) a b = cd a `CDoc_Ver` cd b

(.#.) :: (CD a, CD b) => a -> b -> CDoc
(.#.) a b = cd a .|. " " .|. cd b

cdListSep' :: (CD s, CD c, CD o, CD a) => (forall x . CD x => [x] -> CDoc) -> (forall x y . (CD x, CD y) => x -> y -> CDoc) -> o -> c -> s -> [a] -> CDoc
cdListSep' list aside o c s pps
  = l pps
  where l []      = o `aside` c
        l [p]     = o `aside` p `aside` c
        l (p:ps)  = list ([o `aside` p] ++ map (s `aside`) (init ps) ++ [s `aside` last ps `aside` c])

cdListSep :: (CD s, CD c, CD o, CD a) => o -> c -> s -> [a] -> CDoc
cdListSep = cdListSep' cdHor (.|.)

cdListSepV :: (CD s, CD c, CD o, CD a) => o -> c -> s -> [a] -> CDoc
cdListSepV = cdListSep' cdVer (.|.)

cdDots :: CD a => [a] -> CDoc
cdDots = cdListSep "" "" "."

}

-------------------------------------------------------------------------
-- Utils
-------------------------------------------------------------------------

{
mkTexCmd1 :: CD a => String -> a -> CDoc
mkTexCmd1 cmd a1 = "\\" .|. cmd .|. "{" .|. cd a1 .|. "}"

mkTexCmd2 :: (CD a, CD b) => String -> a -> b -> CDoc
mkTexCmd2 cmd a1 a2 = "\\" .|. cmd .|. "{" .|. cd a1 .|. "}{%" .-. cd a2 .-. "}"

mkTexCmd3 :: (CD a, CD b, CD c) => String -> a -> b -> c -> CDoc
mkTexCmd3 cmd a1 a2 a3 = "\\" .|. cmd .|. "{" .|. cd a1 .|. "}{%" .-. cd a2 .-. "}{%" .-. cd a3 .-. "}"

mkTexCmdDef :: (CD a, CD b) => String -> a -> b -> CDoc
mkTexCmdDef = mkTexCmd2

mkTexCmdUse :: CD a => String -> a -> CDoc
mkTexCmdUse = mkTexCmd1

mkTexCmdUse' :: CD a => String -> a -> CDoc
mkTexCmdUse' cmd nm = mkTexCmdUse cmd nm .|. "%"
}

-------------------------------------------------------------------------
-- Sequence nr (for ordering when printing)
-------------------------------------------------------------------------

ATTR AllChunk AllLine [ | seqNr: Int | ]

SEM AGItf
  | AGItf       dumLines    .   seqNr       =   1

SEM Chunks
  | Cons        hd          .   seqNr       =   @lhs.seqNr + 1

SEM Line
  | Group       lines       .   seqNr       =   @lhs.seqNr + 1

-------------------------------------------------------------------------
-- Line counting, column counting (not kept correct for groups, not used anymore)
-------------------------------------------------------------------------

ATTR AllChunk AllLine [ | lineNr: Int | ]
ATTR AllWord [ | colNr: Int | ]

SEM AGItf
  | AGItf       dumLines    . lineNr    = 1

SEM Lines
  | Cons        tl          . lineNr    = @lhs.lineNr + 1

SEM Chunk
  | Ver Named   loc         . chunkLineNr
                                        = @lhs.lineNr + 1
                lines       . lineNr    = @chunkLineNr
                dumLines    . lineNr    = @lines.lineNr + 1

SEM Line
  | AsIs        words       . colNr     = 0

SEM Word
  | White Black loc         . wordColNr = @lhs.colNr
                lhs         . colNr     = @lhs.colNr + length @chars

-------------------------------------------------------------------------
-- Left + right context
-------------------------------------------------------------------------

ATTR Words [ lCtxt: {[String]}  lAllCtxt: {[String]} | | rCtxt: {[String]} ]
ATTR Word [ | lCtxt: {[String]}  lAllCtxt: {[String]}  rCtxt: {[String]} | ]

SEM Line
  | AsIs        words       . lCtxt     = []
                            . lAllCtxt  = []

SEM Words
  | Nil         lhs         . rCtxt     = []
  | Cons        hd          . rCtxt     = @tl.rCtxt
                lhs         . rCtxt     = @hd.rCtxt

SEM Word
  | Black       lhs         . rCtxt     = @chars : @lhs.rCtxt
                            . lCtxt     = @chars : @lhs.lCtxt
                            . lAllCtxt  = @chars : @lhs.lAllCtxt
  | White       lhs         . lAllCtxt  = @chars : @lhs.lAllCtxt

-------------------------------------------------------------------------
-- Cross ref
-------------------------------------------------------------------------

{
data XRefKind = XRHsDef | XRAgAttrDef | XRAgAltDef | XRAgSemDef | XRHsUse | XRAgAttrUse deriving Show
data XRef = XRef { xrKind :: XRefKind, xrKeyL :: [String] } deriving Show

xrMainKey :: XRef -> String
xrMainKey = head . xrKeyL

xrKindIsDefining :: XRefKind -> Bool
xrKindIsDefining XRHsDef = True
xrKindIsDefining XRAgAttrDef = True
xrKindIsDefining XRAgAltDef = True
xrKindIsDefining XRAgSemDef = True
xrKindIsDefining _ = False

xrIsDefining :: XRef -> Bool
xrIsDefining = xrKindIsDefining . xrKind

type XRefL = Seq.Seq XRef
type XRefExcept = Set.Set String

passXR :: XRefExcept -> String -> ([XRef],Int) -> ([XRef],Int)
passXR exc r xr = if Set.member r exc then ([],0) else xr
}

ATTR AGItf AllNT [ xrefExcept: XRefExcept | | ]
ATTR AllWord AllLine [ | | xrefL USE {`Seq.append`} {Seq.empty} : XRefL ]
ATTR Word [ | rCtxtUsed: Int | ]
ATTR Words [ rCtxtUsed: Int | | ]

SEM Word
  | Black       (loc.xrefL,lhs.rCtxtUsed)
                                        = let ctxtHuge = 10000000
                                              loclhs = ["lhs","loc"]
                                              none = ([],@lhs.rCtxtUsed - 1)
                                              def nms k cUsed
                                                   = if any (flip Set.member @lhs.xrefExcept) nms then ([],0) else ([XRef k nms],cUsed)
                                           in if @lhs.rCtxtUsed <= 0 && isAlpha (head @chars)
                                              then case (@lhs.lAllCtxt,@lhs.lCtxt,@chars,@lhs.rCtxt) of
                                                     (_,("@":_),nm1,(".":nm2:_))
                                                       | nm1 `elem` loclhs          -> def [nm2] XRAgAttrUse 2
                                                     (_,("@":_),nm1,(".":nm2:_))    -> def [nm2,nm1] XRAgAttrUse 2
                                                     (_,("@":_),nm1,_)              -> def [nm1] XRAgAttrUse 0
                                                     (_,("|":_),nm1,_)              -> def [nm1] XRAgAltDef 0
                                                     (_,(".":ll:_),nm1,("=":_))
                                                       | ll `elem` loclhs           -> def [nm1] XRAgAttrDef 1
                                                     (_,(".":nm2:_),nm1,("=":_))    -> def [nm1,nm2] XRAgAttrDef 1
                                                     (_,_,nm1,([sep]:nm2:_))
                                                       | sep `elem` "._"            -> def [nm2,nm1] XRHsUse 2
                                                       | otherwise                  -> none
                                                     (_,["SEM"],nm1,_)              -> def [nm1] XRAgSemDef ctxtHuge
                                                     (_,["data"],nm1,_)             -> def [nm1] XRHsDef 0
                                                     (_,["type"],nm1,_)             -> def [nm1] XRHsDef 0
                                                     ([],_,nm1,_)                   -> def [nm1] XRHsDef ctxtHuge
                                                     (_,_,nm1,_)
                                                       | nm1 `notElem` loclhs       -> def [nm1] XRHsUse 0
                                                     _                              -> none
                                              else none
                lhs         . xrefL     = Seq.fromList @xrefL
  | White       lhs         . rCtxtUsed = 0

SEM Line
  | AsIs        words       . rCtxtUsed = 0

-------------------------------------------------------------------------
-- Named chunks
-------------------------------------------------------------------------

{
data NmChInfo
  = NmChInfo
      { nciNm       :: CRef
      , nciChDest   :: ChDest
      , nciMbCD     :: Maybe CDoc
      }

type NmChMp = Map.Map CRef NmChInfo
}

ATTR AllChunk AGItf [ | | gathNmChMp USE {`Map.union`} {Map.empty}: NmChMp ]
ATTR AllChunk AllLine AGCDocItf AGItf CDoc [ nmChMp: NmChMp | | ]

SEM Chunk
  | Named       loc         .   chInfo      =   NmChInfo @cref ChHere @lines.mbCD
                lhs         .   gathNmChMp  =   Map.singleton @cref @chInfo

SEM AGItf
  | AGItf       chunks      .   nmChMp      =   @chunks.gathNmChMp `Map.union` @lhs.nmChMp
                dumLines    .   nmChMp      =   Map.empty

-------------------------------------------------------------------------
-- Adm for hideable groups of lines
-------------------------------------------------------------------------

{
data HideInfo
  = HideInfo
      { hiNm        :: Nm
      , hiDescr     :: CDoc
      , hiSeqNr     :: Int
      , hiChDest    :: ChDest
      , hiMbCD      :: Maybe CDoc
      , hiChFullNm  :: Nm
      }

type HideMp = Map.Map Nm HideInfo
}

-------------------------------------------------------------------------
-- Content replica, CDoc
-------------------------------------------------------------------------

ATTR AllLine [ | | mbCD : {Maybe CDoc} ]

SEM Line
  | AsIs        lhs         .   mbCD        =   Just (if null @words.charsL then CDoc_Str "" else cdHor @words.charsL)
  | Named       lhs         .   mbCD        =   Just (CDoc_Ref @cref ChHere)
  | Group       (lhs.mbCD,loc.gathHideMp)   =   case @chDest of
                                                  ChHere -> (@lines.mbCD,Map.empty)
                                                  h      -> (Just (mkHideNmRef (cd n)),Map.singleton n (HideInfo n i @lhs.seqNr @chDest @lines.mbCD @lhs.chFullNm))
                                                         where (n,i) = case @userRef of
                                                                         Just (r,Just i ) -> (r,cd i)
                                                                         Just (r,Nothing) -> (r,cd r)
                                                                         _                -> (mkNm (show h) `nmApd` mkNm @lhs.seqNr,CDoc_Emp)

SEM Lines
  | Nil         lhs         .   mbCD        =   Nothing
  | Cons        lhs         .   mbCD        =   maybe (@hd.mbCD) (Just . (maybe CDoc_Emp id @hd.mbCD `CDoc_Ver`)) @tl.mbCD

-------------------------------------------------------------------------
-- Gathering of hidden text
-------------------------------------------------------------------------

ATTR AllChunk AllLine [ | | gathHideMp USE {`Map.union`} {Map.empty}: HideMp ]

SEM Line
  | Group       lhs         .   gathHideMp  =   @gathHideMp `Map.union` @lines.gathHideMp

-------------------------------------------------------------------------
-- CRef subst in CDoc
-------------------------------------------------------------------------

ATTR CDoc [ | | sbRepl: SELF ]
ATTR AGCDocItf [ | | sbRepl: CDoc ]
ATTR CDoc AGCDocItf [ | | sbCRefS USE {`Set.union`} {Set.empty}: {Set.Set Nm} ]

SEM CDoc
  | Ref         lhs         .   (sbRepl,sbCRefS)
                                            =   case Map.lookup (@cref) @lhs.nmChMp of
                                                  Just i
                                                    -> case nciMbCD i of
                                                         Just d -> (r,Set.insert @cref s)
                                                                where (r,s) = cdocSubst (Map.delete @cref @lhs.nmChMp) d
                                                         _      -> (CDoc_Emp,Set.empty)
                                                  _ -> (@sbRepl,Set.empty)

-------------------------------------------------------------------------
-- Content replica, String part
-------------------------------------------------------------------------

ATTR Word [ | | chars: String ]
ATTR Words [ | | charsL: {[String]} ]

SEM Word
  | White       lhs         . chars     = @chars
  | Black       lhs         . chars     = {- show @xrefL ++ -} @chars

SEM Words
  | Nil         lhs         . charsL    = []
  | Cons        lhs         . charsL    = @hd.chars : @tl.charsL

-------------------------------------------------------------------------
-- Chunks
-------------------------------------------------------------------------

{
data VerChunkInfo
  = VerChunkInfo
      { vciLineNr   :: Int
      , vciSeqNr    :: Int
      , vciVer      :: Version
      , vciSubNm    :: Nm
      , vciMinusL   :: [ChunkId]
      , vciChKind   :: ChKind
      , vciChDest   :: ChDest
      , vciMbModNm  :: Maybe String
      , vciImps     :: [String]
      , vciExps     :: [String]
      , vciMbCD     :: Maybe CDoc
      , vciXRefL    :: [XRef]
      }
type VerChunkInfoM = [(Version,[VerChunkInfo])]

vciMToL :: VerChunkInfoM -> [VerChunkInfo]
vciMToL = concat . map snd

vciFullNm :: VerChunkInfo -> Nm
vciFullNm i = mkNm (vciVer i) `nmApd` vciSubNm i

instance Eq VerChunkInfo where
  i1 == i2 = vciVer i1 == vciVer i2

instance Ord VerChunkInfo where
  compare i1 i2 = vciVer i1 `compare` vciVer i2

vciSortBySeqNr :: [VerChunkInfo] -> [VerChunkInfo]
vciSortBySeqNr = sortBy (\v1 v2 -> vciSeqNr v1 `compare` vciSeqNr v2)

vciVerFilter :: (Version -> Bool) -> [VerChunkInfo] -> [VerChunkInfo]
vciVerFilter f = filter (f . vciVer)

vciVerGroup :: [VerChunkInfo] -> [[VerChunkInfo]]
vciVerGroup = groupBy (\i1 i2 -> vciVer i1 == vciVer i2)

vciHasImpExp :: VerChunkInfo -> Bool
vciHasImpExp i = not (null (vciImps i) && null (vciExps i))

vciIsPre :: VerChunkInfo -> Bool
vciIsPre = (==VPre) . vciVer

vciIsHS :: VerChunkInfo -> Bool
vciIsHS = (==ChHS) . vciChKind

vciCD :: VerChunkInfo -> CDoc
vciCD = maybe CDoc_Emp id . vciMbCD

vciHasCD :: VerChunkInfo -> Bool
vciHasCD = isJust . vciMbCD

vciSplitPre :: [VerChunkInfo] -> ([VerChunkInfo],[VerChunkInfo])
vciSplitPre = partition vciIsPre

vciTakePre :: VerChunkInfoM -> ([VerChunkInfo],VerChunkInfoM)
vciTakePre is
  = case is of
        ((VPre,p):r) -> (p,r)
        _            -> ([],is)

selectChunks :: Bool -> Opts -> [VerChunkInfo] -> [(Version,[VerChunkInfo])]
selectChunks appMinus opts agl
  = let (pre,nonPre)    = vciSplitPre agl
        availVersions   = nub . sort . map vciVer $ nonPre
        v               = optGenVersion opts
        vo              = optVerOrder opts
        allowedVersions = voAllLE'' (if optsHasNoVerOrder opts then voDefault else vo) v
        vAndVciL        = map (\v -> (v,vciSortBySeqNr . vciVerFilter (==v) $ nonPre)) allowedVersions
        isNotMinused
          = let minuses = if appMinus then [ m | (_,vciL) <- vAndVciL, ml <- map vciMinusL vciL, m <- ml ] else []
             in \i -> (vciVer i,vciSubNm i) `notElem` minuses
     in filter
          ( not.null.snd )
          ( (VPre,pre)
          : map (\(v,vciL) -> (v,filter isNotMinused vciL)) vAndVciL
          )

data Build
  = Build
      { bldBase     :: String
      , bldVer      :: Version
      , bldCD       :: CDoc
      , bldHideCD   :: [(Nm,CDoc)]
      , bldNmChMp   :: NmChMp
      }
}

-------------------------------------------------------------------------
-- Gathering chunk info
-------------------------------------------------------------------------

ATTR AllChunk [ | | verChInfoL USE {++} {[]} : {[VerChunkInfo]} ]

SEM Chunk
  | Ver         loc         .   chInfo      =   VerChunkInfo
                                                    @chunkLineNr @lhs.seqNr
                                                    @version @subNm @minusL
                                                    @chKind @chDest @mbModNm @imports @exports
                                                    @lines.mbCD (Seq.toList @lines.xrefL)
                lhs         .   verChInfoL  =   [@chInfo]

-------------------------------------------------------------------------
-- Line context, in chunks
-------------------------------------------------------------------------

ATTR AllLine AllChunk [ chFullNm: Nm | | ]

SEM Chunk
  | Ver         loc         .   chFullNm    =   vciFullNm @chInfo
  | Named       loc         .   chFullNm    =   nciNm @chInfo

SEM AGItf
  | AGItf       loc         .   chFullNm    =   NmEmp

-------------------------------------------------------------------------
-- Selecting and building
-------------------------------------------------------------------------

SEM AGItf
  | AGItf       loc         . selChunks = selectChunks True @lhs.opts @chunks.verChInfoL
                            . selLaTeXChunks
                                        = selectChunks False (@lhs.opts {optGenVersion=VAll}) @chunks.verChInfoL
                            . wrapLhs2tex
                                        = if optWrapLhs2tex @lhs.opts
                                          then (\doWr p -> if doWr then "\\begin{code}" .-. p .-. "\\end{code}" else p)
                                          else flip const
                            . build     = \bld chunks
                                               -> let fileBase = fromJust (optBaseName @lhs.opts)
                                                      v = optGenVersion @lhs.opts
                                                      (d,m) = bld @lhs.opts @wrapLhs2tex @lhs.fpath fileBase chunks
                                                      h = [ (hiChFullNm h,mkHideNmDef (cd n) (hiDescr h) (cd (hiMbCD h)))
                                                          | (n,h) <- sortBy (\(_,h1) (_,h2) -> hiSeqNr h1 `compare` hiSeqNr h2) . Map.toList $ @chunks.gathHideMp
                                                          ]
                                                   in [Build fileBase v d h m]

-------------------------------------------------------------------------
-- Gen AG
-------------------------------------------------------------------------

{
buildAGImps :: VerChunkInfo -> CDoc
buildAGImps = cdVer . map (\imp -> "INCLUDE \"" .|. imp .|. ".ag\"") . vciImps

buildAG :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> (CDoc,NmChMp)
buildAG opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        h p  = "{" .-. p .-. "}"
        mk i = if vciIsHS i
               then h (vciCD i)
               else buildAGImps i .-. vciCD i
        ish  = filter vciIsHS noPre'
        pph  = if any vciHasImpExp ish
               then wrap True (h (buildHSModImpExp fileBase ish))
               else CDoc_Emp
        (cds,nmChMpL)
             = unzip
               . map (\i -> let vnm = vciFullNm i
                            in  (wrap (not (vciIsPre i)) (mk i)
                                ,Map.singleton vnm (NmChInfo vnm (vciChDest i) (vciMbCD i))
                                )
                     )
               . vciSortBySeqNr
               $ noPre'
        d = (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
            .-. pph
            .-. (cdVer cds)
     in (d,Map.unions nmChMpL)
}

ATTR AGItf [ | | bldAG: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldAG     = @build buildAG @selChunks

-------------------------------------------------------------------------
-- Gen LaTeX
-------------------------------------------------------------------------

{
mkCmdNmDef :: CDoc -> CDoc -> CDoc
mkCmdNmDef = mkTexCmdDef "chunkCmdDef"

mkHideNmDef :: CDoc -> CDoc -> CDoc -> CDoc
mkHideNmDef = mkTexCmd3 "chunkHideDef"

mkHideNmRef :: CDoc -> CDoc
mkHideNmRef = mkTexCmdUse "chunkHideRef"

mkCmdNmUse :: CDoc -> CDoc
mkCmdNmUse = mkTexCmdUse' "chunkCmdUse"

mkCmdInx :: CDoc -> CDoc
mkCmdInx = mkTexCmdUse' "chunkIndex"

mkLabel :: CDoc -> CDoc
mkLabel = mkTexCmdUse' "label"

mkMetaInfo :: CDoc -> String -> CDoc
mkMetaInfo lab fileBase = mkLabel lab -- .-. mkTexCmdDef "chunkMetaDef" lab (cd fileBase)

buildLaTeX :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> (CDoc,NmChMp)
buildLaTeX opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        versions = nub . map (verRef.vciVer) $ noPre'
        missing = if null versions then []
                                   else [minimum versions .. maximum versions] \\ versions
        mkInx
          = let styleFmt = if optWrapLhs2tex opts then "||" else "|"
             in \ix
                 -> let n = foldr1 (\x y -> y ++ "!" ++ x) . xrKeyL $ ix
                        dfmt = CDoc_Emp -- if xrIsDefining ix then text (styleFmt ++ "emph") else CDoc_Emp
                     in mkCmdInx (n .|. dfmt)
        mkContent = let mk = wrap True . vciCD
                     in if optIndex opts
                        then \i -> cdVer (map mkInx (vciXRefL i)) .-. mk i
                        else mk
        (ppNoPreL,nmChMpL)
          = unzip
            . map (\is -> let vnm = mkNm (vciVer (head is))
                              nm = mkNm fileBase `nmApd` vnm
                              cnm = cd nm
                              (nms,pps,nmChMpL)
                                  = unzip3
                                    . map (\(nr,i) -> let cn = cd (nm `nmApd` mkNm nr)
                                                          content = mkContent i
                                                       in ( cn
                                                          , mkCmdNmDef cn (mkMetaInfo cn fileBase .-. content)
                                                            .-. (let cna = cd (nm `nmApd` vciSubNm i)
                                                                 in  mkCmdNmDef cna (mkMetaInfo cna fileBase .-. mkCmdNmUse cn)
                                                                )
                                                          , let vn = vciFullNm i
                                                            in  Map.singleton vn (NmChInfo vn (vciChDest i) (Just content))
                                                          )
                                          )
                                    . zip [(0::Int)..]
                                    $ is
                              content = cdVer pps .-. mkCmdNmDef cnm (mkMetaInfo cnm fileBase .-. cdVer (map mkCmdNmUse nms))
                           in (content,Map.unions nmChMpL)
                  )
            . vciVerGroup
            $ noPre'
        d = (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
            .-. cdVer ppNoPreL
            .-. cdVer (map (\v -> mkCmdNmDef (cdDots [cd fileBase,cd v]) CDoc_Emp) missing)
     in (d,Map.unions nmChMpL)
}

ATTR AGItf [ | | bldLaTeX: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldLaTeX  = @build buildLaTeX @selLaTeXChunks

-------------------------------------------------------------------------
-- Gen Haskell
-------------------------------------------------------------------------

{
mkModNm :: [CDoc] -> CDoc
mkModNm = cdHor

buildHSImps :: [VerChunkInfo] -> CDoc
buildHSImps = cdVer . map (cdVer . map ("import" .#.) . vciImps)

buildHSModuleHead :: String -> [VerChunkInfo] -> CDoc
buildHSModuleHead fileBase is
  = let ise = [ i | i <- is, not (null (vciExps i) && null (vciImps i))]
        e = filter (not.null) . map vciExps $ ise
        m = catMaybes . map vciMbModNm $ ise
        exps = if null e then CDoc_Emp
                         else cdListSepV "( " " )" ", " . map (cdListSep "" "" ", ") $ e
        modNm = if null m then fileBase else head m
     in "module" .#. modNm .-. {- indent 2 -} (exps .-. "where")

buildHSModImpExp :: String -> [VerChunkInfo] -> CDoc
buildHSModImpExp fileBase is = buildHSModuleHead fileBase is .-. buildHSImps is

buildHS :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> (CDoc,NmChMp)
buildHS opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        ppMod = buildHSModImpExp fileBase (vciMToL is)
        (ppNoPreL,nmChMpL)
          = unzip
            . map   (\is@(i:_)
                        -> let (pbs,nmChMpL)
                                 = unzip
                                   . map (\i -> let vnm = vciFullNm i
                                                in  (wrap (vciHasCD i) (vciCD i)
                                                    ,Map.singleton vnm (NmChInfo vnm (vciChDest i) (vciMbCD i))
                                                    )
                                         )
                                   $ is
                            in (cdVer pbs,Map.unions nmChMpL)
                    )
            . vciVerGroup . vciSortBySeqNr
            $ noPre'
        isEmpty = all (isNothing.vciMbCD) noPre'
        ppNoPre = cdVer ppNoPreL
        d = if isEmpty
            then CDoc_Emp
            else if optPlain opts
            then ppNoPre
            else (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
                 .-. wrap True ppMod
                 .-. ppNoPre
     in (d,Map.unions nmChMpL)
}

ATTR AGItf [ | | bldHS: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldHS     = @build buildHS @selChunks

