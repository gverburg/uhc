% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Simplify code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(Data.Maybe,Data.Char,qualified Data.Map as Map,EHCommon,EHCore,EHTy) export(cmodTrfRenUniq)
%%]

%%[8.WRAPPER import(EHCoreAbsSyn)
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfRenUniq :: CModule -> CModule
cmodTrfRenUniq cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf {gUniq_Inh_CodeAGItf = uidStart})
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | Let         (binds.gUniq,loc.lUniq)     =   mkNewLevUID  @lhs.gUniq
  | Lam         (body.gUniq,loc.lUniq)      =   mkNewUID     @lhs.gUniq

SEM CAlt
  | Alt         (pats.gUniq,loc.lUniq)      =   mkNewLevUID  @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% alpha renaming so all identifiers are unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type ARenMp = Map.Map HsName HsName

aRenAdd :: [HsName] -> UID -> ARenMp -> ARenMp
aRenAdd nL u m
  =  let  uL = mkNewUIDL (length nL) u
     in   Map.fromList [ (n,hsnSuffix n ("~" ++ show u)) | (n,u) <- zip nL uL] `Map.union` m

aRenRepl :: ARenMp -> HsName -> HsName
aRenRepl m n = maybe n id . Map.lookup n $ m
%%]

%%[8
ATTR AllCodeNT [ aRenMp: ARenMp ^^ lev: Int | | ]
ATTR AllBind AllPat [ | | nmL USE {++} {[]}: {[HsName]} ]

SEM CodeAGItf
  | AGItf       module      .   aRenMp      =   Map.empty
                            .   lev         =   cLevOuter

SEM CBind
  | Bind        lhs         .   nmL         =   [@nm]

SEM CPatBind
  | Bind        lhs         .   nmL         =   [@nm] ++ @pat.nmL

SEM CPat
  | Var Con     loc         .   nm          =   cpatNmEither id id @pnm
  | Var         lhs         .   nmL         =   [@nm]
  | Con         lhs         .   nmL         =   [@nm] ++ @rest.nmL ++ @binds.nmL

SEM CPatRest
  | Var         lhs         .   nmL         =   [@nm]

SEM CExpr
  | Let         loc         .   aRenMp      =   if @lhs.lev == cLevOuter
                                                then @lhs.aRenMp
                                                else aRenAdd @binds.nmL @lUniq @lhs.aRenMp
                binds       .   lev         =   @lhs.lev + 1
  | Lam         loc         .   aRenMp      =   aRenAdd [@arg] @lUniq @lhs.aRenMp
                body        .   lev         =   if @body.isLamBody then @lhs.lev + 1 else @lhs.lev

SEM CAlt
  | Alt         loc         .   aRenMp      =   aRenAdd @pats.nmL @lUniq @lhs.aRenMp
                expr        .   lev         =   @lhs.lev + 1
%%]

%%[8
ATTR CExpr [ | | isLamBody: Bool ]

SEM CExpr
  | Lam         lhs         .   isLamBody   =   False
  | * - Lam     lhs         .   isLamBody   =   True
%%]

%%[8
SEM CExpr
  | Var         lhs         .   cTrf        =   CExpr_Var (aRenRepl @lhs.aRenMp @nm)
  | Lam         lhs         .   cTrf        =   CExpr_Lam (aRenRepl @aRenMp @arg) @body.cTrf

SEM CBind
  | Bind        lhs         .   cTrf        =   CBind_Bind (aRenRepl @lhs.aRenMp @nm) @expr.cTrf

SEM CPatBind
  | Bind        lhs         .   cTrf        =   CPatBind_Bind @lbl @offset.cTrf (aRenRepl @lhs.aRenMp @nm) @pat.cTrf

SEM CPat
  | Var         lhs         .   cTrf        =   CPat_Var (CPatNmOrig . aRenRepl @lhs.aRenMp $ @nm)
  | Con         lhs         .   cTrf        =   CPat_Con (CPatNmOrig . aRenRepl @lhs.aRenMp $ @nm) @tag @rest.cTrf @binds.cTrf

SEM CPatRest
  | Var         lhs         .   cTrf        =   CPatRest_Var (aRenRepl @lhs.aRenMp @nm)
%%]

