%
%  Efficient Implementation of Functional Languages
%  2004/2005
%


\documentclass[12pt]{article}
%include lhs2TeX.fmt
%include lhs2TeX.sty

%format ATTR = "\mathbf{ATTR}"
%format DATA = "\mathbf{DATA}"
%format SEM = "\mathbf{SEM}"
%format lhs = "\mathbf{lhs}"
%format . = "."
%format @ = "\;\at"
%format $ = "\;\$\;"

\usepackage{a4wide}
\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{}{,}


%\usepackage{graphics}
\usepackage{graphicx}
%\usepackage{color}
%\usepackage{alltt}
%\usepackage[portuges]{babel}
%\usepackage[latin1]{inputenc}
%\usepackage{latexsym}


%\usepackage{noweb}

%\usepackage[dvips]{epsfig}
%\usepackage{epic}
%\usepackage{eepic}

\usepackage{hyperref}


\newcommand{\derives}{\mbox{$\rightarrow$}}
\newcommand{\orderives}{\mbox{$\mid$}}
\newcommand{\many}[1]{\{ {#1} \}}
\newcommand{\oneormore}[1]{\{ {#1} \}$^{+}$}
\newcommand{\optional}[1]{[ {#1} ]}

\newcommand{\at}{\texttt{@@}}
\newcommand{\att}{@@}
\newcommand{\lam}{\texttt{\char`\\}}

\newcommand{\file}[1]{\noindent {\bf #1}}

\title{\sf EHC to GHC Core Backend \\
\begin{tabular}{c}
{\small University of Utrecht} \\
{\small 2004/2005}  \\
{\small http://www.cs.uu.nl/groups/ST/Eifl/EHCToGhcCore} \\
\end{tabular}
}

\author{Christof Douma \\ Rodrigo Baptista}
\date{}


%\def\eg{\textit{e.g.}}
%\def\ie{\textit{i.e.}}
%\def\attrid#1{\textit{#1}}
%\def\bnfnt#1{\textit{#1}}
%\def\bnfprod#1{\textit{#1}}
%\def\semfun#1{\textsf{#1}}

\begin{document}


\maketitle


\tableofcontents
\newpage
\section{Introduction}

The purpose of this project is to generate GHC Core code from EHC language. GHC Core is an intermediate language of the Glasgow Haskell Compiler \cite{www04ghc} which is an internal representation of various compiling stages in GHC.

EHC is a more-or-less Haskell Compiler and it is a evolutionary project because the final compiler envolves via intermediate steps, so it is divided in various versions. This backend is an extension of version 8 of EHC (8\_1) so it will be one more step to extend the future compiler. EHC has an intermediate Core language too, EHCode. That will be our source language to generate the GHC Core. 

This report is pointed to students or people that are interested to extend this project and we assume that they already have knowledge in the implementation and structure of EHC. We will try to be specific explainning the various steps of the implementation,showing the code and some examples.

See Figure\ref{overview1} for overview of the project. 

\bigskip

\begin{figure}
\caption{Overview of the 3 languages in EHC}
\label{overview1}
\includegraphics[scale=0.5,angle=-90]{overview1}
\end{figure}


\section{The Grammar of GHC Core}

Below a bit simplified grammar definition of GHC Core. The complete description of the external core language is Grammar is represented in \cite{tolmach2001ghc-core} from which we copied and modified the definition below. We tried to define a Abstract Syntax data definition which is close to the GHC Core Concrete syntax. It should be easy to understand the data type for GHC Core used in EHC. The main difference is the merge of Atomic expressions into Expressions. The datatype is defined in {\bf EHGhcCoreAbsSyn.cag}.

\medskip

We use the following notational conventions for syntax:

\begin{tabular}{ll}
{\it [ pat ]} & optional \\
{\it \{ pat \}} & zero or more repetitions \\
{\it \{ pat \}$^{+}$} & one or more repetitions \\
{\it pat$_1$ \orderives\ pat$_2$} & choice \\
@fibonacci@ & terminal syntax in typewriter font \\
\end{tabular}

{\it
\begin{tabular}{lrclr}
{\rm Module} &	 module &	 \derives &	 
	\multicolumn{2}{l}{@%module@ mident \many{tdef @;@} \many{\optional{@%local@} vdefg @;@}} \\
\\
{\rm Type defn.} &	 tdef &	 \derives &	@%data@ qtycon \many{tbind} @=@ @{@ cdef \many{@;@ cdef} @}@ & {\rm algebraic type}\\
\\
{\rm Constr. defn.} &	cdef &	 \derives &	 qdcon \many{\verb|@@| tbind} \many{aty} \\
\\
{\rm Value defn.}  &	vdefg &	 \derives &	 @%rec@ @{@ vdef \many{@;@ vdef} @}@ &			 {\rm recursive} \\
      		   &	&	 \orderives &	 vdef &	 						 {\rm non-recursive} \\
		   &    vdef  &  \derives & qvar @::@ ty @=@ exp & \\
\\
{\rm Atomic expr.} &     aexp &  \derives &	 qvar &	 						{\rm variable} \\
		 &	&	 \orderives &	 qdcon &	 					{\rm data constructor}\\ 
		 &	&	 \orderives &	 lit &	 						{\rm literal} \\
		 &	&	 \orderives &	 @(@ exp @)@ &						{\rm nested expr.}\\
\\
{\rm Expression} &	exp   &  \derives    &   aexp & 						{\rm atomic expresion}\\
	         &	&	\orderives  &    aexp \oneormore{arg} & 				{\rm application}\\
		 &	&	 \orderives &	 @\@ \oneormore{binder} @->@ exp &		 	{\rm abstraction}\\
		 &	&	 \orderives &	 @%let@ vdefg @%in@ exp &	 			{\rm local definition}\\
		 &	&	 \orderives &	 @%case@ exp @%of@ vbind @{@ alt \many{@;@ alt} @}@ &	{\rm case expression}\\
\\
{\rm Argument}   &	arg & 	\derives &	 \at\ aty &						{\rm type argument}\\
		 &	&	 \orderives &	 aexp &							{\rm value argument} \\
\\
{\rm Case alt.} &	alt &	 \derives &	qdcon  \many {\verb|@@| tbind} \many{vbind} @->@ exp &{\rm constructor alternative}\\
		&	&	 \orderives &	 lit @->@ exp &	 			{\rm literal alternative} \\
		&	&	 \orderives &	 @%_@ @->@ exp & 				{\rm default alternative} \\
\\
{\rm Binder}	 & 	binder & \derives & \at\ tbind	&					{\rm type binder}\\
		 & 		& \orderives & 	vbind	&						{\rm value binder}\\
\\
{\rm Type binder} &	tbind & \derives   & tyvar & {\rm implicitly of kind @*@} \\
\\
{\rm Value binder} & 	vbind & \derives &   @(@ var @::@ ty @)@ \\
\\
{\rm Literal} &	 lit &	 \derives &	 @(@ [@-@] \oneormore{digit} @::@ ty @)@ & {\rm integer} \\
	    &	&	 \orderives &	 @(@ [@-@] \oneormore{digit} @.@ \oneormore{digit} @::@ ty @)@ & {\rm rational} \\
	    &	&	 \orderives &	 @(@ @'@ char @'@ @::@ ty @)@ & {\rm character} \\
	    &	&	 \orderives &	 @(@ @"@ \many{char} @"@ @::@ ty @)@ & {\rm string} \\
\\
{\rm Character}  & char & \derives & \multicolumn{2}{l}{any printable ASCII character}\\
		&	& \orderives & @\x@ hex hex  & {\rm ASCII code escape} \\
		&  hex   & \derives & @0@ \orderives  \ldots \orderives  @9@ \orderives  @a@ \orderives  \ldots \orderives  @f@ \\
\end{tabular}

\begin{tabular}{lrclr}
{\rm Identifier}	&	mident & \derives &uname &	{\rm module} \\
	&	tycon &	 \derives &	 uname &	 	{\rm type constr.}  \\
	&	qtycon & \derives &	 mident @.@  tycon &	{\rm qualified type constr.} \\
	&	tyvar &	 \derives &	 lname &		{\rm type variable} \\
	&	dcon &	 \derives &	 uname &	 	{\rm data constr.} \\
	&	qdcon &	 \derives &	 mident @.@  dcon & 	{\rm qualified data constr.} \\
	&	var &	 \derives &	 lname &		{\rm variable} \\
	&	qvar &	 \derives &	 [ mident @.@ ] var &	{\rm optionally qualified variable} \\
\\
{\rm Name} 	&	lname  &  \derives & 	 lower \many{namechar} \\
 	&       uname &  \derives & 	 upper \many{namechar} & \\
	&	namechar & \derives &	 lower \orderives\  upper \orderives\  digit \orderives\  @'@ \\
	&	lower &  \derives &      @a@ \orderives\  @b@ \orderives\  \ldots \orderives\  @z@ \orderives\  @_@ \\
	&	upper &  \derives &      @A@ \orderives\  @B@ \orderives\  \ldots \orderives\  @Z@ \\
	& 	digit &  \derives & 	 @0@ \orderives\  @1@ \orderives\  \ldots \orderives\  @9@ \\
\\
\end{tabular}
}

Ty refers in our implementation to the datatype defined in {\bf EHTyAbsSyn.cag}.

\subsection{EHCode vs GHC-Core}

There are several essential differences between Ghc Core and EHCode.

\subsubsection{Types}
On several places the GHC Core language require type information.

\begin{itemize}
\item In function applications All polymorphic functions and all higher kinded datatypes should get type arguments.
\item all bindings of names to expressions should contain type information.
\item all literals needs to be typed explicit, this is due to the fact that literals in haskell refer to type classes. i.e. a constant 3 is of type |(Num t) => t|. Since Ghc at this level has no type classes anymore it needs to know which instance of Num it has to use.
\end{itemize}

The EHCode language however does not incorperate type information. Since we generate GHC Core out of EHCode we have to incorperate it into EHCode.

\subsubsection{Datatypes}
EHCode convert datatypes into (untyped?) records. GHC Core defines datatypes the same way as haskell datatypes. So we must have means to re\"introduce them.

\subsection{Evaluation forcing constructs}

The EHCode uses a strict let binding to force evaluation. Called let! (Let bang). The GhcCore uses the case expression as the only place where evaluating is forced.

\section{Hook into the compiler}

Compilerdriver, prettyprinter, Makefile \ldots

\section{Add type information to bindings}

In the beginning we were using directly the EH language. This language had all the information we needed. But of course a lot of analysis and desugaring in the front end of EHC is done on EH when translating into EHC Core so the EH language is for the front-end only. We need a few stages 

We are going to explain what we have changed in EHCode abstract syntex. Then we will show the changes when we generate the EHCode, which is done in {\bf EHGenCode.cag}.

\subsection{Top Module}

To make a correct GhcModule out of EH code we bind the toplevel EH expression to en exported top level function named \emph{top}. Since every binding needs a type we have to add the type of the expression that corresponds to the top binding. So we introduce a ty in CModule.

\medskip

\file{EHCodeAbsSyn.cag}
\begin{code}
DATA  CModule
  |  Mod         baseName        :  {String}
                 ty              :  Ty
                 expr            :  CExpr
\end{code}

\medskip

Generating this information from EH is simple.

\medskip

\file{EHGenCode.cag}
\begin{code}
SEM AGItf
  | AGItf       lhs         .   cmodule     =   CModule_Mod @lhs.baseName @expr.ty @expr.cexpr
%%]
\end{code}

\subsection{Lambda Abstractions}

In Lambda Abstractions we add a Type for binding of argument variables.

\medskip

\file{EHAbsSyn.cag}
\begin{code}
DATA CExpr
  |  Lam         arg             :  {HsName}
                 ty              :  Ty
                 body            :  CExpr
\end{code}

\medskip

Again this is not hard to include.

\medskip
\file{EHGenCode.cag}
\begin{code}
SEM CEXpr
  | Lam         loc         .   cexpr       :=   CExpr_Lam @arg.topNm @arg.ty (rceMatch [@arg.topNm] [CAlt_Alt [@arg.cpat] @body.cexpr] cvarUndefined)
\end{code}

\subsection{Pattern variables}

For the pattern variables we also include it in the same way.

\medskip

\file{EHAbsSyn.cag}
\begin{code}
DATA CPat
  | Var         pnm             : {CPatNm}
                ty              : Ty
\end{code}

\file{EHGenCode.cag}
\begin{code}
SEM PatExpr
  | Var         lhs         .   cpat        =   CPat_Var @cpNm
\end{code}

\subsection{Let bindings}

We add Type information in the binds so we could know the type of the expression which is binded so we can create a typed bindings in a let. 

\medskip

\begin{code}
DATA CBind
  | Bind        nm              : {HsName}
                ty              : Ty
                expr            : CExpr
\end{code}

\medskip

GHC Core provides Foreign Function Interface but we did not introduce that yet, we just included a type in the Foreign Function Interface but do nothing with it.

\medskip

\begin{code}
SEM Decl
  | Val         lhs         .   cbindL      =   [CBind_Bind @patExpr.topNm @expr.ty @expr.cexpr] ++ @patExpr.cbindL
  | FFI         lhs         .   cbindL      =   [CBind_Bind @nm @sigTy (CExpr_Var (HNm @impEnt))]

SEM Expr
  | Case        loc         .   cexpr       :=   let  n = uidHNm @lUniq
                                                 in   mkCExprLet CBindPlain emptyGam [CBind_Bind n @expr.ty @expr.cexpr]
                                                        (rceMatch [(n,@expr.ty)] @alts.caltL cvarUndefined)
%%]
\end{code}

As you can see the case alternative uses a binding to, so we have to add that one too. The changes have been simple until now. But the case is the first place the front end is actually doing something with EHCode rather than just building up the tree. It applies a pattern mattching comiling algorithm. The top level function of this algorithm is the rceMatch function.

\subsubsection{Pattern matching compiling algorithm}

The front uses an Patern-matching compiler algorithm described in \cite{ipt:impl-func-prog-lang}.  The algoritm converts a nested pattern to a non overlapping pattern which is flat. i.e. Has a constructor and a list of variables. We give an example below.

\medskip

\noindent The algorithm changes a nested / overlapping case 
\begin{code}
case x of
    Left (Left   z)  -> z
    Left (Right  z)  -> z
\end{code}

%format y'
\noindent into a flat case
\begin{code}
case x of
    Left y ->  let! y' = y
               in  case y' of 
                      Left   z  -> y
                      Right  z  -> z
\end{code}

\medskip

Note that the let! statement is the forcing part of EHCode. Not the case statement. 

Since the algorithm can introduce let bindings and introduces new pattern variables we need to incorperate the types and make them traverse through the algoritm.

HERE WE ARE LEFT\ldots

\begin{itemize}
\item
We add Type information in the variables of the Patterns.

\medskip

\begin{code}
DATA CPat
  | Var         pnm             : {CPatNm}
                ty              : Ty
%%]
\end{code}

\end{itemize}

\bigskip


\subsection{Generating EH Core Code}
Changing the Abstract Syntax Tree of EH Core we had to update the code generation correctly. Below you can see the various changes:

Now the CModule receives the type of the top expression;

?????

\medskip


\begin{code}
%%[8_1.LetLamCase
  | Let         loc         .   cexpr       :=   mkCExprLet CBindRec @lQuTyGam @decls.cbindL @body.cexpr
  | Lam         loc         .   cexpr       :=   CExpr_Lam @arg.topNm @arg.ty (rceMatch [(@arg.topNm,@arg.ty)] [CAlt_Alt [@arg.cpat] @body.cexpr] cvarUndefined)
  | Case        loc         .   cexpr       :=   let  n = uidHNm @lUniq
                                                 in   mkCExprLet CBindPlain emptyGam [CBind_Bind n @expr.ty @expr.cexpr]
                                                        (rceMatch [(n,@expr.ty)] @alts.caltL cvarUndefined)
%%]
\end{code}

\bigskip

To create a correct Bind list in the Values we have added the type of the expression. GHC Core provides Foreign Function Interface but we did not introduced yet, we just included a type in the Foreign Function Interface but it is not working properly.

\medskip

\begin{code}
%%[8.ValAndFFI
  | Val         lhs         .   cbindL      =   [CBind_Bind @patExpr.topNm @expr.cexpr] ++ @patExpr.cbindL
  | FFI         lhs         .   cbindL      =   [CBind_Bind @nm (CExpr_Var (HNm @impEnt))]
%%]
%%[8_1.ValAndFFI -8.ValAndFFI
  | Val         lhs         .   cbindL      =   [CBind_Bind @patExpr.topNm @expr.ty @expr.cexpr] ++ @patExpr.cbindL
  | FFI         lhs         .   cbindL      =   [CBind_Bind @nm @sigTy (CExpr_Var (HNm @impEnt))]
%%]
\end{code}

\bigskip

We have updated the Pattern variables including the type information;

\medskip


\begin{code}
%%[8.PatVar
  | Var         lhs         .   cpat        =   CPat_Var @cpNm
%%]

%%[8_1.PatVar -8.PatVar
  | Var         lhs         .   cpat        =   CPat_Var @cpNm @ty
%%]
\end{code}

\bigskip

??????????

\medskip


\begin{code}
%%[8.PatExprAppTop
  | AppTop Rec  loc         .   cbindL      =   concat
                                                .  map  (\(CPatBind_Bind o _ p)
                                                            -> let  b n = [CBind_Bind n (CExpr_Sel (CExpr_Var @lhs.ceParentN
m) @tag (CExpr_Int o))]
                                                               in   case cpatVarNm p of
                                                                        CPatNmOrig n                          -> b n
                                                                        CPatNmUniq n | not (null @cbindLSub)  -> b n
                                                                        _                                     -> []
                                                        )
                                                $  @cpatBinds
                lhs         .   cbindL      =   @cbindL ++ @cbindLSub
%%]

%%[8_1.PatExprAppTop -8.PatExprAppTop
  | AppTop Rec  loc         .   cbindL      =   concat
                                                .  map  (\(CPatBind_Bind o _ p)
                                                            -> let  b n = [CBind_Bind n Ty_Any (CExpr_Sel (CExpr_Var @lhs.ce
ParentNm) @tag (CExpr_Int o))]
                                                               in   case cpatVarNm p of
                                                                        CPatNmOrig n                          -> b n
                                                                        CPatNmUniq n | not (null @cbindLSub)  -> b n
                                                                        _                                     -> []
                                                        )
                                                $  @cpatBinds
                lhs         .   cbindL      =   @cbindL ++ @cbindLSub
%%]
\end{code}

\bigskip

????????

\medskip

\begin{code}
%%[8_1.reorderCase -8.reorderCase hs
rceSplit :: (CAlt -> Bool) -> CAltL -> [CAltL]
rceSplit f []   = []
rceSplit f [x]  = [[x]]
rceSplit f (x:xs@(x':_))
  | f x == f x'  =  let  (z:zs) = rceSplit f xs
                    in   (x:z) : zs
  | otherwise    =  [x] : rceSplit f xs

rceAltsForCon :: CAltL -> HsName -> CAltL
rceAltsForCon alts conNm
  = [a | a@(CAlt_Alt (CPat_Con _ _ nm _ : _) _) <- alts, nm == conNm]

rceRebinds :: (HsName,Ty) -> CAltL -> CBindL
rceRebinds (nm,ty) alts = [ CBind_Bind n ty (CExpr_Var nm) | (CPatNmOrig n) <- caltLPatNms alts, n /= nm ]

rceMatchVar :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchVar (arg:args') alts ce
  =  let  remMatch  = rceMatch args' [CAlt_Alt remPats e | (CAlt_Alt (CPat_Var n t : remPats) e) <- alts] ce
     in   mkCExprLet CBindPlain emptyGam (rceRebinds arg alts) remMatch

rceMatchCon :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchCon args@((nm,ty):args') alts ce
  =  let  arg'   =  hsnPrefix "!" nm
          alts'  =  map
                      (\alts
                        ->  let  (subAlts,subAltSubNms)
                                               =  unzip
                                                    [ (CAlt_Alt (pats ++ ps) e, map (\p -> (cpatNmNm . cpatVarNm $ p, cpatVarTy p)) pats)
                                                    | (CAlt_Alt (CPat_Con _ _ _ pbinds : ps) e) <- alts,
                                                      let pats = [ p | (CPatBind_Bind _ _ p) <- pbinds ]
                                                    ]
                                 subMatch      =  rceMatch (head subAltSubNms ++ args') subAlts ce
                                 altPat        =  case head alts of
                                                    CAlt_Alt (CPat_Con n t tn pbinds : _) _
                                                      -> CPat_Con n t tn [ CPatBind_Bind o n (CPat_Var (cpatVarNm p) (cpatVarTy p)) | (CPatBind_Bind o n p) <- pbinds ]
                            in   CAlt_Alt [altPat] (mkCExprLet CBindPlain emptyGam (rceRebinds (arg',ty) alts) subMatch)
                      )
                 .  groupBy (\a1 a2 -> caltTag a1 == caltTag a2)
                 .  sortBy (\a1 a2 -> caltTag a1 `compare` caltTag a2)
                 .  filter (not . null . caltPatL)
                 $  alts
     in   ceStrictIn arg' ty (CExpr_Var nm) (\n -> CExpr_Case n alts' ce)

rceMatchVarCon :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchVarCon args alts@(alt:_) ce
  |  caltIsVar alt  = rceMatchVar args alts ce
  |  otherwise      = rceMatchCon args alts ce

rceMatch :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatch [] []    ce =  ce
rceMatch [] alts  ce
  =  case [ e | (CAlt_Alt [] e) <- alts ] of
       (e:_)  -> e
       _      -> ce
-- TODO: create a correct type in bty for the new let binding!
rceMatch args alts ce
  =  foldr
        (\alts e
           ->  case e of
                  CExpr_Var _
                     ->  rceMatchVarCon args alts e
                  _  ->  let  bty = Ty_Any
                              bnm = HNm ("_casecont_" ++ (show . cpatVarNm . caltPat . head $ alts))
                              vc = rceMatchVarCon args alts (CExpr_Var bnm)
                         in   mkCExprLet CBindPlain emptyGam [CBind_Bind bnm bty e] vc
       )
        ce
     $ (rceSplit caltIsVar alts)
%%]
\end{code}

\bigskip

changed data constructor.......

\medskip

\begin{code}
%%[8.DataConstr
SEM DataConstr
  | Constr      loc         .   tag         =   fromJust (tyRecOffset @conNm @lhs.dataAltTy)
                lhs         .   cbindL      =   let  len = length @fields.tyL
                                                     nms = map (\i -> HNm ("x" ++ show i)) [1..len]
                                                in   [CBind_Bind @conNm
                                                        (mkCExprLam nms
                                                          (mkCExprApp (CExpr_App CExpr_Tup (CExpr_Int @tag))
                                                            (map CExpr_Var nms)))
                                                     ]
%%]

%%[8_1.DataConstr -8.DataConstr
SEM DataConstr
  | Constr      loc         .   tag         =   fromJust (tyRecOffset @conNm @lhs.dataAltTy)
                lhs         .   cbindL      =   let zipNameAndType ty lf i = let list = lf (i+1)
                                                                             in (HNm ("x" ++ show i), ty):list
                                                    nms = foldr zipNameAndType (const []) @fields.tyL 1
                                                in   [CBind_Bind @conNm @dataConTy
                                                        (mkCExprLam nms
                                                          (mkCExprApp (CExpr_App CExpr_Tup (CExpr_Int @tag))
                                                            (map (CExpr_Var . fst) nms)))
                                                     ]
%%]
\end{code}

\bigskip

\subsection{Haskell Functions}

Constructors functions

\medskip


\begin{code}
%%[8.mkLamLet hs
mkCExprLet :: CBindCateg -> CBindL -> CExpr -> CExpr
mkCExprLet c bs e = if null bs then e else CExpr_Let c bs e

mkCExprLetRec :: CBindL -> CExpr -> CExpr
mkCExprLetRec = mkCExprLet CBindRec

mkCExprLam :: [HsName] -> CExpr -> CExpr
mkCExprLam as e = foldr (\n e -> CExpr_Lam n e) e as
%%]

%%[8_1.mkLamLet -8.mkLamLet hs
mkCExprLet :: CBindCateg -> TyGam -> CBindL -> CExpr -> CExpr
mkCExprLet c tg bs e = if null bs then e else CExpr_Let c tg bs e

mkCExprLetRec :: TyGam -> CBindL -> CExpr -> CExpr
mkCExprLetRec = mkCExprLet CBindRec

mkCExprLam :: [(HsName, Ty)] -> CExpr -> CExpr
mkCExprLam as e = foldr (\(n,t) e -> CExpr_Lam n t e) e as
%%]
\end{code}

\bigskip


Destruction functions

\medskip

\begin{code}
%%[8.cpatVarNm hs
cpatVarNm :: CPat -> CPatNm
cpatVarNm (CPat_Var n)        = n
cpatVarNm (CPat_Con n _ _ _)  = n

caltIsVar :: CAlt -> Bool
caltIsVar (CAlt_Alt (CPat_Var _ : _) _)  = True
caltIsVar _                              = False
%%]

%%[8_1.cpatVarNm -8.cpatVarNm hs
cpatVarNm :: CPat -> CPatNm
cpatVarNm (CPat_Var n t)      = n
cpatVarNm (CPat_Con n _ _ _)  = n

cpatVarTy :: CPat -> Ty
cpatVarTy (CPat_Var n t) = t
cpatVarTy (CPat_Con n _ _ _)  = error "cpatVarTy: not a variable"

caltIsVar :: CAlt -> Bool
caltIsVar (CAlt_Alt (CPat_Var _ _ : _) _)  = True
caltIsVar _                                = False
%%]
\end{code}

\bigskip


Strict

\medskip

\begin{code}
%%[8.ceStrictIn hs
ceStrictIn :: HsName -> CExpr -> (CExpr -> CExpr) -> CExpr
ceStrictIn nm e mkC = CExpr_Let CBindStrict [CBind_Bind nm e] (mkC (CExpr_Var nm))
%%]

%%[8_1.ceStrictIn -8.ceStrictIn hs
ceStrictIn :: HsName -> Ty -> CExpr -> (CExpr -> CExpr) -> CExpr
ceStrictIn nm t e mkC = CExpr_Let CBindStrict emptyGam [CBind_Bind nm t e] (mkC (CExpr_Var nm))
%%]
\end{code}

\bigskip

\section{Outputting GHC Core Code}



\subsection{Outputting Types}

...........

\medskip

\begin{code}
%%[8_1.ppTy -1.ppTy hs import(Data.Maybe) export(ppGhcCoreTy)
ppTy :: Ty -> PP_Doc
ppTy ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf Nothing)
     in   pp_Syn_TyAGItf t

ppGhcCoreTy ::  String -> Ty -> PP_Doc
ppGhcCoreTy moduleID ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf (Just moduleID))
     in   pp_Syn_TyAGItf t

instance PP Ty where
  pp t = ppTy t
%%]
\end{code}

\bigskip

ghcModuleID....

\medskip

\begin{code}
%%[1.ppAttr
ATTR TyAGItf AllTy [ | | pp: PP_Doc ]
%%]

%%[8_1.ppAttr -1.ppAttr
ATTR TyAGItf AllTy [ ghcModuleID: {Maybe String} | | pp: PP_Doc ]
%%]
\end{code}

\bigskip

ppTy in GHC.....

\medskip

\begin{code}
%%[8_1.pp
SEM Ty
  | Con            loc      . conName   = let ghcModName nm mid = if @nm == hsnInt || @nm == hsnChar then "GHCziBase." else (mid ++ ".")
                                              ghcQualName nm mid = hsnPrefix (ghcModName nm mid) nm
                                          in (maybe @nm (ghcQualName @nm) @lhs.ghcModuleID)
                            . pp        := ppCon @conName
%%]
\end{code}

\bigskip

\section{Overview to the added/created files}

This is an overview of what we have specifically done in the files point of view. We have created version 8\_1 of EHC adding some necessary files:

\begin{itemize}
\item
{\bf EHGhcCoreAbsSyn.cag}: 
                     It contains the Data type of the Abstract Syntax Tree used to represent GHC Core language;
\item
{\bf EHGhcCoreMain.cag}:  
                     It contains the operational semantics and auxiliar functions applied to the GHC Core AST;
\item
{\bf EHGhcCore.cag}: 
                     It contains the Haskell importable interface to GhcCore backend;
\item
{\bf EHGhcCorePretty.cag}:
                     It contains the pretty printer of the GHC Core Abstract Syntax Tree;
\end{itemize}

And we have changed files from version 8 of EHC:

\begin{itemize}
\item
{\bf EHC.chs}: 
                     Added compile rule for GhcCore backend;
\item
{\bf EHCodeAbsSyn.cag}: 
                     Made some changes on EH Code Abstract Syntax Tree;
\item
{\bf EHCode.cag}: 
                     Changed Haskell functions related to EH Code Abstract Syntax Tree;
\item
{\bf EHCommon.chs}: 
                     Added auxiliar function;
\item
{\bf EHGenCode.cag}: 
                     Changed functions related to the translation of EH language to EH Code;
\item
{\bf EHMainAG.cag}:  
                     Added import rules;
\item
{\bf EHTyPretty.cag}:
                     Changed the Pretty Printer for Types;
\item
{\bf Makefile}:
                     Added make rules for version 8\_1;
\end{itemize}

\bigskip

\section{Auxiliar Haskell Function}
We have added a simple haskell function to verify if a HsName is a Constructor.

\medskip

\begin{code}
%%[8_1 import(Data.Char)
hsnIsCon                           :: HsName -> Bool
hsnIsCon  (HNm (c:_))              = isUpper c
hsnIsCon  _                        = False
%%]
\end{code}

\bigskip

\section{Compiling the Backend}

......


\begin{code}
%%[8_1.outputPass -8.outputPass
crCompileCUPass2HS :: HsName -> CompileRun -> IO CompileRun
crCompileCUPass2HS modNm cr
  =  do  {  let  cu     = crCU modNm cr
                 p1ob   = fromJust (cuMbOut (crCU modNm cr))
                 fp     = cuFilePath cu
                 opts   = crOpts cr
                 codePP = ppCModule (cmodule_Syn_AGItf p1ob)
         ;  case ehcoptCodeType opts of
               EHCCoreCode -> do
                      {  writeFile (fpathToStr (fpathSetSuff "code" fp))
                            (disp codePP 120 "")
                      }
              JavaCode    -> do
                      {  let (jBase,jPP) = cexprJavaSrc (cmodule_Syn_AGItf p1ob)
                             jFP = fpathSetBase jBase fp
                      ;  writeFile (fpathToStr (fpathSetSuff "java" jFP))
                            (disp jPP 120 "")
                      }
               GHCCoreCode -> do
                      {  let cmod   = cmodule_Syn_AGItf p1ob
                             ghcmod = genGhcCore cmod
                             hcrPP  = ppGhcModule ghcmod
                      ;  writeFile (fpathToStr (fpathSetSuff "hcr" fp))
                            (disp hcrPP 120 "")
                      ;  putStrLn "*** GHC Core AST:"
                      ;  putStrLn (show ghcmod)
                      }
         ;  return cr
        }
%%]
\end{code}

\bigskip


\begin{code}
%%[EHCCodeOpts.8.1
-- functions to keep the version .8 parts working
ehcoptCode     o = case ehcoptCodeType o of { EHCCoreCode -> True; _ -> False }
ehcoptCodeJava o = case ehcoptCodeType o of { JavaCode    -> True; _ -> False }

data EHCCodeType = EHCCoreCode | JavaCode | GHCCoreCode
%%]

%%[EHCOpts.8.1
                                ,  ehcoptCodeType       ::  EHCCodeType
                                ,  ehcoptSearchPath     ::  [String]
                                ,  ehcoptVerbosity      ::  Verbosity
%%]

%%[defaultEHCOpts.8.1
                                ,  ehcoptCodeType       =   GHCCoreCode
                                ,  ehcoptSearchPath     =   []
                                ,  ehcoptVerbosity      =   VerboseQuiet
%%]

%%[cmdLineOptsA.8.1
     ,  Option "c"  ["code"]   (OptArg oCode "ghc-core")
          "dump code (java -> .java, ghc-core -> .hcr) on file, default=ghc-core (-> .hcr)"
%%]

%%[cmdLineOptsB.8.1
         oCode       ms  o =  case ms of
                                Just "java"      -> o { ehcoptCodeType = JavaCode    }
                                Just "ghc-core"  -> o { ehcoptCodeType = GHCCoreCode }
                                _                -> o { ehcoptCodeType = EHCCoreCode }
%%]
\end{code}

\section{Conclusions}

\section{Examples}

%%%% REFERENCES %%%
\section{References}
\bibliographystyle{../uhcbook}
%\bibliographystyle{plain}
\bibliography{references}

\end{document}
