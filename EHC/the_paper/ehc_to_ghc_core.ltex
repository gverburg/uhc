%
%  Efficient Implementation of Functional Languages
%  2004/2005
%


\documentclass[12pt]{article}
%include lhs2TeX.fmt
%include lhs2TeX.sty

%%%% Nice AG %%%%
%format ATTR = "\mathbf{ATTR}"
%format DATA = "\mathbf{DATA}"
%format SEM = "\mathbf{SEM}"
%format lhs = "\mathbf{lhs}"
%format loc = "\mathbf{loc}"
%format . = "."
%format @ = "\;\at"

%%%% Nice Haskell %%%%
%format $ = "\;\$\;"
%format forall (a)  = "\forall{" a "}"

%%%% Nice GHC Core %%%%
%format % = "\%"

\usepackage{a4wide}
\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{}{,}


%\usepackage{graphics}
\usepackage{graphicx}
%\usepackage{color}
%\usepackage{alltt}
%\usepackage[portuges]{babel}
%\usepackage[latin1]{inputenc}
%\usepackage{latexsym}


%\usepackage{noweb}

%\usepackage[dvips]{epsfig}
%\usepackage{epic}
%\usepackage{eepic}

\usepackage{hyperref}


\newcommand{\derives}{\mbox{$\rightarrow$}}
\newcommand{\orderives}{\mbox{$\mid$}}
\newcommand{\many}[1]{\{ {#1} \}}
\newcommand{\oneormore}[1]{\{ {#1} \}$^{+}$}
\newcommand{\optional}[1]{[ {#1} ]}

\newcommand{\at}{\texttt{@@}}
\newcommand{\att}{@@}
\newcommand{\lam}{\texttt{\char`\\}}

\newcommand{\file}[1]{\noindent {\bf\emph{#1}}}
\newcommand{\header}[1]{\bigskip \noindent {\bf #1}\\}

\title{\sf EHC to GHC Core Backend \\
\begin{tabular}{c}
{\small University of Utrecht} \\
{\small 2004/2005}  \\
{\small http://www.cs.uu.nl/groups/ST/Eifl/EHCToGhcCore} \\
\end{tabular}
}

\author{Christof Douma \\ Rodrigo Baptista}
\date{}


%\def\eg{\textit{e.g.}}
%\def\ie{\textit{i.e.}}
%\def\attrid#1{\textit{#1}}
%\def\bnfnt#1{\textit{#1}}
%\def\bnfprod#1{\textit{#1}}
%\def\semfun#1{\textsf{#1}}

\begin{document}


\maketitle


\tableofcontents
\newpage
\section{Introduction}

The purpose of this project is to generate GHC Core code from EHC language. GHC Core is an intermediate language of the Glasgow Haskell Compiler \cite{www04ghc} which is an internal representation of various compiling stages in GHC.

EHC is a more-or-less Haskell Compiler and it is a evolutionary project because the final compiler envolves via intermediate steps, so it is divided in various versions. This backend is an extension of version 8 of EHC (8\_1) so it will be one more step to extend the future compiler. EHC has an intermediate Core language too, EHCode. That will be our source language to generate the GHC Core. 

This report is pointed to students or people that are interested to extend this project and we assume that they already have knowledge in the implementation and structure of EHC. We will try to be specific explainning the various steps of the implementation,showing the code and some examples.

See Figure \ref{overview1} for overview of the project. 

\bigskip

\begin{figure}
\caption{Overview of the 3 languages in EHC}
\label{overview1}
\includegraphics[scale=0.5,angle=-90]{overview1}
\end{figure}


\section{The Grammar of GHC Core} \label{GhcCore}

Below a bit simplified grammar definition of GHC Core. The complete description of the external core language is Grammar is represented in \cite{tolmach2001ghc-core} from which we copied and modified the definition below. We tried to define a Abstract Syntax data definition which is close to the GHC Core Concrete syntax. It should be easy to understand the data type for GHC Core used in EHC. The main difference is the merge of Atomic expressions into Expressions. The datatype is defined in {\bf EHGhcCoreAbsSyn.cag}.

\medskip

We use the following notational conventions for syntax:

\begin{tabular}{ll}
{\it [ pat ]} & optional \\
{\it \{ pat \}} & zero or more repetitions \\
{\it \{ pat \}$^{+}$} & one or more repetitions \\
{\it pat$_1$ \orderives\ pat$_2$} & choice \\
@fibonacci@ & terminal syntax in typewriter font \\
\end{tabular}

{\it
\begin{tabular}{lrclr}
{\rm Module} &	 module &	 \derives &	 
	\multicolumn{2}{l}{@%module@ mident \many{tdef @;@} \many{\optional{@%local@} vdefg @;@}} \\
\\
{\rm Type defn.} &	 tdef &	 \derives &	@%data@ qtycon \many{tbind} @=@ @{@ cdef \many{@;@ cdef} @}@ & {\rm algebraic type}\\
\\
{\rm Constr. defn.} &	cdef &	 \derives &	 qdcon \many{\verb|@@| tbind} \many{aty} \\
\\
{\rm Value defn.}  &	vdefg &	 \derives &	 @%rec@ @{@ vdef \many{@;@ vdef} @}@ &			 {\rm recursive} \\
      		   &	&	 \orderives &	 vdef &	 						 {\rm non-recursive} \\
		   &    vdef  &  \derives & qvar @::@ ty @=@ exp & \\
\\
{\rm Atomic expr.} &     aexp &  \derives &	 qvar &	 						{\rm variable} \\
		 &	&	 \orderives &	 qdcon &	 					{\rm data constructor}\\ 
		 &	&	 \orderives &	 lit &	 						{\rm literal} \\
		 &	&	 \orderives &	 @(@ exp @)@ &						{\rm nested expr.}\\
\\
{\rm Expression} &	exp   &  \derives    &   aexp & 						{\rm atomic expresion}\\
	         &	&	\orderives  &    aexp \oneormore{arg} & 				{\rm application}\\
		 &	&	 \orderives &	 @\@ \oneormore{binder} @->@ exp &		 	{\rm abstraction}\\
		 &	&	 \orderives &	 @%let@ vdefg @%in@ exp &	 			{\rm local definition}\\
		 &	&	 \orderives &	 @%case@ exp @%of@ vbind @{@ alt \many{@;@ alt} @}@ &	{\rm case expression}\\
\\
{\rm Argument}   &	arg & 	\derives &	 \at\ aty &						{\rm type argument}\\
		 &	&	 \orderives &	 aexp &							{\rm value argument} \\
\\
{\rm Case alt.} &	alt &	 \derives &	qdcon  \many {\verb|@@| tbind} \many{vbind} @->@ exp &{\rm constructor alternative}\\
		&	&	 \orderives &	 lit @->@ exp &	 			{\rm literal alternative} \\
		&	&	 \orderives &	 @%_@ @->@ exp & 				{\rm default alternative} \\
\\
{\rm Binder}	 & 	binder & \derives & \at\ tbind	&					{\rm type binder}\\
		 & 		& \orderives & 	vbind	&						{\rm value binder}\\
\\
{\rm Type binder} &	tbind & \derives   & tyvar & {\rm implicitly of kind @*@} \\
\\
{\rm Value binder} & 	vbind & \derives &   @(@ var @::@ ty @)@ \\
\\
{\rm Literal} &	 lit &	 \derives &	 @(@ [@-@] \oneormore{digit} @::@ ty @)@ & {\rm integer} \\
	    &	&	 \orderives &	 @(@ [@-@] \oneormore{digit} @.@ \oneormore{digit} @::@ ty @)@ & {\rm rational} \\
	    &	&	 \orderives &	 @(@ @'@ char @'@ @::@ ty @)@ & {\rm character} \\
	    &	&	 \orderives &	 @(@ @"@ \many{char} @"@ @::@ ty @)@ & {\rm string} \\
\\
{\rm Character}  & char & \derives & \multicolumn{2}{l}{any printable ASCII character}\\
		&	& \orderives & @\x@ hex hex  & {\rm ASCII code escape} \\
		&  hex   & \derives & @0@ \orderives  \ldots \orderives  @9@ \orderives  @a@ \orderives  \ldots \orderives  @f@ \\
\end{tabular}

\begin{tabular}{lrclr}
{\rm Identifier}	&	mident & \derives &uname &	{\rm module} \\
	&	tycon &	 \derives &	 uname &	 	{\rm type constr.}  \\
	&	qtycon & \derives &	 mident @.@  tycon &	{\rm qualified type constr.} \\
	&	tyvar &	 \derives &	 lname &		{\rm type variable} \\
	&	dcon &	 \derives &	 uname &	 	{\rm data constr.} \\
	&	qdcon &	 \derives &	 mident @.@  dcon & 	{\rm qualified data constr.} \\
	&	var &	 \derives &	 lname &		{\rm variable} \\
	&	qvar &	 \derives &	 [ mident @.@ ] var &	{\rm optionally qualified variable} \\
\\
{\rm Name} 	&	lname  &  \derives & 	 lower \many{namechar} \\
 	&       uname &  \derives & 	 upper \many{namechar} & \\
	&	namechar & \derives &	 lower \orderives\  upper \orderives\  digit \orderives\  @'@ \\
	&	lower &  \derives &      @a@ \orderives\  @b@ \orderives\  \ldots \orderives\  @z@ \orderives\  @_@ \\
	&	upper &  \derives &      @A@ \orderives\  @B@ \orderives\  \ldots \orderives\  @Z@ \\
	& 	digit &  \derives & 	 @0@ \orderives\  @1@ \orderives\  \ldots \orderives\  @9@ \\
\\
\end{tabular}
}

Ty refers in our implementation to the datatype defined in {\bf EHTyAbsSyn.cag}.

\subsection{EHCode vs GHC Core}

There are several essential differences between GHC Core and EHCode.

\subsubsection{Types}
On several places the GHC Core language require type information.

\begin{itemize}
\item In function applications All polymorphic functions and all higher kinded datatypes should get type arguments.
\item all bindings of names to expressions should contain type information.
\item all variables in patterns should contain type information.
\item all literals need to be typed explicit, this is due to the fact that literals in Haskell refer to type classes. i.e. a constant 3 is of type |(Num t) => t|. Since Ghc at this level has no type classes anymore it needs to know which instance of Num it has to use.
\end{itemize}

The EHCode language however does not incorporate type information. Since we generate GHC Core out of EHCode we have to incorporate it into EHCode.

\subsubsection{Datatypes}
EHCode converts datatypes into (untyped?) records. GHC Core defines datatypes the same way as haskell datatypes. So we must have means to reintroduce them.

\subsubsection{Evaluation forcing constructs}

The EHCode uses a strict let binding to force evaluation. Called let! (Let bang). The GhcCore uses the case expression as the only place where evaluating is forced.

\section{Hook into the compiler}


To get a new output chain in the compiler not much has to be changed. The files to look in is are { \bf EHC.chs } and { \bf EHCommon.chs}. The latter contains the definitions of the 'option datatype' and command line switch definitions and help messages (see variable |cmdLineOpts|). 

If the option is added (in our case a new option to the @-c@ switch) the compiler driver must be extended. This is done in { \bf EHC.chs }. The shuffle part @outputPass@ contains the compiler output pass. Overriding this to allow output is not hard since two examples already are availible (java output and code output).

\subsection{Makefile}

The Makefile however is a different story. It is not documented, and hard to understand without good knowledge of make. Which we have not.

To make the AG files compile some @DPDS_*@ variables should be added. Which have the form of @target dependency1 ... dependencyN@.

The second problem is that an AG file not always should output the datatypes. These should be defined in the @EHC_LAG_FOR_HS_*@ variables, which are used in the file {\bf mk/ehfiles.mk}. So here we also have to add these variable lines.

We have noted that not all dependencies are correct at the moment, which is a shame. But since we had very limited time we just continued working at the intresting parts.

\section{Add type information to EHCode}

In the beginning we were using directly the EH language. This language had all the information we needed. But of course a lot of analysis and desugaring in the front end of EHC is done on EH when translating into EHCode so the EH language is for the front-end only.

We are going to explain what we have changed in EHCode abstract syntax. Then we will show the changes when we generate the EHCode, which is done in {\bf EHGenCode.cag}.

\subsection{Top Module}

To make a correct GhcModule out of EHCode we bind the toplevel EH expression to an exported top level function named \emph{top}. Since every binding needs a type we have to add the type of the expression that corresponds to the top binding. So we introduce a ty in CModule.

\medskip

\file{EHCodeAbsSyn.cag}
\begin{code}
DATA  CModule
  |  Mod         baseName        :  {String}
                 ty              :  Ty
                 expr            :  CExpr
\end{code}

\medskip

Generating this information from EH is simple.

\medskip

\file{EHGenCode.cag}
\begin{code}
SEM AGItf
  | AGItf       lhs         .   cmodule     =   CModule_Mod @lhs.baseName @expr.ty @expr.cexpr
\end{code}

\subsection{Lambda Abstractions}

In Lambda Abstractions we add a Type for binding of argument variables.

\medskip

\file{EHCodeAbsSyn.cag}
\begin{code}
DATA CExpr
  |  Lam         arg             :  {HsName}
                 ty              :  Ty
                 body            :  CExpr
\end{code}

\medskip

Again this is not hard to include.

\medskip
\file{EHGenCode.cag}
\begin{code}
SEM CEXpr
  | Lam         loc         .   cexpr       :=   CExpr_Lam @arg.topNm @arg.ty ...
\end{code}

\subsection{Pattern variables}

For the pattern variables we include type info in the same way. 

\medskip

\file{EHCodeAbsSyn.cag}
\begin{code}
DATA  CPat
  |  Var         pnm             :  {CPatNm}
                 ty              :  Ty

\end{code}

\file{EHGenCode.cag}
\begin{code}
SEM PatExpr
  | Var         lhs         .   cpat        =   CPat_Var @cpNm
\end{code}

\subsection{Let bindings}

We add Type information in the binds so we could know the type of the expression which is binded so we can create a typed bindings in a let. 

\medskip

\file{EHCodeAbsSyn.cag}
\begin{code}
DATA CBind
  | Bind        nm              : {HsName}
                ty              : Ty
                expr            : CExpr
\end{code}

\medskip

GHC Core provides Foreign Function Interface but we did not introduce that yet, we just included a type in the Foreign Function Interface and use it as a normal binding.

\medskip

\file{EHGenCode.cag}
\begin{code}
SEM Decl
  | Val         lhs         .   cbindL      =   [CBind_Bind @patExpr.topNm @expr.ty @expr.cexpr] ++ @patExpr.cbindL
  | FFI         lhs         .   cbindL      =   [CBind_Bind @nm @sigTy (CExpr_Var (HNm @impEnt))]

SEM Expr
  | Case        loc         .   cexpr       :=   let  n = uidHNm @lUniq
                                                 in   mkCExprLet CBindPlain emptyGam [CBind_Bind n @expr.ty @expr.cexpr]
                                                        (rceMatch [(n,@expr.ty)] @alts.caltL cvarUndefined)
\end{code}

As you can see the case alternative uses a binding, so we have to add that one too. The changes have been simple until now. The case is the first place the front end is actually doing something with EHCode rather than just building up the tree. It applies a pattern mattching comiling algorithm. The top level function of this algorithm is the |rceMatch| function. The changes needed to its implementation are far from trivial.

\subsubsection{Pattern matching compiling algorithm}

The front uses an Patern-matching compiler algorithm described in \cite{ipt:impl-func-prog-lang}.  The algoritm converts a nested pattern to a non overlapping pattern which is flat. i.e. Has a constructor and a list of variables. We give an example below.

\medskip

\noindent The algorithm changes a nested / overlapping case 
\begin{code}
case x of
    Left (Left   z)  -> z
    Left (Right  z)  -> z
\end{code}

%format y'
\noindent into a flat case
\begin{code}
case x of
    Left y ->  let! y' = y
               in  case y' of 
                      Left   z  -> y
                      Right  z  -> z
\end{code}

\medskip

Note that the let! expression is the forcing part of EHCode. Not the case expression. 

Since the algorithm can introduce let bindings and introduces new pattern variables we need to give the types of all identifiers and make them traverse through the algoritm. We have to introduce the type in the Constructor arguments since such an argument might change into a variable (see example above).

\header{More typeinfo}
A constructor in a pattern stores it arguments in a CPatBind datatype, so we extend that datatype.

\medskip

\file{EHCodeAbsSyn.cag}
\begin{code}
DATA  CPatBind
  |  Bind        offset          :  {Int}
                 nm              :  {HsName}
                 ty              :  Ty
                 pat             :  CPat
\end{code}

\medskip
 
The attribute |cbindL| is a associative list from argument name to its pattern. The argument name is the name of a label in a record. in case of a normal application the name is undefined. There is no reason to use an associative list for this since no lookup is done. However the datatype is availible and is nothing more than a list of tuples which is exacly what was needed here.

To get the type info out of EH language we change this attribute to include also the type info. The change is straitforward, we save types of record fields and of arguments of applications.

Finally  this list is used to create the pattern bindings.

\medskip

\file{EHGenCode.cag}
\begin{code}
ATTR AllPatExpr [ | | cpbindL: {AssocL HsName (Ty,CPat)} ]

SEM RecPatExpr
  | Empty       lhs         .   cpbindL     =   []
  | Ext         lhs         .   cpbindL     =   (@nm,(@patExpr.ty,@patExpr.cpat)) : @recPatExpr.cpbindL

SEM PatExpr
  | App         lhs         .   cpbindL     =   (hsnUnknown,(@arg.ty,@arg.cpat)) : @func.cpbindL
  | AppTop      loc         .   cpbindL     =   @patExpr.cpbindL
  | Rec         loc         .   cpbindL     =   @recPatExpr.cpbindL
  | Con         loc         .   cpbindL     =   []
  | * - App Con 
                lhs         .   cpbindL     =   []

  | AppTop Con Rec
                loc         .   cpatBinds   =   map (\(o,(n,(t,p))) -> CPatBind_Bind o n t p) . zip [0..] . tyRowCanonOrder . reverse $ @cpbindL
                lhs         .   cpat        =   CPat_Con @cpNm @tag @appFunNm @cpatBinds
\end{code}

\medskip

\header{rceMatch}
|rceMatch| first make partitions of patterns which are just variables and patterns which are not. It makes a let binding for the default expressions (|ce|) when it is not a simple variables to prevent duplication of code. For the others it calls rceMatchVarCon directly.

\medskip

\file{EHGenCode.cag}
\begin{code}
rceMatch :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatch [] []    ce =  ce
rceMatch [] alts  ce
  =  case [ e | (CAlt_Alt [] e) <- alts ] of
       (e:_)  -> e
       _      -> ce

rceMatch args alts ce
  =  foldr
        (\alts e
           ->  case e of
                  CExpr_Var _
                     ->  rceMatchVarCon args alts e
                  _  ->  let  bty = Ty_Any
                              bnm = HNm ("_casecont_" ++ (show . cpatVarNm . caltPat . head $ alts))
                              vc = rceMatchVarCon args alts (CExpr_Var bnm)
                         in   mkCExprLet CBindPlain emptyGam [CBind_Bind bnm bty e] vc
       )
        ce
     $ (rceSplit caltIsVar alts)

-- nothing changed here
rceSplit :: (CAlt -> Bool) -> CAltL -> [CAltL]
rceSplit f []   = []
rceSplit f [x]  = [[x]]
rceSplit f (x:xs@(x':_))
  | f x == f x'  =  let  (z:zs) = rceSplit f xs
                    in   (x:z) : zs
  | otherwise    =  [x] : rceSplit f xs

\end{code}

\header{rceMatchVarCon}
|rceMatchVarCon| is simply a dispatcher to match a variable or a constructor.

\medskip

\file{EHGenCode.cag}
\begin{code}
rceMatchVarCon :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchVarCon args alts@(alt:_) ce
  |  caltIsVar alt  = rceMatchVar args alts ce
  |  otherwise      = rceMatchCon args alts ce

\end{code}

\header{rceMatchVar}
Matching on a single variable is superfluous. |rceMatchVar| converts such a pattern into a let binding with the body of this |let| the rest of the match. 

\medskip

\file{EHGenCode.cag}
\begin{code}
rceRebinds :: (HsName,Ty) -> CAltL -> CBindL
rceRebinds (nm,ty) alts = [ CBind_Bind n ty (CExpr_Var nm) | (CPatNmOrig n) <- caltLPatNms alts, n /= nm ]

rceMatchVar :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchVar (arg:args') alts ce
  =  let  remMatch  = rceMatch args' [CAlt_Alt remPats e | (CAlt_Alt (CPat_Var n t : remPats) e) <- alts] ce
     in   mkCExprLet CBindPlain emptyGam (rceRebinds arg alts) remMatch
\end{code}

\header{rceMatchCon}

|rceMatchCon| takes care of grouping of patterns which start with the same constructor and create an |let!| and a case which only will inspect the top level constructor and create the rest of the match by calling rceMatch recursively. So it flattens the pattern match into a case with distict constuctor tags which binds variables only.

The information in the |CPatBind_Bind| is extracted to be used in a let bound variabe or in a pattern variable.

\medskip

\file{EHGenCode.cag}
\begin{code}
rceMatchCon :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchCon args@((nm,ty):args') alts ce
  =  let  arg'   =  hsnPrefix "!" nm
          alts'  =  map
                      (\alts
                        ->  let  (subAlts,subAltSubNms)
                                               =  unzip
                                                    [ (CAlt_Alt (map snd pats ++ ps) e, map (\(t,p) -> (cpatNmNm . cpatVarNm $ p, t)) pats)
                                                    | (CAlt_Alt (CPat_Con _ _ _ pbinds : ps) e) <- alts,
                                                      let pats = [ (t,p) | (CPatBind_Bind _ _ t p) <- pbinds ]
                                                    ]
                                 subMatch      =  rceMatch (head subAltSubNms ++ args') subAlts ce
                                 altPat        =  case head alts of
                                                    CAlt_Alt (CPat_Con n conTag tn pbinds : _) _
                                                      -> CPat_Con n conTag tn [ CPatBind_Bind o n t (CPat_Var (cpatVarNm p) t) | (CPatBind_Bind o n t p) <- pbinds ]
                            in   CAlt_Alt [altPat] (mkCExprLet CBindPlain emptyGam (rceRebinds (arg',ty) alts) subMatch)
                      )
                 .  groupBy (\a1 a2 -> caltTag a1 == caltTag a2)
                 .  sortBy (\a1 a2 -> caltTag a1 `compare` caltTag a2)
                 .  filter (not . null . caltPatL)
                 $  alts
     in   ceStrictIn arg' ty (CExpr_Var nm) (\n -> CExpr_Case n alts' ce)
\end{code}

\medskip

\subsection{Datatypes}

Datatypes in EHCode are translated into Constructor functions which generate records and variants. See example below

\medskip
\noindent EH
\begin{code}
let  data MaybeInt  =  Just Int 
                    |  Nothing
in   e
\end{code}
\medskip
\noindent translate into EHCode
\begin{code}
let  Just     =  \x1 ->  #()  (0)  (x1) 
     Nothing  =          #()  (1) 
in   e
\end{code}

\medskip

GHC Core needs the datatype the same way as Haskell defines them. So we will have to reintroduce them. Forunately there is a type environment at every let expression which contains the structure and all type information of the newly introduced datatypes (attribute |lQuTyGam|). We add this information to EHCode. In section \ref{reintroduce_datatypes} we reconstruct datatype declarations out of this gamma.

\section{Translating EHCode to GhcCore}

Now we have introduced type information into EHCode the translations to GhcCore is for most language constructs straitforward. There are two exceptions to that.

\begin{enumerate}
	\item let! and case constructs
	\item Datatype definitions
	\item type arguments for polymorphic functions and constructors.
\end{enumerate}

We will only show these aspects of the translation process. The source file is {\bf EHGhcCoreMain.cag}.

\subsection{let! and case}

EHCode evaluate with let!. GhcCore with a case construct. Defining a mapping from a let! to a case is surprisingly simple. The most common case would be a let! followed by a case since the let! construct is only generated for a case expression in the EH language. Not all constructs though, consider the following program:

\medskip
\begin{code}
case x of 
    y  ->  e
\end{code} 
\medskip

This case expression, with a match on a variable, is removed and a let! without a case expression results. So we should take care of this situation.

Recall the case expression of GHC Core in section \ref{GhcCore}. The translation rules are a natural translation.  For the let! without a case we map to a GHC Core case expression with one alternative; The default alternative.

%format p1 = "p^{1}"
%format e1 = "e^{1}"
%format pn = "p^{n}"
%format en = "e^{n}"
%format e'
\begin{center}
\begin{tabular}[c]{||rcl||}
\hline & & \\
\begin{minipage}{5cm}
\begin{code}
let!  x :: t = e
in    case x of 
          p1  ->  e1
	  ...
          pn  ->  en
\end{code} 
\end{minipage}
& $\mapsto$ &
\begin{minipage}{5cm}
\begin{code}
%case e of x :: t
          p1  ->  e1
	  ...
          pn  ->  en
\end{code}
\end{minipage}

\\ & & \\ \hline & & \\ 

\begin{minipage}{5cm}
\begin{code}
let!  x :: t = e
in e'
\end{code} 
\end{minipage}
& $\mapsto$ &
\begin{minipage}{5cm}
\begin{code}
%case e of x :: t
          %_  ->  e'
\end{code}
\end{minipage}

\\ & & \\ \hline

\end{tabular}
\end{center}

The last case we should take care of would be a case without a let!. This construction might be introduced when it can be proven by the compiler that the expression to be scrutinized is always a value and thus does not need evaluation. In this case the |vbind| of the GHC Core |%case| expression makes the job difficult. Without the |let!| we have no clue what the type of this binding should be. 

Currently the compiler generates an error when this situation occurs.

\subsection{Reintroducing data definitions}
\label{reintroduce_datatypes}

GHC Core require datatype declarions. We are going to use the datatype information stored in let expression to reintroduce datatype declarations. But first we have to overcome another problem. in EH it is allowed to define datatypes in every let binding, but GHC Core allows it only at the toplevel. To prevent nameclashes we append a unique number to all datatype and constructor names. An other options would be number every let unique however we chose to number the constructor and datatype names. See section \ref{examples} for an example of a redefined datatype.

The reintroduction is done by the |tyGam2DataTypes| which destruct the datatype environment and builds a list of GHC Core datatypes.

\medskip

\begin{code}
tyGam2DataTypes tnamesMap cnamesMap tg =
                              let  datas                       =  gamToAssocL tg
                                   ghcdata                     =  map buildDataType datas
                                   buildDataType (dt,ti)       =  TypeDef_Data (show . fromJust "TypeDef_Data" $ gamLookup dt tnamesMap) [] (buildAlternatives $ tgiData ti)
                                   buildAlternatives structTy  =  let  vars  ::  [(HsName, [(HsName, Ty)])]
                                                                       vars  =   assocLMapSnd (snd . tyRecExts) . snd . tyRecExts $ structTy
                                                                       buildAlternative (cnm,fields) = ConsDef_ConsDef (show . fromJust "ConsDef_ConsDef" $ gamLookup cnm cnamesMap) [] (map (convertTy tnamesMap . snd) fields)
                                                                  in map buildAlternative vars
                              in  ghcdata
\end{code}

\medskip

The |tnamesMap| and |cnamesMap| are rename maps which should contain a mapping for all datatype and constructor names. Note that this translation is incorrect with respect to the higher kinded datatypes. Those types should get the correct number of type arguments.

Figure \ref{overview2} gives an overview of the translation of a datatype definition leaving out the renaming.

The |convertTy| in this code is a renaming function of the datatype names which occur in the types.


\begin{figure}
\caption{translation of datatype definition}
\label{overview2}
\includegraphics[scale=1.5,angle=-90]{overview2}
\end{figure}


\subsection{Outputting GHC Core Code}

\medskip

Outputting the GHC Core code  was quite straightforward, we just created a pretty printer for our version, which is located in the file {\bf EHGhcCorePretty.cag} and made some changes in the pretty printer of the types ({\bf EHTyPretty.cag}). 

To make the generated output compilable, we needed to include some extra information when printing Integers and Characters, i.e. describing that they where boxed direcly.

\medskip

\begin{code}
boxInt i =  "GHCziBase.Izh" >#< pp_parens (i >#< "::GHCziPrim.Intzh" )
boxChar c =  "GHCziBase.Czh" >#< pp_parens (c >#< "::GHCziPrim.Charzh" )
\end{code}

\medskip

The pretty printer will correctly output the data type located in {\bf EHGhcCoreAbsSyn.cag} with the view of GHC Core, which is quite close to normal Haskell code, only some \% are added and some type information that was discussed in the upper sections.

\medskip

We have encountered a problem with the pretty printer that is not clear yet: When the expected generated output is too big, the pretty printer will not work.

\subsubsection{Outputting Types}

\medskip

To output correctly the Types we just changed the {\bf EHTyPretty.cag} in some parts:

\medskip

We use an inherited attribute to signal the GHC Core output of types.  We added
the ppGhcCoreTy to take the module identifier and give it to the type prittyprinter to use in GHC Core output.

\medskip

\begin{code}
ATTR TyAGItf AllTy [ ghcModuleID: {Maybe String} | | pp: PP_Doc ]

ppGhcCoreTy ::  String -> Ty -> PP_Doc
ppGhcCoreTy moduleID ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf (Just moduleID))
     in   pp_Syn_TyAGItf t

\end{code}

\bigskip

Every type or constructor identifier must have a GHC Module identifier. It must be a fully qualified name. So we output this. If the constructor is a buildin type it needs the GHHziBase modulename. The zi is an encoding for the '.' (dot).

Every other constructor identifier uses the module name in the attribute |ghcModuleID|.

\medskip

\begin{code}
SEM Ty
  | Con            loc      . conName   = let ghcModName nm mid = if @nm == hsnInt || @nm == hsnChar then "GHCziBase." else (mid ++ ".")
                                              ghcQualName nm mid = hsnPrefix (ghcModName nm mid) nm
                                          in (maybe @nm (ghcQualName @nm) @lhs.ghcModuleID)
                            . pp        := ppCon @conName
\end{code}

\bigskip

\section{Future work: Type aguments}

GHC Core allows types as arguments of polymorphic functions in the style of Typed lambda calculus. Suppose we have the following useless EH program:

\medskip

\begin{code}
let  skipInt :: forall a . Int -> a -> a
     skipInt i x = x
     twice x = skipInt x skipInt
in   ...
\end{code}

\medskip

In GHC Core this would be expressed as:

\medskip

\begin{code}
%let  skipInt :: %forall a . Int -> a -> a = 
          \@a (x::a) -> a
      twice :: %forall a . Int -> Int -> a -> a =
          \@t (x::Int) -> skipInt @(Int -> t -> t) x (skipInt @t)
%in   ...
\end{code}

\medskip

Note that the type arguments are always the first argument. This not clear from the definition of the grammer of GHC Core as given in \cite{tolmach2001ghc-core} (see also section \ref{GhcCore}). Type arguments are always passed when a polymorphic identifier is used. Haskell allows only monomorphic arguments so this is ok.

The correct introduction of the type arguments need even more type information. Every application should include the types of both function and application. The function expression can be used to get the number of type arguments and the types of the arguments are filled in in the correct positions.

But what to do with polymorphic arguments. These are not allowed and should get their type arguments to make them monomporph. As show in the last |skipInt| in the example above.

Unfornuatly our time did not permit to investigate this deeper, let alone implement this.

\section{Overview to the added/created files}

This is an overview of what we have specifically done in the files point of view. We have created version 8\_1 of EHC adding some necessary files:

\begin{itemize}
\item
{\bf EHGhcCoreAbsSyn.cag}: 
                     It contains the Data type of the Abstract Syntax Tree used to represent GHC Core language;
\item
{\bf EHGhcCoreMain.cag}:  
                     It contains the translation from EHCode to GHC Core;
\item
{\bf EHGhcCore.cag}: 
                     It contains the Haskell importable interface to GhcCore backend;
\item
{\bf EHGhcCorePretty.cag}:
                     It contains the pretty printer of the GHC Core Abstract Syntax Tree;
\end{itemize}

And we have changed files from version 8 of EHC:

\begin{itemize}
\item
{\bf EHC.chs}: 
                     Added compile rule for GhcCore backend;
\item
{\bf EHCodeAbsSyn.cag}: 
                     Made some changes on EHCode Abstract Syntax Tree;
\item
{\bf EHCode.cag}: 
                     Changed auxiliar functions related to EHCode Abstract Syntax Tree;
\item
{\bf EHCommon.chs}: 
                     Added auxiliar function;
\item
{\bf EHGenCode.cag}: 
                     Changed functions related to the translation of EH language to EHCode;
\item
{\bf EHMainAG.cag}:  
                     Added import rules;
\item
{\bf EHTyPretty.cag}:
                     Changed the Pretty Printer for Types;
\item
{\bf Makefile}:
                     Added make rules for version 8\_1 and rules for the new files;
\end{itemize}

\bigskip

\section{Conclusions}

\medskip

After this project we can conclude that.........

\section{Examples}
\label{examples}

\medskip

Here we show some examples, so its easier to understand the main translation. For each example we will show the code in the 3 phases, which are EH, EHCode and GHC Core.

\medskip

The first example is a simple representation of the Integer 3;

\medskip

\begin{code}

>>> EH int <<<
let
in 3

>>> EHCode int <<<
module int
3

>>> GHC Core int <<<
%module Top
top :: GHCziBase.Int = GHCziBase.Izh (3 ::GHCziPrim.Intzh);
\end{code}

\medskip

The next example is a normal let binding;

\medskip

\begin{code}

>>> EH letbinding <<<
let f :: Int -> Int
    f = \i -> i
in f 3

>>> EHCode letbinding <<<
module letbinding
let rec
 f
  = \i
     -> i
in
 f
  (3)

>>> GHC Core letbinding <<<
%module Top
top :: GHCziBase.Int = %let %rec {f :: GHCziBase.Int -> GHCziBase.Int = \ (i :: GHCziBase.Int) -> i}
                       %in f (GHCziBase.Izh (3 ::GHCziPrim.Intzh));
\end{code}

\medskip

The next example is a normal data type;

\medskip

\begin{code}
>>> EH datatype <<<
let data MaybeInt = Just Int | Nothing
in Just 3

>>> EHCode datatype <<<
module datatype
let rec
 Just
  = \x1
     -> #()
         (0)
         (x1)
 Nothing
  = #()
     (1)
in
 Just
  (3)

>>> GHC Core datatype <<<
%module Top
%data Top.MaybeInt0  = {Top.Just1  GHCziBase.Int ;Top.Nothing2  };
top :: Top.MaybeInt = Top.Just1 (GHCziBase.Izh (3 ::GHCziPrim.Intzh));
\end{code}

\medskip

The next example shows how we dealed when a data type is redefined;

\medskip

\begin{code}
>>> EH doubledata <<<
let data Foo = Foo Char
in let data Foo = Foo Int
   in case Foo 3 of
         Foo x -> x

>>> EHCode doubledata <<<
module doubledata
let rec
 Foo
  = \x1
     -> #()
         (0)
         (x1)
in
 let rec
  Foo
   = \x1
      -> #()
          (0)
          (x1)
 in
  let
   14_0
    = Foo
       (3)
  in
   let !
    !14_0
     = 14_0
   in
    case !14_0
     of
      (0=Foo:(0=x))
       -> x
      _-> undefined

>>> GHC Core doubledata <<<
%module Top
%data Top.Foo0  = {Top.Foo1  GHCziBase.Char };
%data Top.Foo2  = {Top.Foo3  GHCziBase.Int };
top :: GHCziBase.Int = %let _14_0 :: Top.Foo2 = Top.Foo3 (GHCziBase.Izh (3 ::GHCziPrim.Intzh))
                       %in %case _14_0 %of
                           (_bang_14_0 :: Top.Foo2)
                           {Top.Foo3  (x :: GHCziBase.Int) -> x};
\end{code}

\medskip

The next example shows a normal case expression;

\medskip

\begin{code}
>>> EH case <<<
let data MaybeInt
        = Just Int
        | Nothing
in case Just 3 of
        Nothing -> 0
        Just x  -> x

>>> EHCode case <<<
module case
let rec
 Just
  = \x1
     -> #()
         (0)
         (x1)
 Nothing
  = #()
     (1)
in
 let
  8_0
   = Just
      (3)
 in
  let !
   !8_0
    = 8_0
  in
   case !8_0
    of
     (0=Just:(0=x))
      -> x
     (1=Nothing:())
      -> 0
     _-> undefined

>>> GHC Core case <<<
%module Top
%data Top.MaybeInt0  = {Top.Just1  GHCziBase.Int ;Top.Nothing2  };
top :: GHCziBase.Int = %let _8_0 :: Top.MaybeInt0 = Top.Just1 (GHCziBase.Izh (3 ::GHCziPrim.Intzh))
                       %in %case _8_0 %of
                           (_bang_8_0 :: Top.MaybeInt0)
                           {Top.Just1  (x :: GHCziBase.Int) -> x;Top.Nothing2   -> GHCziBase.Izh (0 ::GHCziPrim.Intzh)};
\end{code}

\medskip

The next example shows how we dealed with recursive data types;

\medskip

\begin{code}
>> EH recursivedata2 <<<
let data IntList = Nil | Cons Int IntList
in case Cons 3 Nil of
        Cons x _ -> x

>>> EHCode recursivedata2 <<<
module recursivedata2
let rec
 Nil
  = #()
     (1)
 Cons
  = \x1
     -> \x2
         -> #()
             (0)
             (x1)
             (x2)
in
 let
  8_0
   = Cons
      (3)
      (Nil)
 in
  let !
   !8_0
    = 8_0
  in
   case !8_0
    of
     (0=Cons:(0=x,1=23_0))
      -> x
     _-> undefined

>>> GHC Core recursivedata2 <<<
%module Top
%data Top.IntList0  = {Top.Nil1  ;Top.Cons2  GHCziBase.Int Top.IntList0 };
top :: GHCziBase.Int = %let _8_0 :: Top.IntList0 = Top.Cons2 (GHCziBase.Izh (3 ::GHCziPrim.Intzh)) (Top.Nil1)
                       %in %case _8_0 %of
                           (_bang_8_0 :: Top.IntList0)
                           {Top.Cons2  (x :: GHCziBase.Int)
                                       (_23_0 :: Top.IntList0) -> x
                           };
\end{code}

\bigskip

%%%% REFERENCES %%%
\section{References}
\bibliographystyle{../uhcbook}
%\bibliographystyle{plain}
\bibliography{references}

\end{document}
