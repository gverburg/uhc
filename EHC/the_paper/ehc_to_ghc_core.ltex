
%
%  Efficient Implementation of Functional Languages
%  2004/2005
%


\documentclass[12pt]{article}
%include lhs2TeX.fmt
%include lhs2TeX.sty

%format ATTR = "\mathbf{ATTR}"
%format DATA = "\mathbf{DATA}"
%format SEM = "\mathbf{SEM}"
%format lhs = "\mathbf{lhs}"
%format . = "."
%format $ = "\$"

\usepackage{a4wide}
%\usepackage{graphics}
%\usepackage{graphicx}
%\usepackage{color}
%\usepackage{alltt}
%\usepackage[portuges]{babel}
%\usepackage[latin1]{inputenc}
%\usepackage{latexsym}


%\usepackage{noweb}

%\usepackage[dvips]{epsfig}
%\usepackage{epic}
%\usepackage{eepic}

%\usepackage{hyperref}


\def\Ipe#1{\def\IPEfile{#1}\input{#1}}

\newtheorem{exercicio}{}[section]

\title{\sf EHC to GHC Core Backend \\
\begin{tabular}{c}
{\small University of Utrecht} \\
{\small 2004/2005}  \\
{\small http://www.cs.uu.nl/groups/ST/Eifl/EHCToGhcCore} \\
\end{tabular}
}

\author{Christof Douma \\ Rodrigo Baptista}
\date{}


%\def\eg{\textit{e.g.}}
%\def\ie{\textit{i.e.}}
%\def\attrid#1{\textit{#1}}
%\def\bnfnt#1{\textit{#1}}
%\def\bnfprod#1{\textit{#1}}
%\def\semfun#1{\textsf{#1}}

\begin{document}


\maketitle


\tableofcontents

\section{Introduction}

The purpose of this project is to generate GHC Core code from EHC language. GHC Core is an intermediate language of the Glasgow Haskell Compiler which is an internal representation of various compiling stages in GHC.

EHC is a more-or-less Haskell Compiler and it is a evolutionary project because the final compiler envolves via intermediate steps, so it is divided in various versions. This backend is an extension of version 8 of EHC (8\_1) so it will be one more step to extend the future compiler.EHC has an intermediate Core language too, that will be our source language to generate the GHC Core. 

This report is pointed to students or people that are interested to extend this project and we assume that they already have knowledge in the implementation and structure of EHC. We will try to be specific explainning the various steps of the implementation,showing the code and some examples.

\bigskip


\section{The Grammar of GHC Core}

The Grammar is represented in ----Andrew Tolmach. An External Representation for the GHC Core Language (Draft for GHC5.02). http://www.haskell.org/ghc/documentation.html, 2001---- but we simplified it because version 8 of EHC limits some implementation parts of the Grammar.Below you can see the representation of our grammar version:

\(
\begin{array}{l}
\begin{array}[t]{lclccl}
& & GhcModule  & module   & \rightarrow  & mident \\ tdefs \\ vdefs
& & Typedef.   & tdef     & \rightarrow  & dident \\ tbinders \\ cdefs
& &            &          &  ||           & dident \\ tbinders \\ maybetype?
& & ...
\end{array} \\
\end{array}
\)


\bigskip


\section{The Source Language}

The source language of the backend is EHC Core,although in the beginning we were trying to use directly EH source language but then we realized that it wasnt correct, because between EH language and EH Core, it is made many useful transformations and optimizations. 

The Abstract Syntax Tree of EH Core is specified in {\bf EHCodeAbsSyn.cag}, now we are going to explain what we have changed in the tree, then we will show the changes when we generate the EH Core,which is implied in {\bf EHGenCode.cag}, and after in the related Haskell functions specified in the {\bf EHCode.cag}.

\bigskip


\subsection{The Abstract Syntax Tree}
....... in four parts:

\begin{itemize}
\item
We have considered that a Code Module has, besides of a base name and an code expression, an extra Type that corresponds to the top binding;

\medskip

\begin{code}
%%[8.CModule
DATA  CModule
  |  Mod         baseName        :  {String}
                 expr            :  CExpr
%%]

%%[8_1.CModule -8.CModule
DATA  CModule
  |  Mod         baseName        :  {String}
                 ty              :  Ty
                 expr            :  CExpr
%%]
\end{code}

\bigskip

\item
In Let expressions we have added a Type Gama so we could after create data type constructors in GHC Core. In Lambda Abstractions we have added a Type for binding;

\medskip

\begin{code}
%%[8.LamLet
  |  Let         categ           :  {CBindCateg}
                 binds           :  CBindL
                 body            :  CExpr
  |  Lam         arg             :  {HsName}
                 body            :  CExpr
%%]

%%[8_1.LamLet -8.LamLet
  |  Let         categ           :  {CBindCateg}
                 tyGam           :  {TyGam}
                 binds           :  CBindL
                 body            :  CExpr
  |  Lam         arg             :  {HsName}
                 ty              :  Ty
                 body            :  CExpr
%%]
\end{code}

\bigskip

\item
We have added Type information in the Binds so we could know the type of the related expression;

\medskip

\begin{code}
%%[8.Bind
DATA CBind
  | Bind        nm              : {HsName}
                expr            : CExpr
%%]

%%[8_1.Bind -8.Bind
DATA CBind
  | Bind        nm              : {HsName}
                ty              : Ty
                expr            : CExpr
%%]
\end{code}

\bigskip

\item
We have added Type information in the variables of the Patterns;

\medskip

\begin{code}
%%[8.CPat
DATA CPat
  | Var         pnm             : {CPatNm}
  | Con         pnm             : {CPatNm}
                tag             : {Int}
                tagNm           : {HsName}
                binds           : CPatBindL
  | Undef
%%]

%%[8_1.CPat -8.CPat
DATA CPat
  | Var         pnm             : {CPatNm}
                ty              : Ty
  | Con         pnm             : {CPatNm}
                tag             : {Int}
                tagNm           : {HsName}
                binds           : CPatBindL
  | Undef
%%]
\end{code}

\end{itemize}

\bigskip


\subsection{Generating EH Core Code}
Changing the Abstract Syntax Tree of EH Core we had to update the code generation correctly. Below you can see the various changes:

Now the CModule receives the type of the top expression;

\medskip


\begin{code}
%%[8.Top
ATTR AGItf [ | | cmodule: CModule ]

SEM AGItf
  | AGItf       lhs         .   cmodule     =   CModule_Mod @lhs.baseName @expr.cexpr
%%]

%%[8_1.Top -8.Top
ATTR AGItf [ | | cmodule: CModule ]

SEM AGItf
  | AGItf       lhs         .   cmodule     =   CModule_Mod @lhs.baseName @expr.ty @expr.cexpr
%%]
\end{code}

\bigskip

?????

\medskip


\begin{code}
%%[8_1.LetLamCase
  | Let         loc         .   cexpr       :=   mkCExprLet CBindRec @lQuTyGam @decls.cbindL @body.cexpr
  | Lam         loc         .   cexpr       :=   CExpr_Lam @arg.topNm @arg.ty (rceMatch [(@arg.topNm,@arg.ty)] [CAlt_Alt [@arg.cpat] @body.cexpr] cvarUndefined)
  | Case        loc         .   cexpr       :=   let  n = uidHNm @lUniq
                                                 in   mkCExprLet CBindPlain emptyGam [CBind_Bind n @expr.ty @expr.cexpr]
                                                        (rceMatch [(n,@expr.ty)] @alts.caltL cvarUndefined)
%%]
\end{code}

\bigskip

To create a correct Bind list in the Values we have added the type of the expression. GHC Core provides Foreign Function Interface but we did not introduced yet, we just included a type in the Foreign Function Interface but it is not working properly;

\medskip

\begin{code}
%%[8.ValAndFFI
  | Val         lhs         .   cbindL      =   [CBind_Bind @patExpr.topNm @expr.cexpr] ++ @patExpr.cbindL
  | FFI         lhs         .   cbindL      =   [CBind_Bind @nm (CExpr_Var (HNm @impEnt))]
%%]
%%[8_1.ValAndFFI -8.ValAndFFI
  | Val         lhs         .   cbindL      =   [CBind_Bind @patExpr.topNm @expr.ty @expr.cexpr] ++ @patExpr.cbindL
  | FFI         lhs         .   cbindL      =   [CBind_Bind @nm @sigTy (CExpr_Var (HNm @impEnt))]
%%]
\end{code}

\bigskip

We have updated the Pattern variables including the type information;

\medskip


\begin{code}
%%[8.PatVar
  | Var         lhs         .   cpat        =   CPat_Var @cpNm
%%]

%%[8_1.PatVar -8.PatVar
  | Var         lhs         .   cpat        =   CPat_Var @cpNm @ty
%%]
\end{code}

\bigskip

??????????

\medskip


\begin{code}
%%[8.PatExprAppTop
  | AppTop Rec  loc         .   cbindL      =   concat
                                                .  map  (\(CPatBind_Bind o _ p)
                                                            -> let  b n = [CBind_Bind n (CExpr_Sel (CExpr_Var @lhs.ceParentN
m) @tag (CExpr_Int o))]
                                                               in   case cpatVarNm p of
                                                                        CPatNmOrig n                          -> b n
                                                                        CPatNmUniq n | not (null @cbindLSub)  -> b n
                                                                        _                                     -> []
                                                        )
                                                $  @cpatBinds
                lhs         .   cbindL      =   @cbindL ++ @cbindLSub
%%]

%%[8_1.PatExprAppTop -8.PatExprAppTop
  | AppTop Rec  loc         .   cbindL      =   concat
                                                .  map  (\(CPatBind_Bind o _ p)
                                                            -> let  b n = [CBind_Bind n Ty_Any (CExpr_Sel (CExpr_Var @lhs.ce
ParentNm) @tag (CExpr_Int o))]
                                                               in   case cpatVarNm p of
                                                                        CPatNmOrig n                          -> b n
                                                                        CPatNmUniq n | not (null @cbindLSub)  -> b n
                                                                        _                                     -> []
                                                        )
                                                $  @cpatBinds
                lhs         .   cbindL      =   @cbindL ++ @cbindLSub
%%]
\end{code}

\bigskip

????????

\medskip

\begin{code}
%%[8_1.reorderCase -8.reorderCase hs
rceSplit :: (CAlt -> Bool) -> CAltL -> [CAltL]
rceSplit f []   = []
rceSplit f [x]  = [[x]]
rceSplit f (x:xs@(x':_))
  | f x == f x'  =  let  (z:zs) = rceSplit f xs
                    in   (x:z) : zs
  | otherwise    =  [x] : rceSplit f xs

rceAltsForCon :: CAltL -> HsName -> CAltL
rceAltsForCon alts conNm
  = [a | a@(CAlt_Alt (CPat_Con _ _ nm _ : _) _) <- alts, nm == conNm]

rceRebinds :: (HsName,Ty) -> CAltL -> CBindL
rceRebinds (nm,ty) alts = [ CBind_Bind n ty (CExpr_Var nm) | (CPatNmOrig n) <- caltLPatNms alts, n /= nm ]

rceMatchVar :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchVar (arg:args') alts ce
  =  let  remMatch  = rceMatch args' [CAlt_Alt remPats e | (CAlt_Alt (CPat_Var n t : remPats) e) <- alts] ce
     in   mkCExprLet CBindPlain emptyGam (rceRebinds arg alts) remMatch

rceMatchCon :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchCon args@((nm,ty):args') alts ce
  =  let  arg'   =  hsnPrefix "!" nm
          alts'  =  map
                      (\alts
                        ->  let  (subAlts,subAltSubNms)
                                               =  unzip
                                                    [ (CAlt_Alt (pats ++ ps) e, map (\p -> (cpatNmNm . cpatVarNm $ p, cpatVarTy p)) pats)
                                                    | (CAlt_Alt (CPat_Con _ _ _ pbinds : ps) e) <- alts,
                                                      let pats = [ p | (CPatBind_Bind _ _ p) <- pbinds ]
                                                    ]
                                 subMatch      =  rceMatch (head subAltSubNms ++ args') subAlts ce
                                 altPat        =  case head alts of
                                                    CAlt_Alt (CPat_Con n t tn pbinds : _) _
                                                      -> CPat_Con n t tn [ CPatBind_Bind o n (CPat_Var (cpatVarNm p) (cpatVarTy p)) | (CPatBind_Bind o n p) <- pbinds ]
                            in   CAlt_Alt [altPat] (mkCExprLet CBindPlain emptyGam (rceRebinds (arg',ty) alts) subMatch)
                      )
                 .  groupBy (\a1 a2 -> caltTag a1 == caltTag a2)
                 .  sortBy (\a1 a2 -> caltTag a1 `compare` caltTag a2)
                 .  filter (not . null . caltPatL)
                 $  alts
     in   ceStrictIn arg' ty (CExpr_Var nm) (\n -> CExpr_Case n alts' ce)

rceMatchVarCon :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatchVarCon args alts@(alt:_) ce
  |  caltIsVar alt  = rceMatchVar args alts ce
  |  otherwise      = rceMatchCon args alts ce

rceMatch :: [(HsName, Ty)] -> CAltL -> CExpr -> CExpr
rceMatch [] []    ce =  ce
rceMatch [] alts  ce
  =  case [ e | (CAlt_Alt [] e) <- alts ] of
       (e:_)  -> e
       _      -> ce
-- TODO: create a correct type in bty for the new let binding!
rceMatch args alts ce
  =  foldr
        (\alts e
           ->  case e of
                  CExpr_Var _
                     ->  rceMatchVarCon args alts e
                  _  ->  let  bty = Ty_Any
                              bnm = HNm ("_casecont_" ++ (show . cpatVarNm . caltPat . head $ alts))
                              vc = rceMatchVarCon args alts (CExpr_Var bnm)
                         in   mkCExprLet CBindPlain emptyGam [CBind_Bind bnm bty e] vc
       )
        ce
     $ (rceSplit caltIsVar alts)
%%]
\end{code}

\bigskip

changed data constructor.......

\medskip

\begin{code}
%%[8.DataConstr
SEM DataConstr
  | Constr      loc         .   tag         =   fromJust (tyRecOffset @conNm @lhs.dataAltTy)
                lhs         .   cbindL      =   let  len = length @fields.tyL
                                                     nms = map (\i -> HNm ("x" ++ show i)) [1..len]
                                                in   [CBind_Bind @conNm
                                                        (mkCExprLam nms
                                                          (mkCExprApp (CExpr_App CExpr_Tup (CExpr_Int @tag))
                                                            (map CExpr_Var nms)))
                                                     ]
%%]

%%[8_1.DataConstr -8.DataConstr
SEM DataConstr
  | Constr      loc         .   tag         =   fromJust (tyRecOffset @conNm @lhs.dataAltTy)
                lhs         .   cbindL      =   let zipNameAndType ty lf i = let list = lf (i+1)
                                                                             in (HNm ("x" ++ show i), ty):list
                                                    nms = foldr zipNameAndType (const []) @fields.tyL 1
                                                in   [CBind_Bind @conNm @dataConTy
                                                        (mkCExprLam nms
                                                          (mkCExprApp (CExpr_App CExpr_Tup (CExpr_Int @tag))
                                                            (map (CExpr_Var . fst) nms)))
                                                     ]
%%]
\end{code}

\bigskip

\subsection{Haskell Functions}

Constructors functions

\medskip


\begin{code}
%%[8.mkLamLet hs
mkCExprLet :: CBindCateg -> CBindL -> CExpr -> CExpr
mkCExprLet c bs e = if null bs then e else CExpr_Let c bs e

mkCExprLetRec :: CBindL -> CExpr -> CExpr
mkCExprLetRec = mkCExprLet CBindRec

mkCExprLam :: [HsName] -> CExpr -> CExpr
mkCExprLam as e = foldr (\n e -> CExpr_Lam n e) e as
%%]

%%[8_1.mkLamLet -8.mkLamLet hs
mkCExprLet :: CBindCateg -> TyGam -> CBindL -> CExpr -> CExpr
mkCExprLet c tg bs e = if null bs then e else CExpr_Let c tg bs e

mkCExprLetRec :: TyGam -> CBindL -> CExpr -> CExpr
mkCExprLetRec = mkCExprLet CBindRec

mkCExprLam :: [(HsName, Ty)] -> CExpr -> CExpr
mkCExprLam as e = foldr (\(n,t) e -> CExpr_Lam n t e) e as
%%]
\end{code}

\bigskip


Destruction functions

\medskip

\begin{code}
%%[8.cpatVarNm hs
cpatVarNm :: CPat -> CPatNm
cpatVarNm (CPat_Var n)        = n
cpatVarNm (CPat_Con n _ _ _)  = n

caltIsVar :: CAlt -> Bool
caltIsVar (CAlt_Alt (CPat_Var _ : _) _)  = True
caltIsVar _                              = False
%%]

%%[8_1.cpatVarNm -8.cpatVarNm hs
cpatVarNm :: CPat -> CPatNm
cpatVarNm (CPat_Var n t)      = n
cpatVarNm (CPat_Con n _ _ _)  = n

cpatVarTy :: CPat -> Ty
cpatVarTy (CPat_Var n t) = t
cpatVarTy (CPat_Con n _ _ _)  = error "cpatVarTy: not a variable"

caltIsVar :: CAlt -> Bool
caltIsVar (CAlt_Alt (CPat_Var _ _ : _) _)  = True
caltIsVar _                                = False
%%]
\end{code}

\bigskip


Strict

\medskip

\begin{code}
%%[8.ceStrictIn hs
ceStrictIn :: HsName -> CExpr -> (CExpr -> CExpr) -> CExpr
ceStrictIn nm e mkC = CExpr_Let CBindStrict [CBind_Bind nm e] (mkC (CExpr_Var nm))
%%]

%%[8_1.ceStrictIn -8.ceStrictIn hs
ceStrictIn :: HsName -> Ty -> CExpr -> (CExpr -> CExpr) -> CExpr
ceStrictIn nm t e mkC = CExpr_Let CBindStrict emptyGam [CBind_Bind nm t e] (mkC (CExpr_Var nm))
%%]
\end{code}

\bigskip

\section{Overview to the added/created files}

This is an overview of what we have specifically done in the files point of view. We have created version 8\_1 of EHC adding some necessary files:

\begin{itemize}
\item
{\bf EHGhcCoreAbsSyn.cag}: 
                     It contains the Data type of the Abstract Syntax Tree used to represent GHC Core language;
\item
{\bf EHGhcCoreMain.cag}:  
                     It contains the operational semantics and auxiliar functions;
\item
{\bf EHGhcCore.cag}: 
                     It contains the Haskell importable interface to GhcCore backend;
\item
{\bf EHGhcCorePretty.cag}:
                     It contains the pretty printer of the GHC Core Abstract Syntax Tree;
\end{itemize}

And we have changed files from version 8 of EHC:

\begin{itemize}
\item
{\bf EHC.chs}: 
                     Added compile rule for GhcCore backend;
\item
{\bf EHCodeAbsSyn.cag}: 
                     Made some changes on EH Code Abstract Syntax Tree;
\item
{\bf EHCode.cag}: 
                     Changed Haskell functions related to EH Code Abstract Syntax Tree;
\item
{\bf EHCommon.chs}: 
                     Added auxiliar function;
\item
{\bf EHGenCode.cag}: 
                     Changed functions related to the translation of EH language to EH Code;
\item
{\bf EHMainAG.cag}:  
                     Added import rules;
\item
{\bf EHTyPretty.cag}:
                     Changed the Pretty Printer for Types;
\item
{\bf Makefile}:
                     Added make rules for version 8\_1;
\end{itemize}

\bigskip

\section{Auxiliar Haskell Function}
We have added a simple haskell function to verify if a HsName is a Constructor.

\medskip

\begin{code}
%%[8_1 import(Data.Char)
hsnIsCon                           :: HsName -> Bool
hsnIsCon  (HNm (c:_))              = isUpper c
hsnIsCon  _                        = False
%%]
\end{code}

\bigskip

\section{Compiling the Backend}
\section{Examples}

\end{document}


