%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Simplify code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.RenUniq} import(Data.Maybe,Data.Char,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}) export(cmodTrfRenUniq)
%%]

%%[8.WRAPPER import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfRenUniq :: CModule -> CModule
cmodTrfRenUniq cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf {gUniq_Inh_CodeAGItf = uidStart})
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | Let         (binds.gUniq,loc.lUniq)     =   mkNewLevUID  @lhs.gUniq
  | Lam         (body.gUniq,loc.lUniq)      =   mkNewUID     @lhs.gUniq

SEM CAlt
  | Alt         (pats.gUniq,loc.lUniq)      =   mkNewLevUID  @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module name used to uniqify globally over all modules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[12
ATTR AllExpr [ moduleNm: HsName | | ]

SEM CModule
  | Mod         expr        .   moduleNm    =   @moduleNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% alpha renaming so all identifiers are unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type ARenMp = Map.Map HsName HsName
%%]

%%[12 hs
-- breaks assumption that globals are qualified, locals not. Problem in future when records are used for globals and access differs.
mkUniq :: HsName -> HsName -> UID -> HsName
mkUniq q n u
  = (if hsnIsQual n
    then id
    else hsnSetQual q) $ hsnSuffix n ("__" ++ show u)
%%]

%%[8.aRenAdd hs
aRenAdd :: [HsName] -> UID -> ARenMp -> ARenMp
aRenAdd nL u m
  =  let  uL = mkNewUIDL (length nL) u
     in   Map.fromList [ (n,hsnSuffix n ("__" ++ show u)) | (n,u) <- zip nL uL] `Map.union` m
%%]

%%[12 -8.aRenAdd hs
aRenAdd :: HsName -> [HsName] -> UID -> ARenMp -> ARenMp
aRenAdd q nL u m
  =  let  uL = mkNewUIDL (length nL) u
     in   Map.fromList [ (n,mkUniq q n u) | (n,u) <- zip nL uL] `Map.union` m
%%]

%%[8 hs
aRenRepl :: ARenMp -> HsName -> HsName
aRenRepl m n = maybe n id . Map.lookup n $ m
%%]

%%[8
ATTR AllCodeNT [ aRenMp: ARenMp  lev: Int | | ]
ATTR AllBind AllPat [ | | nmL USE {++} {[]}: {[HsName]} ]

SEM CodeAGItf
  | AGItf       module      .   aRenMp      =   Map.empty
                            .   lev         =   cLevOuter

SEM CBind
  | Bind        lhs         .   nmL         =   [@nm]

SEM CPatBind
  | Bind        lhs         .   nmL         =   [@nm] ++ @pat.nmL

SEM CPat
  | Var Con     loc         .   nm          =   cpatNmEither id id @pnm
  | Var         lhs         .   nmL         =   [@nm]
  | Con         lhs         .   nmL         =   [@nm] ++ @binds.nmL

SEM CPatRest
  | Var         lhs         .   nmL         =   [@nm]

SEM CExpr
  | Let         loc         .   aRenMp      =   if @lhs.lev == cLevOuter
                                                then @lhs.aRenMp
                                                else aRenAdd @binds.nmL @lUniq @lhs.aRenMp
                binds       .   lev         =   @lhs.lev + 1
  | Lam         loc         .   aRenMp      =   aRenAdd [@arg] @lUniq @lhs.aRenMp
                body        .   lev         =   if @body.isLamBody then @lhs.lev + 1 else @lhs.lev

SEM CAlt
  | Alt         loc         .   aRenMp      =   aRenAdd @pats.nmL @lUniq @lhs.aRenMp
                expr        .   lev         =   @lhs.lev + 1
%%]

%%[12
SEM CExpr
  | Let         loc         .   aRenMp      :=  if @lhs.lev == cLevOuter
                                                then @lhs.aRenMp
                                                else aRenAdd @lhs.moduleNm @binds.nmL @lUniq @lhs.aRenMp
  | Lam         loc         .   aRenMp      :=  aRenAdd @lhs.moduleNm [@arg] @lUniq @lhs.aRenMp

SEM CAlt
  | Alt         loc         .   aRenMp      :=  aRenAdd @lhs.moduleNm @pats.nmL @lUniq @lhs.aRenMp
%%]

%%[8
ATTR CExpr [ | | isLamBody: Bool ]

SEM CExpr
  | Lam         lhs         .   isLamBody   =   False
  | * - Lam     lhs         .   isLamBody   =   True
%%]

%%[8
SEM CExpr
  | Var         lhs         .   cTrf        =   CExpr_Var (aRenRepl @lhs.aRenMp @nm)
  | Lam         lhs         .   cTrf        =   CExpr_Lam (aRenRepl @aRenMp @arg) @body.cTrf

SEM CBind
  | Bind        lhs         .   cTrf        =   CBind_Bind (aRenRepl @lhs.aRenMp @nm) @expr.cTrf

SEM CPatBind
  | Bind        lhs         .   cTrf        =   CPatBind_Bind @lbl @offset.cTrf (aRenRepl @lhs.aRenMp @nm) @pat.cTrf

SEM CPat
  | Var         lhs         .   cTrf        =   CPat_Var (CPatNmOrig . aRenRepl @lhs.aRenMp $ @nm)
  | Con         lhs         .   cTrf        =   CPat_Con (CPatNmOrig . aRenRepl @lhs.aRenMp $ @nm) @tag @binds.cTrf

SEM CPatRest
  | Var         lhs         .   cTrf        =   CPatRest_Var (aRenRepl @lhs.aRenMp @nm)
%%]

