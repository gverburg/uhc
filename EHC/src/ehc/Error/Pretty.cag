%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Error pretty print
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs module {%{EH}Error.Pretty} import(Data.List, Data.Maybe,UU.Pretty, EH.Util.Utils, EH.Util.PPUtils, {%{EH}Base.Common}, {%{EH}Ty}, {%{EH}Ty.Pretty}, {%{EH}Error}) export(ppErr, ppErrs,ppErrL)
%%]

%%[8 hs import(EH.Util.ParseErrPrettyPrint hiding (ppErr)) export(mkPPErr)
%%]

%%[9 hs import({%{EH}Core},{%{EH}Core.Pretty})
%%]

%%[1 import({Error/AbsSyn})
WRAPPER Err
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.ppErrs hs
ppErrs :: ErrL -> PP_Doc
ppErrs errL = if null errL then empty else ppCmt ("***ERROR(S):" >-< indent 2 (ppErrL errL))
%%]

%%[1 hs
ppErrL :: ErrL -> PP_Doc
ppErrL errL = if null errL then empty else vlist (map ppErr errL)

ppErr :: Err -> PP_Doc
ppErr err =  let  r = wrap_Err (sem_Err err) (Inh_Err {nestDepth_Inh_Err=0})
             in   pp_Syn_Err r
%%]

%%[8 hs
mkPPErr :: PP a => a -> Err
mkPPErr = Err_PP . pp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.ppMsgErr hs
ppMsgErr :: PP msg => msg -> PP_Doc -> PP_Doc
ppMsgErr msg err = msg  >|< ":" >-< indent 2 err
%%]

%%[1.ppUnifyErr hs
ppUnifyErr :: PP msg => msg -> Ty -> Ty -> Ty -> Ty -> PP_Doc
ppUnifyErr msg t1 t2 t1d t2d
  =  ppMsgErr msg    (    "failed to fit:"  >#< ppListSepFill "" "" " <= " [ppTy t1,ppTy t2]
                     >-<  "problem with :"  >#< ppListSepFill "" "" " <= " [ppTy t1d,ppTy t2d]
                     )
%%]

%%[4.ppUnifyErr -1.ppUnifyErr hs
ppUnifyErr :: PP msg => msg -> Ty -> Ty -> FIMode -> Ty -> Ty -> FIMode -> PP_Doc
ppUnifyErr msg t1 t2 fim t1d t2d fimd
  =  ppMsgErr msg    (    "failed to fit:"  >#< ppListSepFill "" "" (m fim)  [ppTy t1,ppTy t2]
                     >-<  "problem with :"  >#< ppListSepFill "" "" (m fimd) [ppTy t1d,ppTy t2d]
                     )
  where  m fim = " " ++ show fim ++ " "
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Weeding nested error msg
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1
ATTR Err ErrL [ nestDepth: Int | | isNestPP USE {`const`} {False}: Bool ]

SEM Err
  | NestedIn            errL    .   nestDepth   =   case @errL.ppL of {[_] -> @lhs.nestDepth+1; _ -> 0}
                        lhs     .   isNestPP    =   True

SEM ErrL
  | Nil                 lhs     .   isNestPP    =   True
  | Cons                lhs     .   isNestPP    =   @hd.isNestPP && @tl.isNestPP
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Error pretty printing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1
ATTR Err [ | | pp: PP_Doc ]
ATTR ErrL [ | | ppL: {[PP_Doc]} ]

SEM Err
  | UnifyClash          lhs     .  pp   =   ppUnifyErr  "Type clash"
                                                        @ty1 @ty2 @ty1detail @ty2detail
  | NamesNotIntrod      lhs     .  pp   =   ppMsgErr    (maybeHd
                                                          "Names not in scope"
                                                          (const (strCapitalize @kind ++ " names not in scope"))
                                                          @kind
                                                        )
                                                        (case catMaybes $ map snd $ @nmL of
                                                           [] -> ppListSep "" "" ", " $ map fst $ @nmL
                                                           _  -> vlist [ n >|< ":" >#< maybe empty vlist rs | (n,rs) <- @nmL ]
                                                        )
  | NamesDupIntrod      lhs     .  pp   =   ppMsgErr    "Names introduced more than once"
                                                        (ppListSep "" "" ", " @nmL)
  | PatArity            lhs     .  pp   =   ppMsgErr    "Known type has wrong arity for pattern"
                                                        ("type :" >#< ppTy @ty >-< "arity:" >#< @arity)
  | NestedIn            loc     .  pp   =   let  h =  if @lhs.nestDepth == 1 && @errL.isNestPP
                                                      then (text "..." >#<)
                                                      else if @lhs.nestDepth <= 1 || @lhs.nestDepth >= 1 && not @errL.isNestPP
                                                      then ppMsgErr ("In `" >|< @wher >|< "'")
                                                      else id
                                            in   h (vlist @errL.ppL)

SEM ErrL
  | Nil                 lhs     .  ppL  =   []
  | Cons                lhs     .  ppL  =   @hd.pp : @tl.ppL
%%]

%%[1.MissingSig
SEM Err
  | MissingSig          lhs     .  pp   =   ppMsgErr    "Missing sig for" (@wher)
%%]

%%[1.HS
SEM Err
  | Fixity              lhs     .  pp   =   ppMsgErr    "Fixity mismatch between" (ppListSep "" "" ", " [@op1,@op2])
%%]

%%[2 -1.MissingSig
SEM Err
  | UnifyOccurs         lhs     .  pp   =   ppUnifyErr  "Infinite type"
                                                        @ty1 @ty2 (mkTyVar @tvar) @ty2detail
%%]

%%[4
SEM Err
  | UnifyClash          lhs     .  pp   :=  ppUnifyErr  "Type clash"
                                                        @ty1 @ty2 @fiMode @ty1detail @ty2detail @fiModeD
  | UnifyOccurs         lhs     .  pp   :=  ppUnifyErr  "Infinite type"
                                                        @ty1 @ty2 @fiMode (mkTyVar @tvar) @ty2detail @fiModeD
%%]

%%[4_2
SEM Err
  | InconsistentAlts    lhs     .  pp   =   ppMsgErr    "Inconsistent type alternatives for type variable"
                                                        (    "in type :" >#< pp @ty
                                                         >-< "for tvar:" >#< pp @tvar
                                                         >-< "types   :" >#< vlist (map ppTy @tyL)
                                                         >-< "fit mode:" >#< text (show @fiMode)
                                                        )
%%]

%%[5
SEM Err
  | Newtype             lhs     .  pp   =   ppMsgErr    ("Newtype must have exactly 1 constructor with 1 field")
                                                        ("Type:" >#< @tyNm)
%%]

%%[7
SEM Err
  | MissingDataFields   lhs     .  pp   =   ppMsgErr    ("Missing field(s) in data construction")
                                                        ("Field(s)   :" >#< ppCommas' @nmL >-< "Constructor:" >#< pp @con)
  | MissingAnyDataField lhs     .  pp   =   ppMsgErr    ("No data constructor has all fields")
                                                        ("Field(s):" >#< ppCommas' @nmL >-< "Type    :" >#< pp @tyNm)
  | DuplicateDataFields lhs     .  pp   =   ppMsgErr    ("Duplicate field(s) in data construction/update")
                                                        ("Field(s):" >#< ppCommas' @nmL)
  | MissingRowLabels    lhs     .  pp   =   ppMsgErr    ("Missing label(s) in row")
                                                        ("Label(s):" >#< ppCommas' @nmL >-< "Row     :" >#< ppTy @ty)
  | TooManyRowLabels    lhs     .  pp   =   ppMsgErr    "Too many label(s) to fit in row"
                                                        ("Label(s):" >#< ppCommas' @nmL >-< "Row     :" >#< ppTy @ty)
  | InconsistentIntros  lhs     .  pp   =   ppMsgErr    ("Inconsistent " ++ @kind ++ " introductions for")
                                                        ("names:" >#< ppCommas' @nmL)
%%]

%%[8
SEM Err
  | FileNotFound        lhs     .  pp   =   ppMsgErr    "File not found"
                                                        (    "file name         :" >#< @fileName
                                                         >-< "searched locations:" >#< vlist (map (text.show) @locations)
                                                        )
  | AmbiguousExport     lhs     .  pp   =   ppMsgErr    "Ambiguous export"
                                                        (    "name   :" >#< @name
                                                         >-< "exports:" >#< ppCommas @entities
                                                        )
  | PP                  lhs     .  pp   =   @pp
%%]

%%[9
SEM Err
  | PrfCutOffReached    lhs     .  pp   =   ppMsgErr    "Proof cut off limit reached"
                                                        (    "limit:" >#< pp @depth
                                                         >-< "pred :" >#< pp @pred
                                                        )
  | NotProvenPreds      lhs     .  pp   =   ppMsgErr    "Predicates did remain unproven"
                                                        (    "preds:" >#< ppBracketsCommas @preds
                                                        )
  | OverlapPreds        lhs     .  pp   =   ppMsgErr    "Proof for predicates did overlap"
                                                        (    vlist . map (\(p,evs) -> p >#< ":" >#< ppBracketsCommas evs) $ @overl
                                                        )
  | TyHasFreeTVars      lhs     .  pp   =   ppMsgErr    "Type has free type vars (not allowed)"
                                                        (    "type:" >#< pp @ty
                                                        )
  | DeclsNotAllowed     lhs     .  pp   =   ppMsgErr    ("Declarations are not allowed " ++ @inside)
                                                        (vlist [ k >|< ":" >#< ppCommas ns | (k,ns) <- @decls ]
                                                        )
  | ValWithoutSig       lhs     .  pp   =   ppMsgErr    ("Instance members without corresponding signature from class")
                                                        (    "names:" >#< ppCommas @nmL
                                                        )
%%]

%%[12
SEM Err
  | ModNameMismatch     lhs     .  pp   =   ppMsgErr    "Module names do not match"
                                                        (    "filename        :" >#< @nmOfFile
                                                         >-< "name from source:" >#< @nmFromSrc
                                                        )
  | AmbiguousNameRef    lhs     .  pp   =   ppMsgErr    "Ambiguous name reference"
                                                        (    "name        :" >#< @nm
                                                         >-< "may refer to:" >#< vlist (map pp @nmAlts)
                                                        )
%%]


