-- ------------------------------------------------------------------------
-- -- Expressions                                                        --
-- ------------------------------------------------------------------------

SEM MaybeExpression [ | | ehcore : { Maybe EHCore.CExpr } ]
    | Nothing       lhs.ehcore = Nothing
    | Just          lhs.ehcore = Just @expression.ehcore
    --  expression               : Expression

ATTR Expressions [ | | ehcore USE { : } { [] } : { [EHCore.CExpr] } ]

SEM Expression [ | | ehcore : { EHCore.CExpr } ]
    | Literal            lhs.ehcore = @literal.ehcore
    --  range                    : Range
    --  literal                  : Literal

    | Variable           lhs.ehcore = undefined -- insertDictionaries @name.self @lhs.dictionaryEnv                     
    --  range                    : Range
    --  name                     : Name

    | Constructor        lhs.ehcore = EHCore.CExpr_Var (hsnFromString $ getNameName @name.self) -- Core.Con (Core.ConId (idFromName @name.self))
    --  range                    : Range
    --  name                     : Name

    | Parenthesized      lhs.ehcore = @expression.ehcore
    --  range                    : Range
    --  expression               : Expression

    | NormalApplication  lhs.ehcore = EHCore.mkCExprApp @function.ehcore @arguments.ehcore
    --  range                    : Range
    --  function                 : Expression
    --  arguments                : Expressions

    | InfixApplication   lhs.ehcore =
        case (@leftExpression.ehcore, @rightExpression.ehcore) of
            (Nothing, Nothing) -> @operator.ehcore
            (Just l , Nothing) -> EHCore.mkCExprApp1 @operator.ehcore l
            (Nothing, Just r ) -> EHCore.mkCExprLam1 parameterName
                                    (EHCore.mkCExprApp @operator.ehcore [EHCore.CExpr_Var parameterName, r])
            {-
                -- At most one new variable is needed. Consider
                --  (. (+ 3))  ==  \x -> (.) x (\x -> (+) x 3)
            -}
            (Just l , Just r ) -> EHCore.mkCExprApp @operator.ehcore [l,r]

--        case (@leftExpression.core, @rightExpression.core) of
--            (Nothing, Nothing) -> @operator.core
--            (Just l , Nothing) -> CExpr_App @operator.core l
--            (Nothing, Just r ) -> Core.Lam parameterId 
--                                    (foldl Core.Ap @operator.core [Core.Var parameterId, r])
--            {-
--                -- At most one new variable is needed. Consider
--                --  (. (+ 3))  ==  \x -> (.) x (\x -> (+) x 3)
--            -}
--            (Just l , Just r ) -> foldl Core.Ap @operator.core [l,r]
    --  range                    : Range
    --  leftExpression           : MaybeExpression
    --  operator                 : Expression
    --  rightExpression          : MaybeExpression

    | If                 lhs.ehcore = undefined
--        if_ @guardExpression.core @thenExpression.core @elseExpression.core
    --  range                    : Range
    --  guardExpression          : Expression
    --  thenExpression           : Expression
    --  elseExpression           : Expression

    | Lambda             lhs.ehcore = undefined
--        let ids = freshIds "u$" @patterns.length
--        in let_ nextClauseId (patternMatchFail "lambda expression" @range.self)
--            (foldr 
--                Core.Lam 
--                (patternsToCore 
--                    (zip ids @patterns.self) 
--                    @expression.core
--                )
--                ids
--            )
    --  range                    : Range
    --  patterns                 : Patterns
    --  expression               : Expression

    | Case               lhs.ehcore = undefined --let_ caseExprId @expression.core @alternatives.core
--                         alternatives.caseRange = @range.self
    --  range                    : Range
    --  expression               : Expression
    --  alternatives             : Alternatives

    | Let                -- declarations.patBindNr = 0
                         -- declarations.isTopLevel = False
                         lhs.ehcore = undefined
--        letrec_ @declarations.decls @expression.core
    --  range                    : Range
    --  declarations             : Declarations
    --  expression               : Expression

    | Do                 lhs.ehcore = undefined -- chainCode @statements.core
    --  range                    : Range
    --  statements               : Statements

    | List               lhs.ehcore = undefined -- coreList @expressions.core
    --  range                    : Range
    --  expressions              : Expressions

    | Tuple              lhs.ehcore = undefined
--        foldl 
--            Core.Ap 
--            (Core.Con
--                (Core.ConTag
--                    (Core.Lit (Core.LitInt 0))
--                    (length @expressions.core)
--                )
--            )
--            @expressions.core
    --  range                    : Range
    --  expressions              : Expressions

    | Comprehension      lhs.ehcore = undefined
--        let singleton x = cons x nil
--        in foldr ($) (singleton @expression.core) @qualifiers.core
    --  range                    : Range
    --  expression               : Expression
    --  qualifiers               : Qualifiers

    | Typed              lhs.ehcore = @expression.ehcore
    --  range                    : Range
    --  expression               : Expression
    --  type                     : Type

    -- negate is overloaded and we need to insert a dictionary argument
    | Negate             lhs.ehcore = undefined
-- insertDictionaries (setNameRange intUnaryMinusName @range.self) @lhs.dictionaryEnv                  
--                                    `app_` @expression.core 
    --  range                    : Range
    --  expression               : Expression

    | NegateFloat        lhs.ehcore = undefined
--            var "$primNegFloat" `app_` @expression.core 
    --  range                    : Range
    --  expression               : Expression

    -- enumerations are overloaded and we need to insert a dictionary argument
    | Enum               lhs.ehcore = undefined
--            case (@then.core, @to.core) of
--                (Just then_, Just to) -> 
--                    insertDictionaries (setNameRange enumFromThenToName @range.self) @lhs.dictionaryEnv
--                       `app_` @from.core `app_` then_ `app_` to
--                (Just then_, Nothing) -> 
--                    insertDictionaries (setNameRange enumFromThenName @range.self) @lhs.dictionaryEnv
--                       `app_` @from.core `app_` then_
--                (Nothing, Just to) ->
--                    insertDictionaries (setNameRange enumFromToName @range.self) @lhs.dictionaryEnv 
--                       `app_` @from.core `app_` to
--                (Nothing, Nothing) ->
--                    insertDictionaries (setNameRange enumFromName @range.self) @lhs.dictionaryEnv
--                       `app_` @from.core
                    
    --  range                    : Range
    --  from                     : Expression
    --  then                     : MaybeExpression
    --  to                       : MaybeExpression

    | RecordConstruction lhs.ehcore = undefined -- internalError "ToCoreExpr" "Expression" "records not supported"
    --  range                    : Range
    --  name                     : Name
    --  recordExpressionBindings : RecordExpressionBindings

    | RecordUpdate       lhs.ehcore = undefined -- internalError "ToCoreExpr" "Expression" "records not supported"
    --  range                    : Range
    --  expression               : Expression
    --  recordExpressionBindings : RecordExpressionBindings


ATTR Statements [ | | ehcore USE { : } { [] } : { [Maybe EHCore.CExpr -> EHCore.CExpr] } ]

SEM Statement [ | | ehcore : { Maybe EHCore.CExpr -> EHCore.CExpr } ]
    | Expression          lhs.ehcore = undefined
{-            \rest -> 
                case rest of
                    Nothing   -> @expression.core
                    Just rest -> bind @expression.core (Core.Lam dummyId rest)
    --  range                    : Range
    --  expression               : Expression-}

    | Let   
                          lhs.ehcore = undefined
{-            \rest ->
                case rest of
                    Nothing   -> internalError "ToCoreExpr" "Statement" "'let' can't be last in 'do'"
                    Just rest -> letrec_ @declarations.decls rest -}
    --  range                    : Range
    --  declarations             : Declarations

    -- let _nextClause = <throw exception> in
    -- let _ok = \_misc -> case _misc of { pattern -> ...; _ -> _nextClause }
    -- in expression >>= ok
    | Generator           lhs.ehcore = undefined
{-        \rest -> case rest of
            Nothing   -> internalError "ToCoreExpr" "Statement" "generator can't be last in 'do'"
            Just rest -> 
                let_ nextClauseId (patternMatchFail "generator" @range.self)
                    (let_ 
                        okId 
                        (Core.Lam parameterId
                            (patternToCore (parameterId, @pattern.self) rest)
                        )
                        (@expression.core `bind` Core.Var okId)
                    )-}
    --  range                    : Range
    --  pattern                  : Pattern
    --  expression               : Expression

-- Not supported

    | Empty               lhs.ehcore = undefined
{-            \rest ->
                case rest of 
                    Nothing   -> internalError "ToCoreExpr" "Statement" "empty statements not supported"
                    Just rest -> rest
    --  range                    : Range-}



ATTR Qualifiers [ | | ehcore USE { : } { [] } : { [EHCore.CExpr -> EHCore.CExpr] } ]

SEM Qualifier [ | | ehcore : { EHCore.CExpr -> EHCore.CExpr } ]
    | Guard               lhs.ehcore = undefined -- \continue -> if_ @guard.core continue nil
    --  range                    : Range
    --  guard                    : Expression -- type: Boolean

    | Let             
                          lhs.ehcore = undefined -- \continue -> letrec_ @declarations.decls continue
    --  range                    : Range
    --  declarations             : Declarations
   
    -- See Haskell report 3.11
    -- let _nextClause = [] in
    -- let _ok = \_misc -> case _misc of { pattern -> ...; _ -> _nextClause }
    -- in concatMap _ok expression

    | Generator           lhs.ehcore = undefined
{-        \continue ->
            let_ nextClauseId nil
                (let_ 
                    okId 
                    (Core.Lam parameterId
                        (patternToCore (parameterId, @pattern.self) continue)
                    )
                    (var "$primConcatMap"
                        `app_` Core.Var okId 
                        `app_` @expression.core
                    )
                )  -}
    --  range                    : Range
    --  pattern                  : Pattern
    --  expression               : Expression
    
-- Not supported

    | Empty               lhs.ehcore = internalError "ToEHCoreExpr" "Qualifier" "empty qualifiers not supported"
    --  range                    : Range
                  
SEM Alternatives [ | | ehcore : { EHCore.CExpr } ]
    | Cons              lhs.ehcore     = @hd.ehcore @tl.ehcore
    | Nil               lhs.ehcore     = patternMatchFailEh "case expression" @lhs.caseRange

SEM Alternative [ | | ehcore : { EHCore.CExpr -> EHCore.CExpr } ]
    | Alternative       lhs.ehcore   = undefined {- \nextCase  ->
                                        let thisCase =
                                                patternToEHCore 
                                                    (caseExprId, @pattern.self) 
                                                    @righthandside.ehcore
                                        in
                                            let_ nextClauseId nextCase thisCase -}
    --  range                    : Range
    --  pattern                  : Pattern
    --  righthandside            : RightHandSide

    | Empty             lhs.ehcore   = id
    --  range                    : Range

ATTR GuardedExpressions [ | | ehcore USE { : } { [] } : { [EHCore.CExpr -> EHCore.CExpr] } ]

SEM GuardedExpression [ | | ehcore : { EHCore.CExpr -> EHCore.CExpr } ]
    | GuardedExpression lhs.ehcore = undefined
{-
        \fail -> if_ @guard.ehcore @expression.ehcore fail
    --  range                    : Range
    --  guard                    : Expression -- type: Boolean
    --  expression               : Expression
-}

SEM Literal [ | | ehcore : { EHCore.CExpr } ]
    | Int                   lhs.ehcore = EHCore.CExpr_Int (read @value)
    --  range                    : Range
    --  value                    : String

    | Char                  lhs.ehcore = EHCore.CExpr_Char (read ("'" ++ @value ++ "'"))
    --  range                    : Range
    --  value                    : String -- without the quotes

    | Float                 lhs.ehcore = undefined -- float @value
    --  range                    : Range
    --  value                    : String

    | String                lhs.ehcore = undefined
--        var "$primPackedToString" `app_` 
--            packedString (read ("\"" ++ @value ++ "\""))
    --  range                    : Range
    --  value                    : String -- without the quotes

{
parameterName = hsnFromString "parameter$"
{-

-- Function "bind" is used in the translation of do-expressions
bind :: Core.Expr -> Core.Expr -> Core.Expr
bind ma f = Core.Var primBindIOId `app_` ma `app_` f

( primBindIOId :  caseExprId :  okId :  parameterId : []) = map idFromString $
 "$primBindIO"  : "caseExpr$" : "ok$" : "parameter$" : []

-- Function "chainCode" is used in the translation of do-expressions
chainCode :: [Maybe Core.Expr -> Core.Expr] -> Core.Expr
chainCode cores =
    case cores of
        [core] -> core Nothing
        (core:cores) -> core (Just (chainCode cores))
-}

}
