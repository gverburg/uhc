Rename numbered identifiers to their names.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.NameIdents} import({%{GRIN}GRINCCommon}, {%{EH}Base.Common}, {%{EH}GrinCode}, Data.Array.IArray, qualified Data.Map as Map) export(nameIdents)

nameIdents :: IdentNameMap -> GrModule -> GrModule
nameIdents m grmod = let t        = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                        (Inh_GrAGItf { names_Inh_GrAGItf = m })
                     in grTrf_Syn_GrAGItf t
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]

%%[8.rename
ATTR GrAGItf AllGrNT  [ names: IdentNameMap | | ]

SEM GrGlobal
  | Global  lhs  .  grTrf  =  GrGlobal_Global (getName' @lhs.names @nm) @val.grTrf

SEM GrPat
  | Node  lhs  .  grTrf     = GrPat_Node @tag.grTrf (map (getName' @lhs.names) @fldL)
  | Var   lhs  .  grTrf     = GrPat_Var  (getName' @lhs.names @nm)

SEM GrBind
  | Bind  loc  .  bindName  = getName' @lhs.names @nm
               .  newNames  = map (getName' @lhs.names) @argNmL
          lhs  .  grTrf     = GrBind_Bind @bindName @newNames @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (getName' @lhs.names @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (getName' @lhs.names @nm)

SEM GrExpr
  | App Eval Call Fetch Update Throw  loc  .  newName  =  getName' @lhs.names @nm
  | App                               lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                              lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                              lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                             lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset @mbTag
  | Update                            lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf @mbTag
  | FetchUpdate                       lhs  .  grTrf    =  GrExpr_FetchUpdate  (getName' @lhs.names @src)(getName' @lhs.names @dst)
  | FFI                               lhs  .  grTrf    =  GrExpr_FFI     @nm (map (getName' @lhs.names) @argL) @resTagL.grTrf
  | Throw                             lhs  .  grTrf    =  GrExpr_Throw   @newName
  | Catch                             lhs  .  grTrf    =  GrExpr_Catch   @body.grTrf (getName' @lhs.names @arg) @handler.grTrf

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @moduleNm @globalL.grTrf @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.names) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.names) @applyTagMp
%%]

%%[8 hs
newMap map (k, EvApTagVar nm) = (k, EvApTagVar $ getName' map nm)
newMap map x                  = x
%%]
