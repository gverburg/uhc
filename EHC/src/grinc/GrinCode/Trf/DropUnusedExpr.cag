Drop expression when the results are not used.
TODO: drop global variables

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.DropUnusedExpr} import(qualified Data.Set as Set)
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}, Data.Maybe) export(dropUnusedExpr)
dropUnusedExpr :: HptMap -> GrModule -> GrModule
dropUnusedExpr hptMap grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                   (Inh_GrAGItf { hptMap_Inh_GrAGItf = hptMap })
                              in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ hptMap: HptMap | | grTrf: GrModule ]
ATTR AllGrNT [ hptMap: HptMap | | grTrf: SELF ]
%%]

TODO: A unit statement can insert used variables for each variable not bounded
to a wildcard or constant pattern. Example:

unit (T a1 ... an); \_ ->     ==>    'a1' t/m 'an' are unused in this expression.

This can be generalized to all other constructs. (e.g when an expr is dead,
don't count its variables as live) (shown in testgrinc/throw.grin)

alternative solution: use current tranformation in fixpoint

%%[8.retrieveUsedVariables
ATTR AllExpr [ | usedVars: {Set.Set HsName} | ]

SEM GrBind
  | Bind  expr  .  usedVars  =  Set.empty

SEM GrVal
  | Var   lhs   .  usedVars  =  Set.insert @nm @lhs.usedVars

SEM GrTag
  | Var   lhs   .  usedVars  =  Set.insert @nm @lhs.usedVars

SEM GrExpr
  | FFI     lhs   .  usedVars  =  foldr Set.insert @lhs.usedVars @argL
  | App     argL  .  usedVars  =  Set.insert @nm @lhs.usedVars
  | Eval    lhs   .  usedVars  =  Set.insert @nm @lhs.usedVars
  | Fetch   lhs   .  usedVars  =  Set.insert @nm @lhs.usedVars
  | Update  val   .  usedVars  =  Set.insert @nm @lhs.usedVars
  | FetchUpdate  
            lhs   .  usedVars  =  Set.insert @src @lhs.usedVars
  | Throw   lhs   .  usedVars  =  Set.insert @nm @lhs.usedVars
  | Seq     body  .  usedVars  =  @lhs.usedVars
            pat   .  usedVars  =  @body.usedVars
            expr  .  usedVars  =  @body.usedVars
            lhs   .  usedVars  =  @expr.usedVars

SEM GrAlt
  | Alt     expr  .  usedVars  =  @lhs.usedVars
            pat   .  usedVars  =  @expr.usedVars
            lhs   .  usedVars  =  @pat.usedVars
%%]

if an exception is ALWAYS thrown in this code path, all code after the throw statement is not needed
%%[8.exceptionThrown
ATTR AllGrExpr [ | throws: {Bool} | ]

SEM GrBind
  | Bind   expr     .  throws  =  False

-- case throws an exception if all alternative throw an exception
-- if exception is thrown before the case statement, make each alternative aware
SEM GrAltL
  | Cons   lhs      .  throws = @hd.throws && @tl.throws
           hd       .  throws = @lhs.throws
           tl       .  throws = @lhs.throws
  | Nil    lhs      .  throws = True -- TODO: only valid if a at least one alternative is availible!!
                      
SEM GrExpr
  | Throw  lhs      .  throws = True
  | Catch  lhs      .  throws = @lhs.throws || @handler.throws
           handler  .  throws = @lhs.throws
  | Call   lhs      .  throws = isBottom (getEnvVar @lhs.hptMap (getNr @nm)) && not (isBottom (getEnvVar @lhs.hptMap (getNr @nm + 1)))
                                -- function call without normal return value, but with exception results will always throw exceptions
                                -- TODO: hpt must make difference between `no value' (denoted with `()') and `unknown value'
%%]

-- AD 20060526: avoid AGC error msg
%%[8
SEM GrAdapt
  | *    loc      .  usedVars  =  Set.empty

SEM GrSplit
  | *    loc      .  usedVars  =  Set.empty

SEM GrGlobal
  | *    loc      .  usedVars  =  Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Remove unused variable bindings %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Remove expressions when its result is not bound to some variable and the
possible side effect is useless without that result. (The ones 
retained are update, throw and FFI)

%%[8.removeUnusedSeqExpr
ATTR GrTag GrPat [ | | isDead : Bool ]

SEM GrPat
  | Node  lhs  .  isDead  =  not (any (`Set.member` @lhs.usedVars) @fldL) && @tag.isDead
  | Var   lhs  .  isDead  =  not (@nm `Set.member` @lhs.usedVars)
  | Tag   lhs  .  isDead  =  @tag.isDead
  | * - Node Var Tag  lhs  .  isDead  =  True

SEM GrTag
  | Var      lhs  .  isDead  =  not (@nm `Set.member` @lhs.usedVars)
  | * - Var  lhs  .  isDead  =  True
 
SEM GrExpr [ | | sideEffect : Bool ]
  |     Update FFI Throw FetchUpdate  lhs  .  sideEffect  =  True
  | * - Update FFI Throw FetchUpdate  lhs  .  sideEffect  =  False

SEM GrExpr
  | Seq  lhs  .  grTrf      =  if @expr.throws then @expr.grTrf
                               else if @isDead then @body.grTrf
                               else                 @grTrf
         loc  .  isDead     =  @pat.isDead && not @expr.sideEffect
%%]


Fields and tag variables in node patterns which are never used are replaced
with wildcards.

%%[8.removeUnusedNamedBinding
SEM GrPat
  | Node  lhs  .  grTrf  =  GrPat_Node @tag.tag (map (mkWildcard @lhs.usedVars) @fldL)
  | Var   lhs  .  grTrf  =  GrPat_Var (mkWildcard @lhs.usedVars @nm)
  | Tag   lhs  .  grTrf  =  GrPat_Tag @tag.tag

SEM GrTag [ | | tag: GrTag ]
  | Var      lhs  .  tag  =  GrTag_Var (mkWildcard @lhs.usedVars @nm)
  | * - Var  lhs  .  tag  =  @grTrf
%%]

%%[8.renameToWildcard hs
mkWildcard m x = if x `Set.member` m then x else wildcardNr
%%]

%%[8.dropUnusedCatchStatements
SEM GrExpr
  | Catch  loc  .  isUnused  =  isBottom (getEnvVar @lhs.hptMap (getNr @arg))
           lhs  .  grTrf     =  if @isUnused then @body.grTrf else @grTrf
%%]

%%[8.removeUnusedFormals
%%]

