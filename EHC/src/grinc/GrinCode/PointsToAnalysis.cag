TODO: Mark unique variables as Unique

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8 hs module {%{GRIN}GrinCode.PointsToAnalysis} import(Data.List(transpose), Debug.Trace)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe, Control.Monad, Control.Monad.ST, Data.Array.ST, Data.Array.IArray)
%%]

%%[8 hs import(Debug.Trace)
%%]

%%[8 hs import({%{GRIN}GRINCCommon}, {%{EH}Base.Common}, {%{EH}GrinCode},{%{GRIN}HeapPointsToFixpoint}) export(heapPointsToAnalysis)

type Action          = ST RealWorld ()
type EnvAction       = ST RealWorld (AbstractEnv RealWorld)
type HeapAction      = ST RealWorld (AbstractHeap RealWorld)
type HPTResult       = (Int, Array Int AbstractEnvElement, Array Int AbstractHeapElement)
type SetEnv          = Variable -> Bool -> AbstractEnvModifier -> Action
type GetEnv          = Variable -> ST RealWorld AbstractEnvElement


error2 s = AbstractEnvElement
           { aeBaseSet    =  AV_Nothing
           , aeIsShared   =  False
           , aeMod        =  EnvSetAV (AV_Error s)
           }


heapPointsToAnalysis :: (Int,Int) -> GrModule -> IO HPTResult
heapPointsToAnalysis (low,high) grmod = stToIO $ do
    { let applyArg = low - 1 ;
    ; absEnv <- (newArray_ (applyArg,high) ) :: EnvAction
    ; foldM_ (\_ v -> writeArray absEnv v (error2 $ "no equation for variable " ++ show v )) () [applyArg..high]
    ; let setEnvVar v shared eq = writeArray absEnv v (AbstractEnvElement
                                                           { aeBaseSet    =  AV_Nothing
                                                           , aeIsShared   =  shared
                                                           , aeMod        =  eq
                                                           }
                                                      )
    ; let getEnvVar v            = readArray absEnv v
          t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                        (Inh_GrAGItf
                                            { setEnvVar_Inh_GrAGItf  = setEnvVar
                                            , getEnvVar_Inh_GrAGItf  = getEnvVar
                                            , tmpVar_Inh_GrAGItf     = applyArg
                                            }
                                        )
    ; fillEnv_Syn_GrAGItf t
    ; absHeap <- makeHeap_Syn_GrAGItf t
    ; setEnvVar applyArg True (EnvSetAV AV_Nothing)
    ; let applyMap = applyMap_Syn_GrAGItf t
    ; count   <- heapPointsTo absEnv absHeap applyMap
    ; absHeap <- unsafeFreeze absHeap
    ; absEnv  <- unsafeFreeze absEnv
    ; return (count, absEnv, absHeap)
    }
%%]

%%[8.toplevelCombining
ATTR GrAGItf AllGrNT [ getEnvVar: GetEnv  setEnvVar: SetEnv tmpVar: Variable | | fillEnv USE {>>} {return ()}: {Action} ]
ATTR AllGrNT [ | heapList: {[(Location, AbstractHeapElement)]} | ]
ATTR GrAGItf [ | | makeHeap: HeapAction ]

SEM GrAGItf
  | AGItf  lhs     .  makeHeap  =  do { arr <- newArray_ (0, @module.heapPointer - 1)
                                      ; mapM (uncurry $ writeArray arr ) @module.heapList
                                      ; return arr
                                      }
           module  . heapList   =  []

SEM GrBind
  | Bind  loc  .  prune     = (@nm == evalNr) || (@nm == applyNr)
          lhs  .  heapList  = if @prune then @lhs.heapList else @expr.heapList
               .  fillEnv   = if @prune then (return ()) else @fillEnvBind >> @exceptEq >> @expr.fillEnv
%%]

%%%%%%%%%%%%%%%%%%%
%% Self replica  %%
%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllGrTag [ | | self: SELF ]
%%]

%%%%%%%%%%%%%%%%%%%
%% Tag2ResultVar %%
%%%%%%%%%%%%%%%%%%%

%%[8.tag2resultVar
ATTR AllGrNT [ tag2resultVar: {AssocL GrTag Int} | | ]
ATTR GrModule [ | | tag2resultVar: {AssocL GrTag Int} ]
SEM GrModule
  | Mod     loc . tag2resultVar = [ (t, f) | ((t,_), EvApTagVar (HNPos f)) <- @evalTagMp ]

SEM GrAGItf
  | AGItf   module . tag2resultVar = []
%%]

%%[8.valueCopy
ATTR GrVal GrValL GrTag [ | | copy                : SELF     ]
SEM GrVal
  | NodeAdapt loc . copy = error "No Node adapt"
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Unique Pointers %%
%%%%%%%%%%%%%%%%%%%%%

%%[8.heapPointerfillEnv
ATTR AllGrNT [ | heapPointer: Int | ]
SEM GrAGItf
  | AGItf  module . heapPointer = 0
%%]

%%%%%%%%%%%%%
%% TagName %%
%%%%%%%%%%%%%

%We use the name @UNBOXED for unboxed nodes.
%Any other node should have a named tag.

%%[8.tagName
SEM GrTag [ | | tagName: SELF ]
  | Var     lhs . tagName = error "Tag variables are not allowed in GRIN Points-To Analysis"
%%]


A grin node is either a single variable or a complete node (with a known tag)

%%[8.nodeInfo hs
type NodeInfo a = Either Int (GrTag, [a])
%%]

%%%%%%%%%%%%%%%%
%% value Info %%
%%%%%%%%%%%%%%%%

A grin value is either a single variable or a complete node (known tag)

%%[8.valInfo
SEM GrValL [ | | valsInfo : {[NodeInfo (Maybe Int)]}]
  | Cons      lhs . valsInfo = @hd.valInfo : @tl.valsInfo
  | Nil       lhs . valsInfo = []

SEM GrVal [ | | valInfo : {NodeInfo (Maybe Int)}]
  | Node      lhs . valInfo = Right (@tag.tagName, @fldL.depVars)
  | Tag       lhs . valInfo = Right (@tag.tagName, [])
  | Var       lhs . valInfo = Left (getNr @nm)
  | Empty     lhs . valInfo = error "no empty value expected!"
  | LitInt LitStr
              lhs . valInfo = error "no literal value expected!"
  | NodeAdapt lhs . valInfo = error "no support for NodeAdapt"
%%]

%%[8.depVars
SEM GrVal  [ | | depVar:  {Maybe Int} ]
  | Var      lhs . depVar = Just (getNr @nm)
  | * - Var  lhs . depVar = Nothing
SEM GrValL [ | | depVars: {[Maybe Int]}  ]
  | Cons     lhs . depVars = @hd.depVar : @tl.depVars
  | Nil      lhs . depVars = []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pattern Information %%
%%%%%%%%%%%%%%%%%%%%%%%%%

A grin pattern is either a single variable or a compete node pattern (known tag)

%%[8.patInfo
SEM GrPat [ | | patInfo: {NodeInfo Int} ]
  | Node       lhs . patInfo = Right (@tag.tagName, map getNr @fldL)
  | Tag        lhs . patInfo = Right (@tag.tagName, [])
  | Var        lhs . patInfo = Left (getNr @nm)
  | Empty      lhs . patInfo = Left (getNr wildcardNr)
  | LitInt     lhs . patInfo = error "literal int in pattern? I did not know that..."
  | NodeSplit  lhs . patInfo = error "no support for NodeSplit"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

The target info is basicly the pattern information. However, for the last
expression in a binding it is the result variable of that binding.

%%[8.targetInformation
ATTR AllGrExpr [ targetInfo: {NodeInfo Int} | exceptions: {[Int]} | ]

SEM GrBind
  | Bind  loc  . resultVar   =  getNr @nm
          expr . targetInfo  =  Left @resultVar

SEM GrExpr
  | Seq    expr     .  targetInfo = @pat.patInfo
           body     .  targetInfo = @lhs.targetInfo
%%]

4 possibilities of source and target info

%%[8.genInfo hs
genInfo :: NodeInfo a
        -> NodeInfo b
        -> (Int->Int->c)
        -> (Int->GrTag->[b]->c)
        -> (GrTag->[a]->Int->c)
        -> (GrTag->[a]->GrTag->[b]->c)
        -> c
genInfo sourceInfo targetInfo llf lrf rlf rrf =
  case (sourceInfo, targetInfo) of
    (Left  sn      , Left  tn       ) -> llf sn     tn
    (Left  sn      , Right (tt, tns)) -> lrf sn     tt  tns
    (Right (st,sns), Left  tn       ) -> rlf st sns tn
    (Right (st,sns), Right (tt, tns)) -> rrf st sns tt  tns
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%
%% Unit %%
%%%%%%%%%%

unit node;           -> \n              => n:
                                             absVal = Nothing
                                             envMod = Union [node]
unit (Tag e1 .. en); -> \n              => n:
                                             absVal = Tag[(absVal e1), .., (absVal en)]
                                             envMod = Tag[(depVar e1), .., (depVar en)]
unit node;           -> \(Tag e1 .. en) => e1:
                                             absVal = Nothing
                                             envMod = node ! Tag ! 1
                                           en:
                                             absVal = Nothing
                                             envMod = node ! Tag ! n
unit (Tag d1 .. dn); -> \(Tag e1 .. en) => e1:
                                             absVal = (absVal d1)
                                             envMod = Union (depVar d1)
                                           en:
                                             absVal = (absVal dn)
                                             envMod = Union (depVar dn)

note: The resultVar will always be Nothing.
      A node not in the heap representing a function is strange at least...

%%[8.unit
SEM GrExpr
  | Unit   loc . fVar2Var   = \s t         -> @lhs.setEnvVar t True (EnvUnion [s] Nothing)
               . fNode2Var  = \tag names t -> let resultVar = lookup tag @lhs.tag2resultVar
                                                  env       = @lhs.setEnvVar t True
                                                                          (EnvTag tag names Nothing)
                                              in env
               . fVar2Node  = buildSelectElems @lhs.setEnvVar
               . fNode2Node = \st snms tt tnms -> let sn2mod = maybe (EnvSetAV AV_Basic) (\x -> EnvUnion [x] Nothing)
                                                      toEnvElem sn tn = if tn == getNr wildcardNr
                                                                        then return ()
                                                                        else @lhs.setEnvVar tn True (sn2mod sn)
                                                  in zipWithM_ toEnvElem snms tnms -- note: st == tt
               . fillEnv    = genInfo @val.valInfo @lhs.targetInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
%%]

%%[8.selectVar hs
buildSelectElems :: SetEnv -> Variable -> GrTag -> [Variable] -> Action
buildSelectElems setEnvVar selectVar tag nms
  = let step (i, f) v     = (i+1, if v == getNr wildcardNr then f else f >> setEnvVar v True (EnvSelect selectVar tag i))
        (count, envElems) = foldl step (0, return ()) nms
    in envElems
%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%

store (Tag e1 .. en); -> \n              => n:
                                              absVal = newLocation
                                              envMod = setAV absVal
                                            newLocation:
                                              absVal  = Tag[(absVal e1), .., (absVal en)]
                                              heapMod = Tag[(depVar e1), .., (depVar en)] |_| resultVar(Tag)

%%[8.store
SEM GrExpr
  | Store  loc . (heapPointer, fillEnv, heapElem) = makeStore @lhs.setEnvVar
                                                              (flip lookup @lhs.tag2resultVar)
                                                              @lhs.heapPointer
                                                              @val.valInfo
                                                              @lhs.targetInfo
           lhs . heapList  = @heapElem : @lhs.heapList
%%]

%%[8.store hs
makeStore setEnvVar ftag2resultVar heapPointer valInfo targetInfo
    = let fNode2Var  tag names t = let resultVar   = ftag2resultVar tag
                                       av          = AV_Locations (Set.singleton heapPointer)
                                       env         = setEnvVar t True envMod
                                       heap        = makeHeapElem heapPointer
                                                                 ((tag, names), resultVar)
                                       envMod      = EnvSetAV av
                                   in ( env, heap )
          fVar2Var   = error "Single variable in a store not allowed!"
          fVar2Node  = error "No location variable afer a store!"
          fNode2Node = error "No location variable afer a store! (And always store a node!)"
          (fillEnv, absHeap) = genInfo valInfo targetInfo fVar2Var fVar2Node fNode2Var fNode2Node
      in (heapPointer + 1, fillEnv, absHeap)
%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%

eval(l); -> \n              => n:
                                 absVal = AV_Nodes []
                                 envMod = Eval l

the next is not needed because of normalisation:

eval(l); -> \(Tag e1 .. en) => @eval@l:
                                 absVal = Nothing
                                 envMod = Eval l
                               e1:
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! 1
                               en:
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! n
%%[8.eval
SEM GrExpr
  | Eval   loc . fillEnv = case @lhs.targetInfo of
                             Left  n           -> @lhs.setEnvVar n True (EnvEval (getNr @nm) @lhs.exceptVar)
                             Right (tag,names) -> error "NormForHPT not executed"
%%]

%%%%%%%%%%
%% Call %%
%%%%%%%%%%

foo a1 .. an; -> \n             => n:
                                     absVal = Nothing
                                     envMod = Union [@foo]

foo a1 ..an; -> \(Tag e1 .. en) => e1:
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! 1
                                   en:
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! n
%%[8.call
SEM GrExpr
  | Call  loc  .  resultVar   =  getNr @nm
               .  fillEnv     =  case @lhs.targetInfo of
                                     Left  n           -> @lhs.setEnvVar n True (EnvUnion [@resultVar] Nothing)
                                     Right (tag,names) -> buildSelectElems @lhs.setEnvVar @resultVar tag names
               .  exceptions  =  @resultVar + 1 : @lhs.exceptions
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%

case node of (T e1 .. en)             => e1:
                                           absVal = Nothing
                                           envMod = node ! Tag ! 1
                                         en:
                                           absVal = Nothing
                                           envMod = node ! Tag ! n

the following is not needed because of normalisation
case (Tag d1 .. dn) of (Tag e1 .. en) => e1:
                                           absVal = (absVal d1)
                                           envMod = Union (depVar d1)
                                         en:
                                           absVal = (absVal dn)
                                           envMod = Union (depVar dn)

%%[8.alt
ATTR AllAlt [ valInfo: {NodeInfo (Maybe Int)} | | ]

SEM GrAlt
  | Alt  loc . fVar2Node  = buildSelectElems @lhs.setEnvVar
             . fNode2Node = error "NormForHPT not executed"
             . fVar2Var   = error "no variable in alternative pattern expected!"
             . fNode2Var  = error "no variable in alternative pattern expected!"
             . fillEnv    = genInfo @lhs.valInfo @pat.patInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
         lhs . fillEnv    = @fillEnv >> @expr.fillEnv
%%]

%%%%%%%%%%%%%%%%%%%%
%% Case and Catch %%
%%%%%%%%%%%%%%%%%%%%

We can have multiple arms in a case, how do we merge the result of each arm?

Since we normalise each case to end with a simple unit (e.g. unit v). So we
collect the last elements of the arms and join these afterwards.

We use the targetName of the wildcard variable so that these last equations and
partial collections are filtered afterwards.

%%[8.case
SEM GrAltL
  | Cons  lhs   .   fillEnv    =  do { @hd.fillEnv
                                     ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                     ; let (EnvUnion hdn _) = aeMod elem
                                     ; @tl.fillEnv
                                     ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                     ; let (EnvUnion tln _) = aeMod elem
                                     ; @lhs.setEnvVar @lhs.tmpVar True (EnvUnion (tln ++ hdn) Nothing)
                                     }
  | Nil   lhs   .   fillEnv    =  @lhs.setEnvVar @lhs.tmpVar True (EnvUnion [] Nothing)
SEM GrAlt
  | Alt  expr   .  targetInfo   =  Left @lhs.tmpVar

SEM GrExpr
  | Case   loc   .  fillEnv     =  case @lhs.targetInfo of
                                     Left resVar     -> do { elem <- @lhs.getEnvVar @lhs.tmpVar
                                                           ; @lhs.setEnvVar resVar True (aeMod elem)
                                                           }
                                     Right (tag,nms) -> error "No node expected after a case expression!"
           lhs   .  fillEnv     =  @altL.fillEnv >> @fillEnv
  | Catch  loc   .  targetInfo  =  Left @lhs.tmpVar
           lhs   .  fillEnv     =  do { @body.fillEnv
                                      ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                      ; let (EnvUnion bn _) = aeMod elem
                                      ; @handler.fillEnv
                                      ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                      ; let (EnvUnion hn _) = aeMod elem
                                      ;  case @lhs.targetInfo of
                                           Left resVar     -> @lhs.setEnvVar resVar True (EnvUnion (bn ++ hn) Nothing)
                                           Right (tag,nms) -> error "No node expected after a Catch expression!"
                                      ; @exceptEq
                                      }
%%]

%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%

ffi "primFoo"; \(Tag e1 en)  => e1:
                                  absVal = prim(Foo) ! Tag ! 1
                                  envMod = SetAv absVal
                                en:
                                  absVal = prim(Foo) ! Tag ! n
                                  envMod = SetAV absVal
ffi "primFoo"; \r            => r:
                                 absVal  = prim(Foo)

ffi "foo"; \(Tag e1 e2)      => note: (Tag == Unboxed)
                                e1: Basic
                                en: Basic

%%[8.ffi
SEM GrExpr
  | FFI  loc . primAbsVal = let l = case @resTagL.self of
                                      (GrTag_Unboxed : _) -> [(GrTag_Unboxed,[AV_Basic])]
                                      ts                  -> map (\t -> (t,avForArity)) ts
                            in  AV_Nodes (Map.fromList l)
             . prim       = case @lhs.targetInfo of
                              Left nm          -> @lhs.setEnvVar nm True (EnvSetAV @primAbsVal)
                              Right (tag, nms) -> let (AV_Nodes nodes) = @primAbsVal
                                                      tagElementsAV    = fromJust' "PointsToAnalysis.GrExpr.FFI" $ Map.lookup tag nodes
                                                      makeAV teAV nm   = @lhs.setEnvVar nm True (EnvSetAV teAV)
                                                  in zipWithM_ makeAV tagElementsAV nms
             . ffi        = case @lhs.targetInfo of
                              Left  nm         -> error "FFI should be followed by an unboxed node pattern"
                              Right (tag, nms) -> mapM_ (\e -> @lhs.setEnvVar e True (EnvSetAV AV_Basic)) nms
             . fillEnv    = if isPrim @nm then @prim else @ffi
%%]
  | FFI  loc . primAbsVal = primAV @nm

Note: we have the ctable, can we do something with that?
      e.g. we could get the result Tags from it. If we save result type for a FFI.

%%[8.prim hs import({%{GRIN}Primitives})
%%]

%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%

Every call to apply equals to an rewrite using the apply map. We must join all
these apply into one argument, so we join them in a list and put them in the
equation array at the top level.

apply (P2upto  ) a => (P1upto a)
apply (P1upto a) b => (Fupto  a b)


apply (P/1/apply f) a == apply f a  -- a P/1/apply should not occur? right?!

notes: - all tags should be of type Partial application
       - all tags should miss the same number of arguments

eval (Fapply a b)

%%[8.apply
SEM GrExpr
  | App    loc . fillEnv  = case @lhs.targetInfo of
                              Right (tag, nms) -> error "Apply bound to pattern?!"
                              Left  nm         -> let makeAppArgInfo = map mkAppInfo
                                                      mkAppInfo :: NodeInfo (Maybe Int) -> Either Variable AbstractEnvModifier
                                                      mkAppInfo l = case l of
                                                                        Left  v  -> Left v
                                                                        Right n  -> error $ "Node in apply argument not implemented: " ++ show n
                                                  in @lhs.setEnvVar nm True (EnvApp (getNr @nm) (makeAppArgInfo @argL.valsInfo) @lhs.exceptVar)

%%]

%%[8.applyMap
ATTR GrModule GrAGItf [ | | applyMap : {AssocL GrTag (Either GrTag Int)} ]
SEM GrModule
  | Mod     loc . applyMap = let rewrite (EvApTagVar (HNPos f)) = Right f
                                 rewrite (EvApTagTag t        ) = Left  t
                             in [ (t, rewrite v) | ((t,_), v) <- @applyTagMp ]
%%]

%%%%%%%%%%%
%% Fetch %%
%%%%%%%%%%%

%%[8.fetch
SEM GrExpr
  | Fetch  loc . fillEnv  =  case @lhs.targetInfo of
                                  Left resVar     -> do { elem <- @lhs.getEnvVar (getNr @nm)
                                                        ; @lhs.setEnvVar resVar True (aeMod elem)
                                                        }
                                  Right (tag,nms) -> error "HPT expects variable after fetch, not a node"


%%]

%%%%%%%%%%%%
%% Update %%
%%%%%%%%%%%%

%%[8.update

ATTR GrVal [ | | getName : {HsName} ]

SEM GrVal
  | Var      lhs.getName = @nm
  | * - Var  lhs.getName = error "HPT expects variable in update"


SEM GrExpr
  | Update  loc . fillEnv  =  @lhs.setEnvVar (getNr @nm) True (EnvUnion [getNr @nm, getNr @val.getName] Nothing)
                                 
%%]


%%%%%%%%%%%%%%%%%
%% FetchUpdate %%
%%%%%%%%%%%%%%%%%

%%[8

SEM GrExpr
  | FetchUpdate  loc . fillEnv  =  @lhs.setEnvVar (getNr @dst) True (EnvUnion [getNr @dst, getNr @src] Nothing)
                                 
%%]


%%%%%%%%%%%
%% Throw %%
%%%%%%%%%%%

TODO: targetInfo should allow empty patterns to be expressed

%%[8.throw
SEM GrExpr
  | Throw  loc  .  exceptions  =  getNr @nm : @lhs.exceptions
                .  fillEnv     =  case @lhs.targetInfo of
                                      Left  n | n /= getNr wildcardNr -> @lhs.setEnvVar n True (EnvSetAV AV_Nothing)
                                      otherwise                       -> return ()
%%]

%%%%%%%%%%%
%% Catch %%
%%%%%%%%%%%

%%[8.catch
SEM GrExpr
  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEq    =  @lhs.setEnvVar @handlerVar True (EnvUnion @body.exceptions Nothing)
                   . handlerVar  =  getNr @arg
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Non local exceptions %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)

%%[8.catch
ATTR AllGrExpr [ exceptVar: Variable | | ]
SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   = @resultVar + 1
          loc     . exceptEq    =  @lhs.setEnvVar @exceptVar True (EnvUnion @expr.exceptions Nothing)
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllGrNT [ | | actualsEnv USE {.} {id} : {[(Int, [Maybe Int])] -> [(Int, [Maybe Int])]} ]
ATTR AllBind [ allActuals: {[(Int, [Maybe Int])]} | | ]

SEM GrExpr
  | Store Unit  loc  .  fGenActuals  = \tag mns n -> let args      = if grinStoreArity
                                                                      then tail mns -- first element is the size of the rest of the node
                                                                      else      mns
                                                         resultVar = lookup tag @lhs.tag2resultVar
                                                         actuals r = ((r, args) :)
                                                     in maybe id actuals resultVar
                loc  .  actualsEnv   = case (@val.valInfo, @lhs.targetInfo) of
                                           (Right (st,snms), Left tn) -> @fGenActuals st snms tn
                                           otherwise                  -> id
  | Call        loc  .  actualsEnv   = ((@resultVar, @argL.depVars) :)

SEM GrModule
  | Mod       bindL  .  allActuals   = @bindL.actualsEnv []

SEM GrBind
  | Bind      loc    .  bindActuals  = transpose [ actuals
                                                 | (resVar, actuals) <- @lhs.allActuals
                                                 , resVar == @resultVar
                                                 ]
                     .  fillEnvBind  = let envElem (formal, i) actuals
                                            = @lhs.setEnvVar (getNr formal)
                                                             True
                                                             (EnvUnion [ actual | Just actual <- actuals]
                                                                       (Just . @applySelect $ i)
                                                             )
                                       in zipWithM_ envElem
                                                    (zip @argNmL [(if grinStoreArity then 1 else 0)..])
                                                    ( if    null @bindActuals
                                                       then replicate (length @argNmL) []
                                                       else @bindActuals
                                                    )
                     .  actualsEnv   = if @prune then id else @expr.actualsEnv
                     .  applySelect  = EnvSelect @lhs.tmpVar (GrTag_Var @nm)
%%]

%%%%%%%%%%%%%
%% Globals %%
%%%%%%%%%%%%%

The globals look like the expression

store (Tag f1 fn); \bla ->

%%[8.global
SEM GrGlobal
  | Global  loc  .  (heapPointer, fillEnv, heapElem)  =  makeStore @lhs.setEnvVar
                                                                (flip lookup @lhs.tag2resultVar)
                                                                @lhs.heapPointer
                                                                @val.valInfo
                                                                (Left $ getNr @nm)
            lhs  .  heapList                          =  @heapElem : @lhs.heapList
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
--revLookup :: (Eq b) => [(a,b)] -> b -> Maybe a
revLookup l e = lookup e (map swap l)
    where swap = uncurry (flip (,))

getCafVar m k = getNr . fromJust' ("cafVar not found " ++ show k) $ Map.lookup k m

fromJust' _ (Just a ) = a
fromJust' m (Nothing) = error $ "fromJust: " ++ m

makeHeapElem l eq =  (l, AbstractHeapElement  {  ahBaseSet = AV_Nothing
                                              ,  ahSharedSet = Just AV_Nothing
                                              ,  ahMod = eq
                                              }
                     )
%%]
