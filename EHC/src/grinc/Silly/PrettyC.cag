%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.PrettyC} import(Data.List(intersperse), UU.Pretty, EH.Util.PPUtils,{%{GRIN}GRINCCommon},{%{GRIN}Silly}, {%{GRIN}Config}) export(prettyC)
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyC :: Bool -> Bool -> SilModule -> PP_Doc
prettyC optTrace optDef silmod
  = let t = wrap_SilModule (sem_SilModule silmod) ---- TESTING!!! test1) -- 
                           (Inh_SilModule { optTraceCall_Inh_SilModule = optTrace
                                          , optCaseDefault_Inh_SilModule = optDef
                                          }
                           )
     in  prettyC_Syn_SilModule t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

{-------------------------------------------------------------------------------
  Notes:

  1. We need to better understand variable and parameter types, since we
     don't have any type information for variables or parameters...
     apparently there is only one type available?
     
  2. Array access needs to be fixed especially for assignment expressions.
     For assignments {a[x] = rhs} we need to generate:
        %array.unique = getelementptr uint* %a , uint %x
        %array.unique = rhs

  3. We need to inline heap_alloc, switch_trap, ?? function definitions.
  
  4. We need to fix global declarations and the initalization function
  
  Other
    function - not complete 
    jump     - not done
    ...
-------------------------------------------------------------------------------}

--------------------------------------------------------------------------------
-- INTRODUCTION OF UNIQUE LABEL COUNTER
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement Alternatives Alternative
[ | unique : {Int} | ]
SEM SilModule
  | SilModule   functions.unique = 0

SEM Alternative
  | Alternative loc.clbl = @lhs.unique
                lhs.unique  = @loc.clbl + 1

--------------------------------------------------------------------------------
-- MODULE GENERATION
--------------------------------------------------------------------------------

SEM SilModule
  | SilModule   lhs.prettyC   = preambule
                                >-< text ""
                                >-< comment "Tag Constants"
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment "Global Table"
                                >-< ppVertically (map variableDeclaration @variables)
                                >-< text ""
                                >-< comment "Function Definitions"
                                >-< @functions.prettyC

--------------------------------------------------------------------------------
-- FUNCTION DECLARATION GENERATION
--------------------------------------------------------------------------------

SEM Function
  | Function    lhs.prettyC   = prefix >|< params 
                                       >|< ") {" 
                                       >-< body 
                                       >-< postfix
                                   where prefix  = "void %" >|< @name >#< "("
                                         params = commaSeparated (map (declareName "uint*") @parameters)
                                         body    = indent 3 @body.prettyC
                                         postfix = "}" >-< text ""
-- ppWhen @tailJumps jumpPrepare
-- methodLocals @locals

--------------------------------------------------------------------------------
-- SWITCH STATEMENT GENERATION
--------------------------------------------------------------------------------
ATTR Alternative Alternatives [ | | prettyAlt : {(PP_Doc, PP_Doc)}]
SEM Alternative
  | Alternative lhs.prettyAlt = (indent 3 tableEntry, targetCode)
                                   where tableEntry = @when.prettyC 
                                                            >|< ", label %" 
                                                            >|< label
                                         label      = "case." >|< show @loc.clbl
                                         targetCode = label >|< ":" 
                                                            >-< indent 3 @body.prettyC

SEM Alternatives
  | Nil   lhs.prettyAlt  = (text "", text "")
  | Cons  lhs.prettyAlt  = @hd.prettyAlt `concat` @tl.prettyAlt
                              where concat (a,b) (c,d) = (a >-< c, b >-< d)

{
ppSwitch :: PP_Doc -> (PP_Doc,PP_Doc) -> PP_Doc
ppSwitch scrutinee alts = "switch int" >#< scrutinee 
                                       >|< ", label %switch_trap" 
                                       >-< "[" >-< fst alts >|< "]" 
                                       >-< snd alts
}

--------------------------------------------
--------------------------------------------
--------------------------------------------

{--
getelementptr <pointer-type> <pointer/array variable> , uint <index>

pointer type is either built-in type or requires type declaration
as in:  %ST = type { int, double, %RT }
--}

ATTR SilModule Functions Function Statements Statement Alternatives Alternative
  [ optTraceCall     : {Bool} -- when True, function entrance/exit is logged
    optCaseDefault   : {Bool} -- when True, error messages are given as default case for each switch
  | | ]



{
optTraceAssign = False
}

ATTR SilModule Functions Function Statements Statement Alternatives Alternative Value Variable Constant
         [ | | prettyC USE {>-<} {empty} : PP_Doc ]

ATTR Values [ | | prettyCs : {[PP_Doc]} ]

ATTR Variable [ | | prettyPtr : {PP_Doc}  ]




SEM Statement
  | Comment     lhs.prettyC   = comment @comment              -- DONE
  | Assignment  lhs.prettyC   = assignment @dest.prettyC      -- DONE
                                           @source.prettyC
  | Switch      lhs.prettyC   = ppSwitch @scrutinee.prettyC   -- DONE (NEED TO DEFINE switch_trap)
                                         @body.prettyAlt
       -- note, switch is not using  @lhs.optCaseDefault 
  | Call        lhs.prettyC   = call @name 
                                     @args.prettyCs >|< ";"
  | Jump        lhs.prettyC   = jump @name
  | Enter       lhs.prettyC   = methodEnter @nLocal @nParam
  | Leave       lhs.prettyC   = methodLeave @diff


SEM Alternative
  | Alternative lhs.prettyC   = text "NOT USED"               -- DONE

SEM Values
  | Nil         lhs.prettyCs  = []                            -- DONE
  | Cons        lhs.prettyCs  = @hd.prettyC : @tl.prettyCs    -- DONE

SEM Value
  | Con         lhs.prettyC   = @con.prettyC                  -- DONE
  | Var         lhs.prettyC   = @var.prettyC                  -- DONE
  | Call        lhs.prettyC   = call @name @args.prettyCs     -- DONE (ARG FORMAT NEEDS TYPE) 
  | Alloc       lhs.prettyC   = "tail call uint %heapalloc"   -- DONE
                                >#< "(uint" 
                                >#< show @size 
                                >|< ")"

SEM Constant
  | Literal     lhs.prettyC   = text ("int " ++ show @value)  -- DONE
  | Alias       lhs.prettyC   = text ("%" ++ @name)           -- DONE

SEM Variable
  | Var         lhs.prettyC   = text ("%" ++ @name)           -- DONE
                lhs.prettyPtr = text "(*" >#< text @name      -- DONE (BUT TYPING PROBLEM)
                                          >#< text ")" 
  | SP          lhs.prettyC   = text "%SP"                    -- DONE
                lhs.prettyPtr = text "%SP"                    -- DONE
  | BP          lhs.prettyC   = text "%BP"                    -- DONE
                lhs.prettyPtr = text "%BP"                    -- DONE
  | RP          lhs.prettyC   = text "%RP"                    -- DONE
                lhs.prettyPtr = text "%RP"                    -- DONE
  | Subs        lhs.prettyC   = "getelementptr uint*" 
                                   >#< @array.prettyPtr
                                   >|< ","
                                   >#< @index.prettyC
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Building a C program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

commaSeparated :: [String] -> String
commaSeparated = concat . intersperse ", "

decrementWith p n
 = incrementWith p (-n)

incrementWith p n
 = if n>0
   then p >#< "+=" >#< n >#< ";"
   else if n<0
   then p >#< "-=" >#< (-n) >#< ";"
   else empty

declareNames :: String -> [String] -> PP_Doc
declareNames tp ns
 = tp >#< commaSeparated ns >|< ";"

declareName :: String -> String -> String
declareName tp nm
 = tp ++ (' ' : nm)

trace :: String -> PP_Doc
trace s
 = text ("printf(\"" ++ s ++ " SP=%d\\n\", SP-Stack); fflush(stdout);")

caseDefault :: PP_Doc -> PP_Doc
caseDefault x
 =  "default: printf(\"undefined case for " >|< x >|< " : %d\\n\", " >|< x >|< "); exit(1);"

comment :: String -> PP_Doc
comment s = "; ----" >#< s >#< "----"

call :: String -> [PP_Doc] -> PP_Doc
call f ps
 = "call" >#< "int" >#< f >#< "(" >|< ppHorizontally (intersperse (text ", ") ps) >|< ")"


--------------------------------------------------------------------------------
-- Semantic functions
--------------------------------------------------------------------------------

preambule :: PP_Doc
preambule = comment "Generated LLVM Code"

constantDefinition :: (String,Int) -> PP_Doc         -- DONE (but only int consts supported)
constantDefinition (x,n) = text ("%" ++ x) >#< text "= global uint" >#< text (show n)

-- %global_false = global uint 1

variableDeclaration :: String -> PP_Doc
variableDeclaration x
 = "%" >|< text x >#< "= global uint 1 ; NEED TO FIX"

methodHead :: String -> [String] -> PP_Doc
methodHead nm params
 =  let parameters = if null params
                      then "void"
                      else commaSeparated (map (declareName "GrWord") params)
    in  "void" >#< nm >|< "(" >|< parameters >|< ")"

methodHeader :: Bool -> String -> [String] -> PP_Doc
methodHeader optTrace nm params
 =  methodHead nm params
    >#< "{"
    >-< ppWhen optTrace (trace ("enter " ++ show nm))

methodFooter ::  Bool -> String -> PP_Doc
methodFooter optTrace nm
 =  ppWhen optTrace (trace ("leave "++show nm))
    >-< text "}"
    >-< text ""

methodLocals :: [String] -> PP_Doc
methodLocals ns
 = ppUnless (null ns)
            (   comment "Local names"
            >-< declareNames "GrWord" ns
            )

jumpPrepare :: PP_Doc
jumpPrepare
 =  pp machDepCForTailcallEnter

jump :: String -> PP_Doc
jump nm
 =  machDepCForTailcallLeave1
    >-< "register void* _tail_call_dest = ((void*)" >|< nm >|< ");"
    >-< machDepCForTailcallLeave2
    >-< "goto *_tail_call_dest;"

assignment :: PP_Doc -> PP_Doc -> PP_Doc
assignment v e
 = v
   >#< "="
   >#< e
   >|< ppWhen optTraceAssign
              (" printf(\"assignment" >#< show v >#< "=" >#< e >#< " : %d\\n\", " >#< show v >#< ");")

methodEnter :: Int -> Int -> PP_Doc
methodEnter nLocal nParam
 = comment "Enter"
   >-< assignment (text "%SP") (text "(%BP)")
   >-< assignment (text "%BP")  (text "%SP")
   >-< incrementWith (text "%SP") (nLocal+nParam+1)

methodLeave :: Int -> PP_Doc
methodLeave nDiff
 = comment "Leave"
   >-< assignment (text "SP")  (text "BP")
   >-< assignment (text "BP") (text "((Pointer)*SP)")
   >-< incrementWith (text "SP") (nDiff)


test1 = SilModule_SilModule [] [] [func]
   where func   = Function_Function "func" False ["p1", "p2"] ["loc"] [swtch]
         swtch  = Statement_Switch (Value_Var (Variable_Var "scr")) [alt1,alt2]
         alt1   = Alternative_Alternative (Constant_Literal 1) [(Statement_Call "fun1" [])]
         alt2   = Alternative_Alternative (Constant_Literal 2) [(Statement_Call "fun2" [arg1, arg2])]
         arg1   = Value_Var (Variable_Var "x")
         arg2   = Value_Con (Constant_Literal 3)
%%]
