%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Prettyprint Silly program as C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}Silly.PrettyC} import(Data.List(intersperse), UU.Pretty, EH.Util.PPUtils,{%{GRIN}GRINCCommon},{%{GRIN}Silly}, {%{GRIN}Config}) export(prettyC)
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyC :: Bool -> Bool -> SilModule -> PP_Doc
prettyC optTrace optDef silmod
  = let t = wrap_SilModule (sem_SilModule test1) -- silmod) <---- TESTING!!!
                           (Inh_SilModule { optTraceCall_Inh_SilModule = optTrace
                                          , optCaseDefault_Inh_SilModule = optDef
                                          }
                           )
     in  prettyC_Syn_SilModule t

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

--------------------------------------------------------------------------------
-- INTRODUCTION OF UNIQUE LABEL COUNTER
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement Alternatives Alternative
[ | unique : {Int} | ]
SEM SilModule
  | SilModule   functions.unique = 0

SEM Alternative
  | Alternative loc.clbl = @lhs.unique
                lhs.unique  = @loc.clbl + 1

--------------------------------------------------------------------------------
-- SWITCH STATEMENT RENDERING
--------------------------------------------------------------------------------
ATTR Alternative Alternatives [ | | prettyAlt : {(PP_Doc, PP_Doc)}]
SEM Alternative
  | Alternative lhs.prettyAlt = (indent 3 tableEntry, targetCode)
                                   where tableEntry = @when.prettyC 
                                                            >|< ", label %" 
                                                            >|< label
                                         label      = "case." >|< show @loc.clbl
                                         targetCode = label >|< ":" 
                                                            >-< indent 3 @body.prettyC

SEM Alternatives
  | Nil   lhs.prettyAlt  = (text "", text "")
  | Cons  lhs.prettyAlt  = @hd.prettyAlt `concat` @tl.prettyAlt
                              where concat (a,b) (c,d) = (a >-< c, b >-< d)


{
ppSwitch :: PP_Doc -> (PP_Doc,PP_Doc) -> PP_Doc
ppSwitch scrutinee alts = "switch int" >#< scrutinee 
                                       >|< ", label %switch_trap" 
                                       >-< "[" >-< fst alts >|< "]" 
                                       >-< snd alts
}

--------------------------------------------------------------------------------
-- NEXT TASK...
--------------------------------------------------------------------------------


ATTR SilModule Functions Function Statements Statement Alternatives Alternative
  [ optTraceCall     : {Bool} -- when True, function entrance/exit is logged
    optCaseDefault   : {Bool} -- when True, error messages are given as default case for each switch
  | | ]



{
optTraceAssign = False
}

ATTR SilModule Functions Function Statements Statement Alternatives Alternative Value Variable Constant
         [ | | prettyC USE {>-<} {empty} : PP_Doc ]

ATTR Values [ | | prettyCs : {[PP_Doc]} ]

ATTR Variable [ | | prettyPtr : {PP_Doc}  ]


SEM SilModule
  | SilModule   lhs.prettyC   = preambule
                                >-< text ""
                                >-< comment "Tag Constants"
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment "Global Table"
                                >-< ppVertically (map variableDeclaration @variables)
                                >-< text ""
                                >-< comment "Function Definitions"
                                >-< @functions.prettyC

SEM Statement
  | Comment     lhs.prettyC   = comment @comment              -- DONE
  | Assignment  lhs.prettyC   = assignment @dest.prettyC      -- DONE
                                           @source.prettyC
  | Switch      lhs.prettyC   = ppSwitch @scrutinee.prettyC   -- DONE
                                         @body.prettyAlt
       -- note, switch is not using  @lhs.optCaseDefault 
  | Call        lhs.prettyC   = call @name 
                                     @args.prettyCs >|< ";"
  | Jump        lhs.prettyC   = jump @name
  | Enter       lhs.prettyC   = methodEnter @nLocal @nParam
  | Leave       lhs.prettyC   = methodLeave @diff


SEM Alternative
  | Alternative lhs.prettyC   = alternative @when.prettyC @body.prettyC

SEM Values
  | Nil         lhs.prettyCs  = []                            -- DONE (nothing to do)
  | Cons        lhs.prettyCs  = @hd.prettyC : @tl.prettyCs    -- DONE (nothing to do)

SEM Value
  | Con         lhs.prettyC   = @con.prettyC                  -- DONE
  | Var         lhs.prettyC   = @var.prettyC                  -- DONE
  | Call        lhs.prettyC   = call @name @args.prettyCs     -- DONE (arg format wrong needs type...) 
  | Alloc       lhs.prettyC   = "tail call uint %heapalloc ( uint" >#< show @size >|< ")"

SEM Constant
  | Literal     lhs.prettyC   = text ("int " ++ show @value)  -- DONE
  | Alias       lhs.prettyC   = text ("%" ++ @name)           -- DONE

SEM Variable
  | Var         lhs.prettyC   = text ("%" ++ @name)           -- DONE
                lhs.prettyPtr = text "(*" >#< text @name      -- DONE (BUT TYPING PROBLEM)
                                          >#< text ")" 
  | SP          lhs.prettyC   = text "%SP"                    -- DONE
                lhs.prettyPtr = text "%SP"                    -- DONE
  | BP          lhs.prettyC   = text "%BP"                    -- DONE
                lhs.prettyPtr = text "%BP"                    -- DONE
  | RP          lhs.prettyC   = text "%RP"                    -- DONE
                lhs.prettyPtr = text "%RP"                    -- DONE
  | Subs        lhs.prettyC   = @array.prettyPtr >|< "[" 
                                                 >|< @index.prettyC 
                                                 >|< "]"
                lhs.prettyPtr = error "attempt to use subscription as pointer"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Building a C program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

commaSeparated :: [String] -> String
commaSeparated = concat . intersperse ", "

decrementWith p n
 = incrementWith p (-n)

incrementWith p n
 = if n>0
   then p >#< "+=" >#< n >#< ";"
   else if n<0
   then p >#< "-=" >#< (-n) >#< ";"
   else empty

declareNames :: String -> [String] -> PP_Doc
declareNames tp ns
 = tp >#< commaSeparated ns >|< ";"

declareName :: String -> String -> String
declareName tp nm
 = tp ++ (' ' : nm)

trace :: String -> PP_Doc
trace s
 = text ("printf(\"" ++ s ++ " SP=%d\\n\", SP-Stack); fflush(stdout);")

caseDefault :: PP_Doc -> PP_Doc
caseDefault x
 =  "default: printf(\"undefined case for " >|< x >|< " : %d\\n\", " >|< x >|< "); exit(1);"

comment :: String -> PP_Doc
comment s = "; ----" >#< s >#< "----"

call :: String -> [PP_Doc] -> PP_Doc
call f ps
 = "call" >#< "int" >#< f >#< "(" >|< ppHorizontally (intersperse (text ", ") ps) >|< ")"


--------------------------------------------------------------------------------
-- Semantic functions
--------------------------------------------------------------------------------

preambule :: PP_Doc
preambule
 = comment "Generated LLVM Code"

constantDefinition :: (String,Int) -> PP_Doc         -- DONE (but only int consts supported)
constantDefinition (x,n) = text ("%" ++ x) >#< text "= global uint" >#< text (show n)

-- %global_false = global uint 1

variableDeclaration :: String -> PP_Doc
variableDeclaration x
 = "%" >|< text x >#< "= global uint 1 ; NEED TO FIX"

methodHead :: String -> [String] -> PP_Doc
methodHead nm params
 =  let parameters = if null params
                      then "void"
                      else commaSeparated (map (declareName "GrWord") params)
    in  "void" >#< nm >|< "(" >|< parameters >|< ")"

methodHeader :: Bool -> String -> [String] -> PP_Doc
methodHeader optTrace nm params
 =  methodHead nm params
    >#< "{"
    >-< ppWhen optTrace (trace ("enter " ++ show nm))

methodFooter ::  Bool -> String -> PP_Doc
methodFooter optTrace nm
 =  ppWhen optTrace (trace ("leave "++show nm))
    >-< text "}"
    >-< text ""

methodLocals :: [String] -> PP_Doc
methodLocals ns
 = ppUnless (null ns)
            (   comment "Local names"
            >-< declareNames "GrWord" ns
            )

jumpPrepare :: PP_Doc
jumpPrepare
 =  pp machDepCForTailcallEnter

jump :: String -> PP_Doc
jump nm
 =  machDepCForTailcallLeave1
    >-< "register void* _tail_call_dest = ((void*)" >|< nm >|< ");"
    >-< machDepCForTailcallLeave2
    >-< "goto *_tail_call_dest;"

assignment :: PP_Doc -> PP_Doc -> PP_Doc
assignment v e
 = v
   >#< "="
   >#< e
   >|< ppWhen optTraceAssign
              (" printf(\"assignment" >#< show v >#< "=" >#< e >#< " : %d\\n\", " >#< show v >#< ");")

alternative :: PP_Doc -> PP_Doc -> PP_Doc
alternative when body = "int" >#< when >|< "," >#< body 

methodEnter :: Int -> Int -> PP_Doc
methodEnter nLocal nParam
 = comment "Enter"
   >-< assignment (text "*SP") (text "((GrWord)BP)")
   >-< assignment (text "BP")  (text "SP")
   >-< incrementWith (text "SP") (nLocal+nParam+1)

methodLeave :: Int -> PP_Doc
methodLeave nDiff
 = comment "Leave"
   >-< assignment (text "SP")  (text "BP")
   >-< assignment (text "BP") (text "((Pointer)*SP)")
   >-< incrementWith (text "SP") (nDiff)


test1 = SilModule_SilModule [] [] [func]
   where func  = Function_Function "func" False [] [] [swtch]
         swtch = Statement_Switch (Value_Var (Variable_Var "scr")) [alt1,alt2]
         alt1   = Alternative_Alternative (Constant_Literal 1) [(Statement_Call "fun1" [])]
         alt2   = Alternative_Alternative (Constant_Literal 2) [(Statement_Call "fun2" [])]
%%]
