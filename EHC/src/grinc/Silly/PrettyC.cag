%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.PrettyC} import(Data.List(intersperse), UU.Pretty, EH.Util.PPUtils,{%{GRIN}GRINCCommon},{%{GRIN}Silly}, {%{GRIN}Config}) export(prettyC)
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyC :: Bool -> Bool -> SilModule -> PP_Doc
prettyC optTrace optDef silmod
  = let t = wrap_SilModule (sem_SilModule silmod) ---- TESTING!!! test1) --  
                           (Inh_SilModule { optTraceCall_Inh_SilModule = optTrace
                                          , optCaseDefault_Inh_SilModule = optDef
                                          }
                           )
     in  prettyC_Syn_SilModule t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

--------------------------------------------------------------------------------
-- INTRODUCTION OF UNIQUE LABEL COUNTER
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value
[ | unique : {Int} | ]

SEM SilModule
  | SilModule   functions.unique = 0

SEM Alternative
  | Alternative loc.clbl    = @lhs.unique
                lhs.unique  = @loc.clbl + 1

SEM Statement
  | Switch      lhs.unique  = @loc.slbl + 1
                loc.slbl    = @lhs.unique
SEM Variable
  | Subs        loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | SP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | RP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | BP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1

SEM Value
  | Con         loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Var         loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Alloc       loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Call        loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
                
--------------------------------------------------------------------------------
-- PROPAGATING CONSTANT SUBSTITUTIONS
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value Constant
[ constants : {[(String,Int)]} | | ]

SEM SilModule
  | SilModule   functions.constants = @constants

--------------------------------------------------------------------------------
-- VARIABLE/VALUE POINTER TYPES
--------------------------------------------------------------------------------
{
data PtrType = Thunk | ThunkPtr | ThunkPtrPtr

ptr :: PtrType -> PP_Doc
ptr Thunk          = text "%thunk_type"
ptr ThunkPtr       = text "%thunk_type*"
ptr ThunkPtrPtr    = text "%thunk_type**"

ptrptr :: PtrType -> PP_Doc
ptrptr p = ptr p >|< "*"

}

ATTR Variable Value [ | | ptrtype : {PtrType}]

SEM Variable
  | Var         loc.ptrtype  = Thunk
                lhs.ptrtype  = @loc.ptrtype
  | SP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | BP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | RP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | Subs        loc.ptrtype  = ThunkPtrPtr ------- PROBABLY WRONG
                lhs.ptrtype  = @loc.ptrtype

SEM Value
  | Con         loc.ptrtype  = Thunk
                lhs.ptrtype  = @loc.ptrtype
  | Var         loc.ptrtype  = ThunkPtr
                lhs.ptrtype  = @loc.ptrtype
  | Alloc       loc.ptrtype  = ThunkPtr
                lhs.ptrtype  = @loc.ptrtype
  | Call        loc.ptrtype  = ThunkPtr ----- NOT SURE ABOUT THIS EITHER
                lhs.ptrtype  = @loc.ptrtype


--------------------------------------------------------------------------------
-- MODULE GENERATION
--------------------------------------------------------------------------------

SEM SilModule
  | SilModule   lhs.prettyC   = header
                                >-< text ""
                                >-< comment "Constants"
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment "Globals"
                                >-< ppVertically (map variableDeclaration @variables)
                                >-< text ""
                                >-< text ""
                                >-< "implementation"
                                >-< text ""
                                >-< text ""
                                >-< @functions.prettyC

{
header :: PP_Doc
header = comment "LLVM Code Generated From Grin"
         >-< "" >-< ""
         >-< "%thunk_type = type uint"
         >-< "declare void main()"
         >-< "declare void switch_trap()"
         >-< "declare %thunk_type heap_alloc(uint)"
         >-< ""

constantDefinition :: (String,Int) -> PP_Doc
constantDefinition (x,n) = ";" >#< x >#< "=" >#< show n

variableDeclaration :: String -> PP_Doc
variableDeclaration x = "%" >|< text x >#< "= global %thunk_type undef"
}

--------------------------------------------------------------------------------
-- FUNCTION DECLARATION GENERATION
--------------------------------------------------------------------------------

SEM Function
  | Function    lhs.prettyC   = prefix >|< params 
                                       >|< ") {" 
                                       >-< body 
                                       >-< postfix
                                   where prefix  = "void %" >|< @name >#< "("
                                         params = commaSeparated (map (declareName "uint*") @parameters)
                                         body    = indent 3 @body.prettyC
                                         postfix = "}" >-< text ""
-- ppWhen @tailJumps jumpPrepare

--------------------------------------------------------------------------------
-- SWITCH STATEMENT GENERATION
--------------------------------------------------------------------------------
ATTR Alternative Alternatives [ break : PP_Doc | | prettyAlt : {(PP_Doc, PP_Doc)}]
SEM Alternative
  | Alternative lhs.prettyAlt = (indent 3 tableEntry, targetCode)
                                   where tableEntry = @when.prettyC 
                                                            >|< ", label %" 
                                                            >|< label
                                         label      = "case." >|< show @loc.clbl
                                         targetCode = label >|< ":" 
                                                            >-< indent 3 
                                                            ( @body.prettyC 
                                                              >-< @lhs.break)

SEM Alternatives
  | Nil   lhs.prettyAlt  = (text "", text "")
  | Cons  lhs.prettyAlt  = @hd.prettyAlt `concat` @tl.prettyAlt
                              where concat (a,b) (c,d) = (a >-< c, b >-< d)

SEM Statement
  | Switch   body.break = "br %switch_end." >|< @loc.slbl >|< ":"

{
ppSwitch :: Int -> PP_Doc -> (PP_Doc,PP_Doc) -> PP_Doc
ppSwitch lbl scrutinee alts = "switch int" >#< scrutinee 
                                       >|< ", label %switch_trap." >|< show lbl 
                                       >-< "[" >-< fst alts >|< "]" 
                                       >-< snd alts
                                       >|< "%switch_trap." >|< show lbl >|< ":"
                                       >-< indent 3 (text "call void switch_trap()")
                                       >-< "%switch_end." 
                                       >|< show lbl
                                       >|< ":"
}

--------------------------------------------------------------------------------
-- LOAD AND STORE OF VALUES
--------------------------------------------------------------------------------
ATTR Constant [ | | self : SELF]


ATTR Variable Value [ | | before : {Maybe PP_Doc}]

SEM Variable
  | Var         lhs.before   = Nothing ------------------------------------ TODO
  | SP          loc.var     = "%SP." >|< show @loc.vlbl
                lhs.before  = Just $ load "SP" @loc.vlbl @loc.ptrtype
  | BP          loc.var     = "%BP." >|< show @loc.vlbl
                lhs.before  = Just $ load "BP" @loc.vlbl @loc.ptrtype
  | RP          loc.var     = "%RP." >|< show @loc.vlbl
                lhs.before  = Just $ load "RP" @loc.vlbl @loc.ptrtype
  | Subs        loc.var     = "%array." >|< show @loc.vlbl
                lhs.before  = Just $ loadArray (isZero @index.self)
                                               @array.prettyC 
                                               @loc.vlbl 
                                               @loc.ptrtype -------- WRONG PtrType
                                               @index.prettyC

SEM Value
  | Con         lhs.before = Nothing
  | Var         lhs.before = Nothing
  | Alloc       lhs.before = Just $ "%alloc.">|< show @loc.vlbl 
                                                 >#< "="
                                                 >#< heapalloc @size

  | Call        lhs.before = Just $ "%call." >|< show @loc.vlbl 
                                             >#< "="
                                             >#< call @name @args.prettyCs

{
loadArray :: Bool -> PP_Doc -> Int -> PtrType -> PP_Doc -> PP_Doc
loadArray zero name lbl pty idx = if zero then deref2 else arith >-< deref1
   where var    = "%array." >|< lbl
         tmp    = var >|< ".tmp"
         arith  = ptrAdd' tmp name pty idx
         -- tmp >#< "= getelementptr" >#< ptr pty >#< name >|< ", int" >#< idx
         deref1 = var >#< "= load" >#< ptr pty >#< tmp
         deref2 = var >#< "= load" >#< ptr pty >#< name

isZero :: Constant -> Bool                         
isZero (Constant_Literal 0) = True
isZero _           = False

heapalloc :: Int -> PP_Doc
heapalloc ps =  "tail call" 
            >#< "%thunk_type*" 
            >#< "%heapalloc" 
            >#< "(uint " 
            >|< show ps 
            >|< ")"

assign :: Maybe PP_Doc -> Maybe PP_Doc -> PtrType -> PP_Doc -> PP_Doc -> PP_Doc
assign b1 b2 typ v e = rndr b1 >|< rndr b2 >|< (store' e typ v) >-< ""
   where rndr b = maybe (text "") (>-< "") b

--------------------------------------------------------------------------------
-- Function Entry / Exit
--------------------------------------------------------------------------------
enter :: Int -> Int -> PP_Doc
enter i j =  comment "Function Entry"
         >-< "; store current BasePointer value on Stack"
         >-< load' (p "BP") (p "deref") ThunkPtrPtr
         >-< load' (p "SP") (p "deref") ThunkPtrPtr
         >-< cast "BP.cast" ThunkPtr "BP.deref" Thunk -- Why not: ThunkPtrPtr ThunkPtr
         >-< store "BP.cast" ThunkPtr "SP.deref"
         >-< ""
         >-< "; Set BasePointer equal to StackPointer"
         >-< store "SP.deref" ThunkPtr "BP" 
         >-< ""
         >-< "; increment StackPointer"
         >-< ptrAdd "SP.incr" "SP.deref" ThunkPtr (i+1)
         >-< ""
         >-< ""

exit :: Int -> PP_Doc
exit i =  comment "Function Exit (TODO)"
      >-< "; restore StackPointer and BasePointer"
      >-< store "SP.deref" ThunkPtr "SP"
      >-< cast "BP.recast" Thunk "BP.cast" ThunkPtr
      >-< store "BP.recast" ThunkPtr "BP"
      >-< ""     ------ TODO: increment SP (see below) ?
      >-< "ret void"

{--
methodLeave :: Int -> PP_Doc
methodLeave nDiff
 = comment "Leave"
   >-< assignment Nothing Nothing (text "SP")  (text "BP")  -- cleanup
   >-< assignment Nothing Nothing (text "BP") (text "((Pointer)*SP)") -- cleanup
   >-< incrementBy (text "SP") (nDiff)
--}

}

--------------------------------------------
--------------------------------------------
--------------------------------------------


ATTR SilModule Functions Function Statements Statement Alternatives Alternative
  [ optTraceCall     : {Bool} -- when True, function entrance/exit is logged
    optCaseDefault   : {Bool} -- when True, error messages are given as default case for each switch
  | | ]


ATTR SilModule Functions Function Statements Statement Alternatives Alternative Value Variable Constant
         [ | | prettyC USE {>-<} {empty} : PP_Doc ]

ATTR Values [ | | prettyCs : {[PP_Doc]} ]

ATTR Variable [ | | prettyPtr : {PP_Doc}  ]




SEM Statement
  | Comment     lhs.prettyC   = comment @comment
  | Assignment  lhs.prettyC   = assign @source.before
                                       @dest.before
                                       @source.ptrtype
                                       @dest.prettyC
                                       @source.prettyC
  | Switch      lhs.prettyC   = ppSwitch @loc.slbl
                                         @scrutinee.prettyC
                                         @body.prettyAlt
  | Call        lhs.prettyC   = call @name 
                                     @args.prettyCs
  | Jump        lhs.prettyC   = jump @name
  | Enter       lhs.prettyC   = enter @nLocal @nParam
  | Leave       lhs.prettyC   = exit @diff


SEM Alternative
  | Alternative lhs.prettyC   = text "NOT USED"

SEM Values
  | Nil         lhs.prettyCs  = []
  | Cons        lhs.prettyCs  = @hd.prettyC : @tl.prettyCs

SEM Value
  | Con         lhs.prettyC   = @con.prettyC
  | Var         lhs.prettyC   = @var.prettyC
  | Call        lhs.prettyC   = "%call." >|< show @loc.vlbl   -- DONE (ARG FORMAT NEEDS TYPE) 
  | Alloc       lhs.prettyC   = "%alloc." >|< show @loc.vlbl

SEM Constant
  | Literal     lhs.prettyC   = text $ show @value
  | Alias       lhs.prettyC   = text $ get @name @lhs.constants

SEM Variable
  | Var         lhs.prettyC   = text "%" >|< @name
                lhs.prettyPtr = text "%" >|< @name
  | SP          lhs.prettyC   = text "%SP"
                lhs.prettyPtr = text "%SP"
  | BP          lhs.prettyC   = @loc.var
                lhs.prettyPtr = text "%BP"
  | RP          lhs.prettyC   = text "%RP"
                lhs.prettyPtr = text "%RP"
  | Subs        lhs.prettyC   = @loc.var
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Building a C program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

commaSeparated :: [String] -> String
commaSeparated = concat . intersperse ", "

declareNames :: String -> [String] -> PP_Doc
declareNames tp ns
 = tp >#< commaSeparated ns >|< ";"

declareName :: String -> String -> String
declareName tp nm
 = tp ++ (' ' : nm)

comment :: String -> PP_Doc
comment s = "; ----" >#< s >#< "----"

call :: String -> [PP_Doc] -> PP_Doc
call f ps
 = "tail call" >#< "int" >#< f >#< "(" >|< ppHorizontally (intersperse (text ", ") ps) >|< ")"


jumpPrepare :: PP_Doc
jumpPrepare
 =  pp machDepCForTailcallEnter

jump :: String -> PP_Doc
jump nm
 =  machDepCForTailcallLeave1
    >-< "register void* _tail_call_dest = ((void*)" >|< nm >|< ");"
    >-< machDepCForTailcallLeave2
    >-< "goto *_tail_call_dest;"

--------------------------------------------------------------------------------
-- LL Primitives
--------------------------------------------------------------------------------

ptrAdd :: String -> String -> PtrType -> Int -> PP_Doc
ptrAdd l r ty i = ptrAdd' (text l) (text r) ty (text $ show i)

ptrAdd' :: PP_Doc -> PP_Doc -> PtrType -> PP_Doc -> PP_Doc
ptrAdd' l r ty i = l >#< "= getelementptr" >#< ptr ty >#< r >|< ", int" >#< i

load :: String -> Int -> PtrType -> PP_Doc
load nm i p = load' (text nm) (text $ show i) p

load' :: PP_Doc -> PP_Doc -> PtrType -> PP_Doc
load' nm i p = "%" >|< nm >|< "." >|< i >#< "= load" >#< ptr p >#< "%" >|< nm

store :: String -> PtrType -> String -> PP_Doc
store val ty adr = store' (text val) ty (text adr)

store' :: PP_Doc -> PtrType -> PP_Doc -> PP_Doc
store' val ty adr = "store" >#< ptr ty >#< val >|< "," >#< ptrptr ty >#< adr

cast :: String -> PtrType -> String -> PtrType -> PP_Doc
cast lhs ty var ty' = lhs >#< "= cast" >#< ptr ty >#< var >#< "to" >#< ptr ty'

--------------------------------------------------------------------------------
-- Utility Functions
--------------------------------------------------------------------------------

get :: String -> [(String, Int)] -> String
get name table = if null res then error msg else show $ head res
   where res = [ b | (a,b) <- table, a == name]
         msg = "constant: " ++ name ++ " not found!"

p :: Show a => a -> PP_Doc
p x = text $ show x

--------------------------------------------------------------------------------
-- Test Data
--------------------------------------------------------------------------------

test1 = SilModule_SilModule [] [] [func]
   where func   = Function_Function "func" False ["p1", "p2"] ["loc"] [swtch]
         swtch  = Statement_Switch (Value_Var (Variable_Var "scr")) [alt1,alt2]
         alt1   = Alternative_Alternative (Constant_Literal 1) [(Statement_Call "fun1" [])]
         alt2   = Alternative_Alternative (Constant_Literal 2) [(Statement_Call "fun2" [arg1, arg2])]
         arg1   = Value_Var (Variable_Var "x")
         arg2   = Value_Con (Constant_Literal 3)
         
%%]
