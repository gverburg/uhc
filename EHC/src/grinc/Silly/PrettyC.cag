%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.PrettyC} import(Data.List(intersperse), UU.Pretty, EH.Util.PPUtils,{%{GRIN}GRINCCommon},{%{GRIN}Silly}, {%{GRIN}Config}) export(prettyC)
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyC :: Bool -> Bool -> SilModule -> PP_Doc
prettyC optTrace optDef silmod
  = let t = wrap_SilModule (sem_SilModule silmod) ---- TESTING!!! test1) --  
                           (Inh_SilModule { optTraceCall_Inh_SilModule = optTrace
                                          , optCaseDefault_Inh_SilModule = optDef
                                          }
                           )
     in  prettyC_Syn_SilModule t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

{-------------------------------------------------------------------------------
  Notes:

  1. We need to better understand variable and parameter types, since we
     don't have any type information for variables or parameters...
     apparently there is only one type available?
     
  2. Array access needs to be fixed especially for assignment expressions.
     For assignments {a[x] = rhs} we need to generate:
        %array.unique = getelementptr uint* %a , uint %x
        store uint %rhs, uint* %array.unique

  3. We need to inline heap_alloc, switch_trap, ?? function definitions.
  
  4. We need to fix global declarations and the initalization function
  
  Other
    function - not complete 
    jump     - not done
    ...
-------------------------------------------------------------------------------}

--------------------------------------------------------------------------------
-- INTRODUCTION OF UNIQUE LABEL COUNTER
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value
[ | unique : {Int} | ]

SEM SilModule
  | SilModule   functions.unique = 0

SEM Alternative
  | Alternative loc.clbl    = @lhs.unique
                lhs.unique  = @loc.clbl + 1

SEM Statement
  | Switch      lhs.unique  = @loc.slbl + 1
                loc.slbl    = @lhs.unique
SEM Variable
  | Subs        loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | SP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | RP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | BP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1

SEM Value
  | Con         loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Var         loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Alloc       loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Call        loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
                
--------------------------------------------------------------------------------
-- PROPAGATING CONSTANT SUBSTITUTIONS
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value Constant
[ constants : {[(String,Int)]} | | ]

SEM SilModule
  | SilModule   functions.constants = @constants

--------------------------------------------------------------------------------
-- VARIABLE/VALUE POINTER TYPES
--------------------------------------------------------------------------------
{
data PtrType = Thunk | ThunkPtr | ThunkPtrPtr

ptr :: PtrType -> PP_Doc
ptr Thunk       = text "%thunk_type"
ptr ThunkPtr    = text "%thunk_type*"
ptr ThunkPtrPtr = text "%thunk_type**"

ptrptr :: PtrType -> PP_Doc
ptrptr p = ptr p >|< "*"

}

ATTR Variable Value [ | | ptrtype : {PtrType}]

SEM Variable
  | Var         loc.ptrtype  = Thunk
                lhs.ptrtype  = @loc.ptrtype
  | SP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | BP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | RP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | Subs        loc.ptrtype  = ThunkPtrPtr ------- PROBABLY WRONG
                lhs.ptrtype  = @loc.ptrtype

SEM Value
  | Con         loc.ptrtype  = Thunk
                lhs.ptrtype  = @loc.ptrtype
  | Var         loc.ptrtype  = ThunkPtr
                lhs.ptrtype  = @loc.ptrtype
  | Alloc       loc.ptrtype  = ThunkPtr
                lhs.ptrtype  = @loc.ptrtype
  | Call        loc.ptrtype  = ThunkPtr ----- NOT SURE ABOUT THIS EITHER
                lhs.ptrtype  = @loc.ptrtype


--------------------------------------------------------------------------------
-- MODULE GENERATION
--------------------------------------------------------------------------------

SEM SilModule
  | SilModule   lhs.prettyC   = header
                                >-< text ""
                                >-< comment "Constants"
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment "Globals"
                                >-< ppVertically (map variableDeclaration @variables)
                                >-< text ""
                                >-< text ""
                                >-< "implementation"
                                >-< text ""
                                >-< text ""
                                >-< @functions.prettyC

{
header :: PP_Doc
header = comment "LLVM Code Generated From Grin"
         >-< "" >-< ""
         >-< "%thunk_type = type uint"
         >-< "declare void main()"
         >-< "declare void switch_trap()"
         >-< "declare %thunk_type heap_alloc(uint)"
         >-< ""
}

--------------------------------------------------------------------------------
-- FUNCTION DECLARATION GENERATION
--------------------------------------------------------------------------------

SEM Function
  | Function    lhs.prettyC   = prefix >|< params 
                                       >|< ") {" 
                                       >-< body 
                                       >-< postfix
                                   where prefix  = "void %" >|< @name >#< "("
                                         params = commaSeparated (map (declareName "uint*") @parameters)
                                         body    = indent 3 @body.prettyC
                                         postfix = "}" >-< text ""
-- ppWhen @tailJumps jumpPrepare
-- methodLocals @locals

--------------------------------------------------------------------------------
-- SWITCH STATEMENT GENERATION
--------------------------------------------------------------------------------
ATTR Alternative Alternatives [ break : PP_Doc | | prettyAlt : {(PP_Doc, PP_Doc)}]
SEM Alternative
  | Alternative lhs.prettyAlt = (indent 3 tableEntry, targetCode)
                                   where tableEntry = @when.prettyC 
                                                            >|< ", label %" 
                                                            >|< label
                                         label      = "case." >|< show @loc.clbl
                                         targetCode = label >|< ":" 
                                                            >-< indent 3 
                                                            ( @body.prettyC 
                                                              >-< @lhs.break)

SEM Alternatives
  | Nil   lhs.prettyAlt  = (text "", text "")
  | Cons  lhs.prettyAlt  = @hd.prettyAlt `concat` @tl.prettyAlt
                              where concat (a,b) (c,d) = (a >-< c, b >-< d)

SEM Statement
  | Switch   body.break = "br %switch_end." >|< @loc.slbl >|< ":"

{
ppSwitch :: Int -> PP_Doc -> (PP_Doc,PP_Doc) -> PP_Doc
ppSwitch lbl scrutinee alts = "switch int" >#< scrutinee 
                                       >|< ", label %switch_trap." >|< show lbl 
                                       >-< "[" >-< fst alts >|< "]" 
                                       >-< snd alts
                                       >|< "%switch_trap." >|< show lbl >|< ":"
                                       >-< indent 3 (text "call void switch_trap()")
                                       >-< "%switch_end." 
                                       >|< show lbl
                                       >|< ":"
}

--------------------------------------------------------------------------------
-- LOAD AND STORE OF VALUES
--------------------------------------------------------------------------------

ATTR Variable Value [ | | before : {Maybe PP_Doc}]

SEM Variable
  | Var         lhs.before   = Nothing ------------------------------------ TODO
  | SP          loc.var     = "%SP." >|< show @loc.vlbl
                lhs.before  = Just $ loadGlbl "SP" @loc.vlbl @loc.ptrtype
  | BP          loc.var     = "%BP." >|< show @loc.vlbl
                lhs.before  = Just $ loadGlbl "BP" @loc.vlbl @loc.ptrtype
  | RP          loc.var     = "%RP." >|< show @loc.vlbl
                lhs.before  = Just $ loadGlbl "RP" @loc.vlbl @loc.ptrtype
  | Subs        loc.var     = "%array." >|< show @loc.vlbl
                lhs.before  = Just $ loadArray @array.prettyC 
                                               @loc.vlbl 
                                               @loc.ptrtype 
                                               @index.prettyC

SEM Value
  | Con         lhs.before = Nothing
  | Var         lhs.before = Nothing
  | Alloc       lhs.before = Just $ "%alloc.">|< show @loc.vlbl 
                                                 >#< "="
                                                 >#< heapalloc @size

  | Call        lhs.before = Just $ "%call." >|< show @loc.vlbl 
                                             >#< "="
                                             >#< call @name @args.prettyCs
{
loadGlbl :: String -> Int -> PtrType -> PP_Doc
loadGlbl name lbl pty = nm >|< "." >|< lbl >#< "= load" >#< ptr pty >#< nm
   where nm = "%" >|< name

loadArray :: PP_Doc -> Int -> PtrType -> PP_Doc -> PP_Doc
loadArray name lbl pty idx = "%array." 
                          >|< lbl 
                          >#< "= getelementptr" 
                          >#< ptr pty -- " uint*" 
                          >#< name
                          >|< ", int"
                          >#< idx

-- TODO remove usages of assign
assignment :: Maybe PP_Doc -> Maybe PP_Doc -> PP_Doc -> PP_Doc -> PP_Doc
assignment b1 b2 v e = rndr b1 >|< rndr b2 >|< "store" >#< e 
                      >|< "," >#< "%thunk_type*" >#< v >-< ""
   where rndr b = maybe (text "") (>-< "") b

assign :: Maybe PP_Doc -> Maybe PP_Doc -> PtrType -> PP_Doc -> PP_Doc -> PP_Doc
assign b1 b2 typ v e = rndr b1 
                       >|< rndr b2 
                       >|< "store" 
                       >#< ptr typ
                       >#< e 
                       >|< "," 
                       >#< ptrptr typ 
                       >#< v 
                       >-< ""
   where rndr b = maybe (text "") (>-< "") b
}

--------------------------------------------
--------------------------------------------
--------------------------------------------

{--
getelementptr <pointer-type> <pointer/array variable> , uint <index>

pointer type is either built-in type or requires type declaration
as in:  %ST = type { int, double, %RT }
--}

ATTR SilModule Functions Function Statements Statement Alternatives Alternative
  [ optTraceCall     : {Bool} -- when True, function entrance/exit is logged
    optCaseDefault   : {Bool} -- when True, error messages are given as default case for each switch
  | | ]



{
optTraceAssign = False
}

ATTR SilModule Functions Function Statements Statement Alternatives Alternative Value Variable Constant
         [ | | prettyC USE {>-<} {empty} : PP_Doc ]

ATTR Values [ | | prettyCs : {[PP_Doc]} ]

ATTR Variable [ | | prettyPtr : {PP_Doc}  ]




SEM Statement
  | Comment     lhs.prettyC   = comment @comment
  | Assignment  lhs.prettyC   = assign @source.before
                                       @dest.before
                                       @source.ptrtype
                                       @dest.prettyC
                                       @source.prettyC
  | Switch      lhs.prettyC   = ppSwitch @loc.slbl
                                         @scrutinee.prettyC   -- DONE 
                                         @body.prettyAlt
  | Call        lhs.prettyC   = call @name 
                                     @args.prettyCs
  | Jump        lhs.prettyC   = jump @name
  | Enter       lhs.prettyC   = methodEnter @nLocal @nParam
  | Leave       lhs.prettyC   = methodLeave @diff


SEM Alternative
  | Alternative lhs.prettyC   = text "NOT USED"               -- DONE

SEM Values
  | Nil         lhs.prettyCs  = []                            -- DONE
  | Cons        lhs.prettyCs  = @hd.prettyC : @tl.prettyCs    -- DONE

SEM Value
  | Con         lhs.prettyC   = @con.prettyC                  -- DONE
  | Var         lhs.prettyC   = @var.prettyC                  -- DONE
  | Call        lhs.prettyC   = "%call." >|< show @loc.vlbl   -- DONE (ARG FORMAT NEEDS TYPE) 
  | Alloc       lhs.prettyC   = "%alloc." >|< show @loc.vlbl   -- DONE

SEM Constant
  | Literal     lhs.prettyC   = text $ show @value
  | Alias       lhs.prettyC   = text $ get @name @lhs.constants

SEM Variable
  | Var         lhs.prettyC   = text "%" >|< @name
                lhs.prettyPtr = text "%" >|< @name
  | SP          lhs.prettyC   = text "%SP"
                lhs.prettyPtr = text "%SP"
  | BP          lhs.prettyC   = @loc.var
                lhs.prettyPtr = text "%BP"
  | RP          lhs.prettyC   = text "%RP"
                lhs.prettyPtr = text "%RP"
  | Subs        lhs.prettyC   = @loc.var
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Building a C program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

commaSeparated :: [String] -> String
commaSeparated = concat . intersperse ", "

decrementWith p n
 = incrementWith p (-n)

incrementWith p n
 = if n>0
   then p >#< "+=" >#< n >#< ";"
   else if n<0
   then p >#< "-=" >#< (-n) >#< ";"
   else empty

declareNames :: String -> [String] -> PP_Doc
declareNames tp ns
 = tp >#< commaSeparated ns >|< ";"

declareName :: String -> String -> String
declareName tp nm
 = tp ++ (' ' : nm)

trace :: String -> PP_Doc
trace s
 = text ("printf(\"" ++ s ++ " SP=%d\\n\", SP-Stack); fflush(stdout);")

caseDefault :: PP_Doc -> PP_Doc
caseDefault x
 =  "default: printf(\"undefined case for " >|< x >|< " : %d\\n\", " >|< x >|< "); exit(1);"

comment :: String -> PP_Doc
comment s = "; ----" >#< s >#< "----"

call :: String -> [PP_Doc] -> PP_Doc
call f ps
 = "tail call" >#< "int" >#< f >#< "(" >|< ppHorizontally (intersperse (text ", ") ps) >|< ")"

heapalloc :: Int -> PP_Doc
heapalloc ps
 = "tail call" >#< "%thunk_type*" >#< "heapalloc" >#< "(uint " >|< show ps >|< ")"


--------------------------------------------------------------------------------
-- Semantic functions
--------------------------------------------------------------------------------


constantDefinition :: (String,Int) -> PP_Doc
constantDefinition (x,n) = ";" >#< x >#< "=" >#< show n

variableDeclaration :: String -> PP_Doc
variableDeclaration x
 = "%" >|< text x >#< "= global %thunk_type undef"

methodHead :: String -> [String] -> PP_Doc
methodHead nm params
 =  let parameters = if null params
                      then "void"
                      else commaSeparated (map (declareName "GrWord") params)
    in  "void" >#< nm >|< "(" >|< parameters >|< ")"

methodHeader :: Bool -> String -> [String] -> PP_Doc
methodHeader optTrace nm params
 =  methodHead nm params
    >#< "{"
    >-< ppWhen optTrace (trace ("enter " ++ show nm))

methodFooter ::  Bool -> String -> PP_Doc
methodFooter optTrace nm
 =  ppWhen optTrace (trace ("leave "++show nm))
    >-< text "}"
    >-< text ""

methodLocals :: [String] -> PP_Doc
methodLocals ns
 = ppUnless (null ns)
            (   comment "Local names"
            >-< declareNames "GrWord" ns
            )

jumpPrepare :: PP_Doc
jumpPrepare
 =  pp machDepCForTailcallEnter

jump :: String -> PP_Doc
jump nm
 =  machDepCForTailcallLeave1
    >-< "register void* _tail_call_dest = ((void*)" >|< nm >|< ");"
    >-< machDepCForTailcallLeave2
    >-< "goto *_tail_call_dest;"


methodEnter :: Int -> Int -> PP_Doc
methodEnter nLocal nParam
 = comment "Enter"
   >-< assignment Nothing Nothing (text "%SP") (text "(%BP)") -- cleanup
   >-< assignment Nothing Nothing (text "%BP")  (text "%SP") -- cleanup
   >-< incrementWith (text "%SP") (nLocal+nParam+1)

methodLeave :: Int -> PP_Doc
methodLeave nDiff
 = comment "Leave"
   >-< assignment Nothing Nothing (text "SP")  (text "BP")  -- cleanup
   >-< assignment Nothing Nothing (text "BP") (text "((Pointer)*SP)") -- cleanup
   >-< incrementWith (text "SP") (nDiff)


test1 = SilModule_SilModule [] [] [func]
   where func   = Function_Function "func" False ["p1", "p2"] ["loc"] [swtch]
         swtch  = Statement_Switch (Value_Var (Variable_Var "scr")) [alt1,alt2]
         alt1   = Alternative_Alternative (Constant_Literal 1) [(Statement_Call "fun1" [])]
         alt2   = Alternative_Alternative (Constant_Literal 2) [(Statement_Call "fun2" [arg1, arg2])]
         arg1   = Value_Var (Variable_Var "x")
         arg2   = Value_Con (Constant_Literal 3)
         
get :: String -> [(String, Int)] -> String
get name table = if null res then error msg else show $ head res
   where res = [ b | (a,b) <- table, a == name]
         msg = "constant: " ++ name ++ " not found!"
%%]
