%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.PrettyC} import(Data.List(intersperse), UU.Pretty, EH.Util.PPUtils,{%{GRIN}GRINCCommon},{%{GRIN}Silly}, {%{GRIN}Config}) export(prettyC)
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyC :: Bool -> Bool -> SilModule -> PP_Doc
prettyC optTrace optDef silmod
  = let t = wrap_SilModule (sem_SilModule silmod) ---- TESTING!!! test1) --  
                           (Inh_SilModule { optTraceCall_Inh_SilModule = optTrace
                                          , optCaseDefault_Inh_SilModule = optDef
                                          }
                           )
     in  prettyC_Syn_SilModule t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

{-------------------------------------------------------------------------------
  Notes:

  1. We need to better understand variable and parameter types, since we
     don't have any type information for variables or parameters...
     apparently there is only one type available?
     
  2. Array access needs to be fixed especially for assignment expressions.
     For assignments {a[x] = rhs} we need to generate:
        %array.unique = getelementptr uint* %a , uint %x
        store uint %rhs, uint* %array.unique

  3. We need to inline heap_alloc, switch_trap, ?? function definitions.
  
  4. We need to fix global declarations and the initalization function
  
  Other
    function - not complete 
    jump     - not done
    ...
-------------------------------------------------------------------------------}

--------------------------------------------------------------------------------
-- INTRODUCTION OF UNIQUE LABEL COUNTER
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value
[ | unique : {Int} | ]

SEM SilModule
  | SilModule   functions.unique = 0

SEM Alternative
  | Alternative loc.clbl    = @lhs.unique
                lhs.unique  = @loc.clbl + 1

SEM Statement
  | Switch      lhs.unique  = @loc.slbl + 1
                loc.slbl    = @lhs.unique
SEM Variable
  | Subs        loc.rlbl    = @lhs.unique
                lhs.unique  = @loc.rlbl + 1

--------------------------------------------------------------------------------
-- PROPAGATING CONSTANT SUBSTITUTIONS
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value Constant
[ constants : {[(String,Int)]} | | ]

SEM SilModule
  | SilModule   functions.constants = @constants

--------------------------------------------------------------------------------
-- MODULE GENERATION
--------------------------------------------------------------------------------

SEM SilModule
  | SilModule   lhs.prettyC   = header
                                >-< text ""
                                >-< comment "Constants"
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment "Globals"
                                >-< ppVertically (map variableDeclaration @variables)
                                >-< text ""
                                >-< text ""
                                >-< "implementation"
                                >-< text ""
                                >-< text ""
                                >-< @functions.prettyC

{
header :: PP_Doc
header = comment "LLVM Code Generated From Grin"
         >-< "" >-< ""
         >-< "%thunk_type = type uint"
         >-< "declare void main()"
         >-< "declare void switch_trap()"
         >-< "declare %thunk_type heap_alloc(uint)"
         >-< ""
}

--------------------------------------------------------------------------------
-- FUNCTION DECLARATION GENERATION
--------------------------------------------------------------------------------

SEM Function
  | Function    lhs.prettyC   = prefix >|< params 
                                       >|< ") {" 
                                       >-< body 
                                       >-< postfix
                                   where prefix  = "void %" >|< @name >#< "("
                                         params = commaSeparated (map (declareName "uint*") @parameters)
                                         body    = indent 3 @body.prettyC
                                         postfix = "}" >-< text ""
-- ppWhen @tailJumps jumpPrepare
-- methodLocals @locals

--------------------------------------------------------------------------------
-- SWITCH STATEMENT GENERATION
--------------------------------------------------------------------------------
ATTR Alternative Alternatives [ break : PP_Doc | | prettyAlt : {(PP_Doc, PP_Doc)}]
SEM Alternative
  | Alternative lhs.prettyAlt = (indent 3 tableEntry, targetCode)
                                   where tableEntry = @when.prettyC 
                                                            >|< ", label %" 
                                                            >|< label
                                         label      = "case." >|< show @loc.clbl
                                         targetCode = label >|< ":" 
                                                            >-< indent 3 
                                                            ( @body.prettyC 
                                                              >-< @lhs.break)

SEM Alternatives
  | Nil   lhs.prettyAlt  = (text "", text "")
  | Cons  lhs.prettyAlt  = @hd.prettyAlt `concat` @tl.prettyAlt
                              where concat (a,b) (c,d) = (a >-< c, b >-< d)

SEM Statement
  | Switch   body.break = "br %switch_end." >|< @loc.slbl >|< ":"

{
ppSwitch :: Int -> PP_Doc -> (PP_Doc,PP_Doc) -> PP_Doc
ppSwitch lbl scrutinee alts = "switch int" >#< scrutinee 
                                       >|< ", label %switch_trap." >|< show lbl 
                                       >-< "[" >-< fst alts >|< "]" 
                                       >-< snd alts
                                       >|< "%switch_trap." >|< show lbl >|< ":"
                                       >-< indent 3 (text "call void switch_trap()")
                                       >-< "%switch_end." 
                                       >|< show lbl
                                       >|< ":"
}

--------------------------------------------------------------------------------
-- ARRAY ACCESS GENERATION
--------------------------------------------------------------------------------
ATTR Variable [ | | lineBefore : {Maybe PP_Doc}]

SEM Variable
  | Var         lhs.lineBefore   = Nothing
  | SP          lhs.lineBefore   = Nothing
  | BP          lhs.lineBefore   = Nothing
  | RP          lhs.lineBefore   = Nothing
  | Subs        loc.var          = "%array." >|< show @loc.rlbl
                lhs.lineBefore   = Just (@loc.var  >#< "= getelementptr uint*" 
                                                   >#< @array.prettyPtr
                                                   >|< ","
                                                   >#< @index.prettyC)

{
assignment :: Maybe PP_Doc -> PP_Doc -> PP_Doc -> PP_Doc
assignment Nothing  v e = v >#< "=" >#< e
assignment (Just p) v e = p >-< v >#< "=" >#< e
}

--------------------------------------------
--------------------------------------------
--------------------------------------------

{--
getelementptr <pointer-type> <pointer/array variable> , uint <index>

pointer type is either built-in type or requires type declaration
as in:  %ST = type { int, double, %RT }
--}

ATTR SilModule Functions Function Statements Statement Alternatives Alternative
  [ optTraceCall     : {Bool} -- when True, function entrance/exit is logged
    optCaseDefault   : {Bool} -- when True, error messages are given as default case for each switch
  | | ]



{
optTraceAssign = False
}

ATTR SilModule Functions Function Statements Statement Alternatives Alternative Value Variable Constant
         [ | | prettyC USE {>-<} {empty} : PP_Doc ]

ATTR Values [ | | prettyCs : {[PP_Doc]} ]

ATTR Variable [ | | prettyPtr : {PP_Doc}  ]




SEM Statement
  | Comment     lhs.prettyC   = comment @comment              -- DONE
  | Assignment  lhs.prettyC   = assignment @dest.lineBefore
                                           @dest.prettyC      -- DONE
                                           @source.prettyC
  | Switch      lhs.prettyC   = ppSwitch @loc.slbl
                                         @scrutinee.prettyC   -- DONE (NEED TO DEFINE switch_trap)
                                         @body.prettyAlt
       -- note, switch is not using  @lhs.optCaseDefault 
  | Call        lhs.prettyC   = call @name 
                                     @args.prettyCs
  | Jump        lhs.prettyC   = jump @name
  | Enter       lhs.prettyC   = methodEnter @nLocal @nParam
  | Leave       lhs.prettyC   = methodLeave @diff


SEM Alternative
  | Alternative lhs.prettyC   = text "NOT USED"               -- DONE

SEM Values
  | Nil         lhs.prettyCs  = []                            -- DONE
  | Cons        lhs.prettyCs  = @hd.prettyC : @tl.prettyCs    -- DONE

SEM Value
  | Con         lhs.prettyC   = @con.prettyC                  -- DONE
  | Var         lhs.prettyC   = @var.prettyC                  -- DONE
  | Call        lhs.prettyC   = call @name @args.prettyCs     -- DONE (ARG FORMAT NEEDS TYPE) 
  | Alloc       lhs.prettyC   = "tail call uint %heapalloc"   -- DONE
                                >#< "(uint" 
                                >#< show @size 
                                >|< ")"

SEM Constant
  | Literal     lhs.prettyC   = "int" >#< show @value         -- DONE
  | Alias       lhs.prettyC   = "int" >#< get @name @lhs.constants     -- DONE

SEM Variable
  | Var         lhs.prettyC   = text ("%" ++ @name)           -- DONE
                lhs.prettyPtr = text "(*" >#< text @name      -- DONE (BUT TYPING PROBLEM)
                                          >#< text ")" 
  | SP          lhs.prettyC   = text "%SP"                    -- DONE
                lhs.prettyPtr = text "%SP"                    -- DONE
  | BP          lhs.prettyC   = text "%BP"                    -- DONE
                lhs.prettyPtr = text "%BP"                    -- DONE
  | RP          lhs.prettyC   = text "%RP"                    -- DONE
                lhs.prettyPtr = text "%RP"                    -- DONE
  | Subs        lhs.prettyC   = @loc.var                      -- DONE
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Building a C program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

commaSeparated :: [String] -> String
commaSeparated = concat . intersperse ", "

decrementWith p n
 = incrementWith p (-n)

incrementWith p n
 = if n>0
   then p >#< "+=" >#< n >#< ";"
   else if n<0
   then p >#< "-=" >#< (-n) >#< ";"
   else empty

declareNames :: String -> [String] -> PP_Doc
declareNames tp ns
 = tp >#< commaSeparated ns >|< ";"

declareName :: String -> String -> String
declareName tp nm
 = tp ++ (' ' : nm)

trace :: String -> PP_Doc
trace s
 = text ("printf(\"" ++ s ++ " SP=%d\\n\", SP-Stack); fflush(stdout);")

caseDefault :: PP_Doc -> PP_Doc
caseDefault x
 =  "default: printf(\"undefined case for " >|< x >|< " : %d\\n\", " >|< x >|< "); exit(1);"

comment :: String -> PP_Doc
comment s = "; ----" >#< s >#< "----"

call :: String -> [PP_Doc] -> PP_Doc
call f ps
 = "call" >#< "int" >#< f >#< "(" >|< ppHorizontally (intersperse (text ", ") ps) >|< ")"


--------------------------------------------------------------------------------
-- Semantic functions
--------------------------------------------------------------------------------


constantDefinition :: (String,Int) -> PP_Doc
constantDefinition (x,n) = ";" >#< x >#< "=" >#< show n

variableDeclaration :: String -> PP_Doc
variableDeclaration x
 = "%" >|< text x >#< "= global %thunk_type undef"

methodHead :: String -> [String] -> PP_Doc
methodHead nm params
 =  let parameters = if null params
                      then "void"
                      else commaSeparated (map (declareName "GrWord") params)
    in  "void" >#< nm >|< "(" >|< parameters >|< ")"

methodHeader :: Bool -> String -> [String] -> PP_Doc
methodHeader optTrace nm params
 =  methodHead nm params
    >#< "{"
    >-< ppWhen optTrace (trace ("enter " ++ show nm))

methodFooter ::  Bool -> String -> PP_Doc
methodFooter optTrace nm
 =  ppWhen optTrace (trace ("leave "++show nm))
    >-< text "}"
    >-< text ""

methodLocals :: [String] -> PP_Doc
methodLocals ns
 = ppUnless (null ns)
            (   comment "Local names"
            >-< declareNames "GrWord" ns
            )

jumpPrepare :: PP_Doc
jumpPrepare
 =  pp machDepCForTailcallEnter

jump :: String -> PP_Doc
jump nm
 =  machDepCForTailcallLeave1
    >-< "register void* _tail_call_dest = ((void*)" >|< nm >|< ");"
    >-< machDepCForTailcallLeave2
    >-< "goto *_tail_call_dest;"


methodEnter :: Int -> Int -> PP_Doc
methodEnter nLocal nParam
 = comment "Enter"
   >-< assignment Nothing (text "%SP") (text "(%BP)") -- cleanup
   >-< assignment Nothing (text "%BP")  (text "%SP") -- cleanup
   >-< incrementWith (text "%SP") (nLocal+nParam+1)

methodLeave :: Int -> PP_Doc
methodLeave nDiff
 = comment "Leave"
   >-< assignment Nothing (text "SP")  (text "BP")  -- cleanup
   >-< assignment Nothing (text "BP") (text "((Pointer)*SP)") -- cleanup
   >-< incrementWith (text "SP") (nDiff)


test1 = SilModule_SilModule [] [] [func]
   where func   = Function_Function "func" False ["p1", "p2"] ["loc"] [swtch]
         swtch  = Statement_Switch (Value_Var (Variable_Var "scr")) [alt1,alt2]
         alt1   = Alternative_Alternative (Constant_Literal 1) [(Statement_Call "fun1" [])]
         alt2   = Alternative_Alternative (Constant_Literal 2) [(Statement_Call "fun2" [arg1, arg2])]
         arg1   = Value_Var (Variable_Var "x")
         arg2   = Value_Con (Constant_Literal 3)
         
get :: String -> [(String, Int)] -> String
get name table = if null res then error msg else show $ head res
   where res = [ b | (a,b) <- table, a == name]
         msg = "constant: " ++ name ++ " not found!"
%%]
