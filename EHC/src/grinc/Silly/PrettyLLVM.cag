%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.PrettyLLVM} import(Data.List(intersperse), Char, Data.Maybe, Data.List, Debug.Trace, UU.Pretty, EH.Util.PPUtils,{%{GRIN}GRINCCommon},{%{GRIN}Silly}, {%{GRIN}Config}) export(prettyLL)
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyLL :: Bool -> Bool -> SilModule -> PP_Doc
prettyLL optTrace optDef silmod
  = let t = wrap_SilModule (sem_SilModule silmod) --  $ traceit silmod) ---- TESTING!!! 
                           (Inh_SilModule { }
                           )
     in  code_Syn_SilModule t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

ATTR SilModule Functions Function 
     Statements Statement Alternatives 
     Alternative Value Variable Constant
     
     [ | | code USE {>-<} {empty} : PP_Doc ]

ATTR Values [ | | codes : {[PP_Doc]} ]

--------------------------------------------------------------------------------
-- MODULE GENERATION
--------------------------------------------------------------------------------

SEM SilModule
  | SilModule   lhs.code  = header
                                >-< text ""
                                >-< comment "Constants"
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment "Globals"
                                >-< ppVertically (map variableDeclaration @variables)
                                >-< text ""
                                >-< text ""
                                >-< "implementation"
                                >-< text ""
                                >-< text ""
                                >-< @functions.code

{
header :: PP_Doc
header = comment "LLVM Code Generated From Grin"
         >-< ""
         >-< comment "Platform Constants"
         >-< "target pointersize = 32"
         >-< "deplibs = [ \"c\" ]"
         >-< ""
         >-< comment "Runtime Library Functions"
         >-< "%thunk_type = type uint"
         >-< "declare void %main()"
         >-< "declare void %switch_trap()"
         >-< "declare %thunk_type* %heapalloc( uint )"
         >-< ""
         >-< comment "Runtime Library Constant Variables"
         >-< "%Heap       = external global %thunk_type*"
         >-< "%Stack      = external global %thunk_type*"
         >-< "%ReturnArea = external global %thunk_type*"
         >-< "%HeapLimit  = external global %thunk_type*"
         >-< ""
         >-< comment "Runtime Library Pointers"
         >-< "%HP = external global %thunk_type*"
         >-< "%SP = external global %thunk_type*"
         >-< "%RP = external global %thunk_type*"
         >-< "%BP = external global %thunk_type*"
         >-< ""

constantDefinition :: (String,Int) -> PP_Doc
constantDefinition (x,n) = ";" >#< x >#< "=" >#< show n

variableDeclaration :: String -> PP_Doc
variableDeclaration x = "%" >|< text x >#< "= global %thunk_type undef"
}

--------------------------------------------------------------------------------
-- FUNCTION DECLARATION GENERATION
--------------------------------------------------------------------------------
SEM Function
  | Function    lhs.code   = prefix >-< indent 3 @body.code
                                    >-< indent 3 (text "ret void")
                                    >-< postfix
                                   where prefix  = "void %" >|< @name >#< "() {"
                                         postfix = "}" >-< text ""

--------------------------------------------------------------------------------
-- PROPOGATION OF INFORMATION WITHIN FUNCTION
--------------------------------------------------------------------------------
ATTR Statements Statement  
     Alternatives Alternative 
     Variables Variable 
     Values Value
     [ islocal : {String -> Bool} | subs : {[(String,String)]} uniq : {Int} | ]

SEM Function
  | Function    body.islocal  = (\x -> x `elem` @locals)
                body.subs     = []
                body.uniq     = 0

                
--------------------------------------------------------------------------------
-- PROPAGATING CONSTANT SUBSTITUTIONS
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value Constant
[ constants : {[(String,Int)]} | | ]

SEM SilModule
  | SilModule   functions.constants = @constants


--------------------------------------------------------------------------------
-- Function Entry / Exit
--------------------------------------------------------------------------------
{
enter :: Int -> Int -> PP_Doc
enter i j = undefined

exit :: Int -> PP_Doc
exit i =  undefined
}


--------------------------------------------------------------------------------
-- Utility Functions
--------------------------------------------------------------------------------

{
comment :: String -> PP_Doc
comment s = "; ----" >#< s >#< "----"

get :: String -> [(String, Int)] -> Int
get name table = if null res then error msg else head res
   where res = [ b | (a,b) <- table, a == name]
         msg = "constant: " ++ name ++ " not found!"

p :: Show a => a -> PP_Doc
p x = text $ show x
}
--------------------------------------------------------------------------------
-- Testing
--------------------------------------------------------------------------------
{
traceit :: Show a => a -> a
traceit x = trace (show x) x

traceloud :: Show a => String -> a -> a
traceloud s x = trace (s ++ show x) x
}
{-
test1 = SilModule_SilModule [] [] [func]
   where func   = Function_Function "func" False ["p1", "p2"] ["loc"] [swtch]
         swtch  = Statement_Switch (Value_Var (Variable_Var "scr")) [alt1,alt2]
         alt1   = Alternative_Alternative (Constant_Literal 1) [(Statement_Call "fun1" [])]
         alt2   = Alternative_Alternative (Constant_Literal 2) [(Statement_Call "fun2" [arg1, arg2])]
         arg1   = Value_Var (Variable_Var "x")
         arg2   = Value_Con (Constant_Literal 3)
-}

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

ATTR Variable Value [ | | resultName : {String} ]



SEM Statement
  | Comment     lhs.code   = comment @comment

  | Assignment  lhs.code   = ";------------------------------------------------------"
                             >-< (";" >#< @dest.descr >#< "=" >#< @source.descr >|< @sbs)
                             >-< ";------------------------------------------------------"
                             >-< @source.code 
                             >-< @dest.code 
                             >-< if @dest.local
                                 then if @doCast
                                      then cast @dest.resultName @source.ty 
                                                @source.resultName @dest.ty    
                                      else comment $ "aliasing: " 
                                                  ++ @dest.resultName 
                                                  ++ " = "
                                                  ++ @source.resultName -- add to subs 
                                 else (if @doCast
                                       then cast @storee 
                                                 @source.ty 
                                                 @source.resultName 
                                                 @storety
                                       else empty
                                      )
                                      >-< store @storee @storety @dest.resultName
                loc.doCast = if @dest.local
                             then @dest.ty /= @source.ty
                             else not $ isPtrTypeOf @dest.ty @source.ty
                loc.storee = if @doCast 
                             then "cast." ++ show @uniq
                             else @source.resultName
                loc.storety = deref @dest.ty

                loc.uniq    = @lhs.uniq
                dest.uniq   = @uniq + 1
                source.uniq = @dest.uniq
                lhs.uniq    = @source.uniq
                
                lhs.subs    = if @dest.local && not @doCast
                              then (@dest.resultName, @source.resultName) : @lhs.subs
                              else @lhs.subs
                loc.sbs    = "   " >|< showSubs (@dest.asubs ++ @source.asubs)
  | Switch      lhs.code   = text "SWITCH"
  | Call        lhs.code   = text "CALL"
  | Jump        lhs.code   = text "JUMP"
  | Enter       lhs.code   = text "ENTER"
  | Leave       lhs.code   = text "LEAVE"


SEM Alternative
  | Alternative lhs.code   = text "ALT"

SEM Values
  | Nil         lhs.codes  = []
  | Cons        lhs.codes  = @hd.code : @tl.codes

SEM Value
  | Con         lhs.code       = empty
                lhs.resultName = show @con.code
  | Var         lhs.code       = @var.code
                lhs.resultName = @var.resultName
  | Call        lhs.code       = text "CALL"
                lhs.resultName = "CALL-RESULT-NAME"
  | Alloc       lhs.code       = "%" >|< @result >#< "=" >#< heapalloc @size
                lhs.resultName = @result
                loc.result     = "alloc." ++ show @uniq
                loc.uniq       = @lhs.uniq
                lhs.uniq       = @uniq + 1



ATTR Constant [ | | value : {Int} ]
SEM Constant
  | Literal     lhs.code   = text $ show @value
                lhs.value  = @value
  | Alias       lhs.code   = "" >|< get @name @lhs.constants
                lhs.value  = @val
                loc.val    = get @name @lhs.constants
                lhs.asubs  = [(@name, show @val)]

SEM Variable
  | Var         lhs.code   = if @lhs.islocal @name
                             then empty -- creates substitution at assign
                             else if isLHS @lhs.side
                                  then empty
                                  else load @name @uniq @ty
                loc.uniq   = @lhs.uniq
                lhs.uniq   = @loc.uniq + 1
                lhs.resultName = if @lhs.islocal @name || isLHS @lhs.side
                                 then @name'
                                 else @name' ++ show @loc.uniq
                loc.name'      = maybe @name id $ lookup @name @lhs.subs
                lhs.asubs      = if @name == @name'
                                 then []
                                 else [(@name,@name')]
  | SP          lhs.code       = load "SP" @uniq @ty
                lhs.resultName = "SP." ++ show @uniq
                loc.uniq       = @lhs.uniq
                lhs.uniq       = @loc.uniq + 1
  | BP          lhs.code       = load "BP" @uniq @ty
                lhs.resultName = "BP." ++ show @uniq
                loc.uniq       = @lhs.uniq
                lhs.uniq       = @loc.uniq + 1
  | RP          lhs.code       = load "RP" @uniq @ty
                lhs.resultName = "RP." ++ show @uniq
                loc.uniq       = @lhs.uniq
                lhs.uniq       = @loc.uniq + 1
  | Subs        lhs.code       = @array.code
                                 >-<
                                 (if @array.ty /= ThunkPtr
                                  then (cast ("cast." ++ show @uniq) 
                                            @array.ty 
                                            @array.resultName 
                                            ThunkPtr
                                        >-< ptrAdd @arithName 
                                                   ("cast." ++ show @uniq)
                                                   ThunkPtr
                                                   @index.value
                                       )
                                  else ptrAdd @arithName 
                                              @array.resultName
                                              ThunkPtr
                                              @index.value                
                                 )
                                 >-<
                                 (if isLHS @lhs.side 
                                  then empty
                                  else load @arithName (@uniq + 1) ThunkPtr
                                 )
                loc.arithName  = "subs." ++ show (@uniq + 1)
                lhs.resultName = if isLHS @lhs.side
                                  then @arithName
                                  else @arithName ++ "." ++ (show $ @uniq + 1)
                loc.uniq       = @lhs.uniq
                array.uniq     = @uniq + 2
                lhs.uniq       = @array.uniq


--------------------------------------------------------------------------------
-- LHS/RHS ROLE	FOR VARIABLES
--------------------------------------------------------------------------------
{
data Side = LHS | RHS

isLHS :: Side -> Bool
isLHS LHS = True
isLHS _   = False

isRHS :: Side -> Bool
isRHS RHS = True
isRHS _   = False

}

ATTR Variables Variable [ side : {Side} | | ]

SEM Statement
  |  Assignment  dest.side   = LHS
SEM Variable
  |  Subs        array.side  = RHS
SEM Value
  | Var          var.side    = RHS
  

--------------------------------------------------------------------------------
-- VARIABLE/VALUE POINTER TYPES
--------------------------------------------------------------------------------
{
data PtrType = Thunk | ThunkPtr | ThunkPtrPtr deriving (Show,Eq,Enum)

ptr :: PtrType -> PP_Doc
ptr Thunk          = text "%thunk_type"
ptr ThunkPtr       = text "%thunk_type*"
ptr ThunkPtrPtr    = text "%thunk_type**"

deref :: PtrType -> PtrType
deref p = pred p

ptrOf :: PtrType -> PtrType
ptrOf p = succ p

ptrptr :: PtrType -> PP_Doc
ptrptr p = ptr p >|< "*"

isPtrTypeOf :: PtrType -> PtrType -> Bool
isPtrTypeOf ptr val = succ val == ptr
}

ATTR Variable Value [ | | ty : {PtrType}]
ATTR Variable [ | | local : {Bool}]

SEM Variable
  | Var         loc.ty    = if @lhs.islocal @name 
                            then Thunk 
                            else if isLHS @lhs.side
                                 then ThunkPtr
                                 else Thunk
                lhs.ty    = @loc.ty
                lhs.local = @lhs.islocal @name
  | SP          loc.ty    = if isLHS @lhs.side 
                            then ThunkPtrPtr
                            else ThunkPtr
                lhs.ty    = @loc.ty
                lhs.local = False
  | BP          loc.ty    = if isLHS @lhs.side 
                            then ThunkPtrPtr
                            else ThunkPtr
                lhs.ty    = @loc.ty
                lhs.local = False
  | RP          loc.ty    = if isLHS @lhs.side 
                            then ThunkPtrPtr
                            else ThunkPtr
                lhs.ty    = @loc.ty
                lhs.local = False
  | Subs        loc.ty    = if isLHS @lhs.side
                            then ThunkPtr
                            else Thunk -- result of array access is always a thunk
                lhs.ty    = @loc.ty
                lhs.local = False

SEM Value
  | Con         loc.ty  = Thunk
                lhs.ty  = @loc.ty
  | Var         loc.ty  = @var.ty
                lhs.ty  = @loc.ty
  | Alloc       loc.ty  = ThunkPtr
                lhs.ty  = @loc.ty
  | Call        loc.ty  = undefined -- calls never occur on rhs
                lhs.ty  = @loc.ty


--------------------------------------------------------------------------------
-- COMMENTING CODE
--------------------------------------------------------------------------------

ATTR Variable Value Constant [ | | descr : {PP_Doc} asubs : {[(String,String)]} ]

SEM Variable
  |  Var    lhs.descr = text @name
  |  Subs   lhs.descr = @array.descr >|< "[" >|< @index.descr >|< "]"
            lhs.asubs = @array.asubs
  |  SP     lhs.descr = text "SP"
            lhs.asubs = []
  |  BP     lhs.descr = text "BP"
            lhs.asubs = []
  |  RP     lhs.descr = text "RP"
            lhs.asubs = []

SEM Value
  | Con     lhs.descr = @con.descr
            lhs.asubs = []
  | Var     lhs.descr = @var.descr
  | Alloc   lhs.descr = "heapalloc(" >|< @size >|< ")"
            lhs.asubs = []
  | Call    lhs.descr = @name >|< "()"
            lhs.asubs = []

SEM Constant
  | Literal lhs.descr = "" >|< @value
            lhs.asubs = []
  | Alias   lhs.descr = text @name

--------------------------------------------------------------------------------
-- LL Primitives
--------------------------------------------------------------------------------

{
call :: String -> PP_Doc
call f = "tail call" >#< "void" >#< pct f >#< "()" 

ptrAdd :: String -> String -> PtrType -> Int -> PP_Doc
ptrAdd l r ty i = pct l >#< "= getelementptr" 
                        >#< ptr ty >#< pct r 
                        >|< ", int" >#< i

load :: String -> Int -> PtrType -> PP_Doc
load nm i p = pct nm >|< "." >|< i >#< "= load" >#< ptr p >#< pct nm

store :: String -> PtrType -> String -> PP_Doc
store val ty adr = "store" >#< ptr ty >#< pct val 
                           >|< "," >#< ptrptr ty >#< pct adr

cast :: String -> PtrType -> String -> PtrType -> PP_Doc
cast lhs ty var ty' = pct lhs >#< "= cast" 
                              >#< ptr ty >#< pct var 
                              >#< "to" >#< ptr ty'

heapalloc :: Int -> PP_Doc
heapalloc ps = "tail call %thunk_type*" 
               >#< "%heapalloc (uint " 
               >|< ps 
               >|< ")"

pct :: String -> String
pct s = if isNumber s then s else "%" ++ s
   where isNumber s = foldr (&&) True $ map isDigit s

showSubs :: [(String,String)] -> String
showSubs []  = ""
showSubs xs  = "substitutions: " ++ show xs'
   where xs' = map (\(a,b) -> a ++ " -> " ++ b) xs
}

%%]
