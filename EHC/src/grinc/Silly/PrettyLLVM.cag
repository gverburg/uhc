%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.PrettyLLVM} import(Data.List(intersperse), Data.List, Debug.Trace, UU.Pretty, EH.Util.PPUtils,{%{GRIN}GRINCCommon},{%{GRIN}Silly}, {%{GRIN}Config}) export(prettyLL)
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyLL :: Bool -> Bool -> SilModule -> PP_Doc
prettyLL optTrace optDef silmod
  = let t = wrap_SilModule (sem_SilModule silmod) --  $ traceit silmod) ---- TESTING!!! 
                           (Inh_SilModule { optTraceCall_Inh_SilModule = optTrace
                                          , optCaseDefault_Inh_SilModule = optDef
                                          }
                           )
     in  prettyLL_Syn_SilModule t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

--------------------------------------------------------------------------------
-- INTRODUCTION OF UNIQUE LABEL COUNTER
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value
[ | unique : {Int} | self : SELF ]

SEM SilModule
  | SilModule   functions.unique = 0

SEM Alternative
  | Alternative loc.clbl    = @lhs.unique
                lhs.unique  = @loc.clbl + 1

SEM Statement
  | Switch      lhs.unique  = @loc.slbl + 1
                loc.slbl    = @lhs.unique
SEM Variable
  | Subs        loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | SP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | RP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | BP          loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1

SEM Value
  | Con         loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Var         loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Alloc       loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
  | Call        loc.vlbl    = @lhs.unique
                lhs.unique  = @loc.vlbl + 1
                
--------------------------------------------------------------------------------
-- PROPAGATING CONSTANT SUBSTITUTIONS
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value Constant
[ constants : {[(String,Int)]} | | ]

SEM SilModule
  | SilModule   functions.constants = @constants

--------------------------------------------------------------------------------
-- VARIABLE/VALUE POINTER TYPES
--------------------------------------------------------------------------------
{
data PtrType = Thunk | ThunkPtr | ThunkPtrPtr

ptr :: PtrType -> PP_Doc
ptr Thunk          = text "%thunk_type"
ptr ThunkPtr       = text "%thunk_type*"
ptr ThunkPtrPtr    = text "%thunk_type**"

ptrptr :: PtrType -> PP_Doc
ptrptr p = ptr p >|< "*"

}

ATTR Variable Value [ | | ptrtype : {PtrType}]

SEM Variable
  | Var         loc.ptrtype  = Thunk
                lhs.ptrtype  = @loc.ptrtype
  | SP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | BP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | RP          loc.ptrtype  = ThunkPtrPtr
                lhs.ptrtype  = @loc.ptrtype
  | Subs        loc.ptrtype  = ThunkPtr      -- We only array-access global vars
                lhs.ptrtype  = @loc.ptrtype

SEM Value
  | Con         loc.ptrtype  = Thunk
                lhs.ptrtype  = @loc.ptrtype
  | Var         loc.ptrtype  = ThunkPtr
                lhs.ptrtype  = @loc.ptrtype
  | Alloc       loc.ptrtype  = ThunkPtr
                lhs.ptrtype  = @loc.ptrtype
  | Call        loc.ptrtype  = ThunkPtr ----- NOT SURE ABOUT THIS EITHER
                lhs.ptrtype  = @loc.ptrtype


--------------------------------------------------------------------------------
-- MODULE GENERATION
--------------------------------------------------------------------------------

SEM SilModule
  | SilModule   lhs.prettyLL  = header
                                >-< text ""
                                >-< comment "Constants"
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment "Globals"
                                >-< ppVertically (map variableDeclaration @variables)
                                >-< text ""
                                >-< text ""
                                >-< "implementation"
                                >-< text ""
                                >-< text ""
                                >-< @functions.prettyLL

{
header :: PP_Doc
header = comment "LLVM Code Generated From Grin"
         >-< ""
         >-< comment "Platform Constants"
         >-< "target endian = little"
         >-< "target pointersize = 32"
         >-< "target triple = \"i686-pc-linux-gnu\""
         >-< "deplibs = [ \"c\" ]"
         >-< ""
         >-< comment "Runtime Library Functions"
         >-< "%thunk_type = type uint"
         >-< "declare void %main()"
         >-< "declare void %switch_trap()"
         >-< "declare %thunk_type* %heapalloc( uint )"
         >-< ""
         >-< comment "Runtime Library Constant Variables"
         >-< "%Heap       = external global %thunk_type*"
         >-< "%Stack      = external global %thunk_type*"
         >-< "%ReturnArea = external global %thunk_type*"
         >-< "%HeapLimit  = external global %thunk_type*"
         >-< ""
         >-< comment "Runtime Library Pointers"
         >-< "%HP = external global %thunk_type*"
         >-< "%SP = external global %thunk_type*"
         >-< "%RP = external global %thunk_type*"
         >-< "%BP = external global %thunk_type*"
         >-< ""

constantDefinition :: (String,Int) -> PP_Doc
constantDefinition (x,n) = ";" >#< x >#< "=" >#< show n

variableDeclaration :: String -> PP_Doc
variableDeclaration x = "%" >|< text x >#< "= global %thunk_type* undef"
}

--------------------------------------------------------------------------------
-- FUNCTION DECLARATION GENERATION
--------------------------------------------------------------------------------

SEM Function
  | Function    lhs.prettyLL   = prefix >-< indent 3 params
                                        >-< indent 3 body
                                        >-< postfix
                                   where prefix  = "void %" >|< @name >#< "() {"
                                         params = if builtin @name
                                                    then params0 
                                                    else params1
                                         params0  = text ""
                                         params1  = mkParams @loc.unique (tail @locals)
                                         body    = @body.prettyLL >-< "ret void"
                                         postfix = "}" >-< text ""
                loc.unique     = @lhs.unique
                body.unique    = @loc.unique + length @parameters
                lhs.unique     = @body.unique

{
mkParams :: Int -> [String] -> PP_Doc
mkParams base names = foldr (>-<) empty ps'
  where ps  = zipWith mkParam [0..] names
        ps' = zipWith ($) ps [base..]

mkParam :: Int -> String -> Int -> PP_Doc
mkParam pi nm ai = loadArray False (text nm) ai ThunkPtr (text (show $ 0 - 1- pi))

-- KLUGE!!
builtin :: String -> Bool
builtin nm = nm `elem` ["fun_main", "initialize"]
}

-- ppWhen @tailJumps jumpPrepare


--------------------------------------------------------------------------------
-- PARAMETER POSITION WITHIN STACK
--------------------------------------------------------------------------------

ATTR Statements Statement Variables Variable 
     Values Value Alternatives Alternative [ stack : {[String]} | | ] 

SEM Function 
  | Function   body.stack = @parameters


  
{
stackPosition :: String -> [String] -> Int
stackPosition v vs = convert $ elemIndex v vs
   where convert = maybe (error $ "variable not on stack: " ++ v) (0-)
}

--------------------------------------------------------------------------------
-- SWITCH STATEMENT GENERATION
--------------------------------------------------------------------------------
ATTR Alternative Alternatives [ break : PP_Doc | | prettyAlt : {(PP_Doc, PP_Doc)}]
SEM Alternative
  | Alternative lhs.prettyAlt = (indent 3 tableEntry, targetCode)
                                   where tableEntry = @when.prettyLL 
                                                            >|< ", label %" 
                                                            >|< label
                                         label      = "case." >|< show @loc.clbl
                                         targetCode = label >|< ":" 
                                                            >-< indent 3 
                                                            ( @body.prettyLL 
                                                              >-< @lhs.break)

SEM Alternatives
  | Nil   lhs.prettyAlt  = (text "", text "")
  | Cons  lhs.prettyAlt  = @hd.prettyAlt `concat` @tl.prettyAlt
                              where concat (a,b) (c,d) = (a >-< c, b >-< d)

SEM Statement
  | Switch   body.break = "br %switch_end." >|< @loc.slbl >|< ":"

{
ppSwitch :: Int -> PP_Doc -> (PP_Doc,PP_Doc) -> PP_Doc
ppSwitch lbl scrutinee alts = "switch int" >#< scrutinee 
                                       >|< ", label %switch_trap." >|< show lbl 
                                       >-< "[" >-< fst alts >|< "]" 
                                       >-< snd alts
                                       >|< "%switch_trap." >|< show lbl >|< ":"
                                       >-< indent 3 (text "call void switch_trap()")
                                       >-< "%switch_end." 
                                       >|< show lbl
                                       >|< ":"
}

--------------------------------------------------------------------------------
-- LOAD AND STORE OF VALUES
--------------------------------------------------------------------------------
ATTR Constant [ | | self : SELF]


ATTR Variable Value [ | | before : {Maybe PP_Doc}]


----***********************************************************************----
SEM Variable
  | Var         lhs.before  = Nothing
  | SP          loc.var     = "%SP." >|< show @loc.vlbl
                lhs.before  = Just $ load "SP" @loc.vlbl @loc.ptrtype
  | BP          loc.var     = "%BP." >|< show @loc.vlbl
                lhs.before  = Just $ load "BP" @loc.vlbl @loc.ptrtype
  | RP          loc.var     = "%RP." >|< show @loc.vlbl
                lhs.before  = Just $ load "RP" @loc.vlbl @loc.ptrtype
  | Subs        loc.var     = "%array." >|< show @loc.vlbl
                lhs.before  = Just $ loadArray (isZero @index.self)
                                               @array.prettyLL 
                                               @loc.vlbl 
                                               @loc.ptrtype
                                               @index.prettyLL

SEM Value
  | Con         lhs.before = Nothing
  | Var         lhs.before = Nothing
  | Alloc       lhs.before = Just $ "%alloc.">|< show @loc.vlbl 
                                                 >#< "="
                                                 >#< heapalloc @size

  | Call        lhs.before = Just $ "%call." >|< show @loc.vlbl 
                                             >#< "="
                                             >#< call @name @args.prettyLLs


{
loadArray :: Bool -> PP_Doc -> Int -> PtrType -> PP_Doc -> PP_Doc
loadArray zero name lbl pty idx = if zero then deref else deref >-< arith
   where var    = "%array." >|< lbl
         tmp    = var >|< ".tmp"
         arith  = ptrAdd' tmp var pty idx
         deref = var >#< "= load" >#< ptrptr pty >#< name



isZero :: Constant -> Bool                         
isZero (Constant_Literal 0) = True
isZero _           = False

heapalloc :: Int -> PP_Doc
heapalloc ps =  "tail call" 
            >#< "%thunk_type*" 
            >#< "%heapalloc" 
            >#< "(uint " 
            >|< show ps 
            >|< ")"

assign :: Maybe PP_Doc -> Maybe PP_Doc -> PtrType -> PP_Doc -> PP_Doc -> PP_Doc
assign b1 b2 typ v e = rndr b1 >|< rndr b2 >|< (store' e typ v) >-< ""
   where rndr b = maybe (text "") (>-< "") b

--------------------------------------------------------------------------------
-- Function Entry / Exit
--------------------------------------------------------------------------------
enter :: Int -> Int -> PP_Doc
enter i j =  comment "Function Entry"
         >-< "; store current BasePointer value on Stack"
         >-< load' (text "BP") (text "deref") ThunkPtrPtr
         >-< load' (text "SP") (text "deref") ThunkPtrPtr
         >-< cast "%BP.cast" ThunkPtr "%BP.deref" Thunk -- Why not: ThunkPtrPtr ThunkPtr
         >-< store "%BP.cast" Thunk "%SP.deref"
         >-< ""
         >-< "; Set BasePointer equal to StackPointer"
         >-< store "%SP.deref" ThunkPtr "%BP" 
         >-< ""
         >-< "; increment StackPointer"
         >-< ptrAdd "%SP.incr" "%SP.deref" ThunkPtr (i+1)
         >-< store "%SP.incr" ThunkPtr "%SP"
         >-< ""
         >-< ""

exit :: Int -> PP_Doc
exit i =  comment "Function Exit (TODO)"
      >-< "; restore StackPointer and BasePointer"
      >-< store "%SP.deref" ThunkPtr "%SP"
      >-< cast "%BP.recast" Thunk "%BP.cast" ThunkPtr
      >-< store "%BP.recast" ThunkPtr "%BP"
      >-< ""     ------ TODO: increment SP (see C code below) ?

{--
methodLeave :: Int -> PP_Doc
methodLeave nDiff
 = comment "Leave"
   >-< assignment Nothing Nothing (text "SP")  (text "BP")  -- cleanup
   >-< assignment Nothing Nothing (text "BP") (text "((Pointer)*SP)") -- cleanup
   >-< incrementBy (text "SP") (nDiff)
--}

}

--------------------------------------------
--------------------------------------------
--------------------------------------------


ATTR SilModule Functions Function Statements Statement Alternatives Alternative
  [ optTraceCall     : {Bool} -- when True, function entrance/exit is logged
    optCaseDefault   : {Bool} -- when True, error messages are given as default case for each switch
  | | ]


ATTR SilModule Functions Function Statements Statement Alternatives Alternative Value Variable Constant
         [ | | prettyLL USE {>-<} {empty} : PP_Doc ]

ATTR Values [ | | prettyLLs : {[PP_Doc]} ]

ATTR Variable [ | | prettyPtr : {PP_Doc}  ]




SEM Statement
  | Comment     lhs.prettyLL   = comment @comment
  | Assignment  lhs.prettyLL   = assign @source.before
                                       @dest.before
                                       @source.ptrtype
                                       @dest.prettyLL
                                       @source.prettyLL
  | Switch      lhs.prettyLL   = ppSwitch @loc.slbl
                                         @scrutinee.prettyLL
                                         @body.prettyAlt
  | Call        lhs.prettyLL   = call @name 
                                     @args.prettyLLs
  | Jump        lhs.prettyLL   = jump @name
  | Enter       lhs.prettyLL   = enter @nLocal @nParam
  | Leave       lhs.prettyLL   = exit @diff


SEM Alternative
  | Alternative lhs.prettyLL   = text "NOT USED"

SEM Values
  | Nil         lhs.prettyLLs  = []
  | Cons        lhs.prettyLLs  = @hd.prettyLL : @tl.prettyLLs

SEM Value
  | Con         lhs.prettyLL   = @con.prettyLL
  | Var         lhs.prettyLL   = @var.prettyLL
  | Call        lhs.prettyLL   = "%call." >|< show @loc.vlbl   -- DONE (ARG FORMAT NEEDS TYPE) 
  | Alloc       lhs.prettyLL   = "%alloc." >|< show @loc.vlbl

SEM Constant
  | Literal     lhs.prettyLL   = text $ show @value
  | Alias       lhs.prettyLL   = text $ get @name @lhs.constants

SEM Variable
  | Var         lhs.prettyLL   = text "%" >|< @name
                lhs.prettyPtr = text "%" >|< @name
  | SP          lhs.prettyLL   = text "%SP"
                lhs.prettyPtr = text "%SP"
  | BP          lhs.prettyLL   = @loc.var
                lhs.prettyPtr = text "%BP"
  | RP          lhs.prettyLL   = text "%RP"
                lhs.prettyPtr = text "%RP"
  | Subs        lhs.prettyLL   = @loc.var >|< (if (isZero @index.self) then "" else ".tmp")
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Building a C program
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

commaSeparated :: [String] -> String
commaSeparated = concat . intersperse ", "

declareNames :: String -> [String] -> PP_Doc
declareNames tp ns
 = tp >#< commaSeparated ns >|< ";"

declareName :: String -> String -> String
declareName tp nm
 = tp ++ (' ' : nm)

comment :: String -> PP_Doc
comment s = "; ----" >#< s >#< "----"

call :: String -> [PP_Doc] -> PP_Doc
call f ps
 = "tail call" >#< "int" >#< f >#< "(" >|< ppHorizontally (intersperse (text ", ") ps) >|< ")"


jumpPrepare :: PP_Doc
jumpPrepare
 =  pp machDepCForTailcallEnter

jump :: String -> PP_Doc
jump nm
 =  machDepCForTailcallLeave1
    >-< "register void* _tail_call_dest = ((void*)" >|< nm >|< ");"
    >-< machDepCForTailcallLeave2
    >-< "goto *_tail_call_dest;"

--------------------------------------------------------------------------------
-- LL Primitives
--------------------------------------------------------------------------------

ptrAdd :: String -> String -> PtrType -> Int -> PP_Doc
ptrAdd l r ty i = ptrAdd' (text l) (text r) ty (text $ show i)

ptrAdd' :: PP_Doc -> PP_Doc -> PtrType -> PP_Doc -> PP_Doc
ptrAdd' l r ty i = l >#< "= getelementptr" >#< ptr ty >#< r >|< ", int" >#< i

load :: String -> Int -> PtrType -> PP_Doc
load nm i p = load' (text nm) (text $ show i) p

load' :: PP_Doc -> PP_Doc -> PtrType -> PP_Doc
load' nm i p = "%" >|< nm >|< "." >|< i >#< "= load" >#< ptr p >#< "%" >|< nm

store :: String -> PtrType -> String -> PP_Doc
store val ty adr = store' (text val) ty (text adr)

store' :: PP_Doc -> PtrType -> PP_Doc -> PP_Doc
store' val ty adr = "store" >#< ptr ty >#< val >|< "," >#< ptrptr ty >#< adr

cast :: String -> PtrType -> String -> PtrType -> PP_Doc
cast lhs ty var ty' = lhs >#< "= cast" >#< ptr ty >#< var >#< "to" >#< ptr ty'

--------------------------------------------------------------------------------
-- Utility Functions
--------------------------------------------------------------------------------

get :: String -> [(String, Int)] -> String
get name table = if null res then error msg else show $ head res
   where res = [ b | (a,b) <- table, a == name]
         msg = "constant: " ++ name ++ " not found!"

p :: Show a => a -> PP_Doc
p x = text $ show x

--------------------------------------------------------------------------------
-- Testing
--------------------------------------------------------------------------------

traceit :: Show a => a -> a
traceit x = trace (show x) x

test1 = SilModule_SilModule [] [] [func]
   where func   = Function_Function "func" False ["p1", "p2"] ["loc"] [swtch]
         swtch  = Statement_Switch (Value_Var (Variable_Var "scr")) [alt1,alt2]
         alt1   = Alternative_Alternative (Constant_Literal 1) [(Statement_Call "fun1" [])]
         alt2   = Alternative_Alternative (Constant_Literal 2) [(Statement_Call "fun2" [arg1, arg2])]
         arg1   = Value_Var (Variable_Var "x")
         arg2   = Value_Con (Constant_Literal 3)
         
%%]
