% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Substituting holes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs import(Maybe,FiniteMap,UU.Pretty,EHCommon,EHTy,EHCore,EHCnstr,EHCorePretty) export(CSubstitutable(..),cAppCoeArg)
%%]

%%[9 hs export(CSubst,emptyCSubst,uidCBindLLToCSubst,uidCExprLToCSubst,poiCExprLToCSubst,cnstrImplsToCSubst)
%%]

%%[9 hs export(coeWipeWeave,coeEvalOn,coeCompose,mkImplsAppCoe, mkImplsLamCoe,mkLamBodyCoe,mkPoiLLamCoe)
%%]

%%[9.WRAPPER import(EHCoreAbsSyn)
WRAPPER CExpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code substitution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
data CSubstInfo
	=  CSIExpr      {csiRepl    ::  CExpr                                           }
    |  CSIImpls     {csiAppCoeL ::  [Coe]       , csiLamCoeL    ::  [Coe]           }
    |  CSIBinds     {csiBindL   ::  CBindL                                          }
    deriving Show

type CSubst = FiniteMap UID CSubstInfo

emptyCSubst :: CSubst
emptyCSubst = emptyFM

cAppCoeArg :: CExpr -> CExpr -> CExpr
cAppCoeArg ce coeArg
  =  let  t = wrap_CExpr (sem_CExpr ce) (Inh_CExpr {cSubst_Inh_CExpr = emptyCSubst, coeArg_Inh_CExpr = coeArg})
     in   (cRepl_Syn_CExpr t)

uidCExprLToCSubst :: AssocL UID CExpr -> CSubst
uidCExprLToCSubst = listToFM . assocLMapElt CSIExpr

uidCBindLLToCSubst :: AssocL UID CBindL -> CSubst
uidCBindLLToCSubst = listToFM . assocLMapElt CSIBinds

poiCExprLToCSubst :: AssocL PredOccId CExpr -> CSubst
poiCExprLToCSubst = uidCExprLToCSubst . assocLMapKey poiId

uidImplsLToCSubst :: AssocL UID ([Coe],[Coe]) -> CSubst
uidImplsLToCSubst = listToFM . assocLMapElt (uncurry CSIImpls)

cnstrImplsToCSubst :: Cnstr -> CSubst
cnstrImplsToCSubst c
  =  uidImplsLToCSubst
        [ (iv,(mkImplsAppCoe i,mkImplsLamCoe coeId i))
        | (iv,CIImpls i) <- cnstrToAssocL c, let (_,mbTl) = implsPredsMbTail i, isNothing mbTl
        ]

instance Show CSubst where
  show = show . fmToList

instance PP CSubstInfo where
  pp (CSIExpr       ce   )  = pp ce
  pp (CSIImpls      l r  )  = pp (coeWeaveOn emptyCSubst l r CExpr_CoeArg)
  pp (CSIBinds      b    )  = ppCBindL b
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code substitution as class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
infixr `cSubstApp`

class CSubstitutable a where
  cSubstApp :: CSubst -> a -> a

instance CSubstitutable CExpr where
  cSubstApp cs ce | isEmptyFM cs
    =  ce
  cSubstApp cs ce
    =  let  t = wrap_CExpr (sem_CExpr ce) (Inh_CExpr {cSubst_Inh_CExpr = cs, coeArg_Inh_CExpr = CExpr_CoeArg})
       in   (cRepl_Syn_CExpr t)

instance CSubstitutable CBind where
  cSubstApp cs (CBind_Bind n e) = CBind_Bind n (cSubstApp cs e)

instance CSubstitutable a => CSubstitutable [a] where
  cSubstApp cs = map (cSubstApp cs)

instance CSubstitutable v => CSubstitutable (k,v) where
  cSubstApp cs (k,v) = (k,cSubstApp cs v)

instance CSubstitutable CSubstInfo where
  cSubstApp  cs  (CSIExpr ce)  = CSIExpr (cSubstApp cs ce)
  cSubstApp  _   csi           = csi

instance CSubstitutable CSubst where
  cSubstApp cs s = mapFM (const (cSubstApp cs)) s `plusFM` cs

%%]
instance CSubstitutable v => CSubstitutable (AssocL k v) where
  cSubstApp cs l = assocLMapElt (cSubstApp cs) l

instance CSubstitutable CxBindLMap where
  cSubstApp cs (CxBindLMap m) = CxBindLMap (mapFM (const (cSubstApp cs)) m)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllCodeNT CodeAGItf [ cSubst: CSubst ^^^ coeArg: CExpr | | cRepl: SELF ]

SEM CExpr
  | Hole        lhs         .   cRepl       =   case lookupFM @lhs.cSubst @uid of
                                                  Just (CSIExpr ce)  -> ce
                                                  _                  -> @cRepl
  | HoleLet     lhs         .   cRepl       =   case lookupFM @lhs.cSubst @bindsUid of
                                                  Just (CSIBinds b)  -> @lhs.cSubst `cSubstApp` mkCExprLetRec b @body.cRepl
                                                  _                  -> @cRepl
  | CoeArg      lhs         .   cRepl       =   @lhs.coeArg
  | ImplsApp ImplsLam
                loc         .   (coeAppL,coeLamL)
                                            =   case lookupFM @lhs.cSubst @uid of
                                                  Just (CSIImpls ca cl)  -> (ca,cl)
                                                  _                      -> ([],[])
  | ImplsApp    lhs         .   cRepl       =   coeWeaveOn emptyCSubst @coeAppL [] @func.cRepl
  | ImplsLam    lhs         .   cRepl       =   coeWeaveOn emptyCSubst [] @coeLamL @body.cRepl
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coercion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
coeImplsAppLCnstr :: Cnstr -> Coe -> [Coe]
coeImplsAppLCnstr c coe
  =  case coe of
       CoeImplApp i  -> maybe [coe] mkImplsAppCoe (cnstrImplsLookup i c)
       _             -> [coe]

coeImplsAppRCnstr :: Cnstr -> Coe -> [Coe]
coeImplsAppRCnstr c coe
  =  case coe of
       CoeImplLam i  -> maybe [coe] (mkImplsLamCoe coeId) (cnstrImplsLookup i c)
       _             -> [coe]

coeEvalOn :: Coe -> CExpr -> CExpr
coeEvalOn coe ce
  =  case coe of
       CoeId            -> ce
       Coe  f           -> f ce
       CoeC e           -> e `cAppCoeArg` ce
       CoeImplApp iv    -> CExpr_ImplsApp ce iv
       CoeImplLam iv    -> CExpr_ImplsLam iv ce

coeCompose :: Coe -> Coe -> Coe
coeCompose c1 c2
  =  mkCoe (\e -> c1 `coeEvalOn` (c2 `coeEvalOn` e))

coeWipeWeave :: Cnstr -> CSubst -> [Coe] -> [Coe] -> Coe
coeWipeWeave c cs lCoeL rCoeL
  =  let  (lCoeL',rCoeL')
            = coeWipe cs (concatMap (coeImplsAppLCnstr c) lCoeL) (concatMap (coeImplsAppRCnstr c) rCoeL)
     in   CoeC (coeWeaveOn cs lCoeL' rCoeL' CExpr_CoeArg)

coeWeaveOn :: CSubst -> [Coe] -> [Coe] -> CExpr -> CExpr
coeWeaveOn cs lCoeL rCoeL ce
  =  let  ev c e = cs `cSubstApp` (c `coeEvalOn` e)
     in   foldr ev (foldr ev ce (reverse lCoeL)) rCoeL

coeWipe :: CSubst -> [Coe] -> [Coe] -> ([Coe],[Coe])
coeWipe cs l r
  =  let  eval coe = cs `cSubstApp` (coe `coeEvalOn` CExpr_CoeArg)
          w l r =  case (l,r) of
                     (CoeImplApp li:ls,CoeImplLam ri:rs)
                                    | li == ri   -> w ls rs
                                    | otherwise  -> (l,r)
                     (lc:ls,rc:rs)  | match      -> w ls rs
                                    | otherwise  -> (CoeC lce : ls, CoeC rce : rs)
                         where  lce    =  eval lc
                                rce    =  eval rc
                                match  =  case (lce,rce) of
                                            (CExpr_App _ (CExpr_Var  ln),CExpr_Lam rn CExpr_CoeArg)
                                              | ln == rn            -> True
                                            (CExpr_App _ (CExpr_Hole li),CExpr_Lam rn CExpr_CoeArg)
                                              | show li == show rn  -> True
                                            _                       -> False
                     _ -> (l,r)
          (l',r') = w (reverse l) (reverse r)
     in   (reverse l',reverse r')

mkImplsAppCoe :: Impls -> [Coe]
mkImplsAppCoe = map (\i -> mkAppCoe [mkCExprPrHole i]) . implsPrIds

mkPoiLLamCoe :: Coe -> [PredOccId] -> [Coe]
mkPoiLLamCoe onLast poiL
  =  case map (mkLamCoe . poiHNm) poiL of
       l@(_:_)  ->  let  h = init l
                         t = last l
                    in   h ++ [t `coeCompose` onLast]
       _        ->  []

mkImplsLamCoe :: Coe -> Impls -> [Coe]
mkImplsLamCoe onLast is = mkPoiLLamCoe onLast (implsPrIds is)

mkLamBodyCoe :: Coe -> [Coe] -> [Coe]
mkLamBodyCoe onLast l
  =  case l of
       (_:_)    ->  let  h = init l
                         t = last l
                    in   h ++ [onLast `coeCompose` t]
       _        ->  case onLast `coeEvalOn` CExpr_CoeArg of
                      CExpr_CoeArg  -> []
                      _             -> [onLast]

instance PP Coe where
  pp c = "<" >|< pp (c `coeEvalOn` CExpr_CoeArg) >|< ">"
%%]
mkImplsLamCoe :: Coe -> Impls -> [Coe]
mkImplsLamCoe onLast is
  =  case map (mkLamCoe . poiHNm) (implsPrIds is) of
       l@(_:_)  ->  let  h = init l
                         t = last l
                    in   h ++ [t `coeCompose` onLast]
       l        ->  [onLast]

coeWipe :: CSubst -> [Coe] -> [Coe] -> ([Coe],[Coe])
coeWipe cs l r
  =  let  eval coe = cs `cSubstApp` (coe `coeEvalOn` CExpr_CoeArg)
          w l r =  case (l,r) of
                     (CoeImplApp li:ls,CoeImplLam ri:rs)
                                    | li == ri   -> w ls rs
                                    | otherwise  -> (l,r)
                     (lc:ls,rc:rs)  | match      -> w ls rs
                                    | otherwise  -> (CoeC lce : ls, CoeC rce : rs)
                         where  lce    =  eval lc
                                rce    =  eval rc
                                match  =  case (lce,rce) of
                                            (CExpr_App _ (CExpr_Var  ln),CExpr_Lam rn CExpr_CoeArg)
                                              | ln == rn            -> True
                                            (CExpr_App _ (CExpr_Hole li),CExpr_Lam rn CExpr_CoeArg)
                                              | show li == show rn  -> True
                                            _                       -> False
                     _ -> (l,r)
          (l',r') = w (reverse l) (reverse r)
     in   (reverse l',reverse r')

