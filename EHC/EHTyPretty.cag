% $Id: EHC.lag 199 2004-05-12 19:11:13Z andres $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Ty pretty print
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs import(UU.Pretty,EHCommon,EHTy) export(ppTy)
%%]

%%[3 hs import(Char)
%%]

%%[1.WRAPPER import(EHTyAbsSyn,EHTyCommonAG)
WRAPPER TyAGItf
%%]

%%[1.ppTy hs
ppTy :: Ty -> PP_Doc
ppTy ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 Inh_TyAGItf
     in   pp_Syn_TyAGItf t

instance PP Ty where
  pp t = ppTy t
%%]

%%[8_1.ppTy -1.ppTy hs import(Data.Maybe) export(ppGhcCoreTy)
ppTy :: Ty -> PP_Doc
ppTy ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf Nothing)
     in   pp_Syn_TyAGItf t

ppGhcCoreTy ::  String -> Ty -> PP_Doc
ppGhcCoreTy moduleID ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf (Just moduleID))
     in   pp_Syn_TyAGItf t

instance PP Ty where
  pp t = ppTy t
%%]


%%[9 hs
instance PP Pred where
  pp p = ppTy (Ty_Pred p)

instance PP Impls where
  pp i = ppTy (Ty_Impls i)

instance PP PredOcc where
  pp po = pp (poPr po) >|< "/" >|< pp (poId po)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyVar name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[3 hs
type TVarNameMap = AssocL TyVarId PP_Doc
%%]

%%[3 hs
ppTnUniq :: Int -> PP_Doc
ppTnUniq u
  =  let  lrepr i     =  if i <= 26
                         then  [repr i]
                         else  let  (d,r) = i `divMod` 26
                               in   (repr d : lrepr r)
          repr        =  (chr . (97+))
     in text (lrepr u)
%%]

%%[3.mkDefaultTvNm hs
mkDefaultTvNm :: String -> TyVarId -> PP_Doc
mkDefaultTvNm pre tv = text (pre ++ "_" ++ show tv)

tvCategPrefix :: TyVarCateg -> String
tvCategPrefix TyVarCateg_Fixed = "c"
tvCategPrefix TyVarCateg_Plain = "v"
%%]

%%[3
ATTR AllTy [ | tnUniq: {Int} ^^ tnMap: TVarNameMap | ]

SEM TyAGItf
  | AGItf           ty      .   tnUniq    =   0
                            .   tnMap     =   []

SEM Ty
  | Quant           loc     .   tnPP      =   ppTnUniq @lhs.tnUniq
                    ty      .   tnUniq    =   @lhs.tnUniq + 1
                            .   tnMap     =   (@tv,@tnPP) : @lhs.tnMap
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pretty printed type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.ppAttr 
ATTR TyAGItf AllTy [ | | pp: PP_Doc ]
%%]

%%[8_1.ppAttr -1.ppAttr
ATTR TyAGItf AllTy [ ghcModuleID: {Maybe String} | | pp: PP_Doc ]
%%]

%%[1.pp

SEM Ty
  | Con             loc     .   pp      =   ppCon @nm
  | App             loc     .   ppDflt  =   @func.pp >#< @arg.pp
                            .   pp      =   if @isSpineRoot
                                            then  ppParNeed  @parNeed @lhs.parNeed
                                                             (ppAppTop (@appFunNm,@appFunPP) @appArgPPL @ppDflt)
                                            else  @ppDflt
  | Any             loc     .   pp      =   pp hsnUnknown
%%]

%%[8_1.pp
SEM Ty
  | Con            loc      . conName   = let ghcModName nm mid = if @nm == hsnInt || @nm == hsnChar then "GHCziBase." else (mid ++ ".")
                                              ghcQualName nm mid = hsnPrefix (ghcModName nm mid) nm
                                          in (maybe @nm (ghcQualName @nm) @lhs.ghcModuleID)
                            . pp        := ppCon @conName
%%]

%%[2.Var
SEM Ty
  | Var             loc     .   pp      =   pp ("v_" ++ show @tv)
%%]

%%[3.Var -2.Var
SEM Ty
  | Var             loc     .   pp      :=  maybe (mkDefaultTvNm (tvCategPrefix @categ.self) @tv) id (lookup @tv @lhs.tnMap)
%%]

%%[3.Quant
SEM Ty
  | Quant           loc     .   pp      =   ppParNeed  @parNeed @lhs.parNeed
                                                       ("forall" >#< @tnPP >#< "." >#< @ty.pp)
%%]

%%[4.Quant -3.Quant
ATTR TyQu [ | | pp: PP_Doc ]

SEM Ty
  | Quant           loc     .   pp      :=  ppParNeed  @parNeed @lhs.parNeed
                                                       (@qu.pp >#< @tnPP >#< "." >#< @ty.pp)
  
SEM TyQu
  | Forall Exists   lhs     .   pp      =   text (showTyQu @self)
%%]

%%[6
SEM TyQu
  | KiForall KiExists
                    lhs     .   pp      =   text (showTyQu @self)
%%]

%%[7
SEM Ty
  | Ext             loc     .   pp      =   ppAppTop  (hsnRow,mkPPAppFun @appFunNm @appFunPP)
                                                      @appArgPPL empty
%%]

%%[9
SEM Ty
  | Pred            loc     .   pp      =   hsnOImpl >#< @pr.pp >#< hsnCImpl
  | Impls           loc     .   pp      =   hsnOImpl >#< @impls.pp >#< hsnCImpl

SEM Pred
  | Lacks           lhs     .   pp      =   @ty.pp >|< "\\" >|< @nm
  | Equal           lhs     .   pp      =   @tvTy.pp >|< "=" >|< @ty.pp

SEM Impls
  | Tail Cons       loc     .   ppIv    =   maybe (mkDefaultTvNm "i" @iv) id (lookup @iv @lhs.tnMap)
  | Tail            lhs     .   pp      =   @ppIv
  | Cons            loc     .   ppPv    =   maybe (mkDefaultTvNm "p" @pv) id (lookup @iv @lhs.tnMap)
                    lhs     .   pp      =   @ppIv >|< "=" >|< @pr.pp >|< "/" >|< @ppPv >|< "," >|< @tl.pp
  | Nil             lhs     .   pp      =   pp "_"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Records, default (positional) name if absent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7
ATTR Ty [ | positionalFldNmL: {[HsName]} | ]

SEM TyAGItf
  | AGItf           ty      .   positionalFldNmL    =   positionalFldNames

SEM Ty
  | Ext             (loc.positionalNm,lhs.positionalFldNmL)
                                                    =   hdAndTl @ty.positionalFldNmL
  | * - Ext         lhs     .   positionalFldNmL    =   @lhs.positionalFldNmL
%%]

%%[9
SEM Pred
  | Class Lacks Equal
                    loc     .   positionalFldNmL    =   positionalFldNames
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ty constr name of app + args, see also EHPretty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.appFunPP
ATTR Ty [ | | appFunPP: PP_Doc ^^ appArgPPL: PP_DocL ]
%%]

%%[1.appFunPP.Ty
SEM Ty
  | App             loc     .  appArgPPL    =   @func.appArgPPL ++ [@arg.pp]
                            .  appFunPP     =   @func.appFunPP
  | * - App         lhs     .  appArgPPL    =   []
                            .  appFunPP     =   @pp
%%]

%%[7 -1.appFunPP.Ty
SEM Ty
  | App             loc     .  (appFunPP,appArgPPL)
                                            :=  mkExtAppPP  (@appFunNm,@func.appFunPP,@func.appArgPPL)
                                                            (@arg.appFunNm,@arg.appFunPP,@arg.appArgPPL,@arg.pp)
  | Ext             loc     .  appArgPPL    :=  @ty.appArgPPL ++ [ppFld "::" @positionalNm @nm @extTy.pp]
                            .  appFunPP     :=  @ty.appFunPP
  | * - App Ext     lhs     .  appArgPPL    :=  []
                            .  appFunPP     :=  @pp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Need for parenthesis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.ParNeed
ATTR Ty [ parNeed: ParNeed ^^^ parNeedL: ParNeedL | | ]

SEM TyAGItf
  | AGItf       ty      .   parNeed             =   ParNotNeeded
                        .   parNeedL            =   []

SEM Ty
  | App         loc     .   (parNeed,argsParNeedL)
                                                =   if @isSpineRoot
                                                    then  let  (here,_,args) = parNeedApp @appFunNm
                                                          in   (here,args)
                                                    else  (ParNotNeeded,@lhs.parNeedL)
                (arg.parNeed,func.parNeedL)
                                                =   hdAndTl @argsParNeedL
%%]

%%[3
SEM Ty
  | Quant       (loc.parNeed,ty.parNeed)        =   (ParNotNeeded,ParNotNeeded)
%%]

%%[7
SEM Ty
  | Ext         ty      .   parNeed             =   ParNotNeeded
                extTy   .   parNeed             =   ParNotNeeded
                loc     .   parNeed             =   ParNotNeeded
%%]

%%[9
SEM Pred
  | Class Lacks Equal  
                loc     .   parNeed             =   ParNotNeeded
                        .   parNeedL            =   []
%%]

