% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Ty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs import(EHCommon) export(TyAGItf(..), Ty(..), TyL, tyInt, tyChar, mkTyArrow, mkTyApp, mkTyConApp, mkTyProdApp, mkTyCon)
%%]

%%[1 hs export(tyArrowArgRes, tyArrowArgsRes, tyArrowArgs, tyArrowRes, tyAppFunArgs, tyProdArgs, tyAppArgs) 
%%]

%%[2 hs export(TyVarId, TyVarIdL, mkTyVar, mkNewTyVar, mkNewUIDTyVarL, mkNewTyVarL, mkTyFreshProd, mkTyFreshProdFrom, tyEnsureNonAny) 
%%]

%%[3 hs export(mkTyQu, TyVarCateg(..))
%%]

%%[4 hs export(TyQu(..), tyquExists, tyquIsExists, tyquIsForall, showTyQu) 
%%]

%%[4 hs export(tyConNm) 
%%]

%%[4 hs import(Maybe) export(tyVar) 
%%]

%%[4 hs export(tvCatIsFixed) 
%%]

%%[4 hs import(FiniteMap) export(TvCatMp) 
%%]

%%[4_2 hs export(tyIsQu,tyIsVar,tyMbVar) 
%%]

%%[4_2 hs export(TyPlus(..),TyPlusL,tyPlusTy) 
%%]

%%[4_2 hs export(TyHardness(..)) 
%%]

%%[6 hs export(kiStar) 
%%]

%%[6_4 hs export(tvIsEx) 
%%]

%%[7 hs import(List) export(rowExtCmp,rowLabCmp,tyRowCanonOrder,kiRow,tyRowEmpty,tyRecEmpty,tySumEmpty,tyRowExtr,tyRecExtr,mkTyRow,mkTyRec,mkTySum,mkTyRecExt,tyRowExts) 
%%]

%%[7 hs export(tyAppFunArg) 
%%]

%%[8 hs export(tyAppFunConNm) 
%%]

%%[8 hs export(tyRecOffset) 
%%]

%%[9 hs export(Pred(..),predNm,predTy,tyPredNm,tyPredMatchNm,predMatchNm,tyPred,tyLImplsPreds,tyArrowImplsRes,tyArrowImplsArgRes,mkTyImpls,mkTyPr,tyPrArrowArgsRes)
%%]

%%[9 hs export(tyRecExts,tyRecRow,tyArrowArity,tyQuant)
%%]

%%[9 hs export(tyImpls,Impls(..),ImplsVarId,mkImplsVar,implsPredsTail,implsPrIds,implsPredsMbTail,tyIsImplsTail,tyImplsPreds)
%%]

%%[9 hs export(TyCtxt(..))
%%]

%%[9_1 hs export(TyPlusId)
%%]

%%[9 hs export(PredOcc(..),poId)
%%]

%%[99 hs export(PredAsArgLocs)
%%]

%%[10 hs export(tyExtsOffset)
%%]

%%[1 import(EHTyAbsSyn)
DERIVING *     : Show, Eq, Ord
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Misc types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.TyL hs
type TyL        = [Ty]
%%]

%%[2.TyVarId.Base hs
type TyVarId    = UID
%%]

%%[2.TyVarId.Rest hs
type TyVarIdL   = [TyVarId]
%%]

%%[4_2 -1.TyL
%%]

%%[9 hs
type ImplsVarId    = UID
%%]

%%[9_1 hs
type TyPlusId      = UID
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tyvar category
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs
tvCatIsFixed :: TyVarCateg -> Bool
tvCatIsFixed TyVarCateg_Plain  = False
tvCatIsFixed _                 = True
%%]

%%[4 hs
type TvCatMp = FiniteMap TyVarId TyVarCateg
%%]

%%[6_4 hs
tvIsEx :: TvCatMp -> TyVarId -> Bool
tvIsEx fvM tv = maybe False (== TyVarCateg_Exist) (lookupFM fvM tv)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Hardness of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2 hs
data TyHardness = TyHard | TySoft deriving (Eq,Ord)

instance Show TyHardness where
  show TyHard = "H"
  show TySoft = "S"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pred occurrence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
data PredOcc
  =  PredOcc
       { poPr               :: Pred
       , poPrId             :: PredOccId
       }
  deriving (Show,Eq)

poId :: PredOcc -> UID
poId = poiId . poPrId
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Description of predicate locations in lambda (after quantification)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
%%]
type PredAsArgLocs = [Maybe PredOcc]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Properties of quantifier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs
tyquIsExists, tyquIsForall :: TyQu -> Bool
%%]

%%[4.tyQuProps hs
tyquIsForall TyQu_Forall              = True
tyquIsForall _                        = False

tyquIsExists TyQu_Exists              = True
tyquIsExists _                        = False
%%]

%%[6.tyQuProps -4.tyQuProps hs
tyquIsForall TyQu_Forall              = True
tyquIsForall TyQu_KiForall            = True
tyquIsForall _                        = False

tyquIsExists TyQu_Exists              = True
tyquIsExists TyQu_KiExists            = True
tyquIsExists _                        = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type quantifier utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs
tyquExists, tyquForall :: TyQu -> TyQu
%%]

%%[4.tyquMisc hs
tyquForall   TyQu_Exists              = TyQu_Forall
tyquForall   q                        = q

tyquExists   TyQu_Forall              = TyQu_Exists
tyquExists   q                        = q
%%]

%%[6.tyquMisc -4.tyquMisc hs
tyquForall   TyQu_Exists              = TyQu_Forall
tyquForall   TyQu_KiExists            = TyQu_KiForall
tyquForall   q                        = q

tyquExists   TyQu_Forall              = TyQu_Exists
tyquExists   TyQu_KiForall            = TyQu_KiExists
tyquExists   q                        = q
%%]

%%[showTyQu.4
showTyQu  TyQu_Forall     =  "forall"
showTyQu  TyQu_Exists     =  "exists"
%%]

%%[4.showTyQu hs
%%@showTyQu.4
%%]

%%[6.showTyQu -4.showTyQu hs
%%@showTyQu.4
showTyQu  TyQu_KiForall   =  "Forall"
showTyQu  TyQu_KiExists   =  "Exists"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Properties of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2 hs
tyMbVar :: Ty -> Maybe TyVarId
tyMbVar t = case t of {Ty_Var v _ -> Just v ; _ -> Nothing}

tyIsVar :: Ty -> Bool
tyIsVar = isJust . tyMbVar

tyIsQu :: Ty -> Bool
tyIsQu t = case t of {Ty_Quant _ _ _ -> True; _ -> False}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.mkTyArrow hs
algTy        ::  MkConApp Ty
algTy        =   (Ty_Con,Ty_App,id,id)

mkTyArrow    ::  TyL -> Ty -> Ty
mkTyArrow    =   flip (foldr (mkArrow algTy))
%%]

%%[1.mkTy hs
mkTyApp      ::  TyL -> Ty
mkTyApp      =   mkApp algTy

mkTyConApp   ::  HsName -> TyL -> Ty
mkTyConApp   =   mkConApp algTy
%%]

%%[1.mkTyProdApp hs
mkTyProdApp  ::  TyL -> Ty
mkTyProdApp  =   mkProdApp algTy
%%]

%%[7.mkTyProdApp -1.mkTyProdApp hs
mkTyProdApp :: TyL -> Ty
mkTyProdApp tyL = mkTyRec (zip positionalFldNames tyL)
%%]

%%[1.mkTyCon hs
mkTyCon :: String -> Ty
mkTyCon n = Ty_Con (HNm n)
%%]

%%[2.mkTyVar hs
mkTyVar :: TyVarId -> Ty
mkTyVar tv = Ty_Var tv
%%]

%%[3.mkTyVar -2.mkTyVar hs
mkTyVar :: TyVarId -> Ty
mkTyVar tv = Ty_Var tv TyVarCateg_Plain
%%]

%%[2.NewTyVar hs
mkNewTyVar :: UID -> Ty
mkNewTyVar u = let  (_,v) = mkNewUID u in mkTyVar v
%%]

%%[2.NewTyVarL hs
mkNewUIDTyVarL :: Int -> UID -> ([UID],TyL)
mkNewUIDTyVarL sz u = let vs = mkNewUIDL sz u in (vs,map mkTyVar vs)

mkNewTyVarL :: Int -> UID -> TyL
mkNewTyVarL sz u = snd (mkNewUIDTyVarL sz u)
%%]

%%[2.tyEnsureNonAny hs
tyEnsureNonAny :: UID -> Ty -> Ty
tyEnsureNonAny u t = if t /= Ty_Any then t else mkNewTyVar u
%%]

%%[3.mkTyQu hs
mkTyQu :: TyVarIdL -> Ty -> Ty
mkTyQu tvL t = foldr (\tv t -> Ty_Quant tv t) t tvL
%%]

%%[4.mkTyQu -3.mkTyQu hs
mkTyQu :: TyQu -> TyVarIdL -> Ty -> Ty
mkTyQu q tvL t = foldr (\tv t -> Ty_Quant q tv t) t tvL
%%]

%%[2.mkTyFreshProd hs
mkTyFreshProdFrom :: UID -> Int -> Ty
mkTyFreshProdFrom uid arity =  mkTyProdApp . map mkTyVar . mkNewUIDL arity $ uid

mkTyFreshProd :: Int -> Ty
mkTyFreshProd = mkTyFreshProdFrom uidStart
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of implicitly parameterized (or predicated) type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
mkImplsVar :: ImplsVarId -> Ty
mkImplsVar v = Ty_Impls (Impls_Tail v)
%%]

%%[9 hs
mkTyImpls :: [Pred] -> Ty -> Ty
mkTyImpls prL t = map Ty_Pred prL `mkTyArrow` t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of pred type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
mkTyPr :: Pred -> Ty
mkTyPr p
  =  case p of
	   Pred_Pred t  -> t
	   _            -> Ty_Pred p
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.tyConsts hs
tyInt   = Ty_Con hsnInt
tyChar  = Ty_Con hsnChar
%%]

%%[6 hs
kiStar  = Ty_Con hsnStar
%%]

%%[7 hs
kiRow       = Ty_Con hsnRow
tyRowEmpty  = Ty_Con hsnRowEmpty
tyRecEmpty	= mkTyRec []
tySumEmpty	= mkTySum []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.unMkTy.sigs.tyArrow hs
tyArrowArgRes   :: Ty -> (Ty,Ty)
%%]

%%[1.unMkTy.sigs.Rest hs
tyArrowArgsRes  :: Ty -> (TyL,Ty)
tyAppFunArgs    :: Ty -> (Ty,TyL)
tyAppArgs       :: Ty -> TyL
tyArrowArgs     :: Ty -> TyL
tyArrowRes      :: Ty -> Ty
tyProdArgs      :: Ty -> TyL
%%]

%%[1.unMkTy.tyArrowArgRes hs
tyArrowArgRes t
  =  case t of
       Ty_App (Ty_App (Ty_Con nm) a) r
         | hsnIsArrow nm  -> (a,r)
       _                  -> (Ty_Any,t)
%%]

%%[1.unMkTy.tyArrowArgsRes hs
tyArrowArgsRes t
  =  case t of
       Ty_App (Ty_App (Ty_Con nm) a) r
         | hsnIsArrow nm  -> let (as,r') = tyArrowArgsRes r in (a:as,r')
       _                  -> ([],t)
%%]

%%[8.unMkTy.tyArrowArgsRes -1.unMkTy.tyArrowArgsRes hs
tyArrowArgsRes t
  =  case t of
       Ty_Quant _ _ t     -> tyArrowArgsRes t
       Ty_App (Ty_App (Ty_Con nm) a) r
         | hsnIsArrow nm  -> let (as,r') = tyArrowArgsRes r in (a:as,r')
       _                  -> ([],t)
%%]

%%[1.unMkTy.tyAppFunArgs hs
tyAppFunArgs
  =  extr []
  where  extr as t
           =  case t of
                Ty_App f a  -> extr (a:as) f
                _           -> (t,as)
%%]

%%[6.unMkTy.tyAppFunArgs -1.unMkTy.tyAppFunArgs hs
tyAppFunArgs
  =  extr []
  where  extr as t
           =  case t of
                Ty_Quant _ _ t  -> tyAppFunArgs t
                Ty_App f a      -> extr (a:as) f
                _               -> (t,as)
%%]

%%[1.unMkTy.funs hs
tyArrowArgs  = fst . tyArrowArgsRes
tyArrowRes   = snd . tyArrowArgsRes
tyAppArgs    = snd . tyAppFunArgs
%%]

%%[1.tyProdArgs hs
tyProdArgs   = tyAppArgs
%%]

%%[4 hs
tyConNm :: Ty -> HsName
tyConNm  (Ty_Con nm)  = nm
tyConNm  _            = hsnUnknown
%%]

%%[4.tyVar hs
tyVar :: Ty -> TyVarId
tyVar (Ty_Var v _)  = v
tyVar _             = uidStart
%%]

%%[4_2.tyPlusTy hs
tyPlusTy :: TyPlus -> Ty
tyPlusTy (TyPlus_Ty t _) = t
%%]

%%[9_1.tyPlusTy -4_1.tyPlusTy hs
tyPlusTy :: TyPlus -> Ty
tyPlusTy (TyPlus_Ty t _) = t
%%]

%%[7.tyProdArgs -1.tyProdArgs hs
tyProdArgs ty = let (t,al) = tyRecExts ty in map snd al
%%]

%%[7 hs
tyAppFunArg :: Ty -> (Ty,Ty)
tyAppFunArg t =  case t of {Ty_App f a -> (f,a); _ -> (Ty_Any,Ty_Any)}
%%]

%%[8 hs
tyAppFunConNm :: Ty -> HsName
tyAppFunConNm = tyConNm . fst . tyAppFunArgs
%%]

%%[9 hs
tyQuant :: Ty -> Ty
tyQuant t
  =  case t of
       Ty_Quant _ _ t'  -> tyQuant t'
       _                -> t

tyArrowArity :: Ty -> Int
tyArrowArity = length . tyArrowArgs
%%]

%%[9 hs
tyArrowImplsRes  :: Ty -> (TyL,Ty)
tyArrowImplsRes t
  =  case t of
       (Ty_App (Ty_App (Ty_Con nm) a) r)
         | hsnIsArrow nm && isImpls a
           -> let (as,r') = tyArrowImplsRes r in (a:as,r')
         where  isImpls (Ty_Pred  _)  = True
                isImpls (Ty_Impls _)  = True
                isImpls _             = False
       _                  -> ([],t)

tyArrowImplsArgRes  :: Ty -> (TyL,Ty,Ty)
tyArrowImplsArgRes t
  =  let  (i,t')  = tyArrowImplsRes  t
          (a,r)   = tyArrowArgRes    t'
     in   (i,a,r)

tyLImplsPreds :: TyL -> ([Pred],Impls)
tyLImplsPreds = foldr (\t (ps,i) -> case t of {Ty_Pred p -> (p:ps,i); Ty_Impls i -> (ps,i)}) ([],Impls_Nil)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction for records/variants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7 hs
mkTyRow :: Ty -> AssocL HsName Ty -> Ty
mkTyRow r = foldl (\t (n,e) -> Ty_Ext t n e) r

mkTyRec :: AssocL HsName Ty -> Ty
mkTyRec al = hsnRec `mkTyConApp` [tyRowEmpty `mkTyRow` al]

mkTyRecExt :: Ty -> AssocL HsName Ty -> Ty
mkTyRecExt rec al
  =  let  (row,exts) = tyRowExts (tyRecRow rec)
     in   hsnRec `mkTyConApp` [row `mkTyRow` (exts ++ al)]

mkTySum :: AssocL HsName Ty -> Ty
mkTySum al = hsnSum `mkTyConApp` [tyRowEmpty `mkTyRow` al]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction for records
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7 hs
tyRecRow :: Ty -> Ty
tyRecRow t
  =  case tyAppFunArgs t of
       (Ty_Con n,[row]) | hsnIsRec n || hsnIsSum n -> row
       _                                           -> Ty_Any

tyRowExts :: Ty -> (Ty,AssocL HsName Ty)
tyRowExts
  =  extr []
  where  extr as t
           =  case t of
                (Ty_Ext r l e) -> extr ((l,e):as) r
                _              -> (t,as)

tyRecExts :: Ty -> (Ty,AssocL HsName Ty)
tyRecExts t
  =  case tyRecRow t of
       Ty_Any  -> (Ty_Any,[])
       row     -> tyRowExts row

tyRowExtr :: HsName -> Ty -> Maybe (Ty,Ty)
tyRowExtr lbl t
  =  case t of
       (Ty_Ext r l e)   | lbl == l   -> Just (r,e)
                        | otherwise  -> maybe Nothing (\(r',e') -> Just (Ty_Ext r' l e,e')) (tyRowExtr lbl r)
       _                             -> Nothing

tyRecExtr :: HsName -> Ty -> Maybe (Ty,Ty)
tyRecExtr lbl t
  =  case tyRowExtr lbl (tyRecRow t) of
       Nothing    -> Nothing
       Just (r,e) -> Just (hsnRec `mkTyConApp` [r],e)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Canonical ordering of fields of record
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7 hs
rowLabCmp :: HsName -> HsName -> Ordering
rowLabCmp = compare

rowExtCmp :: (HsName,a) -> (HsName,a) -> Ordering
rowExtCmp (n1,_) (n2,_) = n1 `rowLabCmp` n2

tyRowCanonOrder :: AssocL HsName a -> AssocL HsName a
tyRowCanonOrder = sortBy rowExtCmp
%%]

%%[8 hs
tyExtsOffset :: HsName -> AssocL HsName a -> Int
tyExtsOffset lbl exts
  = find 0 lbl exts
  where find o l (e:es) = case (l,undefined) `rowExtCmp` e of
                            GT -> find (o+1) l es
                            _  -> o
        find o _ []     = o

tyRecOffset :: HsName -> Ty -> Int
tyRecOffset lbl t
  =  let (_,exts) = tyRecExts t
      in tyExtsOffset lbl . tyRowCanonOrder $ exts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction for predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
tyPred :: Ty -> Pred
tyPred t
  =  case t of
       Ty_Pred pt  -> pt
       _           -> Pred_Pred t

predNm :: Pred -> HsName
predNm = tyAppFunConNm . predTy

tyPredNm :: Ty -> HsName
tyPredNm = predNm . tyPred

tyPrArrowArgsRes :: Ty -> ([Pred],Pred)
tyPrArrowArgsRes tp = let (tl,t) = tyArrowArgsRes tp in (map tyPred tl, tyPred t)
%%]

%%[9 hs
tyPredMatchNm :: Ty -> HsName
tyPredMatchNm = predMatchNm . tyPred

predMatchNm :: Pred -> HsName
predMatchNm p
  =  case p of
       Pred_Class t    -> tyAppFunConNm t
       Pred_Pred  t    -> predMatchNm . snd . tyPrArrowArgsRes $ t
%%]
%%[10 hs
       Pred_Lacks _ l  -> hsnPrefix "_Lab_" l
%%]

%%[9 hs
predTy :: Pred -> Ty
predTy p
  =  case p of
       Pred_Class t    -> t
       Pred_Pred  t    -> t
%%]
%%[10 hs
       Pred_Lacks t _  -> t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction for implicits
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
tyImpls :: Ty -> Impls
tyImpls (Ty_Impls i) = i

implsPredsTail :: Impls -> ([PredOcc],Impls)
implsPredsTail (Impls_Cons v p pv t)  =  let  (p',mi) = implsPredsTail t
                                         in   (PredOcc p pv : p',mi)
implsPredsTail t                      =  ([],t)

implsPredsMbTail :: Impls -> ([PredOcc],Maybe ImplsVarId)
implsPredsMbTail i =  case implsPredsTail i of
                        (i',Impls_Tail v  ) -> (i',Just v)
                        (i',Impls_Nil     ) -> (i',Nothing)

tyImplsPreds :: Ty -> [PredOcc]
tyImplsPreds = fst . implsPredsTail . tyImpls

tyIsImplsTail :: Ty -> Bool
tyIsImplsTail (Ty_Impls (Impls_Tail _))  = True
tyIsImplsTail _                          = False

implsPrIds :: Impls -> [PredOccId]
implsPrIds = map poPrId . fst . implsPredsTail
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
data TyCtxt = TyCtxt_Ty | TyCtxt_Pred | TyCtxt_Class deriving (Show,Eq)
%%]

