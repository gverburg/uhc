target byteorder little;

import grin_main;
import printf;
import getenv;
import atoi;

//GC
//import gc_init;
import malloc;

export main;
export printInt;

const HEAP_SIZE = 1024;

bits32 @hp;
bits32 @eh;

section "data" {
	heapsize_var      : bits8[] "GRIN_HEAPSIZE\0";
	heapsize_msg      : bits8[] "heapsize %d KB\naddress space ranges from %p upto %p\n\0";
	int_msg           : bits8[] "int: %d\n\0";
    error_msg         : bits8[] "error: exception at %p with tag %d\n\0";
}

section "data" {
	align 4;
	argument_count: bits32;
	argument_array: bits32;
}

printInt (bits32 n) {
	foreign "C" printf("address" int_msg, n);
	return;
}

foreign "C" main(bits32 argc, "address" bits32 argv) {
	bits32 result;
	bits32 heapsize;
	bits32 env_var;
	
	//init heap (load from environment var GRIN_HEAPSIZE)
	env_var = foreign "C" getenv("address" heapsize_var);
	if (env_var == 0) {
		heapsize = HEAP_SIZE;
	} else {
		heapsize = foreign "C" atoi("address" env_var);
	}  


	//no GC yet - just allocate the memory and hope we will not allocate to much
	@hp = foreign "C" malloc(heapsize * 1024);
	foreign "C" printf("address" heapsize_msg, heapsize, @hp, @hp + (heapsize * 1024));
	//@hp = foreign "C" gc_init(heapsize * 1024);

	//save argument positions
	bits32[argument_count] = argc;
	bits32[argument_array] = argv;

    //install default exception handler
    @eh = defaultHandler;

	//call main function
	result = grin_main() also cuts to defaultHandler;
	printInt(result);

	foreign "C" return (0);

    bits32 e;
    continuation defaultHandler("address" e):
    foreign "C" printf("address" error_msg, e, bits32[e]);
    foreign "C" return (1);
}

/*
vim:ts=4
*/
