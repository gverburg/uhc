target byteorder little;

import grin_main;
import printf;
import getenv;
import atoi;

//GC
//import gc_init;
import malloc;

export main;
export printInt;

const HEAP_SIZE = 8192;

bits32 @hp;

section "data" {
	heapsize_var      : bits8[] "GRIN_HEAPSIZE\0";
	heapsize_msg      : bits8[] "heapsize %d\n\0";
	int_msg           : bits8[] "int: %d\n\0";
}

section "data" {
	align 4;
	argument_count: bits32;
	argument_array: bits32;
}

printInt (bits32 n) {
	foreign "C" printf("address" int_msg, n);
	return;
}

foreign "C" main(bits32 argc, "address" bits32 argv) {
	bits32 tag, r;
	bits32 heapsize;
	bits32 env_var;
	
	//init heap (load from environment var GRIN_HEAPSIZE)
	env_var = foreign "C" getenv("address" heapsize_var);
	if (env_var == 0) {
		heapsize = HEAP_SIZE;
	} else {
		heapsize = foreign "C" atoi("address" env_var);
	}  
	foreign "C" printf("address" heapsize_msg, heapsize);


	//no GC yet - just allocate the memory and hope we will not allocate to much
	@hp = foreign "C" malloc(heapsize);
	//@hp = foreign "C" gc_init(heapsize);

	//save argument positions
	bits32[argument_count] = argc;
	bits32[argument_array] = argv;

	//call main function
	tag, r = grin_main();

	foreign "C" return (r);
}

/*
vim:ts=4
*/
