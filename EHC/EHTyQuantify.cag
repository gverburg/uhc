% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[3 hs import(EHCommon,EHTy,EHCnstr,EHSubstitutable) export(tyQuantify, tyQuantifyClosed)
%%]

%%[4 hs import(EHDebug,UU.Pretty)
%%]

%%[4 hs import(qualified Data.Set as Set,qualified Data.Map as Map,Data.List as List)
%%]

%%[4 import(EHTyAbsSyn,EHTyCommonAG)
WRAPPER TyAGItf
%%]

%%[6 hs export(kiQuantify)
%%]

%%[9 hs import(Data.Maybe,UU.Pretty) export(tyQuantifyPr,tyQuantifyRank,TyQuOut(..),TyQuOpts(..),defaultTyQuOpts)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Ty quantify
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[3.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty = mkTyQu (filter (not.tvIsBound) (ftv ty)) ty
%%]

%%[3.tyQuantifyClosed hs
tyQuantifyClosed :: Ty -> Ty
tyQuantifyClosed = tyQuantify (const False)
%%]

%%[9.tyQuantifyClosed -3.tyQuantifyClosed hs
tyQuantifyClosed :: Ty -> Ty
tyQuantifyClosed = tyQuantifyRank [1..]

tyQuantifyRank :: [Int] -> Ty -> Ty
tyQuantifyRank rL ty
  = tqoTy (tyQuantifyPr (defaultTyQuOpts {tqoptQuRanks = rL}) (const False) TyQu_Forall [] ty)
%%]

%%[4.tyQuantify -3.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf (TyAGItf_AGItf ty))
                  (Inh_TyAGItf {tvIsBound_Inh_TyAGItf = tvIsBound})
    in   quTy_Syn_TyAGItf t
%%]

%%[6.tyQuantify -4.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty = tyQuantify' tvIsBound TyQu_Forall ty

kiQuantify :: (TyVarId -> Bool) -> Ty -> Ty
kiQuantify tvIsBound ty = tyQuantify' tvIsBound TyQu_KiForall ty
%%]

%%[6.tyQuantifyPrime hs
tyQuantify' :: (TyVarId -> Bool) -> TyQu -> Ty -> Ty
tyQuantify' tvIsBound baseQuant ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf  (TyAGItf_AGItf ty))
                  (Inh_TyAGItf  { baseQu_Inh_TyAGItf        = baseQuant
                                , tvIsBound_Inh_TyAGItf     = tvIsBound
                                })
    in   quTy_Syn_TyAGItf t
%%]

%%[9.tyQuantifyPrime -6.tyQuantifyPrime hs
tyQuantify' :: (TyVarId -> Bool) -> TyQu -> Ty -> Ty
tyQuantify' tvIsBound baseQuant ty = tqoTy (tyQuantifyPr defaultTyQuOpts tvIsBound baseQuant [] ty)
%%]

%%[9 hs
data TyQuOpts  = TyQuOpts  {tqoptLeaveImpls :: Bool, tqoptQuRanks :: [Int]}

defaultTyQuOpts :: TyQuOpts
defaultTyQuOpts = TyQuOpts False [1..]

data TyQuOut
  = TyQuOut   { tqoTy               ::  Ty
              , tqoInsPrIdSet       ::  Set.Set PredOccId
              , tqoImplsCnstr       ::  Cnstr
              }

instance Show TyQuOut where
  show _ = ""

instance PP TyQuOut where
  pp tqo = pp (tqoImplsCnstr tqo)
%%]
              , tqoPredAsArgLocs    ::  PredAsArgLocs
instance PP TyQuOut where
  pp tqo = pp (tqoImplsCnstr tqo) >|< "/" >|< ppCommaList (tqoPredAsArgLocs tqo)

%%[9 hs
tyQuantifyPr :: TyQuOpts -> (TyVarId -> Bool) -> TyQu -> [PredOcc] -> Ty -> TyQuOut
tyQuantifyPr opts tvIsBound baseQuant prL ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf  (TyAGItf_AGItf ty))
                  (Inh_TyAGItf  { baseQu_Inh_TyAGItf        = baseQuant
                                , tvIsBound_Inh_TyAGItf     = tvIsBound
                                , opts_Inh_TyAGItf          = opts
                                , prLL_Inh_TyAGItf          = [prL]
                                })
    in   TyQuOut
            { tqoTy                 = quTy_Syn_TyAGItf t
            , tqoInsPrIdSet         = insPrIdSet_Syn_TyAGItf t
            , tqoImplsCnstr         = assocLToCnstrImpls (prImpls_Syn_TyAGItf t)
            }
%%]
            , tqoPredAsArgLocs      = predAsArgsLocs_Syn_TyAGItf t

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR TyAGItf AllTy [ opts: TyQuOpts | | ]

SEM TyAGItf
  | AGItf       ty          .   opts        =   @lhs.opts {tqoptQuRanks = take 5 (tqoptQuRanks @lhs.opts)}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free type vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.frTvLL
ATTR AllTy [ | | frTvLL USE {++} {[]}: {[TyVarIdL]} ]

SEM TyAGItf
  | AGItf       loc         .   frTvL       =   head @ty.frTvLL

SEM Ty
  | Var         loc         .   frTvL       =   [@tv]
  | App         loc         .   frTvLL      =   @arg.frTvLL ++ @func.frTvLL
                            .   frTvL       =   listCombineUniq @frTvLL
                lhs         .   frTvLL      =   if @isSpineRoot then [@frTvL] else @frTvLL
  | Quant       loc         .   frTvL       =   head @ty.frTvLL \\ @introTVarL
  | Any Con     loc         .   frTvL       =   []
  | Quant Var Any Con
                lhs         .   frTvLL      =   [@frTvL]
%%]

%%[4_2
SEM TyL
  | Nil         lhs         .   frTvLL      =   []

SEM TyPlusL
  | Nil         lhs         .   frTvLL      =   []
%%]

%%[7
SEM Ty
  | Ext         loc         .   frTvLL      =   @extTy.frTvLL ++ @ty.frTvLL
%%]

%%[9
SEM Ty
  | App         (loc.frRowTvL,loc.frTvLL)   :=  if @argIsRow
                                                then hdAndTl (reverse @arg.frTvLL)
                                                else ([],@arg.frTvLL ++ @func.frTvLL)
                loc         .   frTvL       :=  listCombineUniq (@frRowTvL : @frTvLL)
                            .   arrArgTvL   =   @frTvLL !! 1
  | Pred        loc         .   frTvL       =   listCombineUniq @pr.frTvLL
  | Impls       loc         .   frTvL       =   listCombineUniq @impls.frTvLL
  | Pred Impls  lhs         .   frTvLL      =   [@frTvL]

SEM Impls
  | Tail Nil    lhs         .   frTvLL      =   []
  | Cons        lhs         .   frTvLL      =   @pr.frTvLL ++ @tl.frTvLL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fixed tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
ATTR AllTy [ | | gathFxTvM USE {`Map.union`} {Map.empty}: TvCatMp ]
ATTR AllTy [ fxTvM: TvCatMp | | ]

SEM Ty
  | Var         lhs         .   gathFxTvM   =   if tvCatIsFixed @categ.self then @tv `Map.singleton` @categ.self else Map.empty

SEM TyAGItf
  | AGItf       loc         .   fxTvM       =   @ty.gathFxTvM
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free row vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[99
ATTR Ty [ | | frRowTvL: TyVarIdL ]

SEM Ty
  | Ext         lhs         .   frRowTvL    =   @ty.frRowTvL
  | App         loc         .   frRowTvL    =   @func.frRowTvL `List.union` @arg.frRowTvL
  | * - App Ext
                lhs         .   frRowTvL    =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rank
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
ATTR AllTy [ rank: Int | | ]

SEM Ty
  | App         arg         .   rank        =   @lhs.rank + (if @isArrowArg then 1 else 0)

SEM TyAGItf
  | AGItf       ty          .   rank        =   1
%%]

%%[9
SEM Ty
  | Var App Pred
                loc         .   isQuRank    =   @lhs.rank `elem` tqoptQuRanks @lhs.opts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine co- contravariance of place in type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.coco
ATTR AllTy [ coco: CoContraVariance | | ]

SEM Ty
  | App         func        .   coco        =   @lhs.coco
                arg         .   coco        =   if          @appIsLikeProd  then  @lhs.coco
                                                else  if    @isArrowRoot    then  CoVariant
                                                else  if    @isArrowArg     then  ContraVariant
                                                                            else  CoContraVariant

SEM TyAGItf
  | AGItf       ty          .   coco        =   CoVariant
%%]

%%[9
SEM Ty
  | Pred        pr          .   coco        =   CoContraVariant

SEM Pred
  | Pred        ty          .   coco        =   CoVariant
  | Class       ty          .   coco        =   CoContraVariant
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is type a tvar?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
%%]
ATTR Ty [ | | isVar: Bool ]

SEM Ty
  | Var         lhs         .   isVar       =   True
  | * - Var     lhs         .   isVar       =   False

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where we treat quantification specally?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6_4.isSpecLoc
ATTR Ty [ | | isSpecLoc: Bool ^^ isSpecLocL: [Bool] ]

SEM Ty
  | App         loc         .   isSpecLoc   =   @isSpineRoot && (@appIsArrow || @appIsLikeProd)
                            .   isSpecLocL  =   @arg.isSpecLoc : @func.isSpecLocL
  | * - App     loc         .   isSpecLoc   =   False
                            .   isSpecLocL  =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where quantification can take place?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.isQuLoc
SEM Ty
  | Var App Quant
                loc         .   isQuLoc     =   @lhs.coco /= CoContraVariant
%%]

%%[6_4.isQuLoc -4.isQuLoc
ATTR AllTy [ isQuLoc: Bool | | ]

SEM Ty
  | Var         loc         .   isQuLoc     =   @lhs.isQuLoc
  | App         func        .   isQuLoc     =   False
                (loc.isQuLoc,arg.isQuLoc)   =   if          @isArrowRoot    then    (@lhs.isQuLoc,True)
                                                else  if    @isArrowArg     then    (False,True)
                                                else  if    @appIsLikeProd  then    (@lhs.isQuLoc,True)
                                                                            else    (@lhs.isQuLoc,True)

SEM TyAGItf
  | AGItf       ty          .   isQuLoc     =   True
%%]
SEM Ty
  | Var         loc         .   isQuLoc     =   @lhs.isQuLoc
  | App         func        .   isQuLoc     =   False
                loc         .   argIsQuLoc  =   not @arg.isVar
                (loc.isQuLoc,arg.isQuLoc)   =   if          @isArrowRoot    then    (@lhs.isQuLoc,True)
                                                else  if    @isArrowArg     then    (False,True)
                                                else  if    @appIsLikeProd  then    (@lhs.isQuLoc,True)
                                                                            else    (@lhs.isQuLoc,@argIsQuLoc)

%%[9
SEM Ty
  | Pred        loc         .   isQuLoc     =   @lhs.coco /= CoContraVariant
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where quantification of previously existentialized tvar may be done?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
SEM Ty
  | App         loc         .   isReQuExLoc =   @lhs.rank > 1
                                                ||  @lhs.rank == 1
                                                    &&  (@lhs.tyCtxt == TyQuCtxtArrow && not @arg.isArrow
                                                        || @lhs.tyCtxt /= TyQuCtxtArrow
                                                        )
  | Var         loc         .   isReQuExLoc =   True
%%]

%%[9
SEM Ty
  | Pred        loc         .   isReQuExLoc =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where quantification of fixed tvar may be done?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
SEM Ty
  | App         loc         .   isQuFxLoc   =   @lhs.rank > 1
                                                ||  @lhs.rank == 1
                                                    &&  (@lhs.tyCtxt == TyQuCtxtArrow && not @arg.isArrow
                                                        || @lhs.tyCtxt == TyQuCtxtOther
                                                        )
  | Var         loc         .   isQuFxLoc   =   False
%%]

%%[9
SEM Ty
  | Pred        loc         .   isQuFxLoc   =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Candidate free type variables to be quantified over 'here'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.tvarOccurCount hs
tvarOccurCount :: [TyVarIdL] -> AssocL TyVarId Int
tvarOccurCount = map (\vl@(v:_) -> (v,length vl)) . group . sort . concat

tvarOccurGE2 :: [TyVarIdL] -> TyVarIdL
tvarOccurGE2 =  map fst . filter ((>1).snd) . tvarOccurCount
%%]

%%[4.qHereTvL
SEM TyAGItf
  | AGItf       loc         .   qHereTvL        =   []

SEM Ty
  | Var         loc         .   qHereTvL        =   if @isQuLoc then [@tv] else []
  | App         loc         .   qHereTvL        =   if @isQuLoc
                                                    then  if    @appIsArrow || @appIsLikeProd
                                                          then  tvarOccurGE2 @frTvLL
                                                          else  @frTvL
                                                    else  []
%%]

%%[6_4
SEM Ty
  | Var         loc         .   qHereTvL        =   if @isQuLoc && @isReQuExLoc
                                                    then  filter (tvIsEx @lhs.fxTvM) [@tv]
                                                    else  []
  | App         loc         .   qHereTvL        :=  if @isQuLoc
                                                    then  if    @isSpecLoc
                                                          then  tvarOccurGE2 @frTvLL
                                                          else  filter (not . tvIsEx @lhs.fxTvM) @frTvL
                                                    else  []
%%]
SEM Ty
  | Var         loc         .   qHereTvL        =   if @isQuLoc
                                                    then  [@tv]
                                                    else  []
  | App         loc         .   qHereTvL        :=  if @isQuLoc
                                                    then  if    @isSpecLoc
                                                          then  tvarOccurGE2 @frTvLL
                                                          else  filter (not . tvIsEx @lhs.fxTvM) @frTvL
                                                    else  []

%%[9
SEM Ty
  | App         loc         .   qHereTvL        :=  if @isQuLoc
                                                    then  if    @appIsArrow || @appIsLikeProd
                                                          then  tvarOccurGE2 @frTvLL `List.union` @frRowTvL
                                                          else  @frTvL
                                                    else  []
  | Pred        loc         .   qHereTvL        =   @frTvL \\ @pr.qInsideTvL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inside 'here' tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTy [ | | qInsideTvL USE {++} {[]}: TyVarIdL ]

SEM Ty
  | App         lhs         .   qInsideTvL      =   @qHereTvL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Surrounding tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTy [ qSurrTvL: TyVarIdL | | ]

SEM TyAGItf
  | AGItf       loc         .   qSurrTvL                =   @qHereTvL

SEM Ty
  | App Var     loc         .   qSurrTvL                =   @qHereTvL ++ @lhs.qSurrTvL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The implicit preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR Ty [ | | mbImpls: {Maybe Impls} ]

SEM Ty
  | Impls       lhs         .   mbImpls                 =   Just @impls.quTy
  | App         lhs         .   mbImpls                 =   if @isArrowArg then @arg.mbImpls else Nothing
  | * - App Impls
                lhs         .   mbImpls                 =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Can predicates be inserted at location in ty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTy [ mbPrLoc: {Maybe ImplsVarId} | | ]

SEM TyAGItf
  | AGItf       ty          .   mbPrLoc                 =   Nothing

SEM Ty
  | App         loc         .   (implsPrL,mbTail)       =   if tqoptLeaveImpls @lhs.opts
                                                            then ([],Nothing)
                                                            else maybe ([],Nothing) implsPredsMbTail @func.mbImpls
                arg         .   mbPrLoc                 =   @mbTail
  | Var         loc         .   implsPrL                =   []
  | * - App Var Con Any
                loc         .   mbPrLoc                 =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine insertable preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
prLLArrowSplit :: [TyVarId] -> [[PredOcc]] -> ([PredOcc],[[PredOcc]])
prLLArrowSplit frTvL prLL
  =  let  (h,r) = partition (all (`elem` frTvL) . ftv) . concat $ prLL
     in   (h,[r])
%%]

%%[9
ATTR TyAGItf AllTy [ prLL: {[[PredOcc]]} | | ]

SEM Ty
  | Var         loc         .   (herePrL,_)             =   prLLArrowSplit @qSurrTvL @lhs.prLL
  | App         (loc.herePrL,func.prLL,arg.prLL)        =   if @isSpineRoot
                                                            then  if @appIsArrow
                                                                  then  let  (h,r) = prLLArrowSplit (@arrArgTvL ++ @lhs.qSurrTvL) @lhs.prLL
                                                                        in   (h,[],r)
                                                                  else  let  (h,_) = prLLArrowSplit (@frTvL ++ @lhs.qSurrTvL) @lhs.prLL
                                                                        in   (h,[],[])
                                                            else  ([],[],[])
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pass preds up to pred insertable location
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTy [ | | insPrL USE {++} {[]} : {[PredOcc]} ]

SEM Ty
  | App         loc         .   candPrL         =   @herePrL ++ @func.insPrL ++ @arg.insPrL
  | Var         loc         .   candPrL         =   @herePrL
  | App Var     (loc.insHerePrL,lhs.insPrL)     =   maybe ([],@candPrL) (const (@candPrL,[])) @lhs.mbPrLoc
                loc         .   insPrL          =   @implsPrL ++ @insHerePrL
                            .   hasNoInsPrL     =   null @insPrL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine quantifiable tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.tvBoundAdd hs
tvBoundAdd :: (TyVarId -> Bool) -> TyVarIdL -> TyVarId -> Bool
tvBoundAdd tvIsBound tvL = \v -> v `elem` tvL || tvIsBound v
%%]

%%[4.tvarsToQuant hs
tvarsToQuant :: Bool -> TvCatMp -> (TyVarId -> Bool) -> (TyVarId -> Bool) -> TyVarIdL -> (TyVarIdL,TyVarIdL,TyVarId -> Bool)
tvarsToQuant isQuLoc _ mayQuFx tvIsBound tvL
  =  if isQuLoc
     then  let boundables = filter (\tv -> not (tvIsBound tv)) tvL
           in (boundables,[],tvBoundAdd tvIsBound boundables)
     else  ([],[],tvIsBound)
%%]

%%[6_4.tvarsToQuant -4.tvarsToQuant hs
tvarsToQuant :: Bool -> TvCatMp -> (TyVarId -> Bool) -> (TyVarId -> Bool) -> TyVarIdL -> (TyVarIdL,TyVarIdL,TyVarId -> Bool)
tvarsToQuant isQuLoc fxTvM mayQuFx tvIsBound tvL
  =  if isQuLoc
     then  let  tvFrL = filter (\tv -> not (tvIsBound tv)) tvL
                (bndEx,bnd) = partition (tvIsEx fxTvM) tvFrL
           in   (bnd,filter mayQuFx bndEx,tvBoundAdd tvIsBound tvFrL)
     else  ([],[],tvIsBound)
%%]

%%[4.tvMayQuFx hs
tvMayQuFx :: TyQu -> TvCatMp -> Bool -> TyVarId -> Bool
tvMayQuFx qu fxTvM isQuFxLoc tv
  = True
%%]

%%[6_4.tvMayQuFx -4.tvMayQuFx hs
tvMayQuFx :: TyQu -> TvCatMp -> Bool -> TyVarId -> Bool
tvMayQuFx qu fxTvM isQuFxLoc tv
  = isQuFxLoc 
%%]

%%[4.tvIsBound
ATTR TyAGItf AllTy [ tvIsBound: {TyVarId -> Bool} | | ]

SEM TyAGItf
  | AGItf       loc         .   (qBndTvL,qBndExTvL,tvIsBound)
                                                        =   tvarsToQuant True @fxTvM (const False) @lhs.tvIsBound @qHereTvL

SEM Ty
  | App Var     loc         .   (qBndTvL,qBndExTvL,tvIsBound)
                                                        =   tvarsToQuant @isQuLoc @lhs.fxTvM (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc) @lhs.tvIsBound @qHereTvL
  | Quant       loc         .   tvIsBound               =   tvBoundAdd @lhs.tvIsBound @introTVarL
%%]

%%[9
SEM Ty
  | App Var     loc         .   (qBndTvL,qBndExTvL,tvIsBound)
                                                        :=  tvarsToQuant @isQuLoc @lhs.fxTvM (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc) @lhs.tvIsBound (@qHereTvL `List.union` ftv @candPrL)
%%]

%%[9
SEM Ty
  | Pred        loc         .   (qBndTvL,qBndExTvL,tvIsBound)
                                                        =   tvarsToQuant @isQuLoc @lhs.fxTvM (const False) @lhs.tvIsBound @qHereTvL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which quantifier to use for quantification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.hereQu
SEM TyAGItf
  | AGItf       loc         .   hereQu          =   TyQu_Forall

SEM Ty
  | App         loc         .   qAsExist        =   @appIsLikeProd || @lhs.coco == ContraVariant && not @appIsArrow
  | Var         loc         .   qAsExist        =   @lhs.coco == ContraVariant
  | App Var     loc         .   hereQu          =   if @qAsExist then TyQu_Exists else TyQu_Forall
  | Quant       loc         .   hereQu          =   @qu.self
%%]

%%[6.hereQu
ATTR TyAGItf AllTy [ baseQu: TyQu | | ]

SEM TyAGItf
  | AGItf       loc         .   hereQu          :=  @lhs.baseQu

SEM Ty
  | App Var     loc         .   hereQu          :=  if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu
%%]

%%[9.hereQu
SEM Ty
  | App         loc         .   qAsExist        :=  @hasNoInsPrL && (@appIsLikeProd || @lhs.coco == ContraVariant && not @appIsArrow)
  | Var         loc         .   qAsExist        :=  @hasNoInsPrL && @lhs.coco == ContraVariant
%%]

%%[9
SEM Ty
  | Pred        loc         .   qAsExist        =   @lhs.coco == ContraVariant
                            .   hereQu          =   if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Quantified type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs
mkTyQuEx :: TyQu -> TyVarIdL -> TyVarIdL -> Ty -> Ty
mkTyQuEx q tvL tvExL t = mkTyQu q tvL (mkTyQu (tyquExists q) tvExL t)
%%]

%%[4.quTy
ATTR TyAGItf [ | | quTy: Ty ]
ATTR AllTy TyQu TyVarCateg [ | | quTy: SELF ]

SEM TyAGItf
  | AGItf       lhs         .   quTy            =   mkTyQuEx @hereQu @qBndTvL @qBndExTvL @ty.quTy

SEM Ty
  | Var         lhs         .   quTy            =   mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_Var @tv @categ.quTy)
  | App         loc         .   quTy            =   mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_App @func.quTy @arg.quTy)
  | Quant       lhs         .   quTy            =   Ty_Quant @qu.self @tv @ty.quTy
%%]
SEM Ty
  | App         loc         .   quTy            =   mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_App @func.quTy @arg.quTy)
  | Var         lhs         .   quTy            =   tr "Var" (pp @self >#< "coco=" >|< @lhs.coco >#< "isQuLoc=" >|< @isQuLoc >#< ppCommaList @qBndTvL >#< ppCommaList @frTvL) $ mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_Var @tv @categ.quTy)
  | App         loc         .   quTy            =   tr "App" (pp @self >#< "coco=" >|< @lhs.coco >#< "isQuLoc=" >|< @isQuLoc >#< "isQuFxLoc=" >|< @isQuFxLoc >#< "isSpineRoot=" >|< @isSpineRoot >#< ppCommaList @qBndTvL >#< ppCommaList (map ppCommaList @frTvLL)) $ mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_App @func.quTy @arg.quTy)

%%[9 hs
mkTyQuForRank :: Bool -> TyQu -> TyVarIdL -> TyVarIdL -> Ty -> Ty
mkTyQuForRank allow q tvL tvExL t = if allow then mkTyQuEx q tvL tvExL t else t
%%]

%%[9
SEM Ty
  | Var         lhs         .   quTy            :=  mkTyQuForRank @isQuRank @hereQu @qBndTvL @qBndExTvL . mkTyImpls (map poPr @insPrL) $ Ty_Var @tv @categ.quTy
  | App         loc         .   quTy            :=  let  (rwYTvL,rwNTvL) = partition (`elem` @frRowTvL) @qBndTvL
                                                    in   mkTyQuForRank @isQuRank @hereQu rwNTvL @qBndExTvL
                                                         .  mkTyQuForRank @isQuRank @lhs.baseQu rwYTvL []
                                                         .  mkTyImpls (map poPr @insPrL)
                                                         $  (if tqoptLeaveImpls @lhs.opts
                                                             then Ty_App @func.quTy @arg.quTy
                                                             else maybe (Ty_App @func.quTy @arg.quTy) (const @arg.quTy) @func.mbImpls
                                                            )
  | Pred        lhs         .   quTy            =   mkTyQuForRank @isQuRank @hereQu @qBndTvL @qBndExTvL (Ty_Pred @pr.quTy)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preds which have been inserted (from the given ones)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR TyAGItf AllTy [ | | insPrIdSet USE {`Set.union`} {Set.empty} : {Set.Set PredOccId} ]

SEM Ty
  | App         lhs         .   insPrIdSet      =   Set.fromList (map poPoi @insHerePrL) `Set.union` @func.insPrIdSet `Set.union` @arg.insPrIdSet
  | Var         lhs         .   insPrIdSet      =   Set.fromList (map poPoi @insHerePrL)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional bindings for implicits variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
prOccLImpls :: Maybe ImplsVarId -> [PredOcc] -> AssocL ImplsVarId Impls
prOccLImpls mbI prL
  = maybe [] (\i -> [(i,foldr (\p im -> Impls_Cons (poId p) (poPr p) (poPoi p) im) Impls_Nil prL)]) mbI
%%]

%%[9
ATTR TyAGItf [ | | prImpls: {AssocL ImplsVarId Impls} ]
ATTR AllTy [ | prImpls: {AssocL ImplsVarId Impls} | ]

SEM TyAGItf
  | AGItf       ty          .   prImpls         =   []

SEM Ty
  | App         lhs         .   prImpls         =   (if @isArrowRoot then prOccLImpls @lhs.mbPrLoc @insHerePrL else []) ++ @arg.prImpls
  | Var         lhs         .   prImpls         =   prOccLImpls @lhs.mbPrLoc @insHerePrL ++ @lhs.prImpls
%%]

