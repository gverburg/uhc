% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[3 hs import(EHCommon,EHTy,EHCnstr,EHSubstitutable) export(tyQuantify, tyQuantifyClosed)
%%]

%%[4 hs import(EHDebug,UU.Pretty)
%%]

%%[4 hs import(List)
%%]

%%[4 import(EHTyAbsSyn,EHTyCommonAG)
WRAPPER TyAGItf
%%]

%%[6 hs export(kiQuantify)
%%]

%%[9 hs import(Maybe,Set,UU.Pretty) export(tyQuantifyPr,TyQuOut(..),TyQuOpts(..),defaultTyQuOpts)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Ty quantify
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[3.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty = mkTyQu (filter (not.tvIsBound) (ftv ty)) ty
%%]

%%[3.tyQuantifyClosed hs
tyQuantifyClosed :: Ty -> Ty
tyQuantifyClosed = tyQuantify (const False)
%%]

%%[4.tyQuantify -3.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf (TyAGItf_AGItf ty))
                  (Inh_TyAGItf {tvIsBound_Inh_TyAGItf = tvIsBound})
    in   quTy_Syn_TyAGItf t
%%]

%%[6.tyQuantify -4.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty = tyQuantify' tvIsBound TyQu_Forall ty

kiQuantify :: (TyVarId -> Bool) -> Ty -> Ty
kiQuantify tvIsBound ty = tyQuantify' tvIsBound TyQu_KiForall ty
%%]

%%[6.tyQuantifyPrime hs
tyQuantify' :: (TyVarId -> Bool) -> TyQu -> Ty -> Ty
tyQuantify' tvIsBound baseQuant ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf  (TyAGItf_AGItf ty))
                  (Inh_TyAGItf  { baseQu_Inh_TyAGItf        = baseQuant
                                , tvIsBound_Inh_TyAGItf     = tvIsBound })
    in   quTy_Syn_TyAGItf t
%%]

%%[9.tyQuantifyPrime -6.tyQuantifyPrime hs
tyQuantify' :: (TyVarId -> Bool) -> TyQu -> Ty -> Ty
tyQuantify' tvIsBound baseQuant ty = tqoTy (tyQuantifyPr defaultTyQuOpts tvIsBound baseQuant [] ty)
%%]

%%[9 hs
data TyQuOpts  = TyQuOpts  {tqoptLeaveImpls :: Bool}

defaultTyQuOpts :: TyQuOpts
defaultTyQuOpts = TyQuOpts False

data TyQuOut   = TyQuOut   {tqoTy :: Ty, tqoInsPrIdSet :: Set PredOccId, tqoImplsCnstr :: Cnstr}

instance Show TyQuOut where
  show _ = ""

instance PP TyQuOut where
  pp tqo = pp (tqoImplsCnstr tqo)
%%]

%%[9 hs
tyQuantifyPr :: TyQuOpts -> (TyVarId -> Bool) -> TyQu -> [PredOcc] -> Ty -> TyQuOut
tyQuantifyPr opts tvIsBound baseQuant prL ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf  (TyAGItf_AGItf ty))
                  (Inh_TyAGItf  { baseQu_Inh_TyAGItf        = baseQuant
                                , tvIsBound_Inh_TyAGItf     = tvIsBound
                                , opts_Inh_TyAGItf          = opts
                                , prLL_Inh_TyAGItf          = [prL] })
    in   TyQuOut
            { tqoTy = quTy_Syn_TyAGItf t
            , tqoInsPrIdSet = insPrIdSet_Syn_TyAGItf t
            , tqoImplsCnstr = assocLToCnstrImpls (prImpls_Syn_TyAGItf t)
            }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR TyAGItf AllTy [ opts: TyQuOpts | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free type vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.frTvLL
ATTR AllTy [ | | frTvLL USE {++} {[]}: {[TyVarIdL]} ]

SEM TyAGItf
  | AGItf       loc         .   frTvL       =   head @ty.frTvLL

SEM Ty
  | Var         loc         .   frTvL       =   [@tv]
  | App         loc         .   frTvLL      =   @arg.frTvLL ++ @func.frTvLL
                            .   frTvL       =   listCombineUniq @frTvLL
                lhs         .   frTvLL      =   if @isSpineRoot then [@frTvL] else @frTvLL
  | Quant       loc         .   frTvL       =   head @ty.frTvLL \\ @introTVarL
  | Any Con     loc         .   frTvL       =   []
  | Quant Var Any Con
                lhs         .   frTvLL      =   [@frTvL]
%%]

%%[4_2
SEM TyL
  | Nil         lhs         .   frTvLL      =   []

SEM TyPlusL
  | Nil         lhs         .   frTvLL      =   []
%%]

%%[7
SEM Ty
  | Ext         loc         .   frTvLL      =   @extTy.frTvLL ++ @ty.frTvLL
%%]

%%[9
SEM Ty
  | App         (loc.frRowTvL,loc.frTvLL)   :=  if @argIsRow
                                                then hdAndTl (reverse @arg.frTvLL)
                                                else ([],@arg.frTvLL ++ @func.frTvLL)
                loc         .   frTvL       :=  listCombineUniq (@frRowTvL : @frTvLL)
                            .   arrArgTvL   =   @frTvLL !! 1
  | Pred        loc         .   frTvL       =   listCombineUniq @pr.frTvLL
  | Impls       loc         .   frTvL       =   listCombineUniq @impls.frTvLL
  | Pred Impls  lhs         .   frTvLL      =   [@frTvL]

SEM Impls
  | Tail Nil    lhs         .   frTvLL      =   []
  | Cons        lhs         .   frTvLL      =   @pr.frTvLL ++ @tl.frTvLL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free row vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[99
ATTR Ty [ | | frRowTvL: TyVarIdL ]

SEM Ty
  | Ext         lhs         .   frRowTvL    =   @ty.frRowTvL
  | App         loc         .   frRowTvL    =   @func.frRowTvL `List.union` @arg.frRowTvL
  | * - App Ext
                lhs         .   frRowTvL    =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine co- contravariance of place in type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.coco
ATTR AllTy [ coco: CoContraVariance | | ]

SEM Ty
  | App         func        .   coco        =   CoContraVariant
                arg         .   coco        =   if          @appIsLikeProd                  then  @lhs.coco
                                                else  if    @isArrowRoot                    then  CoVariant
                                                else  if    @appIsArrow                     then  ContraVariant
                                                                                            else  CoContraVariant

SEM TyAGItf
  | AGItf       ty          .   coco        =   CoVariant
%%]

%%[9
SEM Ty
  | Pred        pr          .   coco        =   CoContraVariant

SEM Pred
  | Pred  		ty          .   coco        =   CoVariant
  | Class  		ty          .   coco        =   CoContraVariant
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is type a candidate where quantification can take place?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.isQuLoc
SEM Ty
  | Var App Quant
                loc         .   isQuLoc     =   @lhs.coco /= CoContraVariant
%%]

%%[9
SEM Ty
  | Pred        loc         .   isQuLoc     =   @lhs.coco /= CoContraVariant
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Candidate free type variables to be quantified over 'here'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.tvarOccurCount hs
tvarOccurCount :: [TyVarIdL] -> AssocL TyVarId Int
tvarOccurCount = map (\vl@(v:_) -> (v,length vl)) . group . sort . concat

tvarOccurGE2 :: [TyVarIdL] -> TyVarIdL
tvarOccurGE2 =  map fst . filter ((>1).snd) . tvarOccurCount
%%]

%%[4.qHereTvL
SEM TyAGItf
  | AGItf       loc         .   qHereTvL        =   []

SEM Ty
  | Var         loc         .   qHereTvL        =   if @isQuLoc then [@tv] else []
  | App         loc         .   qHereTvL        =   if @isQuLoc
                                                    then  if    @appIsArrow || @appIsLikeProd
                                                          then  tvarOccurGE2 @frTvLL
                                                          else  @frTvL
                                                    else  []
%%]

%%[9
SEM Ty
  | App         loc         .   qHereTvL        :=  if @isQuLoc
                                                    then  if    @appIsArrow || @appIsLikeProd
                                                          then  tvarOccurGE2 @frTvLL `List.union` @frRowTvL
                                                          else  @frTvL
                                                    else  []
  | Pred        loc         .   qHereTvL        =   @frTvL \\ @pr.qInsideTvL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inside 'here' tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTy [ | | qInsideTvL USE {++} {[]}: TyVarIdL ]

SEM Ty
  | App			lhs			.	qInsideTvL		=	@qHereTvL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Surrounding tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTy [ qSurrTvL: TyVarIdL | | ]

SEM TyAGItf
  | AGItf       loc         .   qSurrTvL                =   @qHereTvL

SEM Ty
  | App Var     loc         .   qSurrTvL                =   @qHereTvL ++ @lhs.qSurrTvL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The implicit preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR Ty [ | | mbImpls: {Maybe Impls} ]

SEM Ty
  | Impls       lhs         .   mbImpls                 =   Just @impls.quTy
  | App         lhs         .   mbImpls                 =   if @isArrowArg then @arg.mbImpls else Nothing
  | * - App Impls
                lhs         .   mbImpls                 =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Can predicates be inserted at location in ty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTy [ mbPrLoc: {Maybe ImplsVarId} | | ]

SEM TyAGItf
  | AGItf       ty          .   mbPrLoc                 =   Nothing

SEM Ty
  | App         loc         .   (implsPrL,mbTail)       =   if tqoptLeaveImpls @lhs.opts
                                                            then ([],Nothing)
                                                            else maybe ([],Nothing) implsPredsMbTail @func.mbImpls
                arg         .   mbPrLoc                 =   @mbTail
  | Var         loc         .   implsPrL                =   []
  | * - App Var Con Any
                loc         .   mbPrLoc                 =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine insertable preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
prLLArrowSplit :: [TyVarId] -> [[PredOcc]] -> ([PredOcc],[[PredOcc]])
prLLArrowSplit frTvL prLL
  =  let  (h,r) = partition (all (`elem` frTvL) . ftv) . concat $ prLL
     in   (h,[r])
%%]

%%[9
ATTR TyAGItf AllTy [ prLL: {[[PredOcc]]} | | ]

SEM Ty
  | Var         loc         .   (herePrL,_)             =   prLLArrowSplit @qSurrTvL @lhs.prLL
  | App         (loc.herePrL,func.prLL,arg.prLL)        =   if @isSpineRoot
                                                            then  if @appIsArrow
                                                                  then  let  (h,r) = prLLArrowSplit (@arrArgTvL ++ @lhs.qSurrTvL) @lhs.prLL
                                                                        in   (h,[],r)
                                                                  else  let  (h,_) = prLLArrowSplit (@frTvL ++ @lhs.qSurrTvL) @lhs.prLL
                                                                        in   (h,[],[])
                                                            else  ([],[],[])
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pass preds up to pred insertable location
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTy [ | | insPrL USE {++} {[]} : {[PredOcc]} ]

SEM Ty
  | App         loc         .   candPrL         =   @herePrL ++ @func.insPrL ++ @arg.insPrL
  | Var         loc         .   candPrL         =   @herePrL
  | App Var     (loc.insHerePrL,lhs.insPrL)     =   maybe ([],@candPrL) (const (@candPrL,[])) @lhs.mbPrLoc
                loc         .   insPrL          =   @implsPrL ++ @insHerePrL
                            .   hasNoInsPrL     =   null @insPrL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine quantifiable tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.tvarsToQuant hs
tvBoundAdd :: (TyVarId -> Bool) -> TyVarIdL -> TyVarId -> Bool
tvBoundAdd tvIsBound tvL = \v -> v `elem` tvL || tvIsBound v

tvarsToQuant :: Bool -> (TyVarId -> Bool) -> TyVarIdL -> (TyVarIdL,TyVarId -> Bool)
tvarsToQuant isQuLoc tvIsBound tvL
  =  if isQuLoc
     then  let boundables = filter (not . tvIsBound) tvL
           in (boundables,tvBoundAdd tvIsBound boundables)
     else  ([],tvIsBound)
%%]

%%[4.tvIsBound
ATTR TyAGItf AllTy [ tvIsBound: {TyVarId -> Bool} | | ]

SEM TyAGItf
  | AGItf       loc         .   (qBndTvL,tvIsBound)     =   tvarsToQuant True @lhs.tvIsBound @qHereTvL

SEM Ty
  | App Var     loc         .   (qBndTvL,tvIsBound)     =   tvarsToQuant @isQuLoc @lhs.tvIsBound @qHereTvL
  | Quant       loc         .   tvIsBound               =   tvBoundAdd @lhs.tvIsBound @introTVarL
%%]

%%[9
SEM Ty
  | App Var     loc         .   (qBndTvL,tvIsBound)     :=  tvarsToQuant @isQuLoc @lhs.tvIsBound (@qHereTvL `List.union` ftv @candPrL)
%%]

%%[9
SEM Ty
  | Pred        loc         .   (qBndTvL,tvIsBound)     =   tvarsToQuant @isQuLoc @lhs.tvIsBound @qHereTvL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which quantifier to use for quantification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.hereQu
SEM TyAGItf
  | AGItf       loc         .   hereQu          =   TyQu_Forall

SEM Ty
  | App         loc         .   qAsExist        =   @appIsLikeProd || @lhs.coco == ContraVariant && not @appIsArrow
  | Var         loc         .   qAsExist        =   @lhs.coco == ContraVariant
  | App Var     loc         .   hereQu          =   if @qAsExist then TyQu_Exists else TyQu_Forall
  | Quant       loc         .   hereQu          =   @qu.self
%%]

%%[6.hereQu
ATTR TyAGItf AllTy [ baseQu: TyQu | | ]

SEM TyAGItf
  | AGItf       loc         .   hereQu          :=  @lhs.baseQu

SEM Ty
  | App Var     loc         .   hereQu          :=  if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu
%%]

%%[9.hereQu
SEM Ty
  | App         loc         .   qAsExist        :=  @hasNoInsPrL && (@appIsLikeProd || @lhs.coco == ContraVariant && not @appIsArrow)
  | Var         loc         .   qAsExist        :=  @hasNoInsPrL && @lhs.coco == ContraVariant
%%]

%%[9
SEM Ty
  | Pred        loc         .   qAsExist        =   @lhs.coco == ContraVariant
                            .   hereQu          =   if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Quantified type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.quTy
ATTR TyAGItf [ | | quTy: Ty ]
ATTR AllTy TyQu TyVarCateg [ | | quTy: SELF ]

SEM TyAGItf
  | AGItf       lhs         .   quTy            =   mkTyQu @hereQu @qBndTvL @ty.quTy

SEM Ty
  | Var         lhs         .   quTy            =   mkTyQu @hereQu @qBndTvL (Ty_Var @tv @categ.quTy)
  | App         loc         .   quTy            =   mkTyQu @hereQu @qBndTvL (Ty_App @func.quTy @arg.quTy)
  | Quant       lhs         .   quTy            =   Ty_Quant @qu.self @tv @ty.quTy
%%]

%%[9
SEM Ty
  | Var         lhs         .   quTy            :=  mkTyQu @hereQu @qBndTvL . mkTyPr (map poPr @insPrL) $ Ty_Var @tv @categ.quTy
  | App         loc         .   quTy            :=  mkTyQu @hereQu (filter (`notElem` @frRowTvL) @qBndTvL)
                                                    .  mkTyQu @lhs.baseQu (filter (`elem` @frRowTvL) @qBndTvL)
                                                    .  mkTyPr (map poPr @insPrL)
                                                    $  (if tqoptLeaveImpls @lhs.opts
                                                        then Ty_App @func.quTy @arg.quTy
                                                        else maybe (Ty_App @func.quTy @arg.quTy) (const @arg.quTy) @func.mbImpls
                                                       )
  | Pred        lhs         .   quTy            =   mkTyQu @hereQu @qBndTvL (Ty_Pred @pr.quTy)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preds which have been inserted (from the given ones)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR TyAGItf AllTy [ | | insPrIdSet USE {`Set.union`} {emptySet} : {Set PredOccId} ]

SEM Ty
  | App         lhs         .   insPrIdSet      =   mkSet (map poId @insHerePrL) `Set.union` @func.insPrIdSet `Set.union` @arg.insPrIdSet
  | Var         lhs         .   insPrIdSet      =   mkSet (map poId @insHerePrL)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional bindings for implicits variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
prOccLImpls :: Maybe ImplsVarId -> [PredOcc] -> AssocL ImplsVarId Impls
prOccLImpls mbI prL
  = maybe [] (\i -> [(i,foldr (\p im -> Impls_Cons (poId p) (poPr p) (poId p) im) Impls_Nil prL)]) mbI
%%]

%%[9
ATTR TyAGItf [ | | prImpls: {AssocL ImplsVarId Impls} ]
ATTR AllTy [ | prImpls: {AssocL ImplsVarId Impls} | ]

SEM TyAGItf
  | AGItf       ty          .   prImpls         =   []

SEM Ty
  | App         lhs         .   prImpls         =   (if @isArrowRoot then prOccLImpls @lhs.mbPrLoc @insHerePrL else []) ++ @arg.prImpls
  | Var         lhs         .   prImpls         =   prOccLImpls @lhs.mbPrLoc @insHerePrL ++ @lhs.prImpls
%%]

