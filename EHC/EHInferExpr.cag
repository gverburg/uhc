% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type inferencing for Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Known type distr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.knTy
ATTR AllExpr [ knTy: Ty | | ]
%%]

%%[1.knTy.AGItf
SEM AGItf
  | AGItf       expr        .  knTy         =  Ty_Any
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type of Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[2.tyCnstr
ATTR AllExpr [ | tyCnstr: Cnstr | ]
%%]

%%[4_2
ATTR AllExpr [ | | imprTy: Ty ]
%%]

%%[1.Const
ATTR AllExpr [ | | ty: Ty ]

SEM Expr
  | CConst      loc         .   fTy                 =   tyChar
  | IConst      loc         .   fTy                 =   tyInt
  | IConst CConst
                loc         .   fo                  =   @fTy `fitsIn` @lhs.knTy
                            .   ty                  =   foTy @fo
%%]

%%[2.Const
SEM Expr
  | IConst CConst
                loc         .   fo                  :=  @fTy `fitsIn` (@lhs.tyCnstr |=> @lhs.knTy)
                lhs         .   tyCnstr             =   foCnstr @fo |=> @lhs.tyCnstr
%%]

%%[4.Rest
SEM Expr
  | IConst CConst
                loc         .   fo                  :=  fitsIn @lhs.fiOpts @fe @lUniq @fTy (@lhs.tyCnstr |=> @lhs.knTy)
%%]

%%[4_2
SEM Expr
  | CConst IConst
                loc         .   imprTy              =   @fTy
%%]

%%[1.Var
SEM Expr
  | Var         loc         .   (gTy,nmErrs)
                                                    =   valGamLookupTy @lhs.valGam @nm
                            .   fTy                 =   @gTy
                            .   fo                  =   @fTy `fitsIn` @lhs.knTy
                            .   ty                  =   foTy @fo
%%]

%%[2.Var
SEM Expr
  | Var         loc         .   fTy                 :=  @lhs.tyCnstr |=> @gTy
                            .   fo                  :=  @fTy `fitsIn` (@lhs.tyCnstr |=> @lhs.knTy)
                lhs         .   tyCnstr             =   foCnstr @fo |=> @lhs.tyCnstr
%%]

%%[3.Var
SEM Expr
  | Var         loc         .   fTy                 :=  @lhs.tyCnstr |=> tyInst @lUniq @gTy
%%]

%%[4.Var
SEM Expr
  | Var         loc         .   fo                  :=  fitsIn @lhs.fiOpts @fe @lUniq @fTy (@lhs.tyCnstr |=> @lhs.knTy)
                            .   fTy                 :=  @lhs.tyCnstr |=> @gTy
%%]

%%[4_2
SEM Expr
  | Var         loc         .   imprTy              =   @lhs.imprTyCnstr |=> @gTy
%%]

%%[1.Con
SEM Expr
  | Con         loc         .   ty                  =   let  resTy = tyArrowRes @lhs.knTy
                                                        in   tyProdArgs resTy `mkTyArrow` resTy
%%]

%%[2.Con
SEM Expr
  | Con         loc         .   fo                  =   let  gTy      = mkTyFreshProdFrom @lUniq (hsnProdArity @nm)
                                                             foKnRes  = gTy `fitsIn` (@lhs.tyCnstr |=> tyArrowRes @lhs.knTy)
                                                        in   foKnRes {foTy =  tyProdArgs (foTy foKnRes)
                                                                                `mkTyArrow` (foTy foKnRes)}
                            .   ty                  :=  foTy @fo
                lhs         .   tyCnstr             =   foCnstr @fo |=> @lhs.tyCnstr
%%]

%%[4.Con
SEM Expr
  | Con         loc         .   (gTy,nmErrs)        :=  valGamLookupTy @lhs.valGam @nm
                            .   fTy                 :=  @lhs.tyCnstr |=> @gTy
                            .   fo                  :=  fitsIn @lhs.fiOpts @fe @lUniq2 @fTy (@lhs.tyCnstr |=> @lhs.knTy)
%%]

%%[4_2
SEM Expr
  | Con         loc         .   imprTy              =   @lhs.imprTyCnstr |=> @gTy
%%]

%%[1.App
SEM Expr
  | App         loc         .   knFunTy             =   [Ty_Any] `mkTyArrow` @lhs.knTy
                func        .   knTy                =   @knFunTy
                (arg.knTy,loc.fTy)                  =   tyArrowArgRes @func.ty
                loc         .   ty                  =   @fTy
%%]

%%[2.App
SEM Expr
  | App         loc         .   knFunTy             :=  [mkNewTyVar @lUniq] `mkTyArrow` @lhs.knTy
                            .   ty                  :=  @arg.tyCnstr |=> @fTy
%%]

%%[4_2
SEM Expr
  | App         loc         .   (imprArgTy,imprResTy)
                                                    =   let [a,r] = mkNewTyVarL 2 @lUniq in (a,r)
                            .   knFunTy             :=  [@imprArgTy] `mkTyArrow` @imprResTy
                arg         .   knTy                :=  @imprArgTy
                loc         .   imprFO1             =   fitsIn  (@argFIOpts {fioBindToTyAlts = True}) @fe @lUniq2
                                                                @arg.imprTy @imprArgTy
                            .   imprTyCnstr1        =   foCnstr @imprFO1 |=> @arg.imprTyCnstr
                            .   imprFO2             =   fitsIn  impredFIOpts @fe @lUniq3
                                                                (@imprTyCnstr1 |=> @func.imprTy)
                                                                (@imprTyCnstr1 |=> @knFunTy)
                            .   imprTy              =   foCnstr @imprFO2 |=> @imprResTy
                lhs         .   imprTyCnstr         =   foCnstr @imprFO2 |=> @imprTyCnstr1
  | App         loc         .   fo                  =   fitsIn strongFIOpts @fe @lUniq4 (@lhs.tyCnstr |=> @imprResTy) (@lhs.tyCnstr |=> @lhs.knTy)
                func        .   tyCnstr             =   foCnstr @fo |=> @lhs.tyCnstr
%%]

%%[9.App
SEM Expr
  | App         loc         .   (knFunTy,imTy)      :=  let  [i,a] = mkNewUIDL 2 @lUniq
                                                             im = mkImplsVar i
                                                        in   ([im,mkTyVar a] `mkTyArrow` @lhs.knTy,im)
                (_,arg.knTy,loc.fTy)                :=  tyArrowImplsArgRes @func.ty
                loc         .   prOccL              =   tyImplsPreds (@arg.tyCnstr |=> @imTy)
%%]

%%[9_1.App
SEM Expr
  | App         (_,arg.knTy,loc.fTy)                :=  tyArrowImplsArgRes . tyAltsTy $ @func.ty
%%]

%%[9.AppImpl
SEM Expr
  | AppImpl     loc         .   knFunTy             =   [@argPr.ty] `mkTyArrow` @lhs.knTy
                func        .   knTy                =   @knFunTy
                loc         .   (knImpls,fTy)       =   tyArrowImplsRes @func.ty
                            .   (knArgImpl,knResImpls)
                                                    =   case @knImpls of
                                                            (a:r)  -> (a,r)
                                                            []     -> (Ty_Any,[])
                            .   foPr                =   fitPredToEvid @lUniq @knArgImpl @lhs.prIntroGam
                arg         .   knTy                =   @func.tyCnstr |=> foTy @foPr
                            .   tyCnstr             =   foCnstr @foPr |=> @func.tyCnstr
                loc         .   ty                  =   @arg.tyCnstr |=> (@knResImpls `mkTyArrow` @fTy)
%%]

%%[1.Lam
SEM Expr
  | Lam         loc         .   funTy               =   [Ty_Any] `mkTyArrow` Ty_Any
                            .   foKnFun             =   @funTy `fitsIn` @lhs.knTy
                (arg.knTy,body.knTy)                =   tyArrowArgRes (foTy @foKnFun)
                arg         .   valGam              =   gamPushNew @lhs.valGam
                loc         .   ty                  =   @lhs.knTy
%%]

%%[2.Lam
SEM Expr
  | Lam         loc         .   (argTy,resTy,funTy)
                                                    :=  let  [a,r] = mkNewTyVarL 2 @lUniq
                                                        in   (a,r,[a] `mkTyArrow` r)
                            .   foKnFun             :=  @funTy `fitsIn` (@lhs.tyCnstr |=> @lhs.knTy)
                arg         .   knTy                :=  @argTy
                            .   tyCnstr             =   foCnstr @foKnFun |=> @lhs.tyCnstr
                body        .   knTy                :=  @resTy
                loc         .   bodyTyCnstr         =   @body.tyCnstr
                            .   ty                  :=  [@bodyTyCnstr |=> @arg.ty] `mkTyArrow` @body.ty
%%]

%%[4.Lam
SEM Expr
  | Lam         loc         .   lamKnTyCnstr        =   @lhs.tyCnstr
                            .   foKnFun             :=  let  fo = fitsIn @knFunFIOpts @fe @lUniq2 @funTy (@lamKnTyCnstr |=> @lhs.knTy)
                                                        in   fo {foTy = foCnstr fo |=> @funTy}
%%]

%%[4_2
SEM Expr
  | Lam         loc         .   imprFoKnFun         =   let  fo = fitsIn @knFunFIOpts @fe @lUniq2 @funTy (@lhs.imprTyCnstr |=> @lhs.knTy)
                                                        in   fo {foTy = foCnstr fo |=> @funTy}
                arg         .   tyCnstr             :=  foCnstr @imprFoKnFun |=> @lhs.imprTyCnstr
                body        .   imprTyCnstr         =   @arg.tyCnstr
                loc         .   (lArgElimValGam,elimImprTyCnstr,errGam)
                                                    =   valGamElimAlts meetFIOpts @fe (ftv @lhs.valGam) @lUniq3 @body.imprTyCnstr (gamTop @arg.valGam)
                loc         .   imprBodyTyCnstr     =   @elimImprTyCnstr |=> @body.imprTyCnstr
                            .   imprTy              =   [@imprBodyTyCnstr |=> @arg.ty] `mkTyArrow` @body.imprTy
                lhs         .   imprTyCnstr         =   @imprBodyTyCnstr
  | Lam         loc         .   lamKnTyCnstr        :=  @lhs.tyCnstr
                            .   foKnFun             :=  let  fo = fitsIn @knFunFIOpts @fe @lUniq2 (@lamKnTyCnstr |=> @funTy) (@lamKnTyCnstr |=> @lhs.knTy)
                                                        in   fo {foTy = foCnstr fo |=> @funTy}
                body        .   tyCnstr             =   foCnstr @foKnFun |=> @lamKnTyCnstr
%%]

%%[9.Lam
SEM Expr
  | Lam         loc         .   (imTy,argTy,resTy,funTy)
                                                    :=  let  [iv,av,rv] = mkNewUIDL 3 @lUniq
                                                             i = mkImplsVar iv
                                                             a = mkTyVar av
                                                             r = mkTyVar rv
                                                        in   (i,a,r,[i,a] `mkTyArrow` r)
                loc         .   (knImpls,_,_)       =   tyArrowImplsArgRes (foTy @foKnFun)
                            .   ty                  :=  ((@bodyTyCnstr |=> @knImpls) ++ [@bodyTyCnstr |=> @arg.ty])
                                                          `mkTyArrow` @body.ty
%%]

%%[11.Lam
SEM Expr
  | Lam         body        .   tyCnstr             =   @arg.tyEqCnstr |=> @arg.tyCnstr
                loc         .   bodyTyCnstr         :=  cnstrDel  (cnstrKeys @arg.tyEqCnstr)
                                                                  @body.tyCnstr
%%]

%%[9.LamImpl
SEM Expr
  | LamImpl     loc         .   funTy               =   let  r = mkNewTyVar @lUniq
                                                        in   [@lhs.tyCnstr |=> @argPr.ty] `mkTyArrow` r
                            .   foKnFun             =   let  fo = fitsIn (implFIOpts {fioBindRFirst=True}) @fe @lUniq2 @funTy (@lhs.tyCnstr |=> @lhs.knTy)
                                                        in   fo {foTy = foCnstr fo |=> @funTy}
                            .   (knImpls,fTy)       =   tyArrowImplsRes (foTy @foKnFun)
                            .   (knArgImpl,knResImpls)
                                                    =   hdAndTl @knImpls
                            .   foPr                =   fitPredToEvid @lUniq4 @knArgImpl @lhs.prIntroGam
                arg         .   knTy                =   foTy @foPr
                            .   tyCnstr             =   foCnstr @foPr |=> foCnstr @foKnFun |=> @lhs.tyCnstr
                body        .   knTy                =   @knResImpls `mkTyArrow` @fTy
                loc         .   ty                  =   [@body.tyCnstr |=> @knArgImpl] `mkTyArrow` @body.ty
%%]

%%[2.AppTop
SEM Expr
  | AppTop      loc         .   knTy                =   tyEnsureNonAny @lUniq @lhs.knTy
%%]

%%[9.AppTop
SEM Expr
  | AppTop      loc         .   resTy               =   let  [i,r] = mkNewUIDL 2 @lUniq
                                                        in   [mkImplsVar i] `mkTyArrow` mkTyVar r
                            .   foKnRes             =   let  fo = fitsIn @lhs.fiOpts @fe @lUniq2 @resTy (@lhs.tyCnstr |=> @lhs.knTy)
                                                        in   fo {foTy = foCnstr fo |=> @resTy}
                            .   (imTy,knTy)         :=  tyArrowArgRes (foTy @foKnRes)
                expr        .   tyCnstr             =   foCnstr @foKnRes |=> @lhs.tyCnstr
                loc         .   ty                  =   [@expr.tyCnstr |=> @imTy] `mkTyArrow` @expr.ty
%%]

%%[8.Undefined
SEM Expr
  | Undefined   loc         .   ty                  =   @lhs.tyCnstr |=> (tyEnsureNonAny @lUniq @lhs.knTy)
%%]

%%[1.TypeAs
SEM Expr
  | TypeAs      loc         .   fo                  =   @tyExpr.ty `fitsIn` @lhs.knTy
                expr        .   knTy                =   @tyExpr.ty
%%]

%%[2.TypeAs
SEM Expr
  | TypeAs      loc         .   tyTy                =   @tyExpr.ty
                            .   asTy                =   @tyTy
                            .   fo                  :=  @asTy `fitsIn` @lhs.knTy
                expr        .   knTy                :=  foCnstr @fo |=> @asTy
                            .   tyCnstr             =   foCnstr @fo |=> @lhs.tyCnstr
%%]

%%[4.TypeAs
SEM Expr
  | TypeAs      loc         .   gTyTvL              =   let  ftvVal  = ftv (@lhs.tyCnstr |=> @lhs.valGam)
                                                             ftvTy   = ftv . (@lhs.tyCnstr |=>) . map (tgiTy.snd) . gamToAssocL $ @lhs.tyGam
                                                        in   ftvVal ++ ftvTy
                            .   tyTy                :=  @lhs.tyCnstr |=> @tyExpr.ty
                            .   asTy                :=  tyQuantify (`elem` (@tyExpr.tyVarWildL ++ @gTyTvL)) @tyTy
                            .   fo                  :=  fitsIn @lhs.fiOpts emptyFE @lUniq (@lhs.tyCnstr |=> @asTy) (@lhs.tyCnstr |=> @lhs.knTy)
%%]

%%[4_2
SEM Expr
  | TypeAs      loc         .   gTyTvL              :=  let  ftvVal  = ftv (@lhs.imprTyCnstr |=> @lhs.valGam)
                                                             ftvTy   = ftv . (@lhs.imprTyCnstr |=>) . map (tgiTy.snd) . gamToAssocL $ @lhs.tyGam
                                                        in   ftvVal ++ ftvTy
                            .   tyTy                :=  @lhs.imprTyCnstr |=> @tyExpr.ty
                            .   imprFO              =   fitsIn (@lhs.fiOpts {fioBindToTyAlts = True}) emptyFE @lUniq2 @expr.imprTy @asTy
                lhs         .   imprTy              =   foTy @imprFO
                            .   imprTyCnstr         =   foCnstr @imprFO |=> @expr.imprTyCnstr
%%]
SEM Expr
  | TypeAs      lhs         .   imprTy              =   Ty_Any
                            .   tyCnstr             =   @lhs.tyCnstr
                expr        .   knTy                :=  Ty_Any
SEM Expr
  | TypeAs      lhs         .   imprTy              =   @asTy

%%[10
SEM Expr
  | DynVar      loc         .   ty                  =   Ty_Any
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type is enforced?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
ATTR Expr [ | | isForcedTy: Bool ]
SEM Expr
  | TypeAs      lhs         .   isForcedTy          =   True
  | * - TypeAs Parens
                lhs         .   isForcedTy          =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gamma/Environment for fitting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.FIEnv
SEM Expr
  | *           loc         .   fe                  =   emptyFE
%%]

%%[7.FIEnv
SEM RecExpr
  | *           loc         .   fe                  =   emptyFE
%%]

%%[9.FIEnv -(4.FIEnv 7.FIEnv)
SEM Expr
  | Lam AppTop LamImpl
                loc         .   fe                  =   emptyFE {fePrElimTGam = @lhs.prElimTGam, fePrElimGam = @lhs.prElimGam, fePrfCtxtId = @prfCtxtId}
  | * - Lam AppTop LamImpl
                loc         .   fe                  =   emptyFE {fePrElimTGam = @lhs.prElimTGam, fePrElimGam = @lhs.prElimGam, fePrfCtxtId = @lhs.prfCtxtId}

SEM RecExpr
  | *           loc         .   fe                  =   emptyFE {fePrElimTGam = @lhs.prElimTGam, fePrElimGam = @lhs.prElimGam, fePrfCtxtId = @lhs.prfCtxtId}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Records
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7
SEM RecExpr
  | Empty       loc         .   fo                  =   fitsIn (@lhs.fiOpts) @fe @lUniq tyRecEmpty (@lhs.tyCnstr |=> @lhs.knTy)
                            .   ty                  =   foTy @fo
                lhs         .   tyCnstr             =   foCnstr @fo |=> @lhs.tyCnstr
  | Ext Upd     loc         .   knRecTy             =   let  [r,e] = mkNewTyVarL 2 @lUniq
                                                        in   (hsnRec `mkTyConApp` [r]) `mkTyRecExt` [(@nm,e)]
                            .   foKnRec             =   fitsIn strongFIOpts @fe @lUniq2 @knRecTy (@lhs.tyCnstr |=> @lhs.knTy)
                (loc.knRecHasLab,loc.recKnTlTy,expr.knTy)
                                                    =   maybe (False,foTy @foKnRec,Ty_Any) (\(r,e) -> (True,r,e)) . tyRecExtr @nm . foTy $ @foKnRec
                recExpr     .   tyCnstr             =   foCnstr @foKnRec |=> @lhs.tyCnstr
                loc         .   ty                  =   @expr.tyCnstr |=> foTy @foKnRec
  | Ext         recExpr     .   knTy                =   @recKnTlTy
                            .   fiOpts              =   @lhs.fiOpts {fioNoRLabElimFor = @nm : fioNoRLabElimFor @lhs.fiOpts}
                loc         .   recTy               =   @expr.tyCnstr |=> @recExpr.ty
  | Upd         recExpr     .   knTy                =   if @knRecHasLab then @recKnTlTy `mkTyRecExt` [(@nm,mkNewTyVar @lUniq3)] else @recKnTlTy
                loc         .   recTy               =   (@expr.tyCnstr |=>) . maybe Ty_Any fst . tyRecExtr @nm $ @recExpr.ty

SEM Expr
  | Sel         expr        .   knTy                =   (hsnRec `mkTyConApp` [mkNewTyVar @lUniq]) `mkTyRecExt` [(@lbl,@lhs.knTy)]
                loc         .   (recTy,ty)          =   maybe (Ty_Any,Ty_Any) id (tyRecExtr @lbl @expr.ty)
  | Rec         loc         .   knRecTy             =   let  r = mkNewTyVar @lUniq
                                                        in   hsnRec `mkTyConApp` [r]
                            .   fo                  =   fitsIn @fiOpts @fe @lUniq2 @knRecTy (@lhs.tyCnstr |=> @lhs.knTy)
                recExpr     .   knTy                =   foCnstr @fo |=> @knRecTy
                            .   tyCnstr             =   foCnstr @fo |=> @lhs.tyCnstr
                loc         .   ty                  =   @recExpr.tyCnstr |=> foTy @fo
%%]

%%[9
SEM Expr
  | Sel         expr        .   knTy                :=  [Ty_Impls Impls_Nil] `mkTyArrow` ((hsnRec `mkTyConApp` [mkNewTyVar @lUniq]) `mkTyRecExt` [(@lbl,@lhs.knTy)])
                loc         .   (recTy,ty)          :=  maybe (Ty_Any,Ty_Any) id (tyRecExtr @lbl . snd . tyArrowImplsRes $ @expr.ty)
%%]



