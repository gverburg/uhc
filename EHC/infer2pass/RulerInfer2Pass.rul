
-- -----------------------------------------------------------------------------------------
-- - Externally defined
-- -----------------------------------------------------------------------------------------

external Ty_Int

-- -----------------------------------------------------------------------------------------
-- - Formatting
-- -----------------------------------------------------------------------------------------

format tex Ty_Int = Int

format tex Gam = Gamma
format tex gam = Gamma

format tex ty = tau
format tex pty = sigma
format tex mty = tau

format tex tv = v

format tex cnstr.inh = Cnstr..k
format tex cnstr.syn = Cnstr
format tex cnstr     = Cnstr

format ag cnstr     = c
format ag gam       = g

-- -----------------------------------------------------------------------------------------
-- - Rewriting
-- -----------------------------------------------------------------------------------------

rewrite ag def  (a | Ty) -> (r | Ty) = ((a) `Ty_Arr` (r) | Ty)

rewrite ag def  (c1 | Cnstr) (c2 | Cnstr) (v | a)
                  = (c1 |=> c2 |=> (v) | a)

rewrite ag def  (c | Cnstr) (v | a) = (c |=> (v) | a)
rewrite ag def  i :-> t = ([(i,t)] | Gam)
rewrite ag def  (g1 | Gam), (g2 | Gam) = ((g1) ++ (g2) | Gam)

-- -----------------------------------------------------------------------------------------
-- - View hierarchy
-- -----------------------------------------------------------------------------------------

viewhierarchy = HM < K

-- -----------------------------------------------------------------------------------------
-- - Expr scheme
-- -----------------------------------------------------------------------------------------

scheme expr "Expr" =
  view HM =
    holes [ node e: Expr, gam: Gam | thread cnstr: Cnstr | ty: Ty ]
    judgespec cnstr.inh ; gam :-.."e" e : ty ~> cnstr.syn

-- -----------------------------------------------------------------------------------------
-- - Expr rules
-- -----------------------------------------------------------------------------------------

ruleset expr.base scheme expr  "Expression type rules" =
  rule e.int "Int" =
    view HM =
      -
      judge R : expr = cnstr..k ; gam :- int : Ty_Int ~> cnstr..k

  rule e.var "Var" =
    view HM =
      judge G : gamLookupIdTy = i :-> pty `elem` gam
      judge I : tyInst = ty `=` inst(pty)
      -
      judge R : expr = cnstr..k ; gam :- i : ty ~> cnstr..k

  rule e.app "App" =
    view HM =
      judge V : tvFresh  =  tv
      judge M : match    =  (ty.a -> tv) <=> (cnstr.a ty.f) ~> cnstr
      judge A : expr = cnstr.f ; gam :- a : ty.a ~> cnstr.a
      judge F : expr = cnstr..k ; gam :- f : ty.f ~> cnstr.f
      -
      judge R : expr = cnstr..k ; gam :- ((node 1 = f) (node 2 = a)) : (cnstr cnstr.a tv) ~> cnstr cnstr.a

  rule e.lam "Lam" =
    view HM =
      judge V : tvFresh = tv
      judge B : expr = cnstr..k ; ((i :-> tv) , gam) :- b : ty.b ~> cnstr.b
      -
      judge R : expr = cnstr..k ; gam :- (\i -> (node 1 = b)) : (cnstr.b tv -> ty.b) ~> cnstr.b

  rule e.let "Let" =
    view HM =
      judge V : tvFresh = tv
      judge D : expr = cnstr..k ; ((i :-> tv) , gam) :- e : ty.e ~> cnstr.e
      judge B : expr = cnstr.e ; ((i :-> pty.e), gam) :- b : ty.b ~> cnstr.b
      judge G : tyGen = pty.e `=` ty.e \\ (cnstr.e gam)
      -
      judge R : expr = cnstr..k ; gam :- (let i `=` (node 1 = e) in (node 2 = b)) : ty.b ~> cnstr.b

-- -----------------------------------------------------------------------------------------
-- - Match two types
-- -----------------------------------------------------------------------------------------

relation match =
  view HM =
    holes [ ty.l: Ty, ty.r: Ty | | cnstr: Cnstr ]
    judgespec ty.l <=> ty.r ~> cnstr
    judgeuse ag (cnstr,mtErrs) `=` (ty.l) <=> (ty.r)

-- -----------------------------------------------------------------------------------------
-- - Lookup ty in gam
-- -----------------------------------------------------------------------------------------

relation gamLookupIdTy =
  view HM =
    holes [ nm: Nm, gam: Gam | | ty: Ty ]
    judgespec nm :-> ty `elem` gam
    judgeuse ag (ty,nmErrs) `=` gamLookup nm gam

-- -----------------------------------------------------------------------------------------
-- - Fresh type variables
-- -----------------------------------------------------------------------------------------

relation tvFresh =
  view HM =
    holes [ | | tv: Ty ]
    judgespec tv
    judgeuse tex tv (text "fresh")
    judgeuse ag tv `=` Ty_Var unique

-- -----------------------------------------------------------------------------------------
-- - Type instantiation
-- -----------------------------------------------------------------------------------------

relation tyInst =
  view HM =
    holes [ ty: Ty | | ty.i: Ty ]
    judgespec ty.i `=` inst(ty)
    judgeuse ag ty.i `=` tyInst unique (ty)

-- -----------------------------------------------------------------------------------------
-- - Type generalisation
-- -----------------------------------------------------------------------------------------

relation tyGen =
  view HM =
    holes [ ty: Ty, gam: Gam | | pty: Ty ]
    judgespec pty `=` ty \\ gam
    judgeuse tex pty `=` forall (ftv(ty) \\ ftv(gam)) `.` ty
    judgeuse ag  (retain pty) `=` mkTyAll (ftv(ty) \\ ftv(gam)) (ty)

