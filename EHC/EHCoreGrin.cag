% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Code's GRIN gen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(Maybe,List,Set,FiniteMap,UU.Pretty,EHCommon,EHCore,EHTy,GrinCode,Char) export(cmodGrin)
%%]

%%[8.WRAPPER import(EHCoreAbsSyn,EHCoreCommonLev)
WRAPPER CodeAGItf
%%]

%%[8 hs
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodGrin :: UID -> CModule -> GrModule
cmodGrin uniq cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf {gUniq_Inh_CodeAGItf = uniq})
     in   grMod_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CModule
  | Mod         (loc.gUniq2,loc.lUniq,loc.lUniq2,loc.lUniq3,loc.lUniq4,loc.lUniq5)
                                            =   mkNewLevUID5  @lhs.gUniq
                (expr.gUniq,loc.lUniq6)     =   mkNewLevUID   @gUniq2

SEM CExpr
  | Var         (lhs.gUniq,loc.lUniq)       =   mkNewLevUID   @lhs.gUniq
  | TupIns TupUpd TupDel
                (expr.gUniq,loc.lUniq)      =   mkNewUID      @lhs.gUniq
  | App         (func.gUniq,loc.lUniq,loc.lUniq2)
                                            =   mkNewLevUID2  @lhs.gUniq

SEM CBind
  | FFI         (lhs.gUniq,loc.lUniq)       =   mkNewLevUID   @lhs.gUniq

SEM CPat
  | Con         (rest.gUniq,loc.lUniq)      =   mkNewLevUID   @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level, Let's also one level higher
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM CExpr
  | Let         binds       .   lev         =   @lhs.lev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context: strict yes/no, rhs of lam yes/no
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr AllAlt AllBind [ isStrict, isLamBody: Bool | | ]

SEM CModule
  | Mod         expr        .   isStrict    =   True
                            .   isLamBody   =   False

SEM CBind
  | Bind        expr        .   isStrict    =   @lhs.isStrict || not (null @expr.grLamArgL)

SEM CPatBind
  | Bind        offset      .   isStrict    =   True
                            .   isLamBody   =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Known function arity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LamInfoMp = FiniteMap HsName Int
%%]

%%[8
ATTR AllCodeNT [ lamMp: LamInfoMp | | ]

SEM CodeAGItf
  | AGItf       module      .   lamMp       =   emptyFM
%%]

%%[8
ATTR AllBind [ | | bindLamMp USE {`plusFM`} {emptyFM}: LamInfoMp ]
ATTR AllBind [ | | bindCafMp USE {`plusFM`} {emptyFM}: LamInfoMp ]

SEM CBind
  | Bind        lhs         .   (bindLamMp,bindCafMp)
                                            =   if @expr.isLam
                                                then (@nm `unitFM` length @expr.grLamArgL,emptyFM)
                                                else (emptyFM,@nm `unitFM` 0)
  | FFI         loc         .   (argTyL,resTy)
                                            =   tyArrowArgsRes @ty
                lhs         .   bindLamMp   =   @nm `unitFM` length @argTyL

SEM CExpr
  | Let         loc         .   lamMp       =   @lhs.lamMp `plusFM` @binds.bindLamMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% All tags
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
%%]
type TagInfoMp = FiniteMap HsName CTag

mkTMp :: CTag -> TagInfoMp
mkTMp t@(CTag _ _ l)  = l `unitFM` t
mkTMp _               = emptyFM

%%[8
%%]
ATTR AllCodeNT [ | | tagNmMp USE {`plusFM`} {emptyFM}: TagInfoMp ]

SEM CExpr
  | TupIns TupUpd
                lhs         .   tagNmMp     =   @expr.tagNmMp `plusFM` @offset.tagNmMp `plusFM` @fldExpr.tagNmMp `plusFM` mkTMp @tag
  | TupDel      lhs         .   tagNmMp     =   @expr.tagNmMp `plusFM` @offset.tagNmMp `plusFM` mkTMp @tag
  | Tup         lhs         .   tagNmMp     =   mkTMp @tag

SEM CPat
  | Con         lhs         .   tagNmMp     =   @binds.tagNmMp `plusFM` mkTMp @tag

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% All function names (which only live on top level after lambda lifting), ditto CAF's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | lamNmMp USE {`plusFM`} {emptyFM}: LamInfoMp ]
ATTR CExpr [ | | cafNmMp USE {`plusFM`} {emptyFM}: LamInfoMp ]

SEM CExpr
  | Let         lhs         .   lamNmMp     =   @body.lamNmMp `plusFM` @binds.bindLamMp
                            .   cafNmMp     =   @body.cafNmMp `plusFM` @binds.bindCafMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Variables which are passed as parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | asArgNmS USE {`Set.union`} {emptySet}: FvS ]

SEM CExpr
  | Var         loc         .   mbLam       =   case lookupFM @lhs.lamMp @nm of
                                                    Just arity | @lhs.isTopApp
                                                        -> Just arity
                                                    _   -> Nothing
                lhs         .   asArgNmS    =   maybe emptySet (const (unitSet @nm)) @mbLam
  | App         loc         .   mbLam       =   lookupFM @lhs.lamMp @grAppFun
                            .   appArity    =   length @grAppArgL
                lhs         .   asArgNmS    =   @func.asArgNmS
                                                    `Set.union`  maybe @arg.asArgNmS unitSet @arg.mbVar
                                                    `Set.union`  (case @mbLam of
                                                                    Just a | @lhs.isTopApp && @appArity < a
                                                                      -> unitSet @grAppFun
                                                                    _ -> emptySet
                                                                 )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Grin code, top level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CodeAGItf CModule [ | | grMod: GrModule ]

SEM CModule
  | Mod         loc         .   (nmPFun,nmPArg)
                                            =   let  [u1,u2] = mkNewUIDL 2 @lUniq2
                                                in   (HNm ("f_" ++ show u1),HNm ("a_" ++ show u2))
                            .   mkPAppPat   =   \n nL arity -> mkGrPatTagNode (GrTagPApp (arity-(length nL))) 0 n nL
                            .   applyPAltL  =   zipWith
                                                     (\u (n,arity)
                                                       -> let  (uc:um) = mkNewLevUIDL arity u
                                                               nL = take (arity-1) (hsnUniqSupplyL uc)
                                                          in   ((arity,n,nL)
                                                               ,zipWith  (\u a -> let nL = take (a-1) (hsnUniqSupplyL u)
                                                                                  in  (a,n,nL)
                                                                         )
                                                                         um [1..arity-1]
                                                     )         )
                                                     (mkInfNewLevUIDL @lUniq6)
                                                . ((hsnGrApply,2):)
                                                . fmToList
                                                . filterFM (\n _ -> n `elementOf` @expr.asArgNmS)
                                                $ @expr.lamNmMp
                            .   applyPPatValL
                                            =   concat
                                                .  map  (\((arity,n,nL),missAlts)
                                                            ->  (@mkPAppPat n nL arity,GrExpr_Call n (map GrVal_Var (nL ++ [@nmPArg])))
                                                                : map  (\(a,n,nL) -> (@mkPAppPat n nL arity
                                                                                     ,GrExpr_Unit (mkNdPApp n (arity-a) (map GrVal_Var (nL ++ [@nmPArg])))
                                                                       )             )
                                                                       missAlts
                                                        )
                                                $  @applyPAltL
                            .   applyBind   =   let  applyAlts =  map (uncurry GrAlt_Alt) @applyPPatValL
                                                in   GrBind_Bind hsnGrApply [@nmPFun,@nmPArg] (GrExpr_Case (GrVal_Var @nmPFun) applyAlts)
                            .   applyTagMp  =   map  (\(p,v)
                                                        ->  let  (GrPat_Node grT pL) = p
                                                            in   ( (grT,length pL)
                                                                 , case v of
                                                                        GrExpr_Unit (GrVal_Node grT' _)    -> EvApTagTag grT'
                                                                        GrExpr_Call n _                    -> EvApTagVar n
                                                                 )
                                                     )
                                                     @applyPPatValL
                            .   builtinTags =   map (\n -> (n,[(n,CTag n n 0 1)])) grBuiltinTyNmL
                            .   allCTags    =   @builtinTags ++ @ctagsMp
                            .   (evalAltL,mkEvalBind)
                                            =   let  [n1,n2,n3] = map uidHNm . mkNewUIDL 3 $ @lUniq
                                                     mkCAlt u (CTag _ l t a)
                                                        = GrAlt_Alt
                                                            (mkGrPatTagNode GrTagCon t l argL)
                                                            (GrExpr_Unit (GrVal_Var n2))
                                                        where (argL) = take (a) (hsnUniqSupplyL u)
                                                     mkFAlt u (n,arity)
                                                        = GrAlt_Alt
                                                            (mkGrPatTagNode GrTagFun 0 n argL)
                                                            (GrExpr_Seq (GrExpr_Call n (map GrVal_Var argL)) (GrPat_Var n4)
                                                                (GrExpr_Seq (GrExpr_Update n1 (GrVal_Var n4)) GrPat_Empty
                                                                    (GrExpr_Unit (GrVal_Var n4))))
                                                        where (n4:argL) = take (arity+1) (hsnUniqSupplyL u)
                                                     mkPAlt n nL arity
                                                        = GrAlt_Alt
                                                            (@mkPAppPat n (map (hsnPrefix "~") nL) arity)
                                                            (GrExpr_Unit (GrVal_Var n2))
                                                in   (    (zipWith mkCAlt (mkInfNewLevUIDL @lUniq3) $ [ t | (_,ll) <- @allCTags, (_,t) <- ll ])
                                                      ++  [ mkPAlt n nL arity | ((arity,n,nL),_) <- @applyPAltL ]
                                                      ++  [ mkPAlt n nL arity | ((arity,_,_),as) <- @applyPAltL, (_,n,nL) <- as ]
                                                      ++  (zipWith mkFAlt (mkInfNewLevUIDL @lUniq4) . fmToList $ addToFM @expr.lamNmMp hsnGrApply 2)
                                                      ++  (zipWith mkFAlt (mkInfNewLevUIDL @lUniq5) . fmToList $ @expr.cafNmMp)
                                                     ,\alts ->  GrBind_Bind hsnGrEval [n1]
                                                                    (GrExpr_Seq (GrExpr_Fetch n1 Nothing) (GrPat_Var n2)
                                                                      (GrExpr_Case (GrVal_Var n2) alts))
                                                     )
                            .   evalBind    =   @mkEvalBind @evalAltL
                            .   evalTagMp   =   map  (\(GrAlt_Alt p a)
                                                        ->  case p of
                                                                GrPat_Node grT@(GrTag_Lit GrTagFun _ n) pL -> ((grT,length pL),EvApTagVar n)
                                                                GrPat_Node grT pL -> ((grT,length pL),EvApTagUnit)
                                                     )
                                                     @evalAltL
                lhs         .   grMod       =   GrModule_Mod (HNm @baseName)
                                                    (@expr.grBindL ++ [@applyBind,@evalBind])
                                                    @allCTags @evalTagMp @applyTagMp
%%]
  | Mod         loc         .   applyBindL  =   let  [u1,u2] = mkNewUIDL 2 @lUniq2
                                                     nF = HNm ("f_" ++ show u1)
                                                     nA = HNm ("a_" ++ show u2)
                                                     mkAlt n arity argNmL alt
                                                        = GrAlt_Alt
                                                              (mkGrPatTagNode (GrTagPApp (arity-(length argNmL))) 0 n argNmL)
                                                              alt
                                                     mkMissAlt u n arity nArg
                                                        = mkAlt n arity nL
                                                              (GrExpr_Unit (mkNdPApp n (arity-nArg) (map GrVal_Var (nL ++ [nA]))))
                                                        where nL = take (nArg-1) (hsnUniqSupplyL u)
                                                     mkCallAlt u n arity
                                                        = mkAlt n arity nL
                                                              (GrExpr_Call n (map GrVal_Var (nL ++ [nA])))
                                                        where nL = take (arity-1) (hsnUniqSupplyL u)
                                                     applyAlts
                                                       =  concat
                                                          .  zipWith
                                                               (\u (n,arity)
                                                                 -> let  (uc:um) = mkNewLevUIDL arity u
                                                                    in   mkCallAlt uc n arity
                                                                         : zipWith (\u a -> mkMissAlt u n arity a) um [1..arity-1]
                                                               )
                                                               (mkInfNewLevUIDL @lUniq6)
                                                          . fmToList
                                                          . filterFM (\n _ -> n `elementOf` @expr.asArgNmS)
                                                          $ @expr.lamNmMp
                                                in   if null applyAlts
                                                     then []
                                                     else [GrBind_Bind hsnGrApply [nF,nA] (GrExpr_Case (GrVal_Var nF) applyAlts)]
                            .   evalBind    =   let  [n1,n2,n3] = map uidHNm . mkNewUIDL 3 $ @lUniq
                                                     mkCAlt u (CTag _ l t a)
                                                        = GrAlt_Alt
                                                            (mkGrPatTagNode GrTagCon t l argL)
                                                            (GrExpr_Unit (GrVal_Var n2))
                                                        where (argL) = take (a) (hsnUniqSupplyL u)
                                                     mkFAlt u (n,arity)
                                                        = GrAlt_Alt
                                                            (mkGrPatTagNode GrTagFun 0 n argL)
                                                            (GrExpr_Seq (GrExpr_Call n (map GrVal_Var argL)) (GrPat_Var n4)
                                                                (GrExpr_Seq (GrExpr_Update n1 (GrVal_Var n4)) GrPat_Empty
                                                                    (GrExpr_Unit (GrVal_Var n4))))
                                                        where (n4:argL) = take (arity+1) (hsnUniqSupplyL u)
                                                     mkPAlt n nL arity
                                                        = GrAlt_Alt
                                                            (@mkPAppPat n (map (hsnPrefix "~") nL) arity)
                                                            (GrExpr_Unit (GrVal_Var n2))
                                                in   GrBind_Bind hsnGrEval [n1]
                                                        (GrExpr_Seq (GrExpr_Fetch n1 Nothing) (GrPat_Var n2)
                                                          (GrExpr_Case (GrVal_Var n2)
                                                              (   (zipWith mkCAlt (mkInfNewLevUIDL @lUniq3) $ [ t | (_,ll) <- @allCTags, (_,t) <- ll ])
                                                              ++  [ mkPAlt n nL arity | ((arity,n,nL),_) <- @applyPAltL ]
                                                              ++  [ mkPAlt n nL arity | ((arity,_,_),as) <- @applyPAltL, (_,n,nL) <- as ]
                                                              ++  (zipWith mkFAlt (mkInfNewLevUIDL @lUniq4) . fmToList $ addToFM @expr.lamNmMp hsnGrApply 2)
                                                              ++  (zipWith mkFAlt (mkInfNewLevUIDL @lUniq5) . fmToList $ @expr.cafNmMp)
                                                              )
                                                          ))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Grin code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
grE2V :: GrExpr -> Maybe GrVal
grE2V e = case e of {GrExpr_Unit v -> Just v; _ -> Nothing}

grV2HNm :: GrVal -> Maybe HsName
grV2HNm v = case v of {GrVal_Var n -> Just n; _ -> Nothing}

emptyGrExpr = GrExpr_Unit GrVal_Empty

mbMkStrict :: UID -> Bool -> GrVal -> GrExpr
mbMkStrict u isStrict v
  =  if isStrict
     then  let  n = uidHNm u
           in   GrExpr_Seq (GrExpr_Unit v) (GrPat_Var n) (GrExpr_Eval n)
     else  GrExpr_Unit v

retStrict :: Bool -> GrVal -> GrExpr
retStrict isStrict = if isStrict then GrExpr_Unit else GrExpr_Store
%%]

%%[8 hs
mkNdPApp :: HsName -> Int -> GrValL -> GrVal
mkNdPApp f nMiss argL = mkGrTagNode (GrTagPApp nMiss) 0 f argL

mkNdApp :: HsName -> GrValL -> GrVal
mkNdApp f argL = mkGrTagNode GrTagApp 0 hsnGrApply (GrVal_Var f : argL)

mkSq :: GrExpr -> HsName -> GrExpr -> GrExpr
mkSq e1 p e2 = GrExpr_Seq e1 (GrPat_Var p) e2
%%]

%%[8 hs
simplArgL :: UID -> LamInfoMp -> GrValL -> (GrValL,GrExpr->GrExpr)
simplArgL uniq lamMp vL
  =  let  nL = map uidHNm . mkNewUIDL (length vL) $ uniq
     in   foldr  (\(n,a) (aL,wG)
                    ->  case a of
                            GrVal_Var v | isJust mbArity
                                -> (GrVal_Var n : aL,mkSq a' n . wG)
                                where mbArity = lookupFM lamMp v
                                      a' = GrExpr_Store (mkNdPApp v (fromJust mbArity) [])
                            GrVal_Node _ _
                                -> (GrVal_Var n : aL,mkSq (GrExpr_Store a) n . wG)
                            _   -> (a:aL,wG)
                 )
                 ([],id)
          $ zip nL vL

unboxArgL :: UID -> HsName -> GrValL -> (GrValL,GrExpr->GrExpr)
unboxArgL uniq tyNm vL
  =  let  nL = map uidHNm . mkNewUIDL (length vL) $ uniq
     in   foldr  (\(n,a) (aL,wG)
                    ->  case a of
                            GrVal_LitInt _
                                -> (a:aL,wG)
                            _   -> (GrVal_Var n : aL,GrExpr_Seq (GrExpr_Unit a) (mkGrUnbox tyNm n) . wG)
                 )
                 ([],id)
          $ zip nL vL
%%]

%%[8
ATTR CExpr   [ | | grExpr: GrExpr ]
ATTR CExpr   [ | | grBindL USE {++} {[]}: GrBindL ]

SEM CExpr
  | Let         (loc.grExpr,lhs.grBindL,binds.isStrict)
                                            =   if @lhs.lev == cLevOuter
                                                then  (emptyGrExpr
                                                      ,let  
                                                       in   case @categ of
                                                              CBindRec     ->  [GrBind_Rec @binds.grBindL] ++ @body.grBindL
                                                              _            ->  @binds.grBindL ++ @body.grBindL
                                                      ,True
                                                      )
                                                else  (case @categ of
                                                          CBindRec     ->  mkSt (map (\(GrBind_Bind n _ _) -> n) @binds.grBindL)
                                                                           . mkVs @binds.grBindL
                                                                           $ @body.grExpr
                                                                           where  h             = mkGrTagNode GrTagHole 0 hsnUnknown []
                                                                                  mkSt nmL e    = foldr (\n e -> GrExpr_Seq (GrExpr_Store h) (GrPat_Var n) e) e nmL
                                                                                  mkV b n n' n'' e
                                                                                                = GrExpr_Seq b (GrPat_Var n')
                                                                                                    (GrExpr_Seq (GrExpr_Fetch n' Nothing) (GrPat_Var n'')
                                                                                                        (GrExpr_Seq (GrExpr_Update n (GrVal_Var n'')) GrPat_Empty e))
                                                                                  mkVs bs e     = foldr (\(GrBind_Bind n _ v) e -> mkV v n (hsnPrefix "_" n) (hsnPrefix "__" n) e) e bs
                                                          _            ->  foldr  (\(GrBind_Bind n _ v) e -> GrExpr_Seq v (GrPat_Var n) e)
                                                                                  @body.grExpr @binds.grBindL
                                                      ,[]
                                                      ,@categ == CBindStrict
                                                      )
  | Case        loc         .   grExpr      =   @alts.grWrapCase . GrExpr_Case @expr.grVal $ @alts.grAltL
  | App         loc         .   grExpr      =   let  argL = reverse @grAppArgL
                                                     funNm = @grAppFun
                                                     mkE  = retStrict @lhs.isStrict
                                                     n = uidHNm @lUniq
                                                     (argL',wrapGr) = simplArgL @lUniq2 @lhs.lamMp argL
                                                in   case @func.mbTupApp of
                                                        Just t
                                                            ->  let  v  =  case t of
                                                                             CTagRec       -> mkGrRecNode argL'
                                                                             CTag _ l t _  -> mkGrConNode t l argL'
                                                                in   wrapGr (mkE v)
                                                        Nothing
                                                            ->  let  ap = case @mbLam of
                                                                             Just arity
                                                                               | arity == @appArity && @lhs.isStrict
                                                                                   -> GrExpr_Call funNm argL'
                                                                               | arity == @appArity
                                                                                   -> GrExpr_Store (mkGrTagNode GrTagFun 0 funNm argL')
                                                                               | arity > @appArity
                                                                                   -> mkE (mkNdPApp funNm (arity - @appArity) argL')
                                                                               | arity < @appArity && @lhs.isStrict
                                                                                   -> mkSq (GrExpr_Call funNm (take arity argL')) n (GrExpr_App n (drop arity argL'))
                                                                               | otherwise
                                                                                   -> mkSq (GrExpr_Store (mkNdPApp funNm 0 (take arity argL'))) n (GrExpr_Store (mkNdApp n (drop arity argL')))
                                                                             Nothing
                                                                               | @lhs.isStrict
                                                                                   -> mkSq (GrExpr_Eval funNm) n (GrExpr_App n argL')
                                                                               | otherwise
                                                                                   -> GrExpr_Store (mkNdApp funNm argL')
                                                                in   wrapGr ap
  | Var         loc         .   grExpr      =   mbMkStrict @lUniq @lhs.isStrict @grVal
  | Tup Int Char
                loc         .   grExpr      =   retStrict @lhs.isStrict @grVal
  | TupIns TupUpd TupDel
                loc         .   grExpr      =   if @lhs.isTopTup
                                                then  mkGrAdapt @lUniq @lhs.lamMp @lhs.isStrict (reverse @grTupFldL) (maybe hsnUnknown id (grV2HNm @grTupRec))
                                                else  GrExpr_Unit GrVal_Empty
  | * - Let Case App Var Tup Int Char TupIns TupUpd TupDel
                loc         .   grExpr      =   GrExpr_Unit @grVal
%%]

%%[8 hs
type TupAdaptFldL = [(GrVal,GrVal,GrVal->GrVal->GrAdapt)]

mkGrAdapt :: UID -> LamInfoMp -> Bool -> TupAdaptFldL -> HsName -> GrExpr
mkGrAdapt u lamMp isStrict tupFldL tupRecNm
  =  let  [u1,u2] = mkNewLevUIDL 2 u
          (oL,vL,mkAL) = unzip3 tupFldL
          (oL',wrO) = unboxArgL u1 hsnInt oL
          (vL',wrV) = simplArgL u2 lamMp vL
     in   wrV . wrO . retStrict isStrict
          . GrVal_NodeAdapt tupRecNm
          . zipWith3 ($) mkAL oL' $ vL'
%%]

%%[8
ATTR CExpr   [ | | grVal: GrVal ]

SEM CExpr
  | Tup         loc         .   grVal       =   ctag (mkGrRecNode []) (\_ l t _ -> mkGrConNode t l []) @tag
  | Var         loc         .   grVal       =   maybe (GrVal_Var @nm) (\a -> mkNdPApp @nm a []) @mbLam
  | Int         loc         .   grVal       =   (if @lhs.doBox then mkGrBox hsnInt  else id)  (GrVal_LitInt @int)
  | Char        loc         .   grVal       =   (if @lhs.doBox then mkGrBox hsnChar else id)  (GrVal_LitInt (ord @char))
  | * - Int Char Var Tup
                loc         .   grVal       =   GrVal_Empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Do boxing?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ doBox: Bool | | ]

SEM CExpr
  | TupUpd TupIns TupDel
                offset      .   doBox       =   False
                loc         .   doBox       =   True
  | * - TupUpd TupIns TupDel
                loc         .   doBox       =   True

SEM CModule
  | Mod         expr        .   doBox       =   True

SEM CBind
  | Bind        expr        .   doBox       =   True

SEM CPatBind
  | Bind        offset      .   doBox       =   True

SEM CAlt
  | Alt         expr        .   doBox       =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CBind CBindL  [ | | grBindL USE {++} {[]}: GrBindL ]

SEM CBind
  | Bind        lhs         .   grBindL     =   [GrBind_Bind @nm @expr.grLamArgL @expr.grLamBody]
  | FFI         loc         .   (nmRes,nmArgL,nmArgPatL)
                                            =   let  (nmRes:nmArgL) = take (length @argTyL + 1) (hsnUniqSupplyL @lUniq)
                                                     nmArgPatL = map (hsnPrefix "_") nmArgL
                                                in   (nmRes,nmArgL,nmArgPatL)
                lhs         .   grBindL     =   let  mkPat ty n
                                                       =  case tyConNm ty of
                                                            t | t == hsnInt -> mkGrPatConNode 0 t [n]
                                                            _               -> GrPat_Var n
                                                     mkRes ty v
                                                       =  case tyConNm ty of
                                                            t | t == hsnInt -> \e -> GrExpr_Seq e (mkGrUnboxFFI @nmRes) (GrExpr_Unit (mkGrBox t (GrVal_Var v)))
                                                            _               -> id
                                                in   [GrBind_Bind @nm @nmArgL
                                                        (foldr  (\(n,p) e -> GrExpr_Seq (GrExpr_Eval n) p e)
                                                                (mkRes @resTy @nmRes (GrExpr_FFI @impEnt @nmArgPatL))
                                                        . zip @nmArgL
                                                        . zipWith mkPat @argTyL
                                                        $ @nmArgPatL
                                                        )
                                                     ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case, pattern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CAlt    [ | | grAlt: GrAlt ]
ATTR CAltL   [ | | grAltL: GrAltL ]

SEM CAlt
  | Alt         lhs         .   grAlt       =   GrAlt_Alt (head @pats.grPatL) @expr.grExpr

SEM CAltL
  | Cons        lhs         .   grAltL      =   @hd.grAlt : @tl.grAltL
  | Nil         lhs         .   grAltL      =   []
%%]

%%[8
ATTR CPat    [ | | patNm: HsName ]

SEM CPat
  | Var Con     loc         .   patNm       =   cpatNmEither id id @pnm
  | Undef       loc         .   patNm       =   hsnUnknown
%%]

%%[8
ATTR CPat    [ | | grPat: GrPat ]
ATTR CPatL   [ | | grPatL: GrPatL ]

SEM CPat
  | Var         lhs         .   grPat       =   GrPat_Var @patNm
  | Con         lhs         .   (grPat,grWrapCase)
                                            =   let
                                                in   case @rest.self of
                                                        CPatRest_Empty
                                                          ->  (ctag mkGrPatRecNode (\_ l t _ -> mkGrPatConNode t l) @tag @binds.patNmL,id)
                                                        CPatRest_Var r
                                                          ->  let  (oL,mkSL) = unzip @binds.grTupFldL
                                                                   (oL',wrO) = unboxArgL @lUniq hsnInt oL
                                                              in   (ctag mkGrPatRecSplit (\_ l t _ -> mkGrPatConSplit t l) @tag r . zipWith ($) mkSL $ oL',wrO)
  | Undef       lhs         .   grPat       =   GrPat_Empty

SEM CPatL
  | Cons        lhs         .   grPatL      =   @hd.grPat : @tl.grPatL
  | Nil         lhs         .   grPatL      =   []
%%]

%%[8
ATTR CPatBind CPatBindL [ | | patNmL USE {++} {[]}: {[HsName]} ]
ATTR CPatBind CPatBindL [ | | grTupFldL USE {++} {[]}: {[(GrVal,GrVal->GrSplit)]} ]

SEM CPatBind
  | Bind        lhs         .   patNmL      =   [@pat.patNm]
                            .   grTupFldL   =   [(@offset.grVal,\o -> GrSplit_Sel @pat.patNm o)]
%%]

%%[8
ATTR AllPat AllAlt [ | | grWrapCase USE {`const`} {id}: {GrExpr -> GrExpr} ]
%%]

%%[8
ATTR CPatRest [ | | self: SELF ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Record fields
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
%%]

%%[8
ATTR CExpr [ | | grTupRec: GrVal ^^ grTupFldL: TupAdaptFldL ]

SEM CExpr
  | TupIns TupUpd TupDel
                loc         .   grTupRec    =   @expr.grTupRec
  | TupIns      loc         .   grTupFldL   =   (@offset.grVal,@fldExpr.grVal,\o v -> GrAdapt_Ins o v) : @expr.grTupFldL
  | TupUpd      loc         .   grTupFldL   =   (@offset.grVal,@fldExpr.grVal,\o v -> GrAdapt_Upd o v) : @expr.grTupFldL
  | TupDel      loc         .   grTupFldL   =   (@offset.grVal,GrVal_Empty   ,\o _ -> GrAdapt_Del o  ) : @expr.grTupFldL
  | * - TupIns TupUpd TupDel
                loc         .   grTupRec    =   @grVal
                            .   grTupFldL   =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | grLetBody: GrExpr ]

SEM CExpr
  | Let         lhs         .   grLetBody   =   @body.grLetBody
  | * - Let     lhs         .   grLetBody   =   @grExpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lam arg/body info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | grLamArgL: {[HsName]} ^^ grLamBody: GrExpr ]

SEM CExpr
  | Lam         lhs         .   grLamArgL   =   @arg : @body.grLamArgL
  | * - Lam     lhs         .   grLamArgL   =   []
                            .   grLamBody   =   @grExpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% App func/args info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | grAppFun: HsName ^^ grAppArgL: GrValL ]

SEM CExpr
  | App         loc         .   grAppFun    =   @func.grAppFun
                            .   grAppArgL   =   @arg.grVal : @func.grAppArgL
  | * - App     lhs         .   grAppFun    =   maybe hsnUnknown id . grV2HNm $ @grVal
                            .   grAppArgL   =   []
%%]

