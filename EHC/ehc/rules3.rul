-------------------------------------------------------------------------
-- Preliminaries
-------------------------------------------------------------------------

preamble tex "%include lhs2TeX.fmt\n%include afp.fmt\n%include ehrules.fmt"
preamble ag "%%[0\n%include lhs2TeX.fmt\n%include afp.fmt\n%%]\n"

external _ instTyFixed ftv alpha tvarv exists forall

-------------------------------------------------------------------------
-- View hierarchy
-------------------------------------------------------------------------

viewhierarchy = E < K < C < HM < I1 < EX < DT < CG < P, I1 < I2

-------------------------------------------------------------------------
-- Rewriting
-------------------------------------------------------------------------

-- Ty for expr
format ag def  (a | Ty) -> (r | t) = ([a] `mkArrow` (r) | t)
format ag def  (p | Ty) => (a | Ty) -> (r | t) = ([p,a] `mkArrow` (r) | t)
format ag def  (a | TyL) -> (r | t) = ((a) `mkArrow` (r) | t)

format ag use ((a|Ty) -> r) `=` v = (a,r) `=` tyArrowArgRes (v)
format ag use ((...) -> r) `=` v = r `=` tyArrowRes (v)
format ag use (p => a -> r) `=` v = (p,a,r) `=` tyArrowImplsArgRes (v)

-- Cnstr
format ag def  (c | Cnstr, ICnstr) (v | a) = (((c) |=> (v) | a))
format ag def  (c1 | Cnstr, ICnstr) (c2 | Cnstr, ICnstr) (v | a) = (((c1) |=> (c2) |=> (v) | a))
format ag def  (c1 | Cnstr, ICnstr) (c2 | Cnstr, ICnstr) (c3 | Cnstr, ICnstr) (v | a) = (((c1) |=> (c2) |=> (c3) |=> (v) | a))
format ag def  (c1 | Cnstr, ICnstr) (c2 | Cnstr, ICnstr) (c3 | Cnstr, ICnstr) (c4 | Cnstr, ICnstr) (v | a) = (((c1) |=> (c2) |=> (c3) |=> (c4) |=> (v) | a))
-- format ag def  (c1) (c2) (c3) (v) = c1 |=> c2 |=> c3 |=> v

-- Gam
format ag def  (g1 | ValGam, TyGam) +  (g2 | ValGam, TyGam) = (gamAddGam (g1) (g2) | ValGam, TyGam)
format ag def  (g1 | ValGam, TyGam) ++ (g2 | ValGam, TyGam) = (gamPushGam (g1) (g2) | ValGam, TyGam)
format ag def  (i :-> (t|Ty)) = (gamUnit i (ValGamInfo (t)) | ValGam, TyGam)

format ag use  (g1 | ValGam, TyGam) ++ (g2 | ValGam, TyGam) `=` (g | ValGam, TyGam) = ((g1|ValGam, TyGam),(g2|ValGam, TyGam)) `=` (gamPop (g) | ValGam, TyGam)

-- Coercion
format ag def  (coe | Coe) (transl | TranslExpr) = (foAppCoe' (coe) "@lhs.finTyCnstr" "@lhs.cSubst" (transl) | TranslExpr)

-- Nm
format ag def `|` (nm | Nm) `|` = (hsnProdArity (nm) | Int)

-- FIOpts
format ag def f, (o|FIOpts) = ((o {f})|FIOpts)
format ag def f1, f2, (o|FIOpts) = ((o {f1, f2})|FIOpts)

-- Ty for tyexpr
format ag def (t1 | Ty) (t2 | Ty) = (Ty_App (t1) (t2) | Ty)
format ag def Ty_Quant q v `.` t = (Ty_Quant (q) (tyVar (v)) (t) | Ty)

-- TyVarIdS
format ag def  (l1 | TyVarIdS) + (l2 | TyVarIdS) = (l1 ++ l2 | TyVarIdS)
format ag def  (l1 | TyVarIdS) + (l2 | TyVarIdS) + (l3 | TyVarIdS) = (l1 ++ l2 ++ l3 | TyVarIdS)

-------------------------------------------------------------------------
-- Formatting
-------------------------------------------------------------------------

-- Nm
external hsnUn

format tex hsnUn = "\"un\""

-- matching
external
  strongFIOpts weakFIOpts instLFIOpts instLRFIOpts instFIOpts
  impredFIOpts
  meetFIOpts joinFIOpts
  implFIOpts predFIOpts
  fioBindToTyAltsY fioBindToTyAltsN
  fioLeaveRInstY fioLeaveRInstN
  fioBindLFirstY fioBindLFirstN
  fioBindRFirstY fioBindRFirstN
  fioBindLBeforeRY fioBindLBeforeRN
  fioJoinY fioMeetY fioFitY
  fioDontBind
  emptyFO
  foCSubst foLCoeL foRCoeL

format tex howToMatch = <=>
format ag  fiopt = fiOpts

format ag  fioBindRFirstY = fioBindRFirst `=` True
format ag  fioBindRFirstN = fioBindRFirst `=` False
format ag  fioBindLFirstY = fioBindLFirst `=` True
format ag  fioBindLFirstN = fioBindLFirst `=` False
format ag  fioBindToTyAltsY = fioBindToTyAlts `=` True
format ag  fioBindToTyAltsN = fioBindToTyAlts `=` False
format ag  fioBindLBeforeRY = fioBindLBeforeR `=` True
format ag  fioBindLBeforeRN = fioBindLBeforeR `=` False

-- Gam
external emptyGam

format tex emptyGam = []
format tex valGam = Gamma
format tex valGam.inh = Gamma..k
format tex valGam.syn = Gamma
format tex gathTySigGam = Gamma.t
format tex gathTySigGam.ex = Gamma.t.nexists
format tex tySigGam = Gamma.t.k
format tex patValGam = Gamma.p
format tex patValGam.inh = Gamma.p.k
format tex patValGam.syn = Gamma.p
format tex quValGam = Gamma.q
format tex quValGam.ex = Gamma.q.nexists

format tex tyGam = TGamma
format tex tyGam.inh = TGamma..k
format tex tyGam.syn = TGamma

format tex kiGam = KGamma

format tex predGam = Gamma
format tex PredGam = Gamma

-- Type
external tyInt tyChar ANY thardS thardH tneedR tneedO

format tex ity = isigma
format tex lty = sigma.l
format tex rty = sigma.r
format tex ty = sigma
format tex knTy = sigma..k
format tex knTy.1 = sigma.1.k
format tex knTy.2 = sigma.2.k
format tex pred = pi
format tex tyInt = Int
format tex tyChar = Char
format tex instTyFixed = inst.f
format tex patFunTy = sigma.pf
format tex ty.sig = ty.s
format tex ty.q = sigma.q
format tex ty.elim = sigma.e
format tex ty.tboth = sigma./=/
format tex tboth =  /=/
format tex ty' = sigma'

format ag tvarv..._ = tvars
format ag ty..._ = tys
format ag ANY = (Ty_Any|Ty)
format ag ity = imprTy
format ag ty.ident = gTy

-- tvars
external tyLVar

format tex tyLVar =
format tvars.f = tvarv.f.._
format tvars.g = tvarv.g.._

format ag tyLVar = map tyVar

-- Impred Cnstr
format tex ityCnstr = ICnstr
format tex ityCnstr.inh = ICnstr..k
format tex ityCnstr.syn = ICnstr
format tex ityCnstr.fitA = ICnstr.A
format tex ityCnstr.fitF = ICnstr.F
format tex ityCnstr.valGam = ityCnstr.Gamma
format tex ityCnstr.elim = tyCnstr.Gamma

format ag ityCnstr = imprTyCnstr

-- Plain Cnstr
external emptyCnstr'
external emptyCnstr

format tex cnstr = Cnstr
format tex emptyCnstr = []
format tex emptyCnstr' =
format tex patTyCnstr.syn = Cnstr.p
format tex patTyCnstr.inh = Cnstr.p.k
format tex tyCnstr = Cnstr
format tex tyCnstr.inh = Cnstr..k
format tex tyCnstr.syn = Cnstr
format tex tySigTyCnstr.inh = Cnstr.t.k
format tex tySigTyCnstr.syn = Cnstr.t
format tex tyCnstr.r = Cnstr.r
format tex tyCnstr.fun = Cnstr.f
format tex tyCnstr.fitP = Cnstr.P
format tex tyCnstr.fitF = Cnstr.F
format tex tyCnstr.fitE = Cnstr.E
format tex tyCnstr.arg = Cnstr.a

format ag emptyCnstr' = emptyCnstr

-- Decl
format tex declExpr = e
format tex declTyExpr = t
format tex declPat = p

format ag declExpr = expr
format ag declTyExpr = tyExpr
format ag declPat = patExpr

-- Expr
format tex letDecls = d
format tex letBody = b
format tex lamPat = p
format tex lamBody = e
format tex eFun = e.1
format tex eArg = e.2
format tex eAnn = e
format tex eTop = eFun ^^ (eArg)..._

format ag letDecls = decls
format ag letBody = body
format ag eFun = func
format ag eArg = arg
format ag eAnn = expr
format ag eTop = expr
format ag lamPat = arg
format ag lamBody = body
format ag ident = nm
format ag identv = nm
format ag identc = nm
format ag uniq = gUniq
format ag rulerMk1Uniq = mkNewLevUID
format ag rulerMk2Uniq = mkNewLevUID2
format ag rulerMk3Uniq = mkNewLevUID3
format ag rulerMk4Uniq = mkNewLevUID4
format ag rulerMk5Uniq = mkNewLevUID5
format ag rulerMk6Uniq = mkNewLevUID6

format ag decls.hd = hd
format ag decls.tl = tl

format tex decls.hd = d
format tex decls.tl = ds

-- Type expr
external tyexprCon tyexprQuant

format tex tQu = Qu
format tex tVar = identv
format tex tAnn = t
format tex tExpr = t
format tex tFun = t.1
format tex tArg = t.2

format tex tyexprCon = 
format tex tyexprQuant = 

format ag tQu = qu
format ag tVar = tyVar
format ag tAnn = tyExpr
format ag tExpr = tyExpr
format ag tFun = func
format ag tArg = arg

-- Ty wildcard
format tex tyWildL =  tvarv.w.._

format ag tvarv.w.._ = tyWildL

-- Pat expr
format tex pFun = p.1
format tex pArg = p.2
format tex pAsPat = p
format tex pTopPatK = p
format tex pExpr = p

format ag pFun = func
format ag pArg = arg
format ag pAsPat = patExpr
format ag pTopPatK = patExpr
format ag pExpr = patExpr

-- Translation from TyExpr to Ty
format ag tyexprCon = Ty_Con
format ag tyexprQuant = Ty_Quant

-- Translation to core (CExpr)
external translInt translChar translVar emptyTranslBind

format tex translExpr = Transl
format tex TranslExpr = Transl
format tex translBind = Transl
format tex TranslBind = Transl
format tex emptyTranslBind = []

format ag translExpr = cexpr

format tex translInt = Transl
format ag  translInt = CExpr_Int
format tex translChar = Transl
format ag  translChar = CExpr_Char
format tex translVar = Transl
format ag  translVar = CExpr_Var

-- Coercion
external coeId

format tex coe = Coe

-- Co-, Contravariance
external cocoY cocoN cocoNo

-- Errors
external Err_PatArity

-------------------------------------------------------------------------
-- Expr
-------------------------------------------------------------------------

scheme expr "Expr" =
  view E =
    holes [ node e: Expr, valGam: ValGam, tyGam: TyGam, kiGam: KiGam | ty: Ty | ]
    judgespec kiGam ; tyGam ; valGam :- e : ty
    judgeuse tex valGam :-.."e" e : ty
    explain (Within environment |valGam| , expression |e| has type |ty| .)
    explain ty = (Type of expression)
    explain e = (Expression)
    explain valGam = (Environment | (ident :-> ty)..._ | for value identifiers)
  view K =
    holes [ knTy: Ty | | retain ty: Ty ]
    judgespec kiGam ; tyGam; valGam; knTy :- e : ty
    judgeuse tex valGam; knTy :-.."e" e : ty
    explain (Within environment |valGam| , expecting the type of expression |e| to be |knTy| , |e| has type |ty| .)
    explain knTy = ("Expected/known" type of expression)
    explain tyGam = (Environment | (ident :-> ty)..._ | for type identifiers, cannot be modified (hence treated as a global constant in "\\ruleRef{e.ann}"))
  view C =
    holes [ | thread tyCnstr: Cnstr | ]
    judgespec kiGam ; tyGam ; valGam ; tyCnstr.inh ; knTy :- e : ty ~> tyCnstr.syn
    judgeuse tex valGam ; tyCnstr.inh ; knTy :-.."e" e : ty ~> tyCnstr.syn
    explain (Within environment |valGam| , expecting the type of expression |e| to be |tyCnstr.inh knTy| , |e| has type |ty| , under constraints |tyCnstr.syn| .)
    explain tyCnstr.inh = (Already known constraints)
    explain tyCnstr.syn = (|tyCnstr.inh| + new constraints)
  view I1 =
    holes [ fiopt: FIOpts | | ]
    judgespec fiopt ; kiGam ; tyGam ; valGam ; tyCnstr.inh ; knTy :- e : ty ~> tyCnstr.syn
    judgeuse tex fiopt ; valGam ; tyCnstr.inh ; knTy :-.."e" e : ty ~> tyCnstr.syn
    explain (Within environment |valGam| and context |fiopt| , expecting the type of expression |e| to be |tyCnstr.inh knTy| , |e| has type |ty| , under constraints |tyCnstr.syn| .)
    explain fiopt = (|fitsIn| options, additional contextual information for | <= |)
  view I2 =
    holes [ | thread ityCnstr: ICnstr | retain ity: Ty ]
    judgespec fiopt ; kiGam ; tyGam ; valGam ; ityCnstr.inh ; tyCnstr.inh ; knTy :- e : ity ; ty ~> ityCnstr.syn ; tyCnstr.syn
    judgeuse tex fiopt ; valGam ; ityCnstr.inh ; tyCnstr.inh ; knTy :-.."e" e : ity ; ty ~> ityCnstr.syn ; tyCnstr.syn
    explain (Within environment |valGam| and context |fiopt| , expecting the types of expression |e| to be |ityCnstr.inh knTy| (and |tyCnstr.inh knTy|)
            , |e| has type |ity| (and |ty|) , under constraints |ityCnstr.syn| (and |tyCnstr.syn|) .
            )
    explain ityCnstr.inh = (Already known constraints (for quantifier propagation))
    explain ityCnstr.syn = (|ityCnstr.inh| + new constraints (for quantifier propagation))
    explain ity = (Type (with type alternatives |talt|) of expression (for quantifier propagation))
  view CG =
    holes [ | | retain translExpr: TranslExpr ]
    judgespec fiopt ; kiGam ; tyGam ; valGam ; tyCnstr.inh ; knTy :- e : ty ~> tyCnstr.syn ; translExpr
    judgeuse tex fiopt ; valGam ; tyCnstr.inh ; knTy :-.."e" e : ty ~> tyCnstr.syn ; translExpr
    explain translExpr = (Translated expression)

rulesgroup expr.scratch scheme expr "Expression type rules (scratch)" =
  rule expr.base e.let

rulesgroup expr.baseForEH1 scheme expr "Expression type rules" =
  rule expr.base e.int
  rule expr.base e.char
  rule expr.base e.var
  rule expr.base e.app
  rule expr.onlyE e.prod
  rule expr.base e.lam
  rule expr.base e.ann
  rule expr.base e.let

rulesgroup expr.baseForEH2 scheme expr "Expression type rules" =
  rule expr.base e.int
  rule expr.base e.char
  rule expr.base e.var
  rule expr.base e.con
  rule expr.base e.app
  rule expr.base e.lam
  rule expr.base e.ann
  rule expr.base e.let

rulesgroup expr.baseForEH3 scheme expr "Expression type rules" =
  rule expr.base e.var
  rule expr.base e.ann
  rule expr.base e.let

rulesgroup expr.baseForEH4 scheme expr "Expression type rules" =
  rule expr.base e.var
  rule expr.base e.app
  rule expr.base e.lam
  -- rule expr.base e.ann

rulesgroup expr.eh4B1 scheme expr "Expression type rules, part I" =
  rule expr.base e.int
  -- rule expr.base e.char
  rule expr.base e.var
  rule expr.base e.app
  -- rule expr.base e.app.f
  -- rule expr.base e.ann

rulesgroup expr.eh4B2 scheme expr "Expression type rules, part II" =
  rule expr.base e.lam
  rule expr.base e.let

rulesgroup expr.baseForEH9 scheme expr "Expression type rules" =
  rule expr.base e.iapp
  rule expr.base e.ilam
  rule expr.base e.apptop

rulesgroup expr.baseExplImpl scheme expr "Expression type rules" =
  rule expr.base e.int
  rule expr.base e.var
  rule expr.base e.app
  rule expr.base e.lam
  rule expr.base e.let
  rule expr.onlyE e.pred

ruleset expr.base scheme expr "Expression type rules" =
  rule e.int "IConst" =
    view E =
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- int : tyInt
    view K =
      judge F : fit = :- tyInt <= knTy : fo : ty
      ---
      judge R : expr
          | ty = ty
    view C =
      judge F : fit
          | cnstr = tyCnstr
          | rty = tyCnstr.inh knTy
      ---
      judge R : expr
          | tyCnstr.syn = tyCnstr tyCnstr.inh
    view I2 =
      ---
      judge R : expr
          | ity = tyInt
          | ityCnstr.syn = ityCnstr.inh
    view CG =
      ---
      judge R : expr
          | translExpr = translInt (int)
    view P =
      ---
      judge R : expr
          | translExpr = coe (translInt (int) | TranslExpr)

  rule e.char : e.int "CConst" =
    view E =
      ---
      judge R : expr
          | e = char
          | ty = tyChar
    view K =
      judge F : fit
          | lty = tyChar
      ---
    view I2 =
      ---
      judge R : expr
          | ity = tyChar
    view CG =
      ---
      judge R : expr
          | translExpr = translChar (char)
    view P =
      ---
      judge R : expr
          | translExpr = coe (translChar (char) | TranslExpr)

  rule e.var "Var" =
    view E =
      judge G : valGamLookupIdTy = ident :-> ty `elem` valGam
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- ident : ty
    view K =
      judge G : valGamLookupIdTy
          | ty = ty.g
      judge F : fit
          | lty = ty.g
          | rty = knTy
      ---
    view C =
      judge F : fit
          | lty = tyCnstr.inh ty.g
          | rty = tyCnstr.inh knTy
          | cnstr = tyCnstr
      ---
      judge R : expr
          | tyCnstr.syn = tyCnstr tyCnstr.inh
    view HM =
      judge I : inst.tvar = ty.i, tvarv.i === forall, ty.g, tvarv, "tyInst"
      judge F : fit
          | lty = tyCnstr.inh ty.i
      ---
      judge R : expr
          | tyCnstr.syn = tyCnstr tyCnstr.inh
    view I1 =
      judge - I
      judge F : fit
          | lty = tyCnstr.inh ty.g
      -          
    view I2 =
      -          
      judge R : expr
          | ity = ityCnstr.inh ty.g
          | ityCnstr.syn = ityCnstr.inh
    view CG =
      ---
      judge R : expr
          | translExpr = translVar (ident)
    view P =
      ---
      judge R : expr
          | translExpr = coe (translVar (ident) | TranslExpr)

  rule e.con : e.var viewsel K - * "Con" =
    view K =	
      judge O: tyOpenProd = ty.p.._, n === ty.r
      judge - G F
      ---
      judge R : expr = kiGam ; tyGam ; valGam ; ((...) -> ty.r) :- "(,)" : (ty.p.._ -> ty.r)

    view C =
      judge - G O
      judge V : tvarvFreshN = (`|` (identc | Nm) `|`) : tvarv..._
      judge P : mkProdTy = ty.p === tvarv..._
      judge F : fit
          | lty = (tvarv..._ -> ty.p)
          | rty = tyCnstr.inh knTy
          | ty = ty
      ---
      judge R : expr
          | e = identc
          | knTy = knTy
          | ty = ty

    view HM =
      judge - G I
      judge F : fit
          | lty = (tvarv..._ -> ty.p)
      ---

    view I1 =
      judge - V P
      judge G : valGamLookupIdTy = identc :-> ty.g `elem` valGam
      judge F : fit
          | lty = tyCnstr.inh ty.g
      ---
      judge R : expr
          | e = identc
          | ty = ty
          | knTy = knTy
          | tyCnstr.syn = tyCnstr tyCnstr.inh

    view CG =
      ---
      judge R : expr
          | translExpr = translVar (identc)

    view P =
      ---
      judge R : expr
          | translExpr = coe (translVar (identc) | TranslExpr)

  rule e.app "App" =
    view E =
      judge F : expr = kiGam ; tyGam ; valGam :- eFun : (ty.a -> (ty|Ty))
      judge A : expr = kiGam ; tyGam ; valGam :- eArg : ty.a
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- ((node 1 = eFun) ^^ (node 2 = eArg)) : ty
    view K =
      judge F : expr
          | knTy = ANY -> knTy
      judge A : expr
          | knTy = ty.a
          | ty = _
      ---
    view C =
      judge V : tvarvFresh
      judge F : expr
          | knTy = tvarv -> knTy
          | tyCnstr.syn = tyCnstr.fun
      judge A : expr
          | tyCnstr.inh = tyCnstr.fun
          | tyCnstr.syn = tyCnstr.arg
      ---
      judge R : expr
          | ty = tyCnstr.arg ty
          | tyCnstr.syn = tyCnstr.arg
    view I1 =
      judge F : expr
          | ty = (_|Ty) -> (ty|Ty)
          | fiopt = strongFIOpts
      judge A : expr
          | knTy = tvarv
          | fiopt = instLRFIOpts
      ---
    view I2 =
      judge F : expr
          | ity = ity.f
          | ityCnstr.syn = ityCnstr.f
      judge A : expr
          | ity = ity.a
          | ityCnstr.inh = ityCnstr.fitF ityCnstr.f
          | ityCnstr.syn = ityCnstr.a
      judge fitA : fit = (fioBindToTyAltsY,(instLFIOpts|FIOpts)) :- ity.a <= (ityCnstr.a tvarv) : fo.fitA : _ ~> ityCnstr.fitA
      judge fitF : fit = impredFIOpts :- ity.f <= (ityCnstr.f (tvarv -> knTy)) : fo.fitF : _ ~> ityCnstr.fitF
      judge E1 : eqRLCnstr = ityCnstr.1 =<= ityCnstr.fitA ityCnstr.a
      ---
      judge R : expr
          | ity = ityCnstr.1 knTy
          | ityCnstr.syn = ityCnstr.1
{-
    view I3 =
      judge fitF : fit
          | lty = ityCnstr.a ity.f
          | rty = ityCnstr.a (tvarv -> knTy)
      judge E1 : eqRLCnstr = ityCnstr.1 =<= ityCnstr.fitF ityCnstr.a
      judge fitA : fit
          | lty = ityCnstr.1 ity.a
          | rty = ityCnstr.1 tvarv
      judge E2 : eqRLCnstr = ityCnstr.2 =<= ityCnstr.fitA ityCnstr.1
      ---
-}
    view DT =
      judge A : expr
          | fiopt = instLFIOpts
      ---
    view CG =
      judge F : expr
          | translExpr = translExpr.f
      judge A : expr
          | translExpr = translExpr.a
      ---
      judge R : expr
          | translExpr = translExpr.f ^^ translExpr.a
    view P =
      judge V : tpvarvFresh2
          | tvarv1 = tvarv
          | tvarv2 = pvar
      judge F : expr
          | knTy = pvar => tvarv -> knTy
          | ty = _ => ty.a -> ty
      judge P : pred = valGam :- (tyCnstr.arg pvar) ~> translExpr.a.._ : _
      ---
      judge R : expr
          | translExpr = \translExpr.f ^^ translExpr.a.._ ^^ translExpr.a

  rule e.app.f : e.app viewsel I1 - * "AppImpred" =
    view I1 = 
      judge A : expr
          | fiopt = strongFIOpts
      ---
    view I2 = 
      judge fitA : fit
          | fiopt = impredFIOpts
      ---
      judge R : expr
          | e = (node 1 = eFun) ^^ ~ (node 2 = eArg)

  rule e.iapp viewsel P - * "AppImpl" =
    view P =
      judge F : expr = implFIOpts ; kiGam ; tyGam ; valGam ; tyCnstr.inh ; (pred.2 => knTy) :- eFun : (pred.a => ty) ~> tyCnstr.fun ; translExpr.f
      judge G : predGamLookupPrTyEv = pred.a :> _ : ty.a `elem` valGam
      judge A : expr = strongFIOpts ; kiGam ; tyGam ; valGam ; tyCnstr.fun ; ty.a :- eArg : _ ~> tyCnstr.arg ; translExpr.a
      ---
      judge R : expr
          | e = eFun ^^ (! eArg <: pred.2 !)
          | tyCnstr.syn = tyCnstr.arg
          | translExpr = translExpr.f ^^ translExpr.a
          | ty = tyCnstr.arg ty

  rule e.apptop viewsel C - * "AppTop" =
    view C =
      judge A : tyEnsureNonAny = ty.e.k : knTy
      judge E : expr
          | knTy = ty.e.k
          | e = eTop
      ---
      judge R : expr
          | e = (node 1 = eTop)
    view P =
      judge V : tvarvFresh2 = tvarv, pvar
      judge fitE : match = fiopt :- (pvar => tvarv) <=>.(<=) (tyCnstr.inh ty.e.k) : (pred.a.._ => ty.e) ~> tyCnstr.fitE ; coe.lam
      judge instP : inst.pred = predGam.i === inst.pred(pred.a.._)
      judge openP : predGamOpenIdTy = [_ :~> translExpr.i.._] === predGam.i
      judge E : expr
          | e = eFun ^^ (eArg)..._
          | knTy = ty.e
          | valGam = predGam.i,valGam
          | translExpr = translExpr.e
          | tyCnstr.inh = tyCnstr.fitE tyCnstr.inh
          | tyCnstr.syn = tyCnstr.e
      ---
      judge R : expr
          | e = eFun ^^ (eArg)..._
          | translExpr = \translExpr.i.._ -> translExpr.e
          | ty = tyCnstr.e pred.a.._ -> ty
          | tyCnstr.syn = tyCnstr.e

  rule e.lam "Lam" =
    view E =
      judge B : expr = kiGam ; tyGam ; ((identv :-> ty.identv) + valGam) :- lamBody : ty.e
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- (\identv -> (node 2 = lamBody)) : (ty.identv -> ty.e)

    view K =
      judge P : patexpr = emptyGam ; ty.p :- lamPat : patValGam
      judge fitF : fit = :- (ANY -> ANY) <= knTy : fo.fitF : (ty.p -> ty.r)
      judge B : expr
          | knTy = ty.r
          | valGam = patValGam + valGam
      ---
      judge R : expr
          | e = \(node 1 = lamPat) -> (node 2 = lamBody)
          | ty = ty.p -> ty.e
    view C =
      judge V : tvarvFresh2
      judge P : patexpr
          | tyCnstr.inh = tyCnstr.fitF tyCnstr.inh
          | tyCnstr.syn = tyCnstr.p
          | knTy = tvarv1
          | ty = ty.p
          | patFunTy = _
      judge fitF : fit
          | lty = tvarv1 -> tvarv2
          | rty = tyCnstr.inh knTy
          | cnstr = tyCnstr.fitF
          | ty = _
      judge B : expr
          | tyCnstr.inh = tyCnstr.p
          | tyCnstr.syn = tyCnstr.e
          | knTy = tvarv2
          | ty = ty.e
      ---
      judge R : expr
          | ty = tyCnstr.e ty.p -> ty.e
          | tyCnstr.syn = tyCnstr.e
    view I1 =
      judge P : patexpr
          | valGam.inh = (emptyGam|ValGam) ++ valGam
          | tyGam.inh = tyGam
          | tyGam.syn = tyGam.p
      judge B : expr
          | valGam = patValGam
          | tyGam = tyGam.p
      judge fitF : fit
          | fiopt = fioBindRFirstY, fiopt
      ---
    view I2 =
      judge P : patexpr
          | tyCnstr.inh = emptyCnstr
          | knTy = ityCnstr.fitF tvarv1
          -- | fiopt = strongFIOpts
      judge ifitF : fit = (fioBindRFirstY, fiopt) :- (tvarv1 -> tvarv2) <= ty.e.k : fo.ifitF : _ ~> ityCnstr.fitF
      judge fitF : fit
          | lty = tyCnstr.inh (tvarv1 -> tvarv2)
          | rty = tyCnstr.inh knTy
          | fiopt = fioBindRFirstY, fioBindLBeforeRN, fiopt
          -- | fiopt = fioBindRFirstY, (fioDontBind `=` ftv(tyCnstr.inh (tvarv1 -> tvarv2))), fiopt
      judge B : expr
          | tyCnstr.inh = tyCnstr.3
          | ityCnstr.inh = tyCnstr.p ityCnstr.fitF ityCnstr.inh
          | ityCnstr.syn = ityCnstr.e
          | ity = ity.e
      judge split : valGamPop = valGam.l ++ (_|ValGam) === patValGam
      judge ftvG : valGamFtv = tvarv.g.._ === valGam
      judge elimK : tyAltTyElim = meetFIOpts ; ityCnstr.inh ; tvarv.g.._ :- knTy : ty.e.k ~> _
      judge elimG : valElimExprAlts = meetFIOpts; ityCnstr.e; tvarv.g.._ :- valGam.l : ityCnstr.elim
      judge E1 : eqRLCnstr = ityCnstr.1 =<= ityCnstr.elim ityCnstr.e
      judge E2 : eqRLCnstr = tyCnstr.2 =<= (tyCnstr.fitF |\> ftv(tyCnstr.inh (tvarv1 -> tvarv2)))
      judge E3 : eqRLCnstr = tyCnstr.3 =<= (ityCnstr.elim tyCnstr.p
                                             tyCnstr.2
                                             ((tyCnstr.inh |>> ityCnstr.fitF | Cnstr))
                                            | Cnstr)
                                           tyCnstr.inh
      ---
      judge R : expr
          | ity = ityCnstr.1 ty.p -> ityCnstr.elim ity.e
          | ityCnstr.syn = ityCnstr.1
{-
    view I2 =
      judge P : patexpr
          | tyCnstr.inh = emptyCnstr
          | knTy = tyCnstr.fitF tvarv1
          -- | fiopt = strongFIOpts
      judge fitF : fit
          | rty = ty.e.k -- ityCnstr.inh knTy
      judge B : expr
          | tyCnstr.inh = tyCnstr.2
          | ityCnstr.inh = tyCnstr.p tyCnstr.fitF ityCnstr.inh
          | ityCnstr.syn = ityCnstr.e
          | ity = ity.e
      judge split : valGamPop = valGam.l ++ (_|ValGam) === patValGam
      judge ftvG : valGamFtv = tvarv.g.._ === valGam
      judge elimK : tyAltTyElim = meetFIOpts ; ityCnstr.inh ; tvarv.g.._ :- knTy : ty.e.k ~> _
      judge elimG : valElimExprAlts = meetFIOpts; ityCnstr.e; tvarv.g.._ :- valGam.l : ityCnstr.elim
      judge E1 : eqRLCnstr = ityCnstr.1 =<= ityCnstr.elim ityCnstr.e
      judge E2 : eqRLCnstr = tyCnstr.2 =<= (ityCnstr.elim tyCnstr.p ((tyCnstr.inh |>> tyCnstr.fitF | Cnstr)) | Cnstr) tyCnstr.inh
      ---
      judge R : expr
          | ity = ityCnstr.1 ty.p -> ityCnstr.elim ity.e
          | ityCnstr.syn = ityCnstr.1
-}
{-
    view I2 =
      judge P : patexpr
          | tyCnstr.inh = emptyCnstr
          | knTy = ityCnstr.fitF tvarv1
      judge ifitF : fit = (fioBindRFirstY, fiopt) :- (tvarv1 -> tvarv2) <= (ityCnstr.inh knTy) : fo.ifitF : _ ~> ityCnstr.fitF
      judge fitF : fit
          | lty = tyCnstr.2 (tvarv1 -> tvarv2)
          | rty = tyCnstr.2 knTy
      judge B : expr
          | tyCnstr.inh = tyCnstr.fitF tyCnstr.2
          | ityCnstr.inh = tyCnstr.p ityCnstr.fitF ityCnstr.inh
          | ityCnstr.syn = ityCnstr.e
          | ity = ity.e
      judge split : valGamPop = valGam.l ++ (_|ValGam) === patValGam
      judge ftvG : valGamFtv = tvarv.g.._ === valGam
      judge elimG : valElimExprAlts = meetFIOpts; ityCnstr.e; tvarv.g.._ :- valGam.l : ityCnstr.elim
      judge E1 : eqRLCnstr = ityCnstr.1 =<= ityCnstr.elim ityCnstr.e
      judge E2 : eqRLCnstr = tyCnstr.2 =<= ityCnstr.elim tyCnstr.p tyCnstr.inh ityCnstr.fitF
      ---
      judge R : expr
          | ity = ityCnstr.1 ty.p -> ityCnstr.elim ity.e
          | ityCnstr.syn = ityCnstr.1
-}

    view DT =
      judge P : patexpr
          | valGam.inh = (emptyGam|ValGam) ++ valGam
      judge B : expr
          | valGam = patValGam
      ---

    view CG =
      judge B : expr
          | translExpr = translExpr.e
      ---
      judge R : expr
          | translExpr = (translExprPrev= \lamPat -> translExpr.e)

    view P =
      judge V : tvarvFresh3
          | tvarv3 = pvar
      judge fitF : fit
          | lty = pvar => tvarv1 -> tvarv2
          | ty = pred.a.._ => ty.p -> ty.r
      judge instP : inst.pred = predGam.i === inst.pred(pred.a.._)
      judge openP : predGamOpenIdTy = [_ :~> translExpr.i.._] === predGam.i
      judge B : expr
          | valGam = predGam.i,valGam
      ---
      judge R : expr
          | ty = tyCnstr.e pred.a.._ => tyCnstr.e ty.p -> ty.e
          | translExpr = translExpr.i.._ -> translExprPrev

  rule e.ilam viewsel P - * "LamImpl" =
    view P =
      judge V : tvarvFresh
      judge fitP : match = implFIOpts :- (pred => tvarv) <=>.(<=) (tyCnstr.inh knTy) : (pred.a => ty.r) ~> tyCnstr.fitP ; coe.lam
      judge G : predGamLookupPrTyEv = pred.a :> _ : ty.a `elem` valGam
      judge prG : bind1PredToTy = predGam.i === [pred.a :> lamPat : ty.a]
      judge P : patexpr = fiopt ; tyGam ; emptyGam ; emptyCnstr ; ty.a :- lamPat : _ ; tyGam.p ; patValGam ~> patTyCnstr ; _
      judge B : expr 
          | knTy = ty.r
          | valGam = predGam.i , patValGam , valGam
          | e = lamBody
          | tyCnstr.inh = patTyCnstr tyCnstr.fitP tyCnstr.inh
          | tyCnstr.syn = tyCnstr.e
          | translExpr = translExpr.e
      ---
      judge R : expr
          | e = \(! lamPat <: pred !) -> lamBody
          | tyCnstr.syn = tyCnstr.e
          | translExpr = \lamPat -> translExpr.e

  rule e.let "Let" =
    view E =
      judge D : decl = kiGam ; tyGam ; (gathTySigGam ++ valGam) :- letDecls : gathTySigGam
      judge B : expr = kiGam ; tyGam ; (gathTySigGam ++ valGam) :- letBody : ty
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- (let (node 1 = letDecls) in (node 2 = letBody)) : ty

    view K =
      judge D : decl
          | valGam = patValGam.syn
          | tySigGam = gathTySigGam
          | patValGam.inh = gathTySigGam ++ valGam
      judge B : expr
          | valGam = patValGam.syn
      ---

    view C =
      judge D : decl
          | patTyCnstr.inh = tyCnstr.inh
          | tyCnstr.inh = patTyCnstr.syn
          | tyCnstr.syn = tyCnstr.d
      judge B : expr
          | tyCnstr.inh = tyCnstr.d
          | tyCnstr.syn = tyCnstr.e
      ---
      judge R : expr
          | tyCnstr.syn = tyCnstr.e

    view HM =
      judge split : valGamPop = valGam.l ++ valGam.g === patValGam.syn
      judge B : expr
          | valGam = quValGam + valGam.g
      judge Q : valGamQuantify = quValGam, gTyTvL, lSubsValGam, gSubsValGam === valGam.l, valGam.g, tyCnstr.d
      ---

    view EX =
      judge ED : valGamInst1Exists = gathTySigGam.ex === gathTySigGam
      judge EB : valGamInst1Exists = quValGam.ex === quValGam
      judge D : decl
          | patValGam.inh = gathTySigGam.ex ++ valGam
      judge B : expr
          | valGam = quValGam.ex + valGam.g
      ---

    view I2 =
      judge ED : valGamInst1Exists = _, tyCnstr.t.ex === gathTySigGam, tyCnstr.t
      judge D : decl
          | patTyCnstr.inh = tyCnstr.t.ex tyCnstr.t
          | tyCnstr.inh = ityCnstr.elim patTyCnstr.syn tyCnstr.inh
          | ityCnstr.inh = patTyCnstr.syn ityCnstr.inh
          | ityCnstr.syn = ityCnstr.d
          | tySigTyCnstr.inh = emptyCnstr
          | tySigTyCnstr.syn = tyCnstr.t
          | tySigGam = tyCnstr.t gathTySigGam
      judge ftvG : valGamFtv = tvarv.g.._ === valGam
      judge elimG : valElimExprAlts = joinFIOpts; ityCnstr.d; tvarv.g.._ :- valGam.l : ityCnstr.elim
      judge Q : valGamQuantify
          | cnstr.q = tyCnstr.q
      judge EB : valGamInst1Exists = quValGam.ex, tyCnstr.l.ex === valGam.l, (tyCnstr.q tyCnstr.d)
      judge B : expr
          | ityCnstr.inh = ityCnstr.elim ityCnstr.d
          | ityCnstr.syn = ityCnstr.e
          | tyCnstr.inh = tyCnstr.l.ex tyCnstr.q tyCnstr.d
          | valGam = patValGam.syn
      ---
      judge R : expr
          | ityCnstr.syn = ityCnstr.e

    view CG =
      judge B : expr
          | translExpr = translExpr.e
      judge D : decl
          | translBind = translBind.d.._
      ---
      judge R : expr
          | translExpr = let translBind.d.._ ^^ in translExpr.e

  rule e.ann "TypeAs" =
    view E =
      judge E : expr = kiGam ; tyGam ; valGam :- eAnn : ty
      judge T : tyexpr = :- tAnn : ty
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- (((node 2 = eAnn) :: (node 1 = tAnn))) : ty
    view K =
      judge E : expr
          | ty = ty.e
          | knTy = ty.a
      judge T : tyexpr
          | ty = ty.a
      judge F : fit = :- ty.a <= knTy : fo : _
      ---
      judge R : expr
          | ty = ty.e
    view C =
      judge E : expr
          | tyCnstr.inh = tyCnstr.F tyCnstr.inh
          | tyCnstr.syn = tyCnstr.e
      judge F : fit
          | rty = tyCnstr.inh knTy
          | cnstr = tyCnstr.F
      ---
      judge R : expr
          | tyCnstr.syn = tyCnstr.e
    view HM =
      -- judge Q : tyQuantify = tAnn: ty.q === ty.a, tvarv.t.._
      judge Q : tyQuantify = (tyLVar tvarv.t.._) :- ty.a : ty.q
      judge instKnown : inst.known = ty.i === inst.K(ty.q)
      judge T : tyexpr
          | tyWildL = tvarv.t.._
          | tyGam.inh = tyGam
          | tyGam.syn = tyGam.t
      judge F : fit
          | lty = ty.i
      judge E : expr
          | knTy = ty.i
      ---
      judge R : expr
          | ty = ty.a
    view I1 =
      judge TGFtv : tyGamTyFtv = tvarv.TGamma.._ === tyGam, tyCnstr.inh
      judge GFtv : valGamFtv = tvarv.Gamma.._ === tyCnstr.inh valGam
      judge Q : tyQuantify
          | gtvars = (tyLVar tvarv.t.._ | TyVarIdS) + tvarv.Gamma.._ + tvarv.TGamma.._
          | ty = tyCnstr.inh ty.a
      judge - instKnown
      judge F : fit
          | lty = ty.q
      judge E : expr
          | knTy = ty.q
          | tyGam = tyGam.t
      ---
      judge R : expr
          | ty = tyCnstr.e ty.q
    view I2 =
      judge TGFtv : tyGamTyFtv
          | tyCnstr = ityCnstr.inh
      judge GFtv : valGamFtv
          | g = ityCnstr.inh valGam
      judge Q : tyQuantify
          | ty = ityCnstr.inh ty.a
      judge - instKnown
      judge F : fit
          | lty = tyCnstr.inh ty.q
      judge E : expr
          | ityCnstr.syn = ityCnstr.e
          | ity = ity.e
      judge FI : fit = (fioBindToTyAltsY, fiopt) :- ity.e <= ty.q : fo_fitI : ity ~> ityCnstr
      ---
      judge R : expr
          | ityCnstr.syn = ityCnstr ityCnstr.e

ruleset expr.onlyE scheme expr "Expression type rules" =
  rule e.prod viewsel E - K =
    view E =
      judge F : expr = kiGam ; tyGam ; valGam :- e.1 : ty.1
      judge S : expr = kiGam ; tyGam ; valGam :- e.2 : ty.2
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- ((e.1,e.2)) : ((ty.1,ty.2))
    view K =
      judge F : expr
          | knTy = knTy.1
      judge S : expr
          | knTy = knTy.2
      ---
      judge R : expr
          | knTy = (knTy.1,knTy.2)
      
  rule e.pred viewsel E - K =
    view E =
      judge P : pred = valGam :- pred
      judge E : expr = kiGam ; tyGam ; valGam :- e : (pred -> ty)
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- e : ty

-------------------------------------------------------------------------
-- Declaration
-------------------------------------------------------------------------

scheme decl "Decl" =
  view E =
    holes [ kiGam: KiGam, tyGam: TyGam, valGam: ValGam, node d: Decl | | gathTySigGam: ValGam ]
    judgespec kiGam ; tyGam ; valGam :-.."d" d : gathTySigGam
    judgeuse tex valGam :-.."d" d : gathTySigGam
    explain (Within environment |valGam| , declaration |d| has type signature bindings |gathTySigGam| .)
    explain valGam = (Environment with known bindings)
    explain gathTySigGam = (Environment with type signature bindings)
    explain d = (Declaration)
  view K =
    holes [ tySigGam: ValGam | thread patValGam: ValGam | ]
    judgespec tySigGam ; patValGam.inh ; kiGam ; tyGam ; valGam :- d : gathTySigGam ; patValGam.syn
    judgeuse tex tySigGam ; patValGam.inh ; valGam :-.."d" d : gathTySigGam ; patValGam.syn
    explain (Declaration |d| has explicit type bindings |gathTySigGam| ,
             within explicit bindings |tySigGam| and implicit type bindings |patValGam.inh| ,
             and type checks within |valGam| ,
             yielding additional bindings |patValGam.syn| .
            )
    explain gathTySigGam = (Environment with new type signature bindings)
    explain tySigGam = (Collected |gathTySigGam| , used by patterns to extract bindings for pattern variables)
    explain patValGam.inh = ("Known/gathered" pattern variable bindings)
    explain patValGam.syn = (|patValGam.inh| + new bindings)
    explain tyGam = (Environment | (ident :-> ty)..._ | for type identifiers, cannot be modified (hence treated as a global constant in "\\ruleRef{e.ann}"))
  view C =
    holes [ | thread tyCnstr: Cnstr, thread patTyCnstr: Cnstr | ]
    judgespec tySigGam ; patValGam.inh ; kiGam ; tyGam ; valGam ; patTyCnstr.inh ; tyCnstr.inh :- d : gathTySigGam ; patValGam.syn ~> patTyCnstr.syn ; tyCnstr.syn
    judgeuse tex tySigGam ; patValGam.inh ; valGam ; patTyCnstr.inh ; tyCnstr.inh :-.."d" d : gathTySigGam ; patValGam.syn ~> patTyCnstr.syn ; tyCnstr.syn
    explain (Declaration |d| has explicit type bindings |gathTySigGam| ,
             within explicit bindings |tySigGam| and implicit type bindings |patTyCnstr.inh patValGam.inh| ,
             and type checks within |tyCnstr.inh valGam| ,
             yielding additional bindings |patValGam.syn| ,
             under constraints |patTyCnstr.syn| (for |patValGam.syn|) and
             |tyCnstr.syn| (for |valGam|).
            )
    explain patTyCnstr.inh = ("Known/gathered" constraints during type inference of patterns (i.e. use of type signatures and pattern structure))
    explain patTyCnstr.syn = (|patTyCnstr.inh| + new constraints)
    explain tyCnstr.inh = ("Known/gathered" constraints during type inference of expressions bound to patterns)
    explain tyCnstr.syn = (|tyCnstr.inh| + new constraints)
  view I2 =
    holes [ | thread ityCnstr: ICnstr, thread tySigTyCnstr: Cnstr | ]
    judgespec tySigGam ; patValGam.inh ; kiGam ; tyGam ; valGam ; tySigTyCnstr.inh ; patTyCnstr.inh ; ityCnstr.inh ; tyCnstr.inh :- d : gathTySigGam ; patValGam.syn ~> tySigTyCnstr.syn ; patTyCnstr.syn ; ityCnstr.syn ; tyCnstr.syn
    judgeuse tex tySigGam ; patValGam.inh ; valGam ; tySigTyCnstr.inh ; patTyCnstr.inh ; ityCnstr.inh ; tyCnstr.inh :-.."d" d : gathTySigGam ; patValGam.syn ~> tySigTyCnstr.syn ; patTyCnstr.syn ; ityCnstr.syn ; tyCnstr.syn
    explain tySigTyCnstr.inh = (Type signature information represented as constraint for binding to type variable in |gathTySigGam|)
    explain tySigTyCnstr.syn = (|tySigTyCnstr.inh| + new constraints)
    explain ityCnstr.inh = ("Known/gathered" constraints during quantifier propagation)
    explain ityCnstr.syn = (|ityCnstr.inh| + new constraints)
  view CG =
    holes [ | | translBind: TransDecl ]
    judgespec tySigGam ; patValGam.inh ; kiGam ; tyGam ; valGam ; patTyCnstr.inh ; tyCnstr.inh :- d : gathTySigGam ; patValGam.syn ~> patTyCnstr.syn ; tyCnstr.syn ; translBind
    judgeuse tex tySigGam ; patValGam.inh ; valGam ; patTyCnstr.inh ; tyCnstr.inh :-.."d" d : gathTySigGam ; patValGam.syn ~> patTyCnstr.syn ; tyCnstr.syn ; translBind

-- scheme decls : [decl] "Decls"

ruleset decl.base scheme decl "Declaration type rules" =
  rule d.tysig viewsel K - * "TySig" =
    view K =
      judge B : bind1ValIdToTy = valGam.i === [identv :-> ty.i]
      judge T : tyexpr = tyGam :- declTyExpr : ty.i
      ---
      judge R : decl = _ ; patValGam ; kiGam ; tyGam ; _ :- ((identv :: (node 1 = declTyExpr))) : valGam.i ; patValGam
    view C =
      ---
      judge R : decl
          | patTyCnstr.syn = patTyCnstr.inh
          | tyCnstr.syn = tyCnstr.inh
    view HM =
      judge T : tyexpr
          | tyWildL = tvarv.t.._
          | tyGam.inh = tyGam
          | tyGam.syn = _
      -- judge Q : tyQuantify = declTyExpr: ty.q === ty.i, tvarv.t.._
      judge Q : tyQuantify = (tyLVar tvarv.t.._) :- ty.i : ty.q
      judge B : bind1ValIdToTy
          | ty = ty.q
      ---
    view I1 =
      judge TGFtv : tyGamTyFtv = tvarv.TGamma.._ === tyGam, emptyCnstr'
      judge Q : tyQuantify
          | gtvars = (tyLVar tvarv.t.._ | TyVarIdS) + tvarv.TGamma.._
      ---
    view I2 =
      judge V : tyEnsureTVar = ty.v, tyCnstr.v, tvarv.v === ty.q
      judge B : bind1ValIdToTy
          | ty = ty.v
      ---
      judge R : decl
          | tySigTyCnstr.syn = tyCnstr.v tySigTyCnstr.inh
          | ityCnstr.syn = ityCnstr.inh
    view CG =
      ---
      judge R : decl
          | translBind = emptyTranslBind

  rule d.sig.val viewsel E = 
    view E =
      judge E : expr = kiGam ; tyGam ; valGam :- e.identv : ty.identv
      judge B : bind1ValIdToTy = valGam.identv === [identv :-> ty.identv]
      ---
      judge R : decl = kiGam ; tyGam ; valGam :- ((identv :: ty.identv ; identv `=` e.identv)) : valGam.identv

  rule d.val viewsel K - * "Val" = 
    view K =
      judge L : valGamLookupPatTy = declPat :-> ty.sig `elem` tySigGam
      judge P : patexpr = patValGam.inh ; ty.sig :- declPat : patValGam.syn
      judge E : expr = kiGam ; tyGam ; valGam ; ty.sig :- declExpr : _
      ---
      judge R : decl = tySigGam ; patValGam.inh ; kiGam ; tyGam ; valGam :- (((node 1 = declPat) `=` (node 2 = declExpr))) : emptyGam ; patValGam.syn
    view C =
      judge V : tvarvFresh
      judge C : chooseKnownOrOther = ty.p.k, ty.e.k === tvarv, ty.sig, ty.p
      judge P : patexpr
          | tyCnstr.syn = patTyCnstr.syn
          | tyCnstr.inh = patTyCnstr.inh
          | ty = ty.p
          | knTy = ty.p.k
          | patFunTy = _
      judge E : expr
          | tyCnstr.syn = tyCnstr.e
          | knTy = ty.e.k
      -    
      judge R : decl
          | tyCnstr.syn = tyCnstr.e
    view HM =
      judge instKnown : inst.known = ty.i === inst.K(ty.sig)
      judge C : chooseKnownOrOther
          | ty.s = ty.i
      ---
    view I1 =
      judge - instKnown
      judge C : chooseKnownOrOther
          | ty.s = ty.sig
      judge E : expr
          | fiopt = strongFIOpts
      judge P : patexpr
          | fiopt = strongFIOpts
          | tyGam.inh = tyGam
          | tyGam.syn = _
      ---
    view I2 =
      judge E : expr
          | ity = ity.e
          | ityCnstr.syn = ityCnstr.e
      judge fitE : fit = impredFIOpts :- ity.e <= (ityCnstr.e ty.p) : fo_fitE : _ ~> ityCnstr.E
      ---
      judge R : decl
          | tySigTyCnstr.syn = tySigTyCnstr.inh
          | ityCnstr.syn = ityCnstr.E ityCnstr.e
    view DT =
      judge C : chooseKnownOrOther
          | fiopt.str = strongFIOpts
          | fiopt.wk = weakFIOpts
          | fiopt = fiopt.e
      judge E : expr
          | fiopt = fiopt.e
      ---
    view CG =
      judge E : expr
          | translExpr = translExpr.e
      ---
      judge R : decl
          | translBind = [declPat :-> translExpr.e]

-------------------------------------------------------------------------
-- Pattern Expr
-------------------------------------------------------------------------

scheme patexpr "PatExpr" =
  view K =
    holes [ knTy: Ty, node p: PatExpr | thread valGam: ValGam |  ]
    judgespec valGam.inh ; knTy :-.."p" p : valGam.syn
    explain (Knowing the type of pattern |p| to be |knTy| , yielding additional bindings |valGam.syn| (for identifiers introduced by |p|))
    explain knTy = (Known type of pattern)
    explain valGam.inh = (Already gathered bindings (for this EH version initially | [] |))
    explain valGam.syn = (|valGam.inh| + new bindings)
  view C =
    holes [ | thread tyCnstr: Cnstr | retain ty: Ty, patFunTy: Ty ]
    judgespec tyCnstr.inh ; valGam.inh ; knTy :-.."p" p : ty ; valGam.syn ~> tyCnstr.syn ; patFunTy
    explain (Knowing the type of pattern |p| to be |tyCnstr.inh knTy| ,
             |p| has type |ty| and bindings |valGam.syn| (for identifiers introduced by |p|) ,
             under constraints |tyCnstr.syn|
            )
    explain tyCnstr.inh = (Already known constraints)
    explain tyCnstr.syn = (|tyCnstr.inh| + new constraints)
    explain ty = (Type of pattern |p|)
    -- explain patFunTy = (The type which encodes the value dissection as a function type, from value to tuple (holding the constituents of the value))
    explain patFunTy = ((Internal use only) Encoding of the value dissection as a type of the form |ty.v -> ty.e| ,
                        where a value of type |ty.v| is dissected, yielding a tuple type |ty.e| with the elements (of the dissection)
                       )
  view I1 =
    holes [ fiopt: FIOpts | thread tyGam: TyGam | ]
    judgespec fiopt ; tyGam.inh ; valGam.inh ; tyCnstr.inh ; knTy :- p : ty ; tyGam.syn ; valGam.syn ~> tyCnstr.syn ; patFunTy
    judgeuse tex fiopt ; valGam.inh ; tyCnstr.inh ; knTy :-.."p" p : ty ; valGam.syn ~> tyCnstr.syn ; patFunTy
    explain (Knowing the type of pattern |p| to be |knTy| , |valGam.syn| hold bindings for identifiers introduced by |p| , |tyGam.syn| holds bindings for lexically scoped type variables .)
    explain fiopt = (|fitsIn| options, additional contextual information for | <= |)
    explain tyGam.inh = (Already gathered type variable bindings)
    explain tyGam.syn = (|tyGam.inh| + new bindings)

rulesgroup patexpr.baseForEH1 scheme patexpr "Pattern expression type rules" =
  rule patexpr.base p.int
  rule patexpr.base p.char
  rule patexpr.base p.var
  rule patexpr.base p.varas
  rule patexpr.base p.apptop
  rule patexpr.base p.app

rulesgroup patexpr.baseForEH2 scheme patexpr "Pattern expression type rules" =
  rule patexpr.base p.int
  rule patexpr.base p.con
  rule patexpr.base p.var
  rule patexpr.base p.varas
  rule patexpr.base p.apptop
  rule patexpr.base p.app

rulesgroup patexpr.eh4 scheme patexpr "Pattern expression type rules" =
  rule patexpr.base p.var
  rule patexpr.base p.varas

ruleset patexpr.base scheme patexpr viewsel K - * "Pattern expression type rules" =
  rule p.int "IConst" =
    view K =
      judge F : fit = :- knTy <= tyInt : fo : _
      ---
      judge R : patexpr = valGam ; knTy :- int : valGam
    view C =
      judge F : fit
          | cnstr = tyCnstr.f
          | lty = tyCnstr.inh knTy
      ---
      judge R : patexpr
          | tyCnstr.syn = tyCnstr.f tyCnstr.inh
          | ty = tyInt
          | patFunTy = ANY
    view I1 =
      ---
      judge R : patexpr
          | tyGam.syn = tyGam.inh

  rule p.char : p.int "CConst" =
    view K =
      judge F : fit
          | rty = tyChar
      ---
      judge R : patexpr 
          | p = char
    view C =
      ---
      judge R : patexpr
          | ty = tyChar
          | patFunTy = ANY

  rule p.con "Con" =
    view K =
      ---
      judge R : patexpr = valGam ; knTy :- _ : valGam
    view C =
      judge P : mkProdTy = ty.p === tvarv..._
      judge V : tvarvFreshN = (`|` (identc | Nm) `|`) : (retain tvarv..._)
      ---
      judge R : patexpr
          | tyCnstr.syn = tyCnstr.inh
          | ty = ANY
          | p = identc
          | patFunTy = ty.p -> ty.p
    view I1 =
      judge - P
      judge G : valGamLookupIdTy = (hsnUn identc) :-> ty.g `elem` valGam
      judge V : tvarvFresh2
      judge fitP : fit = instLRFIOpts :- ty.g <= (tvarv1 -> tvarv2) : fo.fitP : ty.pf ~> tyCnstr.p
      judge fitR : fit = fiopt :- (tyCnstr.inh knTy) <= (tyCnstr.p tvarv1) : fo.fitR : (retain ty.r) ~> tyCnstr.r
      ---
      judge R : patexpr
          | tyGam.syn = tyGam.inh
          | ty = ty.r
          | tyCnstr.syn = tyCnstr.r tyCnstr.inh
          | patFunTy = ty.pf
    view DT =
      judge fitP : fit
          | fiopt = instFIOpts
      ---

  rule p.var "Var" =
    view K =
      judge B : bind1PatIdToTy = valGam.i === [identv :-> knTy]
      ---
      judge R : patexpr = valGam ; knTy :- identv : (valGam.i + valGam)
    view C =
      judge B : bind1PatIdToTy
          | ty = ty.p
      judge A : tyEnsureNonAny = ty.p : knTy
      ---
      judge R : patexpr
          | tyCnstr.syn = tyCnstr.inh
          | ty = ty.p
          | patFunTy = ANY
    view I1 =
      judge O : inst.tvar = ty.p, tvarf.i === exists, ty.v, tvarv, "tyInst1Exists"
      judge A : tyEnsureNonAny
          | ty.a = ty.v
      ---
      judge R : patexpr
          | tyGam.syn = tyGam.inh
    view I2 =
      judge O : inst.tvar
          | ty.i = ty.i
      judge V : tyEnsureTVar = ty.p, tyCnstr.v, tvarv.v === ty.i
      ---
      judge R : patexpr
          | tyCnstr.syn = tyCnstr.v tyCnstr.inh

  rule p.varas "VarAs" =
    view K =
      judge B : bind1PatIdToTy = valGam.i === [identv :-> knTy]
      judge P : patexpr = valGam ; knTy :- pAsPat : valGam.p
      ---
      judge R : patexpr = valGam ; knTy :- (identv @ (node 1 = pAsPat)) : (valGam.i + valGam.p)
    view C =
      judge A : tyEnsureNonAny = ty.p : knTy
      judge B : bind1PatIdToTy
          | ty = ty.p
      judge P : patexpr
          | knTy = ty.p
          | tyCnstr.syn = tyCnstr.p
          | ty = _
          | patFunTy = _
      ---
      judge R : patexpr
          | tyCnstr.syn = tyCnstr.p
          | ty = tyCnstr.p ty.p
          | patFunTy = ANY
    view I1 =
      judge O : inst.tvar = ty.p, tvarf.i === exists, ty.v, tvarv, "tyInst1Exists"
      judge A : tyEnsureNonAny
          | ty.a = ty.v
      judge P : patexpr
          | tyGam.syn = tyGam.p
      ---
      judge R : patexpr
          | tyGam.syn = tyGam.p
    view I2 =
      judge O : inst.tvar
          | ty.i = ty.i
      judge V : tyEnsureTVar = ty.p, tyCnstr.v, tvarv.v === ty.i
      judge P : patexpr
          | tyCnstr.inh = tyCnstr.v tyCnstr.inh
      ---

  rule p.apptop "AppTop" =
    view K =
      judge P : patexpr = valGam ; knTy :- pTopPatK : valGam.p
      judge open : tyOpenProd = ty..._, n === knTy
      judge arity : chkProdArity = pTopPatK : knTy , ty..._, n
      ---
      judge R : patexpr = valGam ; knTy :- (node 1 = pTopPatK) : valGam.p
    view C =
      judge F : fit = :- (tyCnstr.inh knTy) <= ty.a : fo_fitR : ty ~> tyCnstr.f
      judge P : patexpr
          | patFunTy = ty.a -> ty.r
          | tyCnstr.inh = tyCnstr.f tyCnstr.inh
      judge open : tyOpenProd
          | typ = ty.r
      ---
      judge R : patexpr
          | patFunTy = ANY   
          | ty = tyCnstr.syn ty
    view I1 =
      judge P : patexpr
          | tyGam.syn = tyGam.p
      ---
      judge R : patexpr
          | tyGam.syn = tyGam.p

  rule p.app "App" =
    view K =
      judge F : patexpr = valGam ; ty.f :- pFun : valGam.f
      judge A : patexpr = valGam.f ; ty.a :- pArg : valGam.a
      judge open: tyInitLastProd = pFun: ty.f, ty.a === knTy
      ---
      judge R : patexpr = valGam ; knTy :- ((node 1 = pFun) ^^ (node 2 = pArg)) : valGam.a
    view C =
      judge F : patexpr
          | tyCnstr.syn = tyCnstr.f
      judge A : patexpr
          | patFunTy = _ 
          | knTy = ty.a -- tyCnstr.f ty.a
          | tyCnstr.syn = tyCnstr.a
          | tyCnstr.inh = tyCnstr.f
      ---
      judge R : patexpr
          | tyCnstr.syn = tyCnstr.a
    view I1 =
      judge F : patexpr
          | tyGam.syn = tyGam.f
      judge A : patexpr
          | tyGam.inh = tyGam.f
          | tyGam.syn = tyGam.a
      ---
      judge R : patexpr
          | tyGam.syn = tyGam.a

  rule p.ann viewsel I1 - * "TypeAs" =
    view I1 =
      judge T : tyexpr = tyGam.inh :- tAnn : ty.t ~> tyGam.t ; _
      judge F : fit = fiopt :- (tyCnstr.inh knTy) <= (tyCnstr.inh ty.t) : fo : ty ~> tyCnstr.f
      judge P : patexpr = fiopt ; tyGam.t ; valGam.inh ; (tyCnstr.f tyCnstr.inh) ; ty :- pExpr : ty.p ; tyGam.p ; valGam.p ~> tyCnstr.p ; _
      ---
      judge R : patexpr = fiopt ; tyGam.inh ; valGam.inh ; tyCnstr.inh ; knTy :- (((node 2 = pExpr) :: (node 1 = tAnn))) : ty.p ; tyGam.p ; valGam.p ~> tyCnstr.p ; ANY
      
-------------------------------------------------------------------------
-- Type Expr
-------------------------------------------------------------------------

scheme tyexpr "TyExpr" =
  view E =
    holes [ node t: TyExpr | | retain ty: Ty ]
    judgespec :-.."t" t : ty
    explain (Type expression |t| has a corresponding type signature |ty| .)
    explain ty = (Type signature)
    explain t = (Type expression)
  view K =
    holes [ tyGam: TyGam | | ]
    judgespec tyGam :-.."t" t : ty
    explain (Within environment |tyGam| , type expression |t| has a (replica) type signature |ty| .)
    explain tyGam = (Environment | (ident :-> ty)..._ | for type identifiers)
  view HM =
    holes [ | thread tyGam: TyGam | tyWildL: TyL ]
    judgespec tyGam.inh :-.."t" t : ty ~> tyGam.syn ; tyWildL
    explain (Within environment |tyGam.inh| , type expression |t| has a (replica) type signature |ty|
            , yielding additional bindings |tyGam.syn| and wild type variables |tyWildL|
            .)
    explain tyGam.inh = (Environment | (ident :-> ty)..._ | with known bindings for type identifiers)
    explain tyGam.syn = (Environment with |tyGam.inh| + new bindings)
    explain tyWildL = (Type variables which occur as wildcard)

rulesgroup tyexpr.eh2 scheme tyexpr "Type expression type rules" =
  rule tyexpr.base t.wild

rulesgroup tyexpr.eh3 scheme tyexpr "Type expression type rules" =
  rule tyexpr.base t.con
  rule tyexpr.base t.app
  rule tyexpr.base t.var
  rule tyexpr.base t.var.w

rulesgroup tyexpr.eh4 scheme tyexpr "Type expression type rules" =
  rule tyexpr.base t.quant

ruleset tyexpr.base scheme tyexpr viewsel K - * "Type expression type rules" =
  rule t.con "Con" =
    view E =
      ---
      judge R : tyexpr = :- identc : (tyexprCon identc)
    view K =
      judge G : tyGamLookupId = identc :-> tgi, ty `elem` tyGam
      ---
      judge R : tyexpr
          | ty = ty
    view HM =
      judge G : tyGamLookupId
          | tyGam = tyGam.inh
      ---
      judge R : tyexpr
          | tyWildL = []
          | tyGam.syn  = tyGam.inh
    
  rule t.app "App" =
    view E =
      judge F : tyexpr = :- tFun : ty.f
      judge A : tyexpr = :- tArg : ty.a
      ---
      judge R : tyexpr = :- ((node 1 = tFun) ^^ (node 2 = tArg)) : (ty.f ty.a)
    view HM =
      judge F : tyexpr
          | tyGam.syn  = tyGam.f
          | tyWildL = tvarv.f.._
      judge A : tyexpr
          | tyWildL = tvarv.a.._
          | tyGam.inh  = tyGam.f
          | tyGam.syn  = tyGam.a
      ---
      judge R : tyexpr
          | tyWildL = tvarv.a.._ ++ tvarv.f.._
          | tyGam.syn  = tyGam.a

  rule t.wild viewsel C - * "Wild" =
    view C =
      judge V : kvarvFresh = tgi, tvarv
      ---
      judge R : tyexpr = tyGam :- (...) : tvarv
    view HM =
      ---
      judge R : tyexpr
          | tyWildL = [tvarv]
          | tyGam.syn  = tyGam.inh

  rule t.var viewsel HM - * "Var" =
    view HM =
      judge G : tyGamLookupOrNewId = tgi, ty, tvarv, tyGam.i === identv, tyGam.inh
      ---
      judge R : tyexpr = tyGam.inh :- identv : ty ~> (tyGam.i + tyGam.inh) ; ([])

  rule t.var.w : t.var viewsel HM - * "VarWild" =
    view HM =
      ---
      judge R : tyexpr
          | t = % identv
          | tyWildL = [tvarv]

  rule t.quant viewsel I1 - * "Quant" =
    view I1 =
      judge V : tvarvFresh
      judge G : bind1TyIdToTy = tyGam.i, tgi === tVar, tvarv
      judge T : tyexpr = ((emptyGam|TyGam) ++ (tyGam.i ++ tyGam.inh)) :- tExpr : ty.t ~> tyGam.t ; tvarv.t.._
      judge split : valGamPop = tyGam.l ++ _ === tyGam.t
      ---
      judge R : tyexpr = tyGam.inh :- ((tQu|TyQu) tVar (.) (node 1 = tExpr)) : (tyexprQuant tQu tvarv `.` ty.t) ~> (tyGam.l + tyGam.inh) ; tvarv.t.._
    
-------------------------------------------------------------------------
-- Predicates (proving of)
-------------------------------------------------------------------------

scheme pred "Pred" =
  view E =
    holes [ predGam: PredGam, node pred: Pred | |  ]
    judgespec predGam :-.."pi" pred
  view P =
    holes [ | | ty: Ty, translExpr: TranslExpr ]
    judgespec predGam :-.."pi" pred ~> translExpr : ty

-------------------------------------------------------------------------
-- Ty alternative elimination
-------------------------------------------------------------------------

relation tyAltTyElim =
  view I2 =
    holes [ fiopt: FIOpts, ity: Ty, ityCnstr.inh: ICnstr, tvarv.g.._: TyVarIdS | | ty: Ty, ityCnstr: ICnstr ]
    judgespec fiopt; ityCnstr.inh; tvarv.g.._ :-..."talt elim" ity : ty ~> ityCnstr
    judgeuse ag (retain fo_altElim) `=` tyElimAlts (mkFitsInWrap' "@fe") fiopt tvarv.g.._ unique (ityCnstr.inh ity)
              | (retain ityCnstr  ) `=` tyElimAltsCleanup ityCnstr.inh (foCnstr "@fo_altElim")
              | (retain ty        ) `=` foTy "@fo_altElim"
    explain (Within a meet/join context (indicated by |fiopt|), known constraints |ityCnstr.inh| for |ity| , 
             |ty| equals |ity| in which all type alternatives (except for global type variables |tvarv.g.._|) are eliminated,
             under |ityCnstr| constraining the type alternative variables to their type alternive eliminated type.
            )
    explain ity = (Type with type alternatives |talt|)
    explain ty = (Result type, without type alternatives |talt| (for non global type variables))
    explain ityCnstr.inh =  (Known constraints for type variables in |ity|)
    explain ityCnstr =  (New constraints, constraining the type alternative variables to their type alternive eliminated type)
    explain tvarv.g.._ = (Global variables (which are not eliminated))
    explain fiopt = (Options to matching, in particular indicating meet/join)

ruleset tyAltTyElim scheme tyAltTyElim viewsel I2 - * "Type alternative elimination" =
  rule ty.ae.alts =
    view I2 =
      judge C : bind1TyVarToTy = tyCnstr === [tvarv :-> ty]
      judge NE : notIsEmpty = `|` (ty.thardH.._, ty.Qu.._) `|` > 0
      judge EQ : eqRLTy = (tvarv [ talt..._ ]) =<= ity
      judge tysH : tyAltSelect = ty.thardH.._ === talt..._ , ty, thardH, tneed
      judge tysS : tyAltSelect = ty.thardS.._ === talt..._ , ty.nQu, thardS, tneed
      judge tysQ : tyAltSelect = ty.Qu.._ === talt..._ , ty.Qu, thardS, tneed
      judge H : match = fiopt :- ((ty.thardH.._, ty.Qu.._)) <=>.(<=>) ANY : ity.thardH ~> ityCnstr.h
      judge S : match = fiopt :- (ityCnstr.h ty.thardS.._) <=>.(<=>) ity.thardH : ity.thardS ~> _
      judge AE : tyAltTyElim = fiopt ; ityCnstr.inh; tvarv.g.._ :- ity.thardS : ty ~> tyCnstr.e
      judge need : fioptMkNeed = tneed === fiopt
      judge glob : notElemTyVarIdS = tvarv `notElem` tvarv.g.._
      ---
      judge R : tyAltTyElim = fiopt ; ityCnstr.inh; tvarv.g.._ :- ity : ty ~> (tyCnstr tyCnstr.e)

  rule ty.ae.var =
    view I2 =
      judge P : tyAltPartition = (tvarv [ _ ]) === ity
      judge glob : notElemTyVarIdS = tvarv `notElem` tvarv.g.._
      ---
      judge R : tyAltTyElim = fiopt ; ityCnstr.inh; tvarv.g.._ :- ity : tvarv ~> emptyCnstr

  rule ty.ae.ty =
    view I2 =
      ---
      judge R : tyAltTyElim = fiopt ; ityCnstr.inh; tvarv.g.._ :- ty : ty ~> emptyCnstr

  rule ty.ae.arrow =
    view I2 =
      judge Res : tyAltTyElim = fiopt ; ityCnstr.inh; tvarv.g.._ :- ity.r : ty.r ~> tyCnstr.r
      judge Arg : tyAltTyElim = fiopt.a ; ityCnstr.inh; tvarv.g.._ :- ity.a : ty.a ~> tyCnstr.a
      judge S : fioptSwapMeetJoin = fiopt.a === fiopt
      ---
      judge R : tyAltTyElim = fiopt ; ityCnstr.inh; tvarv.g.._ :- (ity.a -> ity.r) : (ty.a -> ty.r) ~> (tyCnstr.a tyCnstr.r)

-------------------------------------------------------------------------
-- Gam Ty alternative elimination
-------------------------------------------------------------------------

relation valElimExprAlts =
  view I2 =
    holes [ fiopt: FIOpts, valGam: ValGam, ityCnstr.inh: ICnstr, tvarv.g.._: TyVarIdS | | ityCnstr: ICnstr ]
    judgespec fiopt; ityCnstr.inh; tvarv.g.._ :-..."Gamma talt elim" valGam : ityCnstr
    judgeuse ag (lArgElimValGam,ityCnstr,errGam)
                    `=` valElimExprAlts (fiopt) "@fe" (tvarv.g.._) unique (ityCnstr.inh) (valGam)
    explain (Within a meet/join context (indicated by |fiopt|), known constraints |ityCnstr.inh| for types in |valGam| , 
             all type alternatives (except for global type variables |tvarv.g.._|) are eliminated,
             under constraints |ityCnstr| .
            )

ruleset valElimExprAlts scheme valElimExprAlts viewsel I2 - * "Type alternative elimination (for a |Gamma|)" =
  rule g.ae.cons =
    view I2 =
      judge G : valElimExprAlts = fiopt ; ityCnstr.inh; tvarv.g.._ :- (ityCnstr.a valGam) : ityCnstr.g
      judge A : tyAltTyElim = fiopt ; ityCnstr.inh; tvarv.g.._ :- ityCnstr.inh ity : _ ~> ityCnstr.a
      ---
      judge R : valElimExprAlts = fiopt ; ityCnstr.inh; tvarv.g.._ :- ((_ :-> ity, valGam)) : (ityCnstr.g ityCnstr.a)

-------------------------------------------------------------------------
-- 'Both' alternative elimination
-------------------------------------------------------------------------

scheme tyBtTyElim =
  view I2 =
    holes [ bv: TyVarIdS, ty.tboth: Ty | | ty: Ty, ty.elim: Ty, tyCnstr: Cnstr ]
    judgespec bv :-...("/=/ elim") ty.tboth : ty ~> ty.elim ; tyCnstr
    explain (Split |ty.tboth| holding |tboth| types into |ty| holding type variables (of |tboth| types) and |tyCnstr| holding constraints on those type variables.)
    explain ty.tboth = (Type to be |tboth| type eliminated)
    explain ty = (Result type, |tboth| types replaced by their original type variable)
    explain ty.elim = (Type where |tboth| types are replaced by their |tboth| type (if not |ANY|), only used internally)
    explain tyCnstr = (Constraints for |tboth| type variables, mapping to their |tboth| type)
    explain bv = (Already bound variables for which no elimination takes place)

ruleset tyBtTyElim scheme tyBtTyElim viewsel I2 - * "Type `both' elimination" =
  rule ty.eb.any =
    view I2 =
      judge E : tvarsHasTvar = tvarv `elem` bv
      ---
      judge R : tyBtTyElim = bv :- (tvarv /=/ ANY) : tvarv ~> tvarv; ([])

  rule ty.eb.var =
    view I2 =
      judge T : tyBtTyElim = bv :- ty.b : ty ~> tvarv.e ; tyCnstr
      judge E : tvarsHasTvar = tvarv `elem` bv
      ---
      judge R : tyBtTyElim = bv :- (tvarv /=/ ty.b) : tvarv ~> tvarv; ([tvarv.e :-> tvarv] tyCnstr)

  rule ty.eb.ty =
    view I2 =
      judge T : tyBtTyElim = bv :- ty.b : ty ~> ty.e ; tyCnstr
      judge E : tvarsHasTvar = tvarv `elem` bv
      ---
      judge R : tyBtTyElim = bv :- (tvarv /=/ ty.b) : tvarv ~> ty.e ; ([tvarv :-> ty.e] tyCnstr)

-------------------------------------------------------------------------
-- Match of types
-------------------------------------------------------------------------

relation match =
  view K =
    holes [ lty: Ty, rty: Ty | howToMatch: HowToMatch | ty: Ty ]
    judgespec :-..howToMatch lty <=>.howToMatch rty : ty
    judgeuse tex :-..howToMatch lty howToMatch rty : ty
    explain (|lty| matches |rty| , |ty === rty| with |ANY| eliminated from |ty|)
    explain lty = (Type to match)
    explain rty = (Type to match)
    explain ty = (Result type)
  view C =
    holes [ | | cnstr: Cnstr ]
    judgespec :-..howToMatch lty <=>.howToMatch rty : ty ~> cnstr
    judgeuse tex :-..howToMatch lty howToMatch rty : ty ~> cnstr
    explain cnstr = (Additional constraints under which matching succeeds)
    explain (|lty| matches |rty| under constraints |cnstr| , |ty === cnstr rty|)
  view I1 =
    holes [ fiopt: FIOpts | | ]
    judgespec fiopt :-..howToMatch lty <=>.howToMatch rty : ty ~> cnstr
    judgeuse tex fiopt :-..howToMatch lty howToMatch rty : ty ~> cnstr
    explain fiopt = (Options to steer | <=> | , encodes matching variants as well)
  view EX =
    explain (|lty| matches |rty| under constraints |cnstr| , |ty| equals |cnstr rty| , where |ty| may have its quantifiers instantiated, depending on |fiopt|)
  view P =
    holes [ | | coe: Coe ]
    judgespec fiopt :-..howToMatch lty <=>.howToMatch rty : ty ~> cnstr ; coe
    judgeuse tex fiopt :-..howToMatch lty howToMatch rty : ty ~> cnstr ; coe
    explain coe = (Coercion (from |lty| to |rty| values) required for | <=> | to hold (currently only meaningful for | <= |))

rulesgroup match.base scheme match "Type matching (basic |<=>|, part I)" =
  rule match.all m.con
  rule match.all m.var
  rule match.all m.var.l1
  rule match.all m.var.l2
  rule match.all m.arrow
  rule match.all m.prod

rulesgroup match.onlyK scheme match "Type matching" =
  rule match.all m.con
  rule match.all m.var
  rule match.all m.arrow
  rule match.all m.prod
  rule match.all m.any.l
  rule match.all m.any.r

rulesgroup match.eh4 scheme match "Type matching (related to |forall|)" =
  rule match.all m.con
  rule match.all m.var
  rule match.all m.var.l1
  rule match.all m.var.r1
  rule match.all m.forall.l
  rule match.all m.forall.r
  rule match.all m.forall.r2
  rule match.all m.var.l2
  rule match.all m.var.r2
  rule match.all m.arrow
  rule match.all m.prod

rulesgroup match.eh4B scheme match "Type alternative related matching (finding possible quantified types)" =
  rule match.all m.var.l1
  -- rule match.all m.var.l2
  rule match.all m.var.l3
  -- rule match.all m.var.l4
  rule match.all m.var.r1
  -- rule match.all m.var.r2
  rule match.all m.var.r3
  -- rule match.all m.var.r4
  rule match.all m.alt
  rule match.all m.alt.l1
  rule match.all m.alt.r1

rulesgroup match.eh4C scheme match "Type matching (related to |exists|)" =
  rule match.all m.exists.l
  rule match.all m.exists.r
  rule match.all m.exists.r2

rulesgroup match.eh4Bmeetjoin scheme match "Type meet/join" =
  rule match.all m.forall.l2
  rule match.all m.forall.l3
  rule match.all m.alt.l2
  rule match.all m.alt.l3

rulesgroup match.eh4Cmeetjoin scheme match "Type meet/join (|exists| specific)" =
  rule match.all m.exists.l2
  rule match.all m.exists.l3

rulesgroup match.forall scheme match "Type matching (|<=| on |forall|)" =
  rule match.all m.forall.l
  rule match.all m.forall.r
  rule match.all m.forall.r2

rulesgroup match.exists scheme match "Type matching (|<=| on |exists|)" =
  rule match.all m.exists.l
  rule match.all m.exists.r

rulesgroup match.meet scheme match "Type matching (|<+>| specific)" =
  rule match.all m.forall.l2
  rule match.all m.exists.l2

rulesgroup match.join scheme match "Type matching (|<->| specific)" =
  rule match.all m.forall.l3
  rule match.all m.exists.l3

rulesgroup match.tyBt scheme match "Type matching (|<=>| on |/=/|)" =
  rule match.all m.both
  rule match.all m.both.l1
  rule match.all m.both.l2

ruleset match.all scheme match viewsel K - * "Type matching rules" =
  rule m.any.l =
    view K =
      ---
      judge R : match = :- ANY <=>.(<=>) ty : ty

    view C =
      ---
      judge R : match
          | cnstr = []

    view P =
      ---
      judge R : match
          | coe = coeId

  rule m.any.r =
    view K =
      ---
      judge R : match = :- ty <=>.(<=>) ANY : ty

    view C =
      ---
      judge R : match
          | cnstr = []

    view P =
      ---
      judge R : match
          | coe = coeId

  rule m.con =
    view K =
      judge E : eqTy = identc.1 === identc.2
      ---
      judge R : match = :- identc.1 <=>.(<=>) identc.2 : identc.2

    view C =
      ---
      judge R : match
          | cnstr = []

    view P =
      ---
      judge R : match
          | coe = coeId

  rule m.var viewsel C - * =
    view C =
      judge E : eqTy = tvar.1 === tvar.2
      ---
      judge R : match = :- tvar.1 <=>.(<=>) tvar.2 : tvar.2 ~> ([])

    view P =
      ---
      judge R : match
          | coe = coeId

  rule m.var.l1 viewsel C - * =
    view C =
      judge C : bind1TyVarToTy = tyCnstr === [tvarv :-> ty]
      ---
      judge R : match = :- tvarv <=>.(<=>) ty : ty ~> tyCnstr
    view I1 =
      judge O : fioptHasOpt = fioBindLFirstY `elem` fiopt
      ---
    view I2 =
      judge O : fioptHasOpt 
          | opt = fioBindToTyAltsN, fioBindLFirstY
      ---
    view P =
      ---
      judge R : match
          | coe = coeId

  rule m.var.l2 : m.var.l1 viewsel I1 - * =
    view I1 =
      judge O : fioptHasOpt = fioBindLFirstN `elem` fiopt
      ---
    view I2 =
      judge O : fioptHasOpt = (fioBindToTyAltsN, fioBindLFirstN) `elem` fiopt
      ---

  rule m.var.l3 viewsel I2 - * =
    view I2 =
      judge NE : neqTy = ty.2 =/= (_[_])
      judge M : tyAltMk = ty === tvarv.1 [ (ty.2 :: thardS / tneedR) ]
      judge C : bind1TyVarToTy = tyCnstr === [tvarv.1 :-> ty]
      judge O : fioptHasOpt = (fioBindToTyAltsY, fioBindLFirstY) `elem` fiopt
      ---
      judge R : match = fiopt :- tvarv.1 <=>.(<=>) ty.2 : ty ~> tyCnstr

  rule m.var.l4 : m.var.l3 viewsel I2 - * =
    view I2 =
      judge O : fioptHasOpt = (fioBindToTyAltsY, fioBindLFirstN) `elem` fiopt
      ---

  rule m.var.r1 : m.var.l1 viewsel C - * =
    view C =
      ---
      judge R : match
          | lty = ty
          | rty = tvarv
    view I1 =
      judge O : fioptHasOpt
          | opt = fioBindRFirstY
      ---
    view I2 =
      judge O : fioptHasOpt
          | opt = fioBindToTyAltsN, fioBindRFirstY
      ---

  rule m.var.r2 : m.var.l1 viewsel I1 - * =
    view I1 =
      judge O : fioptHasOpt
          | opt = fioBindRFirstN
      ---
      judge R : match
          | lty = ty
          | rty = tvarv
    view I2 =
      judge O : fioptHasOpt
          | opt = fioBindToTyAltsN, fioBindRFirstN
      ---

  rule m.var.r3 : m.var.l3 viewsel I2 - * =
    view I2 =
      judge NE : neqTy
          | lty = ty.1
      judge O : fioptHasOpt
          | opt = fioBindToTyAltsY, fioBindRFirstY
      judge M : tyAltMk
          | tys = ty.1 :: thardS / tneedO
          | tvarv = tvarv.2
      judge C : bind1TyVarToTy
          | tvarv = tvarv.2
      ---
      judge R : match
          | lty = ty.1
          | rty = tvarv.2

  rule m.var.r4 : m.var.r3 viewsel I2 - * =
    view I2 =
      judge O : fioptHasOpt
          | opt = fioBindToTyAltsY, fioBindRFirstN
      ---

  rule m.forall.l viewsel I1 - * =
    view I1 = 
      judge F : match = fiopt :- ty.i <=>.(<=) ty.2 : ty ~> tyCnstr
      judge I : inst.tvarv' = ty.i, tvarv, tvarv..._ === ty.1, alpha
      ---
      judge R : match = fiopt :- (forall ^ alpha..._ `.` ty.1) <=>.(<=) ty.2 : ty ~> tyCnstr
    
  rule m.forall.r viewsel I1 - * =
    view I1 = 
      judge F : match = fiopt :- ty.1 <=>.(<=) ty.i : ty ~> tyCnstr
      judge I : inst.tvarv' = ty.i, tvarf, tvarf..._ === ty.2, alpha
      ---
      judge R : match = fiopt :- ty.1 <=>.(<=) (forall ^ alpha..._ `.` ty.2) : (tyCnstr (forall ^ alpha..._ `.` ty.2)) ~> tyCnstr  
    view DT = 
      judge O : fioptHasOpt = fioLeaveRInstN `elem` fiopt
      ---
    
  rule m.forall.r2 viewsel DT - * =
    view DT = 
      judge O : fioptHasOpt = fioLeaveRInstY `elem` fiopt
      judge F : match = fiopt :- ty.1 <=>.(<=) ty.i : ty ~> tyCnstr
      judge I : inst.tvarv' = ty.i, tvarv, tvarv..._ === ty.2, alpha
      ---
      judge R : match = fiopt :- ty.1 <=>.(<=) (forall ^ alpha..._ `.` ty.2) : ty ~> tyCnstr
    
  rule m.exists.l viewsel I1 - * =
    view I1 = 
      judge F : match = fiopt :- ty.i <=>.(<=) ty.2 : ty ~> tyCnstr
      judge I : inst.tvarv' = ty.i, tcon, tcon..._ === ty.1, alpha
      ---
      judge R : match = fiopt :- (exists ^ alpha..._ `.` ty.1) <=>.(<=) ty.2 : ty ~> tyCnstr
    
  rule m.exists.r viewsel I1 - * =
    view I1 = 
      judge F : match = fiopt :- ty.1 <=>.(<=) ty.i : ty ~> tyCnstr.f
      judge I : inst.tvarv' = ty.i, tvarv, tvarv..._ === ty.2, alpha
      judge C : bindDelTyVarIds = tyCnstr === tyCnstr.f \\ tvarv..._
      ---
      judge R : match = fiopt :- ty.1 <=>.(<=) (exists ^ alpha..._ `.` ty.2) : (tyCnstr (exists ^ alpha..._ `.` ty.2)) ~> tyCnstr
    view DT =
      judge O : fioptHasOpt = fioLeaveRInstN `elem` fiopt
      ---

  rule m.exists.r2 viewsel DT - * =
    view DT = 
      judge O : fioptHasOpt = fioLeaveRInstY `elem` fiopt
      judge F : match = fiopt :- ty.1 <=>.(<=) ty.i : ty ~> tyCnstr
      judge I : inst.exists = ty.i === inst.exists(exists ^ alpha..._ `.` ty.2)
      ---
      judge R : match = fiopt :- ty.1 <=>.(<=) (exists ^ alpha..._ `.` ty.2) : ty ~> tyCnstr
    
  rule m.arrow =
    view K =
      judge Arg : match = :- ty.2.a <=>.(<=>) ty.1.a : ty.a
      judge Res : match = :- ty.1.r <=>.(<=>) ty.2.r : ty.r
      ---
      judge R : match = :- (ty.1.a -> ty.1.r) <=>.(<=>) (ty.2.a -> ty.2.r) : (ty.a -> ty.r)
    view C =
      judge Arg : match
          | cnstr = tyCnstr.a
      judge Res : match
          | cnstr = tyCnstr.r
          | lty = tyCnstr.a ty.1.r
          
          | rty = tyCnstr.a ty.2.r
      ---
      judge R : match
          | cnstr = tyCnstr.r tyCnstr.a
          | ty = tyCnstr.r ty.a -> ty.r
    view I1 =
      judge Arg : match
          | fiopt = fioBindRFirstY, fioBindLFirstY, fiopt
      ---
    view DT =
      judge Arg : match
          | fiopt = fioLeaveRInstN, fioBindRFirstY, fioBindLFirstY, fiopt
      ---
    
  rule m.prod =
    view K =
      judge Arg : match = :- ty.1.l <=>.(<=>) ty.2.l : ty.l
      judge Res : match = :- ty.1.r <=>.(<=>) ty.2.r : ty.r
      ---
      judge R : match = :- ((ty.1.l,ty.1.r)) <=>.(<=>) ((ty.2.l,ty.2.r)) : ((ty.l,ty.r))

    view C =
      judge Arg : match
          | cnstr = tyCnstr.l
      judge Res : match
          | cnstr = tyCnstr.r
          | lty = tyCnstr.l ty.1.r
          | rty = tyCnstr.l ty.2.r
      ---
      judge R : match
          | cnstr = tyCnstr.r tyCnstr.l
          | ty = (tyCnstr.r ty.l,ty.r)
    
  rule m.alt viewsel I2 - * =
    view I2 =
      judge M : tyAltMk = ty === tvarv.2 [ (talt.1.._, talt.2.._) ]
      judge C : bind2TyVarToTy = tyCnstr === [tvarv.1, tvarv.2 :-> ty]
      ---
      judge R : match = fiopt :- (tvarv.1 [ talt.1.._ ]) <=>.(<=) (tvarv.2 [ talt.2.._ ]) : ty ~> tyCnstr

  rule m.alt.l1 viewsel I2 - * =
    view I2 =
      judge M : tyAltMk = ty === tvarv.1 [ (ty.2 :: thardS / tneedR, talt.1.._) ]
      judge C : bind1TyVarToTy = tyCnstr === [tvarv.1 :-> ty]
      ---
      judge R : match = fiopt :- (tvarv.1 [ talt.1.._ ]) <=>.(<=) ty.2 : ty ~> tyCnstr

  rule m.alt.r1 : m.alt.l1 viewsel I2 - * =
    view I2 =
      judge M : tyAltMk
          | tys = ty.1 :: thardS / tneedO, talt.2.._
          | tvarv = tvarv.2
      judge C : bind1TyVarToTy
          | tvarv = tvarv.2
      ---
      judge R : match
          | lty = ty.1
          | rty = tvarv.2 [ talt.2.._ ]

  rule m.forall.l2 viewsel I2 - * =
    view I2 =
      judge I : inst.tvarb' = ty.i, (tvarv./=/), tvarv./=/.._ === ty.1, alpha, _
      judge M : match = fiopt :- ty.i <=>.(<+>) ty.2 : ty.m ~> tyCnstr.m
      judge BE : tyBtTyElim = tvarv./=/.._ :- ty.m : ty ~> _ ; tyCnstr.e
      ---
      judge R : match = fiopt :- (forall ^ alpha..._ `.` ty.1) <=>.(<+>) ty.2 : (forall ^ tvarv./=/.._ `.` ty) ~> (tyCnstr.e tyCnstr.m)

  rule m.exists.l2 viewsel I2 - * =
    view I2 =
      judge I : inst.tvarb' = ty.i, (tvarv./=/), tvarv./=/.._ === ty.1, alpha, _
      judge M : match = fiopt :- ty.i <=>.(<+>) ty.2 : ty.m ~> tyCnstr.m
      judge BE : tyBtTyElim = tvarv./=/.._ :- ty.m : ty ~> _ ; tyCnstr.e
      ---
      judge R : match = fiopt :- (exists ^ alpha..._ `.` ty.1) <=>.(<+>) ty.2 : (exists ^ tvarv./=/.._ `.` tyCnstr.e ty) ~> (tyCnstr.e tyCnstr.m)

  rule m.forall.l3 : m.forall.l2 viewsel I2 - * =
    view I2 =
      judge M : match
          | howToMatch = <->
      ---
      judge R : match
          | howToMatch = <->
          | ty = forall ^ tvarv./=/.._ `.` tyCnstr.e ty

  rule m.exists.l3 : m.exists.l2 viewsel I2 - * =
    view I2 =
      judge M : match
          | howToMatch = <->
      ---
      judge R : match
          | howToMatch = <->
          | ty = exists ^ tvarv./=/.._ `.` ty

  rule m.both viewsel I2 - * =
    view I2 =
      judge M : match = fiopt :- ty.1 <=>.(<+->) ty.2 : ty ~> tyCnstr.m
      judge C : bind1TyVarToTy = tyCnstr === [(tvarv.1, tvarv.2) :-> (tvarv.2 /=/ ty)]
      ---
      judge R : match = fiopt :- (tvarv.1 /=/ ty.1) <=>.(<+->) (tvarv.2 /=/ ty.2) : (tvarv.2 /=/ ty) ~> (tyCnstr tyCnstr.m)

  rule m.both.l1 viewsel I2 - * =
    view I2 =
      judge C : bind1TyVarToTy = tyCnstr === [tvarv :-> (tvarv /=/ ty)]
      ---
      judge R : match = fiopt :- (tvarv /=/ ANY) <=>.(<+->) ty : (tvarv /=/ ty) ~> tyCnstr

  rule m.both.l2 viewsel I2 - * =
    view I2 =
      judge M : match = fiopt :- ty.1 <=>.(<+->) ty.2 : ty ~> tyCnstr.m
      judge C : bind1TyVarToTy = tyCnstr === [tvarv :-> (tvarv /=/ ty)]
      ---
      judge R : match = fiopt :- (tvarv /=/ ty.1) <=>.(<+->) ty.2 : (tvarv /=/ ty) ~> (tyCnstr tyCnstr.m)

  rule m.alt.l2 : m.alt.l1 viewsel I2 - * =
    view I2 =
      judge M : tyAltMk
          | tys = ty.2 :: thardH / tneedR, talt.1.._
      ---
      judge R : match
          | howToMatch = <+>

  rule m.alt.l3 : m.alt.l1 viewsel I2 - * =
    view I2 =
      judge M : tyAltMk
          | tys = ty.2 :: thardH / tneedO, talt.1.._
      ---
      judge R : match
          | howToMatch = <->

{-
    judge fit fiopt ; Gamma :- (tvarv.1 [ talt.1.._ ]) <= (tvarv.2 [ talt.2.._ ])
        : sigma
        ~> ([tvarv.(1,2) :-> sigma]) ; CnstrEq ; coe
-}

-------------------------------------------------------------------------
-- Fit
-------------------------------------------------------------------------

relation fit =
  view K =
    holes [ lty: Ty, rty: Ty | | fo: FIOut, ty: Ty ]
    judgespec :-.."<=" lty <= rty : fo : ty
    judgeuse tex :-.."<=" lty <= rty : ty
    judgeuse ag (retain fo) `=` (lty) `fitsIn` (rty)
           | ty `=` foTy (fo)
    explain (| <= | delegates to | <=> | .)
    explain lty = (Type to fit in |rty|)
    explain rty = (Type in which |lty| must fit)
    explain ty = (Result type, (in general) equals |rty| , but differs slightly in later versions)
  view C =
    holes [ | | cnstr: Cnstr ]
    judgespec :-.."<=" lty <= rty : fo : ty ~> cnstr
    judgeuse tex :-.."<=" lty <= rty : ty ~> cnstr
    judgeuse ag (retain fo) `=` fitsIn ^ ((lty) - (rty))
           | ty `=` foTy (fo)
           | cnstr `=` foCnstr (fo)
    explain ty = (|ty === cnstr rty|)
  view I1 =
    holes [ fiopt: FIOpts | | ]
    judgespec fiopt :-.."<=" lty <= rty : fo : ty ~> cnstr
    judgeuse tex fiopt :-.."<=" lty <= rty : ty ~> cnstr
    judgeuse ag (retain fo) `=` fitsIn (fiopt) "@fe" unique (lty) (rty)
           | ty `=` foTy (fo)
           | cnstr `=` foCnstr (fo)
    explain fiopt = (Options to | <=> |)
  view EX =
    explain ty = (|ty === cnstr rty| , where quantifiers in |rty| may be left instantiated in |ty| (depending on |fiopt|))
  view P =
    holes [ | | coe: Coe ]
    judgespec fiopt :-.."<=" lty <= rty : fo : ty ~> cnstr ; coe
    judgeuse tex fiopt :-.."<=" lty <= rty : ty ~> cnstr ; coe
    judgeuse ag (retain fo) `=` fitsIn (fiopt) "@fe" unique (lty) (rty)
           | ty `=` foTy fo
           | cnstr `=` foCnstr (fo)
           | coe `=` (foCSubst (fo),foLCoeL (fo),foRCoeL (fo))
    explain coe = (Coercion (from |lty| to |rty| values) required for | <= | to hold)

ruleset fit scheme fit viewsel K - * "Fitting of types" =
  rule fit =
    view K =
      judge M : match
      ---
      judge R : fit
          | fo = emptyFO

    view I2 =
      judge M : match
          | fiopt = fioFitY, fiopt
      ---

-------------------------------------------------------------------------
-- Join
-------------------------------------------------------------------------

relation join =
  view I2 =
    holes [ fiopt: FIOpts, lty: Ty, rty: Ty | | ty: Ty, cnstr: Cnstr ]
    judgespec fiopt :-.."<->" lty <-> rty : ty ~> cnstr
    explain (| <-> | delegates to | <=> | .)
    explain lty = (Type to join)
    explain rty = (Type to join)
    explain ty = (Result type: |lty <= ty && rty <= ty|)

ruleset join scheme join "Join of types" =
  rule join viewsel I2 - * =
    view I2 =
      judge M : match
          | fiopt = fioJoinY, fiopt
      ---
      judge R : join

-------------------------------------------------------------------------
-- Meet
-------------------------------------------------------------------------

relation meet =
  view I2 =
    holes [ fiopt: FIOpts, lty: Ty, rty: Ty | | ty: Ty, cnstr: Cnstr ]
    judgespec fiopt :-.."<+>" lty <+> rty : ty ~> cnstr
    explain (| <+> | delegates to | <=> | .)
    explain lty = (Type to meet)
    explain rty = (Type to meet)
    explain ty = (Result type: |ty <= lty && ty <= rty|)

ruleset meet scheme meet "Join of types" =
  rule meet viewsel I2 - * =
    view I2 =
      judge M : match
          | fiopt = fioMeetY, fiopt
      ---
      judge R : meet

-------------------------------------------------------------------------
-- Binding from a Gamma
-------------------------------------------------------------------------

relation valGamLookupIdTy =
  view E =
    holes [ nm: Nm, valGam: ValGam | | ty: Ty ]
    judgespec nm :-> ty `elem` valGam
    judgeuse ag  (ty,nmErrs) `=` valGamLookupTy (nm) (valGam)

relation tyGamLookupId =
  view K =
    holes [ nm: Nm, tyGam: TyGam | | ty: Ty, tgi: TyGamInfo ]
    judgespec nm :-> tgi, ty `elem` tyGam
    judgeuse tex nm :-> ty `elem` tyGam
    judgeuse ag  (tgi,nmErrs) `=` case ( tyGamLookup nm tyGam of
                                       - Nothing    ->  (TyGamInfo Ty_Any,[Err_NamesNotIntrod [nm]])
                                       - Just tgi   ->  (tgi,[])
                                       )
              |  ty           `=` tgiTy tgi

relation tyGamLookupOrNewId =
  view HM =
    holes [ nm: Nm, tyGam: TyGam | | ty: Ty, tvarv: Ty, tgi: TyGamInfo, tyGam.i: TyGam ]
    judgespec tgi, ty, tvarv, tyGam.i === nm, tyGam
    judgeuse tex nm :-> ty `elem` tyGam ^^ || ^^ tyGam.i === (nm :-> tvarv) && ty === tvarv && tvarv (text "fresh")
    judgeuse ag  (tgi,tyGam.i) `=` case ( tyGamLookup nm tyGam of
                                        - Nothing    ->  ( let  t `=` TyGamInfo (mkTyVar unique)
                                                         - in   (t,gamUnit nm t)
                                                         )
                                        - Just t     ->  (t,emptyGam)
                                        )
              |  (retain ty)   `=` tgiTy tgi
              |  tvarv         `=` ty

relation valGamLookupPatTy =
  view K =
    holes [ pat: PatExpr, valGam: ValGam | | pty: Ty ]
    judgespec pat :-> pty `elem` valGam
    judgeuse tex pat :-> pty `elem` valGam
    judgeuse ag  (pty,nmErrs)
                    `=` ( let ^ ( e `=` [Err_MissingSig (pat).pp]
                                - l n `=` gamLookup n (valGam)
                                )
                        - in case ^ ( ((pat).mbTopNm) of
                                    - Nothing ->  ((ANY, e))
                                    - Just nm ->  case ^ ( l nm of
                                                         - Nothing   -> ((ANY, e))
                                                         - Just vgi  -> ((vgiTy vgi, []))
                                                         )
                                    )
                        )
                        
  view C =
    judgeuse ag  (pty,hasTySig)
                    `=` case ( ((pat).mbTopNm) of
                             - Nothing ->  ((ANY,False))
                             - Just nm ->  case ( gamLookup nm (valGam) of
                                                - Nothing   -> ((ANY,False))
                                                - Just vgi  -> ((vgiTy vgi,True))
                                                )
                             )

relation predGamLookupPrTyEv =
  view P =
    holes [ pred: Pred, predGam: PredGam | | ty: Ty, evid: Transl ]
    judgespec pred :> evid : ty `elem`.pi predGam
    judgeuse ag (ty,evid) `=` fitPredToEvid (pred) (predGam)

-------------------------------------------------------------------------
-- Choose quantifier based on coco variance
-------------------------------------------------------------------------

relation quForCoCo =
  view I1 =
    holes [ coco: CoCo | | qu: TyQu ]
    judgespec qu === coco
    judgeuse tex qu === if coco === cocoY then forall else exists

-------------------------------------------------------------------------
-- Choose between known and other type
-------------------------------------------------------------------------

relation chooseKnownOrOther =
  view C =
    holes [ tvarv: Ty, ty.s: Ty, ty.p: Ty | | ty.p.k: Ty, ty.e.k: Ty ]
    judgespec ty.p.k, ty.e.k === tvarv, ty.s, ty.p
    judgeuse tex ty.p.k === ty.s && ty.e.k === ty.s ^^ || ^^ ty.p.k === tvarv && ty.e.k === ty.p
    judgeuse ag ty.p.k `=` if "@hasTySig" then ty.s else tvarv
              | ty.e.k `=` if "@hasTySig" then ty.s else ty.p
  view DT =
    holes [ fiopt.str: FIOpts, fiopt.wk: FIOpts | | fiopt: FIOpts ]
    judgespec ty.p.k, ty.e.k, fiopt === tvarv, ty.s, ty.p, fiopt.str, fiopt.wk
    judgeuse tex ty.p.k === ty.s && ty.e.k === ty.s && fiopt === fiopt.str ^^ || ^^ ty.p.k === tvarv && ty.e.k === ty.p && fiopt === fiopt.wk
    judgeuse ag ty.p.k `=` if "@hasTySig" then ty.s else tvarv
              | ty.e.k `=` if "@hasTySig" then ty.s else ty.p
              | fiopt `=` if "@hasTySig" then fiopt.str else fiopt.wk

-------------------------------------------------------------------------
-- Split gam
-------------------------------------------------------------------------

relation valGamPop =
  view K =
    holes [ g: ValGam | | g.l: ValGam, g.g: ValGam ]
    judgespec g.l ++ g.g === g
    judgeuse ag (g.l,g.g) `=` gamPop (g)

-------------------------------------------------------------------------
-- Bindings from a PredGam, deconstruction
-------------------------------------------------------------------------

relation predGamOpenIdTy =
  view P =
    holes [ predGam: PredGam | | nm: Nm, pred: Pred ]
    judgespec [nm :~> pred] === predGam

-------------------------------------------------------------------------
-- Make a singleton Gamma
-------------------------------------------------------------------------

relation bind1ValIdToTy =
  view E =
    holes [ nm: Nm, ty: Ty | | valGam: ValGam ]
    judgespec valGam === [nm :-> ty]
    judgeuse ag  valGam `=` gamUnit (nm) (ValGamInfo (ty))

relation bind1TyIdToTy =
  view I1 =
    holes [ nm: Nm, ty: Ty | | tyGam: TyGam, tgi: TyGamInfo ]
    judgespec tyGam, tgi === nm, ty
    judgeuse tex tyGam === [nm :-> ty]
    judgeuse ag  (retain tgi) `=` TyGamInfo (ty)
              |  tyGam        `=` gamUnit (nm) (tgi)

relation bind1PatIdToTy =
  view E =
    holes [ nm: Nm, ty: Ty | | valGam: ValGam ]
    judgespec valGam === [nm :-> ty]
    judgeuse ag  (retain valGam)
                        `=` ( if "@lhs.inclVarBind" && nm /= hsnWild
                            - then  gamUnit nm (ValGamInfo ty)
                            - else  emptyGam
                            )

relation bind1PredToTy =
  view E =
    holes [ pred: Pred, ty: Ty, evid: TranslExpr | | predGam: PredGam ]
    judgespec predGam === [pred :> evid : ty ]

-------------------------------------------------------------------------
-- Make a Cnstr
-------------------------------------------------------------------------

relation bind1TyVarToTy =
  view C =
    holes [ tvarv: TyVarId, ty: Ty | | tyCnstr: Cnstr ]
    judgespec tyCnstr === [tvarv :-> ty]
    judgeuse ag  tyCnstr `=` cnstrTyUnit (tvarv) (ty)

relation bind2TyVarToTy =
  view C =
    holes [ tvarv.1: TyVarId, tvarv.2: TyVarId, ty: Ty | | tyCnstr: Cnstr ]
    judgespec tyCnstr === [tvarv.1, tvarv.2 :-> ty]
    judgeuse tex tyCnstr === [tvarv.1 :-> ty, tvarv.2 :-> ty]
    judgeuse ag  tyCnstr `=` assocLToCnstr [(tvarv.1,ty),(tvarv.2,ty)]

-------------------------------------------------------------------------
-- Remove keys from Cnstr
-------------------------------------------------------------------------

relation bindDelTyVarIds =
  view I1 =
    holes [ tvars: TyVarIdS | thread tyCnstr: Cnstr | ]
    judgespec tyCnstr.syn === tyCnstr.inh \\ tvars
    judgeuse tex tyCnstr.syn === tyCnstr.inh \\.tvars."dom"

-------------------------------------------------------------------------
-- Free type variables
-------------------------------------------------------------------------

relation ftv =
  view HM =
    holes [ ty: Ty | | tvars: TyVarIdS ]
    judgespec tvars === ftv (ty)
    judgeuse ag  tvars `=` ftv (ty)

-------------------------------------------------------------------------
-- Preds on coco
-------------------------------------------------------------------------

relation elemCoCoS =
  view I1 =
    holes [ coco: CoCo, cocos: CoCoS | | ]
    judgespec coco `elem` cocos

-------------------------------------------------------------------------
-- Preds on type variables
-------------------------------------------------------------------------

relation elemTyVarIdS =
  view I1 =
    holes [ tvarv: TyVarId, tvars: TyVarIdS | | ]
    judgespec tvarv `elem` tvars

relation notElemTyVarIdS =
  view I1 =
    holes [ tvarv: TyVarId, tvars: TyVarIdS | | ]
    judgespec tvarv `notElem` tvars

-------------------------------------------------------------------------
-- Fresh type/... variables
-------------------------------------------------------------------------

relation tvarvFresh =
  view C =
    holes [ | | tvarv: Ty ]
    judgespec tvarv
    judgeuse tex tvarv (text "fresh")
    judgeuse ag tvarv `=` mkTyVar unique

relation tvarvFresh2 =
  view C =
    holes [ | | tvarv1: Ty, tvarv2: Ty ]
    judgespec tvarv1, tvarv2
    judgeuse tex tvarv1, tvarv2 (text "fresh")
    judgeuse ag tvarv1 `=` mkTyVar unique | tvarv2 `=` mkTyVar unique

relation tpvarvFresh2 =
  view C =
    holes [ | | tvarv1: Ty, tvarv2: Ty ]
    judgespec tvarv1, tvarv2 (text "fresh")
    judgeuse ag tvarv1 `=` mkTyVar unique | tvarv2 `=` mkImplsVar unique

relation tvarvFresh3 =
  view P =
    holes [ | | tvarv1: Ty, tvarv2: Ty, tvarv3: Ty ]
    judgespec tvarv1, tvarv2, tvarv3 (text "fresh")
    judgeuse ag tvarv1 `=` mkTyVar unique | tvarv2 `=` mkTyVar unique | tvarv3 `=` mkTyVar unique

relation tvarvFresh4 =
  view P =
    holes [ | | tvarv1: Ty, tvarv2: Ty, tvarv3: Ty, tvarv4: Ty ]
    judgespec tvarv1, tvarv2, tvarv3, tvarv4 (text "fresh")
    judgeuse ag tvarv1 `=` mkTyVar unique | tvarv2 `=` mkTyVar unique | tvarv3 `=` mkTyVar unique | tvarv4 `=` mkTyVar unique

relation tvarvFreshN =
  view C =
    holes [ sz: Int | | tvarvs: TyL ]
    judgespec sz : tvarvs
    judgeuse tex tvarvs (text "fresh"), ^^ sz === `|` tvarvs `|`
    judgeuse ag tvarvs `=` map mkTyVar (mkNewUIDL (sz) unique)

relation kvarvFresh =
  view C =
    holes [ | | tgi: TyGamInfo, tvarv: Ty ]
    judgespec tgi, tvarv
    judgeuse tex tvarv (text "fresh")
    judgeuse ag (retain tgi) `=` TyGamInfo (mkTyVar unique)
              | tvarv        `=` tgiTy tgi

-------------------------------------------------------------------------
-- Free tvars of ...
-------------------------------------------------------------------------

relation valGamFtv =
  view I1 =
    holes [ g: ValGam | | tvars: TyVarIdS ]
    judgespec tvars === g
    judgeuse tex tvars === ftv(g)
    judgeuse ag tvars `=` ftv(g)

-------------------------------------------------------------------------
-- Binding from a Gamma
-------------------------------------------------------------------------

{-
relation properLetPat =
  view C =
    holes [ p: PatExpr, identv: Nm | | ]
    judgespec p === identv || p === identv@
-}

-------------------------------------------------------------------------
-- Quantification of type
-------------------------------------------------------------------------

relation tyQuantify =
  view HM =
    holes [ ty: Ty, gtvars: TyVarIdS | | ty.q: Ty ]
    judgespec gtvars :- ty : ty.q
    -- judgeuse tex ty.q === forall ^ (ftv(ty)) (.) ty
    judgeuse tex ty.q === forall ^ (ftv(ty) \\ (gtvars)) `.` ty
    judgeuse ag (retain ty.q) `=` tyQuantify (`elem` (gtvars)) ty
{-
  view I1 =
    judgeuse tex ty.q === forall ^ (ftv(ty) \\ (gtvars)) `.` ty
-}

scheme tyqu =
  view I1 =
    holes [ node ty: Ty, tvars.g: TyVarIdS, coco: CoCo | | ty.q: Ty, tvars.f: TyVarIdS ]
    judgespec tvars.g; coco :-.."Qu" ty : ty.q ~> tvars.f
    -- explain (Type |ty.q| equals |ty| , with quantifiers for type variables in |ty.q| not in |tvars.g|)
    explain (Type |ty.q| has quantified type |ty| , with quantifiers for type variables | `elem` (ftv(ty.q) \\ tvars.g)|)
    explain coco = ("Co/contravariance" context, used internally)
    explain ty =  (Type to be quantified)
    explain ty.q = (Quantified type)
    explain tvars.g = (Global type  variables, are not quantified)
    explain tvars.f = (Free type variables of |ty| , used internally)

ruleset tyqu.base scheme tyqu viewsel I1 - * "Type quantification rules" =
  rule ty.qu.var =
    view I1 =
      judge B : notElemTyVarIdS = tvarv `notElem` tvars.g
      judge Q : quForCoCo = tQu === coco
      ---
      judge R : tyqu = tvars.g; coco :- tvarv : (tQu tvarv `.` tvarv) ~> ([tvarv])

  rule ty.qu.arrow =
    view I1 =
      judge V : elemTyVarIdS = tvarv `elem` ((tvarv.a.f._ `intersect` tvarv.r.f._) \\ tvars.g)
      judge Arg : tyqu = (tvarv + tvars.g); cocoY :- ty.a : ty.a.q ~> tvarv.a.f._
      judge Res : tyqu = (tvarv + tvars.g); cocoN :- ty.r : ty.r.q ~> tvarv.r.f._
      ---
      judge R : tyqu = tvars.g; _ :- (ty.a -> ty.r) : (forall ^ tvarv `.` ty.a.q -> ty.r.q) ~> (tvarv.a.f._ `union` tvarv.r.f._)
      
  rule ty.qu.prod =
    view I1 =
      judge V : elemTyVarIdS = tvarv `elem` ((tvarv.l.f._ `intersect` tvarv.r.f._) \\ tvars.g)
      judge T1 : tyqu = (tvarv + tvars.g); cocoY :- ty.l : ty.l.q ~> tvarv.l.f._
      judge T2 : tyqu = (tvarv + tvars.g); cocoY :- ty.r : ty.r.q ~> tvarv.r.f._
      ---
      judge R : tyqu = tvars.g; _ :- ((ty.l, ty.r)) : (exists ^ tvarv `.` (ty.l.q, ty.r.q)) ~> (tvarv.l.f._ `union` tvarv.r.f._)
      
  rule ty.qu.app viewsel DT - * =
    view DT =
      judge V : elemTyVarIdS = tvarv `elem` ((tvarv.f.f._ `intersect` tvarv.a.f._) \\ tvars.g)
      judge F : tyqu = (tvarv + tvars.g); cocoNo :- ty.f : ty.f.q ~> tvarv.f.f._
      judge A : tyqu = (tvarv + tvars.g); cocoNo :- ty.a: ty.a.q ~> tvarv.a.f._
      judge Q : quForCoCo = tQu === coco
      judge C : elemCoCoS = coco `elem` ([cocoY,cocoN])
      ---
      judge R : tyqu = tvars.g; coco :- (ty.f ^^ ty.a) : (tQu tvarv `.` (ty.f.q ^^ ty.a.q)) ~> (tvarv.f.f._ `union` tvarv.a.f._)
      
  rule ty.qu.quant =
    view I1 =
      judge V : notElemTyVarIdS = tvarv `notElem` tvars.g
      judge T : tyqu = (tvarv + tvars.g); coco :- ty : ty..q ~> tvarv..f._
      ---
      judge R : tyqu = tvars.g; coco :- (Qu tvarv `.` ty) : (Qu tvarv `.` ty..q) ~> (tvarv..f._ \\ [tvarv])
      

-------------------------------------------------------------------------
-- Quantification of gamma
-------------------------------------------------------------------------

relation valGamQuantify =
  view HM =
    holes [ valGam.l: ValGam, valGam.g: ValGam, tyCnstr: Cnstr | | valGam.q: ValGam, valGam.l.subs: ValGam, valGam.g.subs: ValGam, gtvars: TyVarIdS ]
    judgespec valGam.q, gtvars, valGam.l.subs, valGam.g.subs === valGam.l, valGam.g, tyCnstr
    judgeuse tex valGam.q
                   ===  [   i :-> forall alpha..._ (.) sigma
                       `|`  (i :-> sigma) <- tyCnstr valGam.l
                        ,   alpha..._ === ftv(sigma) `-` ftv(tyCnstr valGam.g)
                        ]
    judgeuse ag (retain valGam.l.subs) `=` tyCnstr (valGam.l)
              | (retain valGam.g.subs) `=` tyCnstr (valGam.g)
              | (retain gtvars       ) `=` ftv (valGam.g.subs)
              | (retain valGam.q     ) `=` valGamQuantify gtvars valGam.l.subs
  view I2 =
    holes [ | | cnstr.q: Cnstr ]
    judgespec valGam.q, gtvars, valGam.l.subs, valGam.g.subs, cnstr.q === valGam.l, valGam.g, tyCnstr
    judgeuse tex cnstr.q
                   ===  [   tvarv.g :-> forall alpha..._ (.) sigma
                       `|`  (i :-> tvarv.g) <- valGam.l
                        ,   sigma === tyCnstr tvarv.g
                        ,   alpha..._ === ftv(sigma) \\ ftv(tyCnstr valGam.g)
                        ]
    judgeuse ag (retain valGam.l.subs) `=` tyCnstr (valGam.l)
              | (retain valGam.g.subs) `=` tyCnstr (valGam.g)
              | (retain gtvars       ) `=` ftv (valGam.g.subs)
              | (valGam.q,cnstr.q    ) `=` valGamQuantifyWithCnstr (tyCnstr) gtvars (valGam.l)

-------------------------------------------------------------------------
-- Open top level existential types in gamma
-------------------------------------------------------------------------

relation valGamInst1Exists =
  view I1 =
    holes [ valGam: ValGam | | valGam.e: ValGam ]
    judgespec valGam.e === valGam
    judgeuse tex valGam.e
                   ===  [   i :-> Cnstr sigma
                       `|`  (i :-> exists ^ tvarv..._ (.) sigma) <- valGam
                        ,   Cnstr === (tvarv :-> tvarf)..._
                        ,   tvarf (text "fresh")
                        ]
    judgeuse ag (retain valGam.e) `=` valGamInst1Exists unique (valGam)
  view I2 =
    holes [ cnstr: Cnstr | | cnstr.e: Cnstr ]
    judgespec valGam.e, cnstr.e === valGam, cnstr
    judgeuse tex cnstr.e
                   ===  [   tvarv.g :-> Cnstr sigma
                       `|`  (i :-> tvarv.g) <- valGam
                        ,   exists ^ tvarv..._ (.) sigma === cnstr tvarv.g
                        ,   Cnstr === (tvarv :-> tvarf)..._
                        ,   tvarf (text "fresh")
                        ]
    judgeuse ag (valGam.e,cnstr.e) `=` valGamInst1ExistsWithCnstr (cnstr) unique (valGam)

-------------------------------------------------------------------------
-- Ftv of ty part of tyGam
-------------------------------------------------------------------------

relation tyGamTyFtv =
  view I1 =
    holes [ tyGam: TyGam, tyCnstr: Cnstr | | tvars: TyVarIdS ]
    judgespec tvars === tyGam, tyCnstr
    judgeuse tex tvars === ftv (tyCnstr tyGam)
    judgeuse ag (retain tvars) `=` ftv `.` (tyCnstr |=>) `.` map (tgiTy `.` snd) `.` gamToAssocL $ tyGam

-------------------------------------------------------------------------
-- Filtering out ty alt constraints
-------------------------------------------------------------------------

{-
relation cnstrDelTyAlt =
  view I2 =
  holes [ ityCnstr: ICnstr | | ityCnstr.elim: ICnstr ]
  judgespec ityCnstr.elim === [c `|` c@(_ :-> ity) <- ityCnstr, ity =/= _ [_] && ity =/= tvarv ]
-}

-------------------------------------------------------------------------
-- Structural equality of ...
-------------------------------------------------------------------------

relation eqTy =
  view K =
    holes [ ty.1: Ty, ty.2: Ty | | ]
    judgespec ty.1 === ty.2

relation eqLRTy =
  view K =
    holes [ lty: Ty | | rty: Ty ]
    judgespec lty =>= rty
    judgeuse tex lty === rty

relation eqRLTy =
  view K =
    holes [ rty: Ty | | lty: Ty ]
    judgespec lty =<= rty
    judgeuse tex lty === rty

relation eqRLCnstr =
  view I2 =
    holes [ r: Cnstr | | l: Cnstr ]
    judgespec l =<= r
    judgeuse tex l === r
    judgeuse ag l `=` r

relation neqTy =
  view I2 =
    holes [ lty: Ty, rty: Ty | | ]
    judgespec lty =/= rty

-------------------------------------------------------------------------
-- Predicates on tvars
-------------------------------------------------------------------------

relation tvarsHasTvar =
  view I2 =
    holes [ tvars: TyVarIdS, tvar: TyVarId | | ]
    judgespec tvar `elem` tvars

-------------------------------------------------------------------------
-- Predicates on fiopt
-------------------------------------------------------------------------

relation fioptHasOpt =
  view I1 =
    holes [ fiopt: FIOpts, opt: Opt | | ]
    judgespec opt `elem` fiopt

relation fioptSwapMeetJoin =
  view I2 =
    holes [ fiopt: FIOpts | | fiopt.s: FIOpts ]
    judgespec fiopt.s === fiopt
    judgeuse tex fiopt.s === (text "toggle") ^^ fioMeetY (text "and") ^^ fioJoinY (text "in") ^^ fiopt

relation fioptMkNeed =
  view I2 =
    holes [ fiopt: FIOpts | | tneed: TyNeed ]
    judgespec tneed === fiopt
    judgeuse tex tneed === if fioMeetY `elem` fiopt then tneedR else tneedO

-------------------------------------------------------------------------
-- Instantiation of type (with tvars)
-------------------------------------------------------------------------

relation inst.tvar =
  view HM =
    holes [ ty: Ty, q: TyQu, tvar: TyVarId, mk: String | | ty.i: Ty, tvar.i: TyVarId ]
    judgespec ty.i, tvar.i === q, ty, tvar, mk
    judgeuse tex ty.i === Cnstr.i ty', ^^ q ^ (tvar)..._ (.) ty' === ty, ^^ Cnstr.i === ([tvar :-> tvar.i])..._, ^^ (tvar.i)..._ (text "fresh")
    judgeuse ag ty.i `=` mk unique (ty)

relation inst.tvarv' =
  view HM =
    holes [ ty: Ty, tvar: TyVarId | | ty.i: Ty, tvar.i: TyVarId, tvars.i: TyVarIdS ]
    judgespec ty.i, tvar.i, tvars.i === ty, tvar
    judgeuse tex ty.i === (Cnstr).(tvar) ty, ^^ (Cnstr).(tvar) === (tvar :-> tvar.i)..._, ^^ tvars.i (text "fresh")

-------------------------------------------------------------------------
-- Instantiation of type (with `both` vars)
-------------------------------------------------------------------------

relation inst.tvarb =
  view I1 =
    holes [ ty: Ty | | ty.i: Ty, tvars: TyVarIdS ]
    judgespec (tvars,ty.i) === inst.tvarb(ty)
    judgeuse tex ty.i === Cnstr.i ty', tvars === (tvarv')..._, | forall ^ tvarv..._ (.) ty' === ty, | Cnstr.i === ([tvarv :-> (tvarv' /=/ ANY)])..._, | (tvarv')..._ (text "fresh")

relation inst.tvarb' =
  view HM =
    holes [ ty: Ty, tvar: TyVarId, mk: String | | ty.i: Ty, tvar.i: TyVarId, tvars.i: TyVarIdS ]
    judgespec ty.i, tvar.i, tvars.i === ty, tvar, mk
    judgeuse tex ty.i === (Cnstr).(tvar) ty, ^^ (Cnstr).(tvar) === (tvar :-> (tvar.i /=/ ANY))..._, ^^ tvars.i (text "fresh")
    judgeuse ag ty.i `=` mk unique (ty)

-------------------------------------------------------------------------
-- Instantiation of type for HM checking
-------------------------------------------------------------------------

relation inst.known =
  view HM =
    holes [ ty: Ty | | ty.i: Ty ]
    judgespec ty.i === inst.K(ty)
    judgeuse tex ty.i === Cnstr.i ty', ^^ forall ^ tvarv..._ (.) ty' === ty, ^^ Cnstr.i === ([tvarv :-> tvarf])..._, ^^ (tvarf)..._ (text "fresh")
    judgeuse ag ty.i `=` tyInstKnown unique (ty)

-------------------------------------------------------------------------
-- Instantiation of type (with existential tvars, i.e. constants), only 1/top level
-------------------------------------------------------------------------

relation inst.exists1 =
  view I1 =
    holes [ ty: Ty | | ty.i: Ty ]
    judgespec ty.i === inst.exists(ty)
    judgeuse ag ty.i `=` tyInst1Exists unique (ty)

-------------------------------------------------------------------------
-- Instantiation of type (with existential tvars, i.e. constants)
-------------------------------------------------------------------------

relation inst.exists =
  view I1 =
    holes [ ty: Ty | | ty.i: Ty ]
    judgespec ty.i === inst.exists(ty)

-------------------------------------------------------------------------
-- Instantiation of predicate
-------------------------------------------------------------------------

relation inst.pred =
  view P =
    holes [ pred: Pred | | pred.i: Pred ]
    judgespec pred.i === inst.pred(pred)
    judgeuse tex pred.i === inst.pi(pred)

-------------------------------------------------------------------------
-- Non emptiness of ...
-------------------------------------------------------------------------

relation notIsEmpty =
  view I2 =
    holes [ set: Set | | ]
    judgespec `|` set `|` > 0

-------------------------------------------------------------------------
-- Ensure non equality to Ty_Any
-------------------------------------------------------------------------

relation tyEnsureNonAny =
  view C =
    holes [ ty.e: Ty | | ty.a: Ty ]
    judgespec ty.a : ty.e
    judgeuse tex ty.a === ty.e, ^^^ ty.a =/= ANY
    judgeuse ag ty.a `=` tyEnsureNonAny unique (ty.e)

-------------------------------------------------------------------------
-- Ensure quality to tvar
-------------------------------------------------------------------------

relation tyEnsureTVar =
  view I1 =
    holes [ ty.e: Ty | | ty.v: Ty, cnstr: Cnstr, tvarv: TyVarId ]
    judgespec ty.v, cnstr, tvarv === ty.e
    judgeuse tex ty.v === tvarv ^^ && ^^ cnstr === [tvarv :-> ty.e] ^^ && ^^ tvarv (text "fresh")
    judgeuse ag (ty.v,cnstr) `=` tyAsCnstr unique (ty.e)

-------------------------------------------------------------------------
-- Partitioning of alt ty
-------------------------------------------------------------------------

relation tyAltPartition =
  view I2 =
    holes [ ty: Ty | | partitionTy: Ty ]
    judgespec partitionTy === ty

relation tyAltSelect =
  view I2 = 
    holes [ tyAlts: TyPlusL, thard: TyHardness, tneed: TyNeed | | tys: TyL, tyElt: Ty ]
    judgespec tys === tyAlts, tyElt, thard, tneed
    judgeuse tex tys === [ tyElt `|` (tyElt :: thard / tneed) <- tyAlts ]

-------------------------------------------------------------------------
-- Construction of alt ty
-------------------------------------------------------------------------

relation tyAltMk =
  view I2 =
    holes [ tvarv: TyVarId, tys: TyL | | ty: Ty ]
    judgespec ty === tvarv [ tys ]

-------------------------------------------------------------------------
-- Open prod ty
-------------------------------------------------------------------------

relation tyOpenProd =
  view K =
    holes [ typ: Ty | | n: Int, tyl: TyL ]
    judgespec tyl, n === typ
    judgeuse tex tyl === [(ty).1, (...), (ty).(n)], ^^^ ((ty).1, (...), (ty).(n)) === typ
    judgeuse ag tyl `=` tyProdArgs (typ)

-------------------------------------------------------------------------
-- Deconstruct into init/last, for use in PatExpr.App combined with chkProdArity
-------------------------------------------------------------------------

relation tyInitLastProd =
  view K =
    holes [ typ: Ty, pat: PatExpr | | tyi: TyL, tyl: Ty ]
    judgespec pat: tyi, tyl === typ
    judgeuse tex tyi, tyl === ((ty).1, (...), (ty).(n(-)1)), (ty).n, ^^^ ((ty).1, (...), (ty).(n(-)1), (ty).n) === typ
    judgeuse ag (tyl,"@loc.tyi_l") `=` tyLHdAndTl "@lhs.knTyL"
              | (pat).knTyL `=` "@tyi_l"
              | tyi `=` ANY

-------------------------------------------------------------------------
-- Construct patfun prod ty
-------------------------------------------------------------------------

relation mkPatFunProdTy =
  view C =
    holes [ nm: Nm | | pty: Ty ]
    judgespec pty === nm
    judgeuse tex pty === ((ty).1, (...), (ty).n) -> ((ty).1, (...), (ty).n), ^^^ n === `|` nm `|`
    judgeuse ag pty `=` ( let  prTy `=` mkTyFreshProdFrom unique (hsnProdArity nm)
                        - in   ([prTy] `mkArrow` prTy)
                        )
    
-------------------------------------------------------------------------
-- Construct prod ty
-------------------------------------------------------------------------

relation mkProdTy =
  view C =
    holes [ tyl: TyL | | pty: Ty ]
    judgespec pty === tyl
    judgeuse tex pty === ((ty).1, (...), (ty).n), ^^^ [(ty).1, (...), (ty).n] === tyl
    judgeuse ag pty `=` mkProdApp (tyl)
    
-------------------------------------------------------------------------
-- Construct prod ty, for use in PatExpr.AppTop combined with tyInitLastProd
-------------------------------------------------------------------------

relation chkProdArity =
  view K =
    holes [ ty: Ty, tyl: TyL, pat: PatExpr, n: Int | | ]
    judgespec pat: ty, tyl, n
    judgeuse tex `|` tyl `|` ^^ === n
    judgeuse ag (retain "loc.arityErrs") `=` (if length tyl == (pat).arity - then [] - else [Err_PatArity ty (pat).arity])
              | (pat).knTyL `=` reverse tyl

