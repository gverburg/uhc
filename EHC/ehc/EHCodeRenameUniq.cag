% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Simplify code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(Maybe,FiniteMap,EHCommon,EHCode) export(cmodSimplify)
%%]

%%[9 hs import(EHTy)
%%]

%%[8.WRAPPER import(EHCodeAbsSyn)
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodSimplify :: CModule -> CModule
cmodSimplify cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cSimpl_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cSimpl: SELF ]
ATTR CodeAGItf [ | | cSimpl: CModule ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% alpha renaming so all identifiers are unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type ARenMp = FiniteMap HsName HsName

aRenAdd :: [HsName] -> Int -> ARenMp -> ARenMp
aRenAdd nL l m = addListToFM m (map (\n -> (n,hsnSuffix n ("~" ++ show l))) nL)

aRenRepl :: ARenMp -> HsName -> HsName
aRenRepl m n = maybe n id . lookupFM m $ n
%%]

%%[8
ATTR AllCodeNT [ aRenMp: ARenMp ^^ aLev: Int | | ]
ATTR CBindL CBind CPatBindL CPatBind CPatL CPat [ | | nmL USE {++} {[]}: {[HsName]} ]

SEM CodeAGItf
  | AGItf       module      .   aRenMp      =   emptyFM
                            .   aLev        =   0

SEM CBind
  | Bind        lhs         .   nmL         =   [@nm]

SEM CPatBind
  | Bind        lhs         .   nmL         =   [@nm] ++ @pat.nmL

SEM CPat
  | Var Con     lhs         .   nmL         =   cpatNmEither (:[]) (const []) @pnm

SEM CExpr
  | Let         loc         .   aRenMp      =   if @lhs.aLev == 0
                                                then @lhs.aRenMp
                                                else aRenAdd @binds.nmL @lhs.aLev @lhs.aRenMp
                binds       .   aLev        =   @lhs.aLev + 1
  | Lam         loc         .   aRenMp      =   aRenAdd [@arg] @lhs.aLev @lhs.aRenMp
                body        .   aLev        =   if @body.isLamBody then @lhs.aLev + 1 else @lhs.aLev

SEM CAlt
  | Alt         loc         .   aRenMp      =   aRenAdd @pats.nmL @lhs.aLev @lhs.aRenMp
                expr        .   aLev        =   @lhs.aLev + 1
%%]

%%[8
ATTR CExpr [ | | isLamBody: Bool ]

SEM CExpr
  | Lam         lhs         .   isLamBody   =   False
  | * - Lam     lhs         .   isLamBody   =   True
%%]

%%[8
SEM CExpr
  | Var         lhs         .   cSimpl      =   CExpr_Var (aRenRepl @lhs.aRenMp @nm)
  | Lam         lhs         .   cSimpl      =   CExpr_Lam (aRenRepl @aRenMp @arg) @body.cSimpl

SEM CBind
  | Bind        lhs         .   cSimpl      =   CBind_Bind (aRenRepl @lhs.aRenMp @nm) @expr.cSimpl

SEM CPatBind
  | Bind        lhs         .   cSimpl      =   CPatBind_Bind @offset.cSimpl (aRenRepl @lhs.aRenMp @nm) @pat.cSimpl

SEM CPat
  | Var         lhs         .   cSimpl      =   CPat_Var (cpatNmEither (CPatNmOrig . aRenRepl @lhs.aRenMp) CPatNmUniq @pnm)
  | Con         lhs         .   cSimpl      =   CPat_Con (cpatNmEither (CPatNmOrig . aRenRepl @lhs.aRenMp) CPatNmUniq @pnm)
                                                    @tag (aRenRepl @lhs.aRenMp @tagNm) @binds.cSimpl
%%]

