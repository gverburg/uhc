% $Id: EHInfer.cag 269 2005-08-14 12:49:00Z cddouma $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let expressions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- generated from ruler rules into EHRulerRules, was 1.Let
%%[5.Let
SEM Expr
  | Let         decls       .   patValGam           =   gamPushGam @decls.gathTySigGam @lhs.valGam
                loc         .   (valGam_l_,valGam_g_)
                                                    =   gamPop @decls.patValGam
                decls       .   valGam              =   @decls.patValGam
                body        .   valGam              =   @decls.patValGam
%%]

-- generated from ruler rules into EHRulerRules, was 2.Let
%%[5.Let
SEM Expr
  | Let         decls       .   patTyCnstr          =   @lhs.tyCnstr
                            .   tyCnstr             =   @decls.patTyCnstr
%%]

-- generated from ruler rules into EHRulerRules, was 3.Let
%%[5.Let
SEM Expr
  | Let         loc         .   lSubsValGam_        =   @decls.tyCnstr |=> @valGam_l_
                            .   gSubsValGam_        =   @decls.tyCnstr |=> @valGam_g_
                            .   gTyTvL              =   ftv @gSubsValGam_
                            .   quValGam_           =   valGamQuantify @gTyTvL @lSubsValGam
                body        .   valGam              :=  gamPushGam @quValGam_ @gSubsValGam_
%%]

-- generated from ruler rules into EHRulerRules, was 4.Let
%%[5.Let
SEM Expr
  | Let         decls       .   patValGam           :=  gamPushGam  (valGamInst1Exists @lUniq @decls.gathTySigGam)
                                                                    @lhs.valGam
                loc         .   quValGam_ex_        :=  valGamInst1Exists @lUniq2 . valGamQuantify @gTyTvL $ @lSubsValGam_
                            .   quValGam_           :=  emptyGam
                body        .   valGam              :=  gamPushGam @quValGam_ex_ @gSubsValGam_
%%]

%%[4_2 hs
valElimExprAlts :: FIOpts -> FIEnv -> TyVarIdL -> UID -> Cnstr -> ValGam -> (ValGam,Cnstr,ErrGam)
valElimExprAlts fio fe globTvL u c g
  = (g',c'',eg)
  where  (g',c',eg) = valGamElimAlts fio fe globTvL u c g
         c'' = cnstrDelAlphaRename c'
%%]

-- generated from ruler rules into EHRulerRules, was 4_2.Let
%%[99.Let
SEM Expr
  | Let         decls       .   tySigTyCnstr        =   emptyCnstr
                loc         .   (_,lExSigTyCnstr)   =   valGamInst1ExistsWithCnstr @decls.tySigTyCnstr @lUniq @decls.gathTySigGam
                            .   lExplTyCnstr        =   @lExSigTyCnstr |=> @decls.tySigTyCnstr
                decls       .   patValGam           :=  gamPushGam @decls.gathTySigGam @lhs.valGam
                            .   patTyCnstr          :=  @lExplTyCnstr
                            .   imprTyCnstr         =   @decls.patTyCnstr |=> @lhs.imprTyCnstr
                loc         .   (_,imprTyCnstr_elim_,_)
                                                    =   valElimExprAlts joinFIOpts @fe (ftv @valGam_g_) @lUniq4 @decls.imprTyCnstr @valGam_l_
                decls       .   tyCnstr             :=  @imprTyCnstr_elim_ |=> @decls.patTyCnstr |=> @lhs.tyCnstr
                loc         .   (quValGam_ex_,lQuTyCnstr)
                                                    :=  let  (g1,c1) = valGamQuantifyWithCnstr @decls.tyCnstr @gTyTvL @valGam_l_
                                                             (g2,c2) = valGamInst1ExistsWithCnstr (c1 |=> @decls.tyCnstr) @lUniq2 g1
                                                        in   (g2,c2 |=> c1)
                body        .   imprTyCnstr         =   @imprTyCnstr_elim_ |=> @decls.imprTyCnstr
                            .   tyCnstr             :=  @lQuTyCnstr |=> @decls.tyCnstr
                            .   valGam              :=  @decls.patValGam
%%]

%%[9
SEM Expr
  | Let         loc         .   (quValGam_ex_,tqoGam)
                                                    :=  let  (vg,tqog) = valGamQuantify @gTyTvL @prfArgPrOccL @lSubsValGam_
                                                        in   (valGamInst1Exists @lUniq2 vg,tqog)
                            .   tqoTyCnstr          =   foldr (\tqo c -> tqoImplsCnstr tqo |=> c) emptyCnstr (gamElts @tqoGam)
%%]

%%[11
%%]
SEM Expr
  | Let         loc         .   lElimEqualValGam    =   valGamElimEqual (@decls.tyCnstr |=> @valGam_l_)
                            .   lSubsValGam_        :=  @lElimEqualValGam

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Known type and instantiation required
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- generated from ruler rules into EHRulerRules, was 1.tyInstKnown
%%[5.tyInstKnown
SEM Decl
  | Val         loc         .   knTy                =   @ty_sig_
%%]

-- generated from ruler rules into EHRulerRules, was 2.tyInstKnown
%%[5.tyInstKnown
SEM Decl
  | Val         expr        .   knTy                =   if @hasTySig then @knTy else @patExpr.ty
%%]

-- generated from ruler rules into EHRulerRules, was 3.tyInstKnown
%%[5.tyInstKnown
SEM Decl
  | Val         loc         .   knTy                :=  tyInstKnown @lUniq @ty_sig_
%%]

-- generated from ruler rules into EHRulerRules, was 4.tyInstKnown
%%[5.tyInstKnown
SEM Decl
  | Val         loc         .   knTy                :=  @ty_sig_
%%]

%%[9.tyInstKnown
%%]

SEM Decl
  | Val         expr        .   knTy                :=  if @hasTySig  then @knTy
                                                                      else [mkImplsVar @lUniq2] `mkArrow` @patExpr.ty

%%[10.tyInstKnown
SEM Decl
  | DynVal      loc         .   knTy                =   Ty_Any
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Final type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[2.finValGam
ATTR AllDecl [ finValGam: ValGam | | ]
ATTR AllNT [ finTyCnstr: Cnstr | | ]

SEM Expr
  | Let         decls       .   finValGam           =   @lhs.finTyCnstr |=> (gamTop @decls.patValGam)

SEM Decl
  | TySig       loc         .   finalTy             =   vgiTy . fromJust
                                                        . valGamLookup @nm $ @lhs.finValGam

SEM AGItf
  | AGItf       expr        .   finTyCnstr          =   @expr.tyCnstr
%%]

%%[3.finValGam
SEM Expr
  | Let         decls       .   finValGam           :=  @lhs.finTyCnstr |=> @quValGam_
%%]

%%[4.finValGam
SEM Expr
  | Let         decls       .   finValGam           :=  @lhs.finTyCnstr |=> @quValGam_ex_
%%]

%%[9
SEM Expr
  | Let         loc         .   finTyCnstr          =   @tqoTyCnstr |=> @lhs.finTyCnstr
%%]

%%[10
SEM Decl
  | DynTySig    loc         .   finalTy             =   vgiTy . fromJust
                                                        . valGamLookup @nm $ @lhs.finValGam
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Known kind
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6
SEM Decl
  | Data        loc         .   knKi                =   @sigKi
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type inferencing, decls, top level, abstraction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.valGam
ATTR AllDecl AllExpr [ valGam: ValGam | | ]

SEM AGItf
  | AGItf       expr        .   valGam              =   emptyGam
%%]

%%[1.patValGam
ATTR AllDecl [ | patValGam: ValGam | ]
%%]

-- generated from ruler rules into EHRulerRules, was 1.patValGam.Val
%%[5.patValGam.Val
SEM Decl
  | Val         patExpr     .   valGam              =   @lhs.patValGam
                lhs         .   patValGam           =   @patExpr.valGam
                expr        .   valGam              =   @lhs.valGam
%%]

%%[2.tyCnstr
ATTR AllDecl [ | tyCnstr: Cnstr  patTyCnstr: Cnstr | ]

SEM AGItf
  | AGItf       expr        .   tyCnstr             =   emptyCnstr
%%]

-- generated from ruler rules into EHRulerRules, was 2.tyCnstr.Val
%%[5.tyCnstr.Val
SEM Decl
  | Val         patExpr     .   tyCnstr             =   @lhs.patTyCnstr
                lhs         .   patTyCnstr          =   @patExpr.tyCnstr
                expr        .   tyCnstr             =   @lhs.tyCnstr
%%]

%%[4_2
ATTR AllDecl AllExpr [ | imprTyCnstr: Cnstr | ]

SEM AGItf
  | AGItf       expr        .   imprTyCnstr         =   emptyCnstr
%%]

-- generated from ruler rules into EHRulerRules, was 4_2.Val
%%[99.Val
SEM Decl
  | Val         loc         .   imprFO              =   fitsIn impredFIOpts @fe uidStart (@expr.imprTyCnstr |=> @patExpr.ty) @expr.imprTy
                lhs         .   imprTyCnstr         =   foCnstr @imprFO |=> @expr.imprTyCnstr
%%]
SEM AGItf
  | AGItf       expr        .   tyCnstr             :=  emptyCnstr

SEM AGItf
  | AGItf       loc         .   (exprTyCnstr1,ambTvS)
                                                    =   cnstrElimForgetAlts @expr.imprTyCnstr
                            .   exprTyCnstr         =   let (eC,(vC,_))
                                                              =  cnstrMapThrTy  (\v t (c,u) ->  let  (u',u1) = mkNewLevUID u
                                                                                                     (t',c') = tyFreshVar (`Set.member` @ambTvS) u1 c t
                                                                                                in   (t',(c',u'))
                                                                                )
                                                                                (emptyCnstr,@lUniq)
                                                                 @exprTyCnstr1
                                                        in  eC
                expr        .   tyCnstr             :=  emptyCnstr

SEM AGItf
  | AGItf       loc         .   (exprTyCnstr1,ambTvS)
                                                    =   cnstrElimForgetAlts @expr.imprTyCnstr
                            .   exprTyCnstr         =   let (eC,(vC,_))
                                                              =  cnstrMapThrTy  (\v t (c,u) ->  let  (u',u1) = mkNewLevUID u
                                                                                                     (t',c') = tyFreshVar (`Set.member` @ambTvS) u1 c t
                                                                                                in   (t',(c',u'))
                                                                                )
                                                                                (emptyCnstr,@lUniq)
                                                                 @exprTyCnstr1
                                                        in  eC
                expr        .   tyCnstr             :=  @exprTyCnstr1

                            .   exprTyCnstr         =   fst
                                                        .  cnstrMapThrTy (\v t u -> let (u',u1) = mkNewLevUID u in (tyFreshVar (const True) u1 t,u')) @lUniq
                                                        $  @exprTyCnstr1

%%[5
ATTR AllCase [ | tyCnstr: Cnstr | ]
ATTR AllDataConstr AllCase [ valGam: ValGam | | ]
%%]

%%[5_2
ATTR AllCase [ | imprTyCnstr: Cnstr | ]
%%]

%%[11
SEM Decl
  | Val         loc         .   (_,elimEqCnstr)     =   tyElimEqual @expr.ty
                lhs         .   tyCnstr             =   @elimEqCnstr |=> @expr.tyCnstr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Kind inferencing, decls, top level, abstraction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.tyGam
ATTR AllDecl [ | tyGam: TyGam | ]
ATTR AllExpr [ tyGam: TyGam | | ]
%%]

%%[3
SEM Decl
  | TySig       lhs         .   tyGam               =   @lhs.tyGam
%%]

%%[4
ATTR AllPatExpr [ | tyGam: TyGam | ]
%%]

%%[5
ATTR AllDataConstr AllCase [ tyGam: TyGam | | ]
ATTR AllDecl [ | patTyGam: TyGam | ]

SEM Expr
  | Let         decls       .   patTyGam            =   gamPushNew @lhs.tyGam
                            .   tyGam               =   @decls.patTyGam
%%]

%%[6
ATTR AllExpr AllPatExpr AllData AllCase AllDecl [ | kiCnstr: Cnstr | ]
ATTR AllDecl [ | patKiCnstr: Cnstr | ]

SEM Expr
  | Let         decls       .   patTyGam            :=  gamPushGam @decls.gathKiSigGam @lhs.tyGam
                            .   patKiCnstr          =   @lhs.kiCnstr
                loc         .   (tyGam_l_,tyGam_g_) =   gamPop @decls.patTyGam
                decls       .   tyGam               :=  gamPushGam @tyGam_l_ @lhs.tyGam
                            .   kiCnstr             =   @decls.patKiCnstr
                loc         .   lSubsTyGam          =   @decls.kiCnstr |=> @tyGam_l_
                            .   gSubsTyGam          =   @decls.kiCnstr |=> @tyGam_g_
                            .   gKiTvL              =   ftv @gSubsTyGam
                            .   lQuTyGam            =   tyGamInst1Exists @lUniq3 . tyGamQuantify @gKiTvL $ @lSubsTyGam
                body        .   tyGam               =   gamPushGam @lQuTyGam @gSubsTyGam

SEM Decl
  | TySig       tyExpr      .   tyGam               =   gamPushNew @lhs.tyGam
                loc         .   fo_                 =   fitsIn weakFIOpts @fe @lUniq2 @tyExpr.ki kiStar
                lhs         .   kiCnstr             =   foCnstr @fo_ |=> @tyExpr.kiCnstr
%%]

%%[7
ATTR AllDataField [ | tyGam: TyGam | ]
%%]

%%[11
ATTR AllDataConstrEq [ | tyGam: TyGam | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data info gam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.dataGam
ATTR AllDecl AllExpr AllCase [ | gathDataGam: DataGam | ]
ATTR AllDecl AllExpr AllCase AllPatExpr [ dataGam: DataGam | | ]

SEM AGItf
  | AGItf       expr        .   gathDataGam         =   emptyGam
                            .   dataGam             =   @expr.gathDataGam
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gamma/Environment for fitting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
SEM Decl
  | *           loc         .   fe                  =   emptyFE
%%]

%%[9
SEM Decl
  | Instance    loc         .   fe                  :=  emptyFE {fePrfCtxtId = @prfCtxtId, feEHCOpts = @lhs.opts}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Init of tyGam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[initTyGam.1
                                                          [ (hsnArrow,  TyGamInfo (Ty_Con hsnArrow))
                                                          , (hsnInt,    TyGamInfo tyInt)
                                                          , (hsnChar,   TyGamInfo tyChar)
%%]

%%[initTyGam.6
                                                          [ (hsnArrow,  mkTGI (Ty_Con hsnArrow) ([kiStar,kiStar] `mkArrow` kiStar))
                                                          , (hsnInt,    mkTGI tyInt kiStar)
                                                          , (hsnChar,   mkTGI tyChar kiStar)
%%]

%%[initTyGam.7
                                                          , (hsnRow,    mkTGI (Ty_Con hsnUnknown) kiRow)
                                                          , (hsnRec,    mkTGI (Ty_Con hsnRec) ([kiRow] `mkArrow` kiStar))
                                                          , (hsnSum,    mkTGI (Ty_Con hsnSum) ([kiRow] `mkArrow` kiStar))
%%]

%%[1.initTyGam
SEM AGItf
  | AGItf       loc         .   tyGam               =   assocLToGam
%%@initTyGam.1
                                                          ]
%%]

%%[6
SEM AGItf
  | AGItf       loc         .   tyGam               :=  assocLToGam
%%@initTyGam.6
                                                          ]
                            .   kiCnstr             =   emptyCnstr
%%]

%%[7
SEM AGItf
  | AGItf       loc         .   tyGam               :=  assocLToGam
%%@initTyGam.6
%%@initTyGam.7
                                                          ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Sort, but no inferencing && etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[initKiGam.6
                                                          [ (hsnArrow,  KiGamInfo (Ty_Con hsnArrow))
                                                          , (hsnStar,   KiGamInfo kiStar)
%%]

%%[6
ATTR AllExpr AllTyExpr AllPatExpr AllData AllCase AllDecl [ kiGam: KiGam | | ]

SEM AGItf
  | AGItf       loc         .   kiGam               =   assocLToGam
%%@initKiGam.6
                                                          ]
%%]

%%[initKiGam.7
                                                          , (hsnRow,    KiGamInfo kiRow)
%%]

%%[7
SEM AGItf
  | AGItf       loc         .   kiGam               :=  assocLToGam
%%@initKiGam.6
%%@initKiGam.7
                                                          ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type signatures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.gathTySigGam
ATTR AllDecl [ | | gathTySigGam USE {`gamAddGam`} {emptyGam}: ValGam ]
%%]

-- generated from ruler rules into EHRulerRules, was 1.gamSigTyGath
%%[5.gamSigTyGath
SEM Decl
  | TySig       loc         .   gamSigTy            =   @tyExpr.ty
                            .   gathTySigGam        =   @nm `gamUnit` ValGamInfo @gamSigTy
%%]
SEM Expr
  | Let         decls       .   gathTySigGam        =   emptyGam

%%[1.tySigGam
ATTR AllDecl [ tySigGam: ValGam | | ]
%%]

-- generated from ruler rules into EHRulerRules, was 1.tySigGam.TysigLet
%%[5.tySigGam.TysigLet
SEM Expr
  | Let         decls       .   tySigGam            =   @decls.gathTySigGam
%%]

-- generated from ruler rules into EHRulerRules, was 1.tySigGam.Val
%%[5.tySigGam.Val
SEM Decl
  | Val         loc         .   (ty_sig_,hasTySig)  =   case @patExpr.mbTopNm of
                                                          Nothing
                                                            ->  (Ty_Any,False)
                                                          Just nm
                                                            ->  case gamLookup nm @lhs.tySigGam of
                                                                  Nothing   -> (Ty_Any,False)
                                                                  Just vgi  -> (vgiTy vgi,True)
%%]

-- generated from ruler rules into EHRulerRules, was 3.TySig
%%[5.TySig
SEM Decl
  | TySig       loc         .   ty_sig_             =   tyQuantify (`elem` @tyExpr.tyVarWildL) @tyExpr.ty
                            .   gamSigTy            :=  @ty_sig_
%%]

%%[4_2
ATTR AllDecl [ | tySigTyCnstr: Cnstr | ]
%%]

-- generated from ruler rules into EHRulerRules, was 4_2.TySig
%%[99
SEM Decl
  | TySig       loc         .   (gamSigTy,gamSigCnstr)
                                                    :=  tyAsCnstr @lUniq @ty_sig_
                lhs         .   tySigTyCnstr        =   @gamSigCnstr |=> @lhs.tySigTyCnstr
%%]

-- generated from ruler rules into EHRulerRules, was 4_2.Let.tySigGam
%%[99.Let.tySigGam
SEM Expr
  | Let         decls       .   tySigGam            :=  @decls.tySigTyCnstr |=> @decls.gathTySigGam
%%]

%%[6
SEM Decl
  | TySig       loc         .   gTyTvL              =   ftv . map (tgiTy.snd) . gamToAssocL $ @lhs.tyGam
                            .   ty_sig_             :=  tyQuantify (`elem` (@tyExpr.tyVarWildL ++ @gTyTvL)) @tyExpr.ty
%%]

%%[9
SEM Decl
  | TySig       loc         .   ty_sig_             :=  tqoTy (tyQuantifyPr  (defaultTyQuOpts {tqoptLeaveImpls=True})
                                                                             (`elem` (@tyExpr.tyVarWildL ++ @gTyTvL))
                                                                             TyQu_Forall [] @tyExpr.ty)
%%]

%%[8
SEM Decl
  | FFI         loc         .   ty_sig_             =   tyQuantifyClosed @tyExpr.ty
                lhs         .   gathTySigGam        =   @nm `gamUnit` ValGamInfo @ty_sig_
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Kind signatures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6.kiSigGam
ATTR AllDecl [ kiSigGam: TyGam | gathKiSigGam: TyGam | ]

SEM Decl
  | KiSig       lhs         .   gathKiSigGam        =   gamAdd @nm (mkTGI (Ty_Con @nm) @sigKi) @lhs.gathKiSigGam

SEM Expr
  | Let         decls       .   gathKiSigGam        =   emptyGam
                            .   kiSigGam            =   @decls.gathKiSigGam

SEM Decl
  | Data        loc         .   (sigKi,hasKiSig)    =   case gamLookup @tyNm @lhs.kiSigGam of
                                                          Nothing   -> (Ty_Any,False)
                                                          Just tgi  -> (tgiKi tgi,True)
%%]

%%[6
SEM Decl
  | KiSig       loc         .   sigKi               =   kiQuantify (const False) @kiExpr.ki
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Include binding for pattern var?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.inclVarBind
ATTR PatExpr [ inclVarBind: Bool | | ]

SEM PatExpr
  | AppTop      patExpr     .   inclVarBind         =   True

SEM Decl
  | Val         patExpr     .   inclVarBind         =   False

SEM Expr
  | Lam         arg         .   inclVarBind         =   True
%%]

%%[2
SEM Decl
  | Val         patExpr     .   inclVarBind         :=  not @hasTySig
%%]

%%[5
SEM CaseAlt
  | Pat         patExpr     .   inclVarBind         =   True
%%]

%%[7
SEM RecPatExpr
  | Ext Expr    patExpr     .   inclVarBind         =   True
%%]

%%[9
SEM Expr
  | LamImpl     arg         .   inclVarBind         =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Top name of pattern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.mbTopNm
ATTR PatExpr [ | | mbTopNm: {Maybe HsName} ]

SEM PatExpr
  | Var VarAs   loc         .   mbTopNm             =   if @nm == hsnWild then Nothing else Just @nm
  | * - Var VarAs
                loc         .   mbTopNm             =   Nothing
%%]

%%[7.topNm
ATTR PatExpr [ | | topNm: HsName ]

SEM PatExpr
  | Var VarAs   loc         .   topNm               =   if @nm == hsnWild then uidHNm @lUniq else @nm
  | App         lhs         .   topNm               =   hsnUnknown
  | AppTop Con Rec CConst IConst
                loc         .   topNm               =   uidHNm @lUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Records, default (positional) name if absent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7
ATTR RecPatExpr RowTyExpr RecExpr [ | positionalFldNmL: {[HsName]} | ]
ATTR RecPatExpr [ matchOnFld: Bool | | hasAFldRef: Bool ]

SEM Expr
  | Rec         recExpr     .   positionalFldNmL    =   positionalFldNames

SEM TyExpr
  | Row         rowTyExpr   .   positionalFldNmL    =   positionalFldNames

SEM PatExpr
  | Rec         recPatExpr  .   positionalFldNmL    =   positionalFldNames
                            .   matchOnFld          =   @recPatExpr.hasAFldRef

SEM RecPatExpr
  | Ext         lhs         .   hasAFldRef          =   maybe @recPatExpr.hasAFldRef (const True) @mbNm
                (loc.positionalNm,lhs.positionalFldNmL)
                                                    =   hdAndTl @recPatExpr.positionalFldNmL
                loc         .   nm                  =   case @mbNm of
                                                          Just nm                     -> nm
                                                          Nothing  | @lhs.matchOnFld  -> @patExpr.topNm
                                                                   | otherwise        -> @positionalNm
  | * - Ext     lhs         .   hasAFldRef          =   False
 
SEM RowTyExpr
  | Ext         (loc.positionalNm,lhs.positionalFldNmL)
                                                    =   hdAndTl @rowTyExpr.positionalFldNmL
                loc         .   nm                  =   maybe @positionalNm id @mbNm

SEM RecExpr
  | Ext         (loc.positionalNm,lhs.positionalFldNmL)
                                                    =   hdAndTl @recExpr.positionalFldNmL
                loc         .   nm                  =   maybe @positionalNm id @mbNm
%%]

%%[10
SEM PrExpr
  | Lacks       rowTyExpr   .   positionalFldNmL    =   positionalFldNames
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% How to do subsumption
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.fiOpts.init
ATTR AllExpr AllPatExpr [ fiOpts: FIOpts | | ]

SEM AGItf
  | AGItf       expr        .  fiOpts               =   strongFIOpts
%%]

-- generated from ruler rules into EHRulerRules, was/from 4.fiOpts.init
%%[5.fiOpts.init
SEM Expr
  | AppImpred   func        .  fiOpts               =   strongFIOpts
                loc         .  argFIOpts            =   strongFIOpts
                arg         .  fiOpts               =   @argFIOpts

%%]

-- generated from ruler rules into EHRulerRules, was 2.App
%%[5.fiOpts.init
SEM Decl
  | Val         expr        .  fiOpts               =   strongFIOpts
                patExpr     .  fiOpts               =   strongFIOpts
%%]

-- generated from ruler rules into EHRulerRules, was 2.App
%%[5.fiOpts.init
SEM Expr
  | Lam         loc         .  knFunFIOpts          =   @lhs.fiOpts {fioBindRFirst=True}
  | App         func        .  fiOpts               =   strongFIOpts
                loc         .  argFIOpts            =   instLFIOpts
                arg         .  fiOpts               =   @argFIOpts
%%]

%%[5
ATTR AllCase [ fiOpts: FIOpts | | ]

SEM Decl
  | Val         expr        .  fiOpts               :=  if @hasTySig then strongFIOpts else weakFIOpts

SEM CaseAlt
  | Pat         patExpr     .  fiOpts               =   strongFIOpts
%%]

%%[7
SEM RecExpr
  | Ext Upd     expr        .  fiOpts               =   strongFIOpts

SEM Expr
  | Rec         loc         .  fiOpts               =   strongFIOpts
%%]

%%[9
SEM Expr
  | App         func        .  fiOpts               :=  implFIOpts
  | AppImpl     arg         .  fiOpts               =   strongFIOpts

SEM Decl
  | InstanceIntro
                expr        .  fiOpts               =   strongFIOpts
%%]

%%[10
SEM Decl
  | DynVal      expr        .  fiOpts               =   strongFIOpts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Predicate env, for elim of predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllDecl [ | patPrElimTGam: PrElimTGam | ]
ATTR NTPrf [ | prElimTGam: PrElimTGam | ]

SEM AGItf
  | AGItf       loc         .   prElimTGam          =   emptyTGam @prfCtxtId
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Predicate env, for intro of predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllDecl [ | patPrIntroGam: PrIntroGam | ]
ATTR NTPrf AllPrExpr AllTyExpr AllData AllPatExpr [ prIntroGam: PrIntroGam | | ]

SEM Expr
  | Let         decls       .   patPrIntroGam       =   gamPushNew @lhs.prIntroGam
                loc         .   (lPrIGam,gPrIGam)   =   gamPop @decls.patPrIntroGam
                decls       .   prIntroGam          =   gamPushGam @lPrIGam @lhs.prIntroGam
                loc         .   lSubsPrIGam         =   @decls.kiCnstr |=> @lPrIGam
                            .   gSubsPrIGam         =   @decls.kiCnstr |=> @gPrIGam
                            .   gKiTvL              :=  ftv @gSubsTyGam `List.union` ftv @gSubsPrIGam
                            .   lQuPrIGam           =   gamMap
                                                            (\(n,t) -> (n,t {pigiKi = tyQuantify (`elem` @gKiTvL) (pigiKi t)}))
                                                            @lSubsPrIGam
                body        .   prIntroGam          =   gamPushGam @lQuPrIGam @gSubsPrIGam

SEM AGItf
  | AGItf       loc         .   prIntroGam          =   emptyGam
%%]

