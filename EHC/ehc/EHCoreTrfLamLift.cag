% $Id: EHCoreTrfLamLift.cag 269 2005-08-14 12:49:00Z cddouma $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(Data.Maybe,qualified Data.Set as Set,Data.List,qualified Data.Map as Map,EHCommon,EHCore,EHTy) export(cmodTrfLamLift)
%%]

%%[8 hs import(EHDebug)
%%]

%%[8.WRAPPER import(EHCoreAbsSyn,EHCoreCommonLev,EHCoreTrfCommonFv,EHCoreTrfCommonLev)
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfLamLift :: CModule -> CModule
cmodTrfLamLift cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf)
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: Int | ]

SEM CodeAGItf
  | AGItf       module      .   gUniq       =   0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM CExpr
  | Let         binds       .   lev         =   @lhs.lev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which id's are functions resp values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind [ | | bindVarS, bindLamS USE {`Set.union`} {Set.empty}: FvS ]

SEM CBind
  | Bind        lhs         .   (bindVarS,bindLamS)
                                            =   if @expr.isLam
                                                then (Set.empty,Set.singleton @nm)
                                                else (Set.singleton @nm,Set.empty)
  | FFI         lhs         .   bindVarS    =   Set.singleton @nm
%%]

%%[8
ATTR AllCodeNT [ varS, lamS: FvS | | ]

SEM CodeAGItf
  | AGItf       module      .   varS        =   Set.empty
                            .   lamS        =   Set.empty

SEM CExpr
  | Let         loc         .   varS        =   @lhs.varS `Set.union` @binds.bindVarS
                            .   lamS        =   @lhs.lamS `Set.union` @binds.bindLamS
  | Lam         loc         .   varS        =   @arg `Set.insert` @lhs.varS

SEM CAlt
  | Alt         expr        .   varS        =   @lhs.varS `Set.union` Set.fromList @pats.nmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free var of lam's for which arg lifting is done
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
startFvSLamMp :: FvS -> FvS -> FvS -> FvSMp -> FvSMp -> (FvSMp,FvSMp)
startFvSLamMp bLamS lamS varS fvm bFvm
  =  let  bFvm2    =  Map.filterWithKey (\n _ -> n `Set.member` bLamS) bFvm
          fvlam  s =  lamS `Set.intersection` s
          fvvar  s =  varS `Set.intersection` s
          fv     s =  fvvar s `Set.union`
                        (Set.unions . map (\n -> Map.findWithDefault Set.empty n fvm) . Set.toList . fvlam $ s)
     in   (Map.map fv bFvm2,Map.map (`Set.intersection` bLamS) bFvm2)

iterFvSLamMp :: FvSMp -> FvSMp -> FvSMp
iterFvSLamMp frLamMp frVarMp
  =  let  frVarMp2 = Map.mapWithKey (\n s -> s `Set.union` (Set.unions . map (\n -> fromJust . Map.lookup n $ frVarMp) . Set.toList . fromJust . Map.lookup n $ frLamMp)) frVarMp
          sz = sum . map Set.size . Map.elems
     in   if sz frVarMp2 > sz frVarMp
          then iterFvSLamMp frLamMp frVarMp2
          else frVarMp
%%]

%%[8
ATTR AllCodeNT [ fvSLamMp: FvSMp | | ]

SEM CodeAGItf
  | AGItf       module      .   fvSLamMp    =   Map.empty

SEM CExpr
  | Let         loc         .   fvSLamMp    =   (let  start varS = startFvSLamMp @binds.bindLamS @lhs.lamS varS @lhs.fvSLamMp @binds.fvSMp
                                                 in   case @categ of
                                                        CBindRec  ->  let  (m,lm)  = start (@lhs.varS `Set.union` @binds.bindVarS)
                                                                      in   iterFvSLamMp lm m
                                                        _         ->  let  (m,_)   = start @lhs.varS
                                                                      in   m
                                                )
                                                `Map.union` @lhs.fvSLamMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is expr a let?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | isLet: Bool ]

SEM CExpr
  | Let         lhs         .   isLet       =   True
  | * - Let     lhs         .   isLet       =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Has a strictness?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | hasStrict: Bool ]

SEM CExpr
  | TupIns TupDel Case
                lhs         .   hasStrict   =   True
  | * - TupIns TupDel Case
                lhs         .   hasStrict   =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Mapping of argument names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ argSubst: {Map.Map HsName HsName} | | ]

SEM CodeAGItf
  | AGItf       module      .   argSubst    =   Map.empty

SEM CBind
  | Bind        expr        .   argSubst    =   @argMp `Map.union` @lhs.argSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Adding parameters to lam call sites
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LamArgMp = Map.Map HsName [HsName]
%%]

%%[8
ATTR AllBind [ | | bindLamArgMp USE {`Map.union`} {Map.empty}: LamArgMp ]
ATTR AllCodeNT [ lamArgMp: LamArgMp | | ]

SEM CodeAGItf
  | AGItf       module      .   lamArgMp    =   Map.empty

SEM CExpr
  | Let         loc         .   lamArgMp    =   @binds.bindLamArgMp `Map.union` @lhs.lamArgMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional used identifiers for mutual recursive definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ mutRecMp: LevMp | | ]

SEM CodeAGItf
  | AGItf       module      .   mutRecMp    =   Map.empty

SEM CExpr
  | Let         binds       .   mutRecMp    =   (if @categ == CBindRec
                                                 then Map.fromList (zip @binds.nmL (repeat @lhs.lev)) `Map.union` @lhs.mutRecMp
                                                 else @lhs.mutRecMp
                                                )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LamBindSq = Seq (CBindCateg,CBindL)

fvLAsArg :: LevMp -> FvS -> AssocL HsName Int
fvLAsArg levMp fvS
  =  sortOn snd . filter (\(_,l) -> l > cLevOuter)
     . map (\n -> (n,fvLev levMp n)) . Set.toList $ fvS

mkFvNm :: Int -> HsName -> HsName
mkFvNm i n = hsnSuffix n ("~" ++ show i)

fvLArgRepl :: Int -> AssocL HsName Int -> ([HsName],[HsName],Map.Map HsName HsName)
fvLArgRepl uniq argLevL
  =  let  argOL = assocLKeys argLevL
          argNL = zipWith (\u n -> mkFvNm u n) [uniq..] argOL
     in   (argOL,argNL,Map.fromList (zip argOL argNL))

varRepl :: Map.Map HsName HsName -> HsName -> CExpr
varRepl nMp n = maybe (CExpr_Var n) CExpr_Var . Map.lookup n $ nMp
%%]

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

ATTR AllCodeNT [ | | lamBindSq USE {<+>} {emptySeq}: LamBindSq ]
ATTR AllBind [ | | bindLamBindL, bindCAFBindL, bindVarBindL USE {++} {[]}: CBindL ]

SEM CBind
  | Bind        (expr.gUniq,loc.argMp,loc.bindLamBindL,loc.bindCAFBindL,loc.bindVarBindL,loc.bindLamArgMp)
                                            =   if @expr.isLam
                                                then  let  argLevL = fvLAsArg @lhs.levMp . fromJust . Map.lookup @nm $ @lhs.fvSLamMp
                                                           (argOL,argNL,argONMp) = fvLArgRepl @lhs.gUniq argLevL
                                                      in   (@lhs.gUniq + length argOL,argONMp
                                                           ,[CBind_Bind @nm (mkCExprLam argNL @expr.cTrf)],[],[]
                                                           ,@nm `Map.singleton` argOL
                                                           )
                                                else  if @expr.isLet
                                                then  let  argLevL = fvLAsArg (@lhs.mutRecMp `Map.union` @lhs.levMp) @expr.fvS
                                                           cafLamNm = mkFvNm @lhs.gUniq @nm
                                                           (argOL,argNL,argONMp) = fvLArgRepl (@lhs.gUniq + 1) argLevL
                                                      in   if null argLevL
                                                           then  (@lhs.gUniq,Map.empty,[],[@cTrf],[],Map.empty)
                                                           else  (@lhs.gUniq + 1 + length argOL,argONMp
                                                                 ,[CBind_Bind cafLamNm (mkCExprLam argNL @expr.cTrf)]
                                                                 ,[]
                                                                 ,[CBind_Bind @nm (mkCExprApp (CExpr_Var cafLamNm) (map (varRepl @lhs.argSubst) argOL))]
                                                                 ,Map.empty
                                                                 )
                                                else  (@lhs.gUniq,Map.empty,[],[],[@cTrf],Map.empty)
  | FFI         loc         .   bindVarBindL=   [@cTrf]

SEM CExpr
  | Var         lhs         .   cTrf        =   let  r n = varRepl @lhs.argSubst n
                                                     v1 = r @nm
                                                     v2 = maybe v1 (mkCExprApp v1 . map r) . Map.lookup @nm $ @lhs.lamArgMp
                                                in   v2
  | Let         (loc.hereBindSq,lhs.lamBindSq)
                                            =   let  b1      = @binds.lamBindSq
                                                     b2l     = unitSeq (@categ,@binds.bindLamBindL)
                                                     b2c     = unitSeq (@categ,@binds.bindCAFBindL)
                                                     b2v     = unitSeq (@categ,@binds.bindVarBindL)
                                                     b12lcv  = unitSeq (@categ,(concat . map snd . seqToList $ b1)
                                                                                ++ @binds.bindLamBindL ++ @binds.bindCAFBindL ++ @binds.bindVarBindL)
                                                     b3      = @body.lamBindSq
                                                in   if @lhs.lev == cLevOuter
                                                     then  (b12lcv <+> b3,emptySeq)
                                                     else  (b2v,b1 <+> b2l <+> b2c <+> b3)
                lhs         .   cTrf        =   foldr (\(c,b) e -> mkCExprLet c b e) @body.cTrf . seqToList $ @hereBindSq
%%]

                                                then  let  argLevL = zip @lhs.mutRecNmL (repeat cLevOuter) ++ fvLAsArg @lhs.levMp @expr.fvS
                                                           cafLamNm = mkFvNm @lhs.gUniq @nm
                                                           (argOL,argNL,argONMp) = fvLArgRepl (@lhs.gUniq + 1) argLevL
                                                      in   if null argLevL
                                                           then  (@lhs.gUniq,Map.empty,[],[@cTrf],[],Map.empty)
                                                           else  (@lhs.gUniq + 1 + length argOL,argONMp
                                                                 ,[CBind_Bind cafLamNm (mkCExprLam argNL @expr.cTrf)]
                                                                 ,[]
                                                                 ,[CBind_Bind @nm (mkCExprApp (CExpr_Var cafLamNm) (map CExpr_Var argOL))]
                                                                 ,Map.empty
                                                                 )
