% $Id: EHTyElimAlts.cag 149 2005-02-11 13:59:25Z atze $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to refresh tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2 hs import(EHCommon,EHTy,EHCnstr,EHSubstitutable) export(tyFreshVar)
%%]

%%[4_2.WRAPPER import(EHTyAbsSyn)
WRAPPER TyAGItf
%%]

%%[4_2.tyFreshVar hs
tyFreshVar :: (TyVarId -> Bool) -> UID -> Cnstr -> Ty -> (Ty,Cnstr)
tyFreshVar allowFresh uniq tvCnstr ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf {tvCnstr_Inh_TyAGItf = tvCnstr, allowFresh_Inh_TyAGItf = allowFresh, gUniq_Inh_TyAGItf = uniq})
     in   (repl_Syn_TyAGItf t,tvCnstr_Syn_TyAGItf t)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Check if allowed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf AllAllTy [ allowFresh: {TyVarId -> Bool} | | ]

SEM Ty
  | Quant           ty      .   allowFresh  =   \v -> v /= @tv && @lhs.allowFresh v
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Uniq
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf [ gUniq: UID | | ]
ATTR AllTy [ | gUniq: UID | ]

SEM Ty
  | Var             (lhs.gUniq,loc.lUniq)   =   mkNewUID @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% New tvar map as Cnstr, replacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllAllTy [ | | repl: SELF  ]
ATTR TyAGItf  [ | | repl: Ty    ]
%%]

%%[4_2
ATTR AllTy TyAGItf [ | tvCnstr: Cnstr | ]

SEM Ty
  | Var             lhs     .   (repl,tvCnstr)
                                            =   if @lhs.allowFresh @tv
                                                then  case cnstrTyLookup @tv @lhs.tvCnstr of
                                                        Just t   -> (t,@lhs.tvCnstr)
                                                        Nothing  -> (t,(@tv `cnstrTyUnit` t) |=> @lhs.tvCnstr)
                                                                 where t = Ty_Var @lUniq @categ.repl
                                                else  (@repl,@lhs.tvCnstr)
%%]
SEM TyAGItf
  | AGItf           ty      .   tvCnstr     =   emptyCnstr

SEM Ty
  | Var             lhs     .   repl        =   if @lhs.allowFresh @tv then Ty_Var @lUniq @categ.repl else @repl
SEM Ty
  | Var             lhs     .   (repl,tvCnstr)
                                            =   if @lhs.allowFresh @tv
                                                then  case cnstrTyLookup @tv @lhs.tvCnstr of
                                                        Just t   -> (t,@lhs.tvCnstr)
                                                        Nothing  -> (t,(@tv `cnstrTyUnit` t) |=> @lhs.tvCnstr)
                                                                 where t = Ty_Var @lUniq @categ.repl
                                                else  (@repl,@lhs.tvCnstr)

