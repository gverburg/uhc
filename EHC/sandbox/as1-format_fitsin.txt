Plan of attack:

1) Generate two maps: input/output
     input is the map AttrAGDecl_Attr Ty x y _= x ++ y
     output is the map AttrAGDecl_Attr Ty _ y z = y ++ z
2) Fetch for each Jd_Ats in the second list (the result!) the pattern from the Top_App thing
3) If the Jd_Ats thing is in input, put it as parameter
   if it is as output, add it to the output tuple
4) Fetch the Jd_Ats from the first list of RlDecl_Rl
5) See 3, but threat the input as applications
6) Build the result as follows
     fitsIn <parameters> = let <premise_output_tuple> = <premise_input>
                            in <output_tuple>

[ Decl_AttrAG 
  ( AttrAGDecl_Attr 
    Ty 
    [ (typeLeft,Ty)
    , (typeRight,Ty)
    ] 
    [] 
    [ (typeResult,Ty)
    ]
  )
, Decl_RsVw 
    ( RsVwDecl_Rs 
        fitsInRuleSet 
        fitsInScheme 
        "Typerules for FitsIn" 
        [ VwDecl_Vw 
            Equational 
            rules.Equational.fitsInRuleSet 
            [ RlDecl_Rl 
                fitsInCon 
                rules.Equational.fitsInRuleSet.fitsInCon 
                ( "fitsInCon","rule2HS.rul"(line 10, column 8) ) 
                fitsInCon 
                [] 
                [ Jd_Ats 
                    R 
                    fitsInScheme 
                    [ JdAt_At 
                        typeLeft 
                        ( Expr_AppTop 
                            ( Expr_App 
                                ( Expr_Var TyCon ) 
                                ( Expr_Var x )
                            )
                        )
                    , JdAt_At 
                        typeResult 
                        ( Expr_AppTop 
                            ( Expr_App 
                                ( Expr_Var TyCon ) 
                                ( Expr_Var x )
                            )
                        )
                    , JdAt_At 
                        typeRight 
                        (  Expr_AppTop 
                            ( Expr_App 
                                ( Expr_Var TyCon )
                                ( Expr_Var y )
                            )
                        )
                    ]
                ]
            ]
        ]
    )
]
