
--------------------------------------------------------------------------------
Version 3:
--------------------------------------------------------------------------------
rule 1: Ty_Any  t1 True => res t1
rule 2: t1@(Ty_Con s1)    t2@(Ty_Con s2) (s1 == s2) => res t2
rule 3: t1@(Ty_Var v1 f1) (Ty_Var v2 f2) (v1 == v2 && f1 == f2)  => res t1
rule 4: t1@(Ty_Var v1 f)  t2             (f == TyVarCateg_Plain) => occurBind v1 t2

rule 5: t1@(Ty_App (Ty_App (Ty_Con c1) ta1) tr1) t2@(Ty_App (Ty_App (Ty_Con c2) ta2) tr2)
                 (hsnIsArrow c1 && c1 == c2)
                 => comp ta2 tr1 ta1 tr2 (\a r -> [a] `mkArrow` r)
rule 6: t1@(Ty_App tf1 ta1) t2@(Ty_App tf2 ta2) True => comp tf1 ta1 tf2 ta2 Ty_App

-- rule 5 is too complicated





--------------------------------------------------------------------------------
Version 4:
--------------------------------------------------------------------------------

rule 1: fi t1 t2 (fioMode (fiFIOpts fi) == FitSubRL) => unify fi' t2 t1
   where  fi' = fi  {fiFIOpts = fioSwapOpts . fioSwapCoCo ContraVariant . fiFIOpts $ fi}

rule 2: fi Ty_Any  t2 True  => res fi t2

rule 3: fi t1@(Ty_Con s1) t2@(Ty_Con s2) (s1 == s2) => res fi t2


rule 4: fi t1@(Ty_Var v1 f1) t2@(Ty_Var v2 f2)
                | v1 == v2 && f1 == f2              = res fi t1
                | lBefR && allowBind fi t1          = bind fi v1 t2
                | not lBefR && allowBind fi t2      = bind fi v2 t1
                where lBefR = fioBindLBeforeR (fiFIOpts fi)

rule 5: fi t1@(Ty_Var v1 _)  t2  (allowImpredTVBindL fi t1 t2) => occurBind fi v1 t2


rule 6: fi t1@(Ty_Quant q1 _ _) t2@(Ty_Quant q2 _ _)
                (fioMode (fiFIOpts fi) == FitUnify && q1 == q2)  => ff fi2 uqt1 uqt2
                where  (fi1,uqt1,_) = unquant fi   t1 False instCoConst
                       (fi2,uqt2,_) = unquant fi1  t2 False instCoConst



rule 7: fi t1 t2@(Ty_Quant _ _ _)
           (fioIsSubsume (fiFIOpts fi) && fioLeaveRInst (fiFIOpts fi))
                                                    => back2 (ff fi2 t1 uqt2)
    where (fi2,uqt2,back2) = unquant fi t2 False instCoConst


rule 8: fi t1 t2@(Ty_Quant _ _ _)
           (fioIsSubsume (fiFIOpts fi) && not (fioLeaveRInst (fiFIOpts fi)))
                                                    => back2 (ff fi2 t1 uqt2)
    where (fi2,uqt2,back2) = unquant fi t2 True instContra

rule 9: fi t1@(Ty_Quant _ _ _) t2
           (fioIsSubsume (fiFIOpts fi))  => ff fi1 uqt1 t2
    where (fi1,uqt1,back1) = unquant fi t1 False instCoConst



rule 10: fi t1@(Ty_Var v1 _)  t2 (allowBind fi t1)   => occurBind fi v1 t2

rule 11: fi t1@(Ty_App tf1 ta1)  t2@(Ty_App tf2 ta2) True => manyFO [ffo,afo,foCmbApp ffo afo]
     where  ffo  = f fi tf1 tf2
            fs   = foCnstr ffo
          (as:_) = foAppSpineL ffo
            fi'  = fi  { fiFIOpts  = asFIO as . fioSwapCoCo (asCoCo as) . fiFIOpts $ fi
                       , fiUniq    = foUniq ffo }
            afo  = f fi' (fs |=> ta1) (fs |=> ta2)




