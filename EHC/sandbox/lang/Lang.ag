{
import UU.Pretty
import Data.List

import Debug.Trace

data Direction 
  = Node
  | In 
  | InOut 
  | Out
  deriving (Show,Eq,Ord)

class Named a where
  name :: a -> String

instance Named Layer where
   name (Layer_RawLayer n _ _) = n
   name (Layer_Layer n _ _) = n

instance Named Interface where
   name (Interface_Interface n _ _ _) = n

instance Named Parameter where
   name (Parameter_Parameter n _ _ _ _) = n
}

{--
Things to think about:
1. adding symmetric,etc to judgments
2. how to accomodate relations, e.g. literal Haskell syntax
--}

-- INTERFACE SPECIFICATION

TYPE Layers          = [Layer]
TYPE Interfaces      = [Interface]
TYPE Parameters      = [Parameter]
TYPE Rules           = [Rule]
TYPE Judgments       = [Judgment]
TYPE BodyAssignments = [BodyAssignment]
TYPE RuleSets        = [RuleSet]

--------------------------------------------------------------------------------
-- LAYER INTERFACE STRUCTURE
--------------------------------------------------------------------------------

DATA Layer
  |  RawLayer          name       : {String}
                       parent     : {Maybe String}
                       interfaces : Interfaces
  |  Layer             name       : {String}
                       parent     : {Maybe Layer}
                       interfaces : Interfaces

DATA Interface
  |  Interface         name       : {String}
                       params     : Parameters
                       uses       : Parameters
                       pattern    : {String}

DATA Parameter
  |  Parameter         name       : {String}
                       direction  : {Direction}
                       type       : {String}
                       visible    : {Bool}
                       directives : {[String]}

--------------------------------------------------------------------------------
-- IMPLEMENTATION STRUCTURE
--------------------------------------------------------------------------------

DATA Implementation
  | RawImplementation layer       : {String}
                      rulesets    : RuleSets
  | Implementation    layer       : Layer
                      rulesets    : RuleSets

DATA RuleSet
  | RuleSet           name        : {String}
                      interface   : {String}
                      directives  : {[String]}
                      rules       : Rules

DATA Rule
  | RawRule           name           : {String}
                      interface      : {String}
                      directives     : {[String]}
                      preconditions  : Judgments
                      postcondition  : Judgment
  | Rule              name           : {String}
                      interface      : Interface
                      directives     : {[String]}
                      preconditions  : Judgments
                      postcondition  : Judgment

DATA Judgment
  | RawJudgment1      name           : {String}
                      interface      : {String}
                      directives     : {[String]}
                      body           : {String}
                      defs           : {[(String,String)]}
  | RawJudgment2      name           : {String}
                      interface      : {String}
                      directives     : {[String]}
                      body           : {[(String,String)]}
                      defs           : {[(String,String)]}
  | Judgment          name           : {String}
                      interface      : Interface
                      directives     : {[String]}
                      body           : BodyAssignments
                      defs           : {[(String,String)]} 
                      
DATA BodyAssignment
  | BodyAssignment    param          : Parameter
                      value          : String                                        


-- equivalence of rules and rulesets is according to name and interface
{ 
instance Eq RuleSet where
   (==) (RuleSet_RuleSet n1 i1 _ _)
        (RuleSet_RuleSet n2 i2 _ _) = n1 == n2 && i1 == i2

instance Eq Rule where
   (==) (Rule_Rule n1 i1 _ _ _) 
        (Rule_Rule n2 i2 _ _ _) = n1 == n2 && name i1 == name i2
   (==) (Rule_RawRule n1 i1 _ _ _)
        (Rule_RawRule n2 i2 _ _ _) = n1 == n2 && i1 == i2

instance Eq Judgment where
   (==) (Judgment_RawJudgment1 n1 i1 _ _ _)
        (Judgment_RawJudgment1 n2 i2 _ _ _) = n1 == n2 && i1 == i2
   (==) (Judgment_RawJudgment2 n1 i1 _ _ _)
        (Judgment_RawJudgment2 n2 i2 _ _ _) = n1 == n2 && i1 == i2
   (==) (Judgment_Judgment n1 i1 _ _ _)
        (Judgment_Judgment n2 i2 _ _ _) = n1 == n2 && name i1 == name i2

instance Eq BodyAssignment where
   (==) (BodyAssignment_BodyAssignment p1 _)
        (BodyAssignment_BodyAssignment p2 _) = p1 == p2
   
class HasDirectives a where
   getDirectives :: a -> [String]
   hasDirective  :: a -> String -> Bool 
   getDirective  :: a -> [String] -> Maybe String

   hasDirective x s  = s `elem` getDirectives x

   getDirective x ss = result matches
      where matches    = [s' | s' <- getDirectives x, s' `elem` ss]
            result []  = Nothing
            result [x] = Just x
            result xs  = error ("Conflicting Directives: " ++ show xs)

instance HasDirectives RuleSet where
   getDirectives (RuleSet_RuleSet _ _ ds _) = ds

instance HasDirectives Rule where
   getDirectives (Rule_RawRule _ _ ds _ _) = ds
   getDirectives (Rule_Rule _ _ ds _ _)    = ds
   
instance HasDirectives Judgment where
   getDirectives (Judgment_RawJudgment1 _ _ ds _ _) = ds
   getDirectives (Judgment_RawJudgment2 _ _ ds _ _) = ds
   getDirectives (Judgment_Judgment _ _ ds _ _)     = ds
}

DERIVING Interface Parameter : Eq
DERIVING Layer Interface Parameter Implementation RuleSet Rule Judgment BodyAssignment : Show 

INCLUDE "PrettyHaskell.ag"