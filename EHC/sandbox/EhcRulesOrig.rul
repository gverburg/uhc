-------------------------------------------------------------------------
-- Preliminaries
-------------------------------------------------------------------------

preamble tex "%include lhs2TeX.fmt\n%include afp.fmt\n%include ehrules.fmt"
preamble ag "%%[0\n%include lhs2TeX.fmt\n%include afp.fmt\n%%]\n"

external _ instTyFixed ftv alpha tvarv exists forall

-------------------------------------------------------------------------
-- View hierarchy
-------------------------------------------------------------------------

viewhierarchy = E

-------------------------------------------------------------------------
-- Rewriting
-------------------------------------------------------------------------

-- Ty for expr
format ag def  (a | Ty) -> (r | t) = ([a] `mkArrow` (r) | t)
format ag def  (p | Ty) => (a | Ty) -> (r | t) = ([p,a] `mkArrow` (r) | t)
format ag def  (a | TyL) -> (r | t) = ((a) `mkArrow` (r) | t)

format ag use ((a|Ty) -> r) `=` v = (a,r) `=` tyArrowArgRes (v)
format ag use ((...) -> r) `=` v = r `=` tyArrowRes (v)
format ag use (p => a -> r) `=` v = (p,a,r) `=` tyArrowImplsArgRes (v)

-- Cnstr
format ag def  (c | Cnstr, ICnstr) (v | a) = (((c) |=> (v) | a))
format ag def  (c1 | Cnstr, ICnstr) (c2 | Cnstr, ICnstr) (v | a) = (((c1) |=> (c2) |=> (v) | a))
format ag def  (c1 | Cnstr, ICnstr) (c2 | Cnstr, ICnstr) (c3 | Cnstr, ICnstr) (v | a) = (((c1) |=> (c2) |=> (c3) |=> (v) | a))
format ag def  (c1 | Cnstr, ICnstr) (c2 | Cnstr, ICnstr) (c3 | Cnstr, ICnstr) (c4 | Cnstr, ICnstr) (v | a) = (((c1) |=> (c2) |=> (c3) |=> (c4) |=> (v) | a))
-- format ag def  (c1) (c2) (c3) (v) = c1 |=> c2 |=> c3 |=> v

-- Gam
format ag def  (g1 | ValGam, TyGam) +  (g2 | ValGam, TyGam) = (gamAddGam (g1) (g2) | ValGam, TyGam)
format ag def  (g1 | ValGam, TyGam) ++ (g2 | ValGam, TyGam) = (gamPushGam (g1) (g2) | ValGam, TyGam)
format ag def  (i :-> (t|Ty)) = (gamUnit i (ValGamInfo (t)) | ValGam, TyGam)

format ag use  (g1 | ValGam, TyGam) ++ (g2 | ValGam, TyGam) `=` (g | ValGam, TyGam) = ((g1|ValGam, TyGam),(g2|ValGam, TyGam)) `=` (gamPop (g) | ValGam, TyGam)

-- Coercion
format ag def  (coe | Coe) (transl | TranslExpr) = (foAppCoe' (coe) "@lhs.finTyCnstr" "@lhs.cSubst" (transl) | TranslExpr)

-- Nm
format ag def `|` (nm | Nm) `|` = (hsnProdArity (nm) | Int)

-- FIOpts
format ag def f, (o|FIOpts) = ((o {f})|FIOpts)
format ag def f1, f2, (o|FIOpts) = ((o {f1, f2})|FIOpts)

-- Ty for tyexpr
format ag def (t1 | Ty) (t2 | Ty) = (Ty_App (t1) (t2) | Ty)
format ag def Ty_Quant q v `.` t = (Ty_Quant (q) (tyVar (v)) (t) | Ty)

-- TyVarIdS
format ag def  (l1 | TyVarIdS) + (l2 | TyVarIdS) = (l1 ++ l2 | TyVarIdS)
format ag def  (l1 | TyVarIdS) + (l2 | TyVarIdS) + (l3 | TyVarIdS) = (l1 ++ l2 ++ l3 | TyVarIdS)

-------------------------------------------------------------------------
-- Formatting
-------------------------------------------------------------------------

-- Nm
external hsnUn

format tex hsnUn = "\"un\""

-- matching
external
  strongFIOpts weakFIOpts instLFIOpts instLRFIOpts instFIOpts
  impredFIOpts
  meetFIOpts joinFIOpts
  implFIOpts predFIOpts
  fioBindToTyAltsY fioBindToTyAltsN
  fioLeaveRInstY fioLeaveRInstN
  fioBindLFirstY fioBindLFirstN
  fioBindRFirstY fioBindRFirstN
  fioBindLBeforeRY fioBindLBeforeRN
  fioJoinY fioMeetY fioFitY
  fioDontBind
  emptyFO
  foCSubst foLCoeL foRCoeL

format tex howToMatch = <=>
format ag  fiopt = fiOpts

format ag  fioBindRFirstY = fioBindRFirst `=` True
format ag  fioBindRFirstN = fioBindRFirst `=` False
format ag  fioBindLFirstY = fioBindLFirst `=` True
format ag  fioBindLFirstN = fioBindLFirst `=` False
format ag  fioBindToTyAltsY = fioBindToTyAlts `=` True
format ag  fioBindToTyAltsN = fioBindToTyAlts `=` False
format ag  fioBindLBeforeRY = fioBindLBeforeR `=` True
format ag  fioBindLBeforeRN = fioBindLBeforeR `=` False

-- Gam
external emptyGam

format tex emptyGam = []
format tex valGam = Gamma
format tex valGam.inh = Gamma..k
format tex valGam.syn = Gamma
format tex gathTySigGam = Gamma.t
format tex gathTySigGam.ex = Gamma.t.nexists
format tex tySigGam = Gamma.t.k
format tex patValGam = Gamma.p
format tex patValGam.inh = Gamma.p.k
format tex patValGam.syn = Gamma.p
format tex quValGam = Gamma.q
format tex quValGam.ex = Gamma.q.nexists

format tex tyGam = TGamma
format tex tyGam.inh = TGamma..k
format tex tyGam.syn = TGamma

format tex kiGam = KGamma

format tex predGam = Gamma
format tex PredGam = Gamma

-- Type
external tyInt tyChar tyFloat tyInteger tyDouble tyString ANY thardS thardH tneedR tneedO

format tex ity = isigma
format tex lty = sigma.l
format tex rty = sigma.r
format tex ty = sigma
format tex knTy = sigma..k
format tex knTy.1 = sigma.1.k
format tex knTy.2 = sigma.2.k
format tex pred = pi
format tex tyInt = Int
format tex tyChar = Char
format tex instTyFixed = inst.f
format tex patFunTy = sigma.pf
format tex ty.sig = ty.s
format tex ty.q = sigma.q
format tex ty.elim = sigma.e
format tex ty.tboth = sigma./=/
format tex tboth =  /=/
format tex ty' = sigma'

format ag tvarv..._ = tvars
format ag ty..._ = tys
format ag ANY = (Ty_Any|Ty)
format ag ity = imprTy
format ag ty.ident = gTy

-- tvars
external tyLVar

format tex tyLVar =
format tvars.f = tvarv.f.._
format tvars.g = tvarv.g.._

format ag tyLVar = map tyVar

-- Impred Cnstr
format tex ityCnstr = ICnstr
format tex ityCnstr.in = ICnstr..k
format tex ityCnstr.inh = ICnstr..k
format tex ityCnstr.syn = ICnstr
format tex ityCnstr.fitA = ICnstr.A
format tex ityCnstr.fitF = ICnstr.F
format tex ityCnstr.valGam = ityCnstr.Gamma
format tex ityCnstr.elim = tyCnstr.Gamma

format ag ityCnstr = imprTyCnstr

-- Plain Cnstr
external emptyCnstr'
external emptyCnstr

format tex cnstr = Cnstr
format tex emptyCnstr = []
format tex emptyCnstr' =
format tex patTyCnstr.syn = Cnstr.p
format tex patTyCnstr.inh = Cnstr.p.k
format tex tyCnstr = Cnstr
format tex tyCnstr.inh = Cnstr..k
format tex tyCnstr.syn = Cnstr
format tex tySigTyCnstr.inh = Cnstr.t.k
format tex tySigTyCnstr.syn = Cnstr.t
format tex tyCnstr.r = Cnstr.r
format tex tyCnstr.fun = Cnstr.f
format tex tyCnstr.fitP = Cnstr.P
format tex tyCnstr.fitF = Cnstr.F
format tex tyCnstr.fitE = Cnstr.E
format tex tyCnstr.arg = Cnstr.a

format ag emptyCnstr' = emptyCnstr

-- Decl
format tex declExpr = e
format tex declTyExpr = t
format tex declPat = p

format ag declExpr = expr
format ag declTyExpr = tyExpr
format ag declPat = patExpr

-- Expr
format tex letDecls = d
format tex letBody = b
format tex lamPat = p
format tex lamBody = e
format tex eFun = e.1
format tex eArg = e.2
format tex eAnn = e
format tex eTop = eFun ^^ (eArg)..._

format ag letDecls = decls
format ag letBody = body
format ag eFun = func
format ag eArg = arg
format ag eAnn = expr
format ag eTop = expr
format ag lamPat = arg
format ag lamBody = body
format ag ident = nm
format ag identv = nm
format ag identc = nm
format ag uniq = gUniq
format fmtcmd rulerMk1Uniq = mkNewLevUID
format fmtcmd rulerMk2Uniq = mkNewLevUID2
format fmtcmd rulerMk3Uniq = mkNewLevUID3
format fmtcmd rulerMk4Uniq = mkNewLevUID4
format fmtcmd rulerMk5Uniq = mkNewLevUID5
format fmtcmd rulerMk6Uniq = mkNewLevUID6

format ag decls.hd = hd
format ag decls.tl = tl

format tex decls.hd = d
format tex decls.tl = ds

-- Type expr
external tyexprCon tyexprQuant

format tex tQu = Qu
format tex tVar = identv
format tex tAnn = t
format tex tExpr = t
format tex tFun = t.1
format tex tArg = t.2

format tex tyexprCon = 
format tex tyexprQuant = 

format ag tQu = qu
format ag tVar = tyVar
format ag tAnn = tyExpr
format ag tExpr = tyExpr
format ag tFun = func
format ag tArg = arg

-- Ty wildcard
format tex tyWildL =  tvarv.w.._

format ag tvarv.w.._ = tyWildL

-- Pat expr
format tex pFun = p.1
format tex pArg = p.2
format tex pAsPat = p
format tex pTopPatK = p
format tex pExpr = p

format ag pFun = func
format ag pArg = arg
format ag pAsPat = patExpr
format ag pTopPatK = patExpr
format ag pExpr = patExpr

-- Translation from TyExpr to Ty
format ag tyexprCon = Ty_Con
format ag tyexprQuant = Ty_Quant

-- Translation to core (CExpr)
external translInt translChar translString translFloat translDouble translInteger translVar emptyTranslBind

format tex translExpr = Transl
format tex TranslExpr = Transl
format tex translBind = Transl
format tex TranslBind = Transl
format tex emptyTranslBind = []

format ag translExpr = cexpr

format tex translInt = Transl
format ag  translInt = CExpr_Int
format tex translChar = Transl
format ag  translChar = CExpr_Char
format tex translString = Transl
format ag  translString = CExpr_String
format tex translFloat = Transl
format ag  translFloat = CExpr_Float
format tex translDouble = Transl
format ag  translDouble = CExpr_Double
format tex translInteger = Transl
format ag  translInteger = CExpr_Integer
format tex translVar = Transl
format ag  translVar = CExpr_Var

-- Coercion
external coeId

format tex coe = Coe

-- Co-, Contravariance
external cocoY cocoN cocoNo

-- Errors
external Err_PatArity

-------------------------------------------------------------------------
-- Expr
-------------------------------------------------------------------------

scheme expr "Expr" =
  view E =
    holes [ node e: Expr, valGam: ValGam, tyGam: TyGam, kiGam: KiGam | ty: Ty | ]
    judgespec kiGam ; tyGam ; valGam :- e : ty
    judgeuse tex valGam :-.."e" e : ty
    explain (Within environment |valGam| , expression |e| has type |ty| .)
    explain ty = (Type of expression)
    explain e = (Expression)
    explain valGam = (Environment | (ident :-> ty)..._ | for value identifiers)

rulesgroup expr.scratch scheme expr "Expression type rules (scratch)" =
  rule expr.base e.let

rulesgroup expr.baseForEH1 scheme expr "Expression type rules" =
  rule expr.base e.int
  rule expr.base e.char
  rule expr.base e.var
  rule expr.base e.app
  rule expr.onlyE e.prod
  rule expr.base e.lam
  rule expr.base e.ann
  rule expr.base e.let

ruleset expr.base scheme expr "Expression type rules" =
  rule e.int "IConst" =
    view E =
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- int : tyInt

  rule e.char : e.int "CConst" =
    view E =
      ---
      judge R : expr
          | e = char
          | ty = tyChar

  rule e.str : e.int "SConst" =
    view E =
      ---
      judge R : expr
          | e = str
          | ty = tyString

  rule e.float : e.int "FConst" =
    view E =
      ---
      judge R : expr
          | e = float
          | ty = tyFloat

  rule e.iint : e.int "IIConst" =
    view E =
      ---
      judge R : expr
          | e = integer
          | ty = tyInteger
 
  rule e.double : e.int "DConst" =
    view E =
      ---
      judge R : expr
          | e = double
          | ty = tyDouble

  rule e.var "Var" =
    view E =
      judge G : valGamLookupIdTy = ident :-> ty `elem` valGam
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- ident : ty

  rule e.app "App" =
    view E =
      judge F : expr = kiGam ; tyGam ; valGam :- eFun : (ty.a -> (ty|Ty))
      judge A : expr = kiGam ; tyGam ; valGam :- eArg : ty.a
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- ((node 1 = eFun) ^^ (node 2 = eArg)) : ty

  rule e.lam "Lam" =
    view E =
      judge B : expr = kiGam ; tyGam ; ((identv :-> ty.identv) + valGam) :- lamBody : ty.e
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- (\identv -> (node 2 = lamBody)) : (ty.identv -> ty.e)

  rule e.let "Let" =
    view E =
      judge D : decl = kiGam ; tyGam ; (gathTySigGam ++ valGam) :- letDecls : gathTySigGam
      judge B : expr = kiGam ; tyGam ; (gathTySigGam ++ valGam) :- letBody : ty
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- (let (node 1 = letDecls) in (node 2 = letBody)) : ty

  rule e.ann "TypeAs" =
    view E =
      judge E : expr = kiGam ; tyGam ; valGam :- eAnn : ty
      judge T : tyexpr = :- tAnn : ty
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- (((node 2 = eAnn) :: (node 1 = tAnn))) : ty

  rule e.prod =
    view E =
      judge F : expr = kiGam ; tyGam ; valGam :- e.1 : ty.1
      judge S : expr = kiGam ; tyGam ; valGam :- e.2 : ty.2
      ---
      judge R : expr = kiGam ; tyGam ; valGam :- ((e.1,e.2)) : ((ty.1,ty.2))

-------------------------------------------------------------------------
-- Declaration
-------------------------------------------------------------------------

scheme decl "Decl" =
  view E =
    holes [ kiGam: KiGam, tyGam: TyGam, valGam: ValGam, node d: Decl | | gathTySigGam: ValGam ]
    judgespec kiGam ; tyGam ; valGam :-.."d" d : gathTySigGam
    judgeuse tex valGam :-.."d" d : gathTySigGam
    explain (Within environment |valGam| , declaration |d| has type signature bindings |gathTySigGam| .)
    explain valGam = (Environment with known bindings)
    explain gathTySigGam = (Environment with type signature bindings)
    explain d = (Declaration)
     
-------------------------------------------------------------------------
-- Type Expr
-------------------------------------------------------------------------

scheme tyexpr "TyExpr" =
  view E =
    holes [ node t: TyExpr | | retain ty: Ty ]
    judgespec :-.."t" t : ty
    explain (Type expression |t| has a corresponding type signature |ty| .)
    explain ty = (Type signature)
    explain t = (Type expression)

-------------------------------------------------------------------------
-- Binding from a Gamma
-------------------------------------------------------------------------

relation valGamLookupIdTy =
  view E =
    holes [ nm: Nm, valGam: ValGam | | ty: Ty ]
    judgespec nm :-> ty `elem` valGam
    judgeuse ag  (ty,nmErrs) `=` valGamLookupTy (nm) (valGam)
