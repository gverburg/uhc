% $Id: EHC.lag 199 2004-05-12 19:11:13Z andres $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Code's Java gen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(UU.Pretty,EHCommon,EHCode,Char) export(cexprJavaSrc)
%%]

%%[8.WRAPPER import(EHCodeAbsSyn)
WRAPPER CodeAGItf
%%]

%%[8 hs
cexprJavaSrc :: CModule -> (String,PP_Doc)
cexprJavaSrc cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   (jvBasename_Syn_CodeAGItf t,jvSrc_Syn_CodeAGItf t)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Convenience functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
jvInd :: PP_Doc -> PP_Doc
jvInd = indent 1

jvNm :: HsName -> String
jvNm hn
  = if    n `elem` jKeyw
    then  surr n
    else  concat . map (\c -> maybe [c] (\f -> surr (f c)) (lookup c jSymChs)) $ (if isDigit (head n) then "_" ++ n else n)
  where  n        =  show hn
         jKeyw    =  [ "const" ]
         jSymChs  =  [ ((=='\''),const "squot")
                     , ((=='-'),const "dash")
                     , ((=='!'),const "bang")
                     ]
         surr x   =  "_" ++ x ++ "_"
         lookup v [] = Nothing
         lookup v ((f,r):ls) | f v = Just r
                             | otherwise = lookup v ls

jvNmPP :: HsName -> PP_Doc
jvNmPP
  = text . jvNm

jvRet :: PP_Doc -> PP_Doc
jvRet r = "return" >-< jvInd r >#< ";"

jvBody :: String -> String -> PP_DocL -> PP_Doc -> PP_Doc -> PP_Doc -> PP_Doc
jvBody cl f as d1 d2 b
  = (cl >#< "{")
    >-< jvInd
            (   d1
            >-< "public" >#< (f >-< jvInd as') >#< "{"
            >-< jvInd (d2 >-< b)
            >-< "}"
            )
    >-< "}"
  where as' = jvArgs as

jvArgs :: PP_DocL -> PP_Doc
jvArgs = pp_block "(" ")" ","

jvCall :: PP a => a -> PP_DocL -> PP_Doc
jvCall f as = let as' = jvArgs as
              in  pp f >-< jvInd as'

jvCast :: String -> PP_Doc -> PP_Doc
jvCast c o = pp_parens (pp_parens (pp c) >|< o)

jvForceEval :: PP a => a -> PP_Doc
jvForceEval e = "eval" >|< pp_parens (pp e)

jvForceCast :: PP a => String -> a -> PP_Doc
jvForceCast c e = jvCast c (jvForceEval e)

jvForceInt :: PP a => a -> PP_Doc
jvForceInt e = jvForceCast "Int" e >|< ".intValue()"

jvApp :: PP_Doc -> PP_DocL -> PP_Doc
jvApp f as
  =  let  n = length as
     in   if n <= 5
          then jvCall (jvCast "Eval" f >|< ".apply" ++ show n) as
          else jvCall (jvCast "Eval" f >|< ".applyN") [jvTupApp as]

jvTupApp :: PP_DocL -> PP_Doc
jvTupApp as = "new Object[]" >-< jvInd (pp_block "{" "}" "," as)

jvLam :: HsName -> [HsName] -> PP_Doc -> PP_Doc
jvLam fNm as b
  =  let  n = length as
     in   if n <= 5
          then jvBody ("new Function" ++ show n ++ "(\"" ++ show fNm ++ "\")") ("Object eval" ++ show n) (map (\a -> "final Object" >#< jvNmPP a) as) empty empty b
          else jvBody ("new FunctionN(" ++ show n ++ ",\"" ++ show fNm ++ "\")") ("Object evalN") [pp "Object[] _x_"] empty empty
                    (vlist (zipWith (\i a -> jvBind "Object" a (jvInx "_x_" i)) [0..] as) >-< b)

jvAssign :: HsName -> PP_Doc -> PP_Doc
jvAssign nm val = (jvNmPP nm >#< "=") >-< jvInd val >#< ";"

jvDeclare :: String -> HsName -> PP_Doc
jvDeclare jvtp nm = jvtp >#< jvNmPP nm >#< ";"

jvBind :: PP a => String -> HsName -> a -> PP_Doc
jvBind jvtp nm val = "final" >#< jvtp >-< jvInd (jvAssign nm (pp val))

jvInx :: PP a => a -> Int -> PP_Doc
jvInx ar i = ar >|< pp_brackets (pp i)

jvCAF :: (PP a, PP b) => a -> b -> PP_Doc
jvCAF stats body = jvBody "new Apply0()" "void evalSet" [] empty (pp stats) (jvCall "setValue" [pp body] >#< ";")

jvSelNm   = HNm "_sel"
jvSel1Nm  = HNm "_sel1"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CodeAGItf AllCodeNT [ | | jvSrc USE {>-<} {empty} : PP_Doc ]
ATTR CBind CBindL [ | | jvSrcInd USE {>-<} {empty} : PP_Doc ^^^ jvSrcSetInd USE {>-<} {empty} : PP_Doc ^^^ jvSrcStrict USE {>-<} {empty} : PP_Doc ]
ATTR CodeAGItf CModule [ | | jvBasename: String ]

SEM CModule
  | Mod         loc         .   jvBasename  =   jvNm (HNm @baseName)
                expr        .   jvBuiltin   =   let primCmpIntNm = HNm "primCmpInt"
                                                in  jvBind "Function2" jvSelNm
                                                        (jvLam jvSelNm [HNm "tup",HNm "off"] (jvRet (jvForceCast "Object[]" "tup" >|< pp_brackets (jvForceInt "off"))))
                                                    >-< jvBind "Function2" jvSel1Nm
                                                        (jvLam jvSel1Nm [HNm "tup",HNm "off"] (jvRet (jvForceCast "Object[]" "tup" >|< pp_brackets ("1+" >|< jvForceInt "off"))))
                                                    >-< jvBind "Object" hsnUndefined "null"
                                                    >-< jvBind "Function2" primCmpIntNm
                                                            (jvLam primCmpIntNm [HNm "i1",HNm "i2"]
                                                                (   jvBind "int" (HNm "_i1") (jvForceInt "i1")
                                                                >-< jvBind "int" (HNm "_i2") (jvForceInt "i2")
                                                                >-< "if (_i1 < _i2) return new Object[]{new Int(2)} ; else if (_i1 > _i2) return new Object[]{new Int(1)}; else return new Object[]{new Int(0)} ;"
                                                                ))
                lhs         .   jvSrc       =   "import uu.jazy.core.* ;"
                                                >-< "import uu.jazy.prelude.* ;"
                                                >-< "import uu.jazy.gui.* ;"
                                                >-< jvBody ("public class " ++ @jvBasename) "static void main" [text "String args[]"]
                                                      empty empty
                                                      (   "// EvalFollower.setupVisualTrace() ;"
                                                      >-< jvCall "IO.timeNShowln" [@expr.jvSrc] >#< ";")

SEM CExpr
  | Int         loc         .   jvSrc       =   "new Int" >|< pp_parens (pp @int)
  | Char        loc         .   jvSrc       =   "new Char" >|< pp_parens (pp (show @char))
  | Var         loc         .   jvSrc       =   maybe (jvNmPP @nm) (jvNmPP) . lookup @nm $ primToJavaMp
  | App         loc         .   jvSrc       =   let  (f:as) = reverse @jvSrcL
                                                in   if @func.isTupApp then jvTupApp as else jvApp f as
  | Let         loc         .   jvBinds     =   case @categ of
                                                    CBindPlain   -> @binds.jvSrc
                                                    CBindStrict  -> @binds.jvSrcStrict
                                                    CBindRec     -> @binds.jvSrcInd >-< @binds.jvSrcSetInd
                            .   jvSrc       =   jvCAF (@lhs.jvBuiltin >-< @jvBinds) @body.jvSrc
  | Lam         loc         .   jvSrc       =   jvLam (maybe hsnUnknown id @lhs.mbLamNm) @jvArgL (jvRet @jvBody)
  | Tup         loc         .   jvSrc       =   text "new Object" >|< pp_brackets (pp @arity)
  | Sel         loc         .   jvSrc       =   jvApp (jvNmPP (if @tag >= 0 then jvSel1Nm else jvSelNm)) [@expr.jvSrc,@offset.jvSrc]
  | Case        loc         .   jvSrc       =   jvCAF
                                                    (    jvBind "Object[]" @jvCaseScrutinee (jvCast "Object[]" @expr.jvSrc)
                                                     >-< jvDeclare "Object" @jvCaseResult
                                                     >-< "switch"
                                                     >|< pp_parens
                                                           (if @alts.tagSz > 0
                                                            then jvForceInt (jvInx (jvNmPP @jvCaseScrutinee) 0)
                                                            else pp ctagNone
                                                           )
                                                     >-< pp_braces
                                                            (   @alts.jvSrc
                                                            >-< "default :"
                                                            >-< jvAssign @jvCaseResult @dflt.jvSrc
                                                            )
                                                    )
                                                    (jvNmPP @jvCaseResult)
                            .   jvCaseScrutinee
                                            =   HNm (show @expr.varNm ++ "_scrutinee")
                            .   jvCaseResult
                                            =   HNm (show @expr.varNm ++ "_result")

SEM CBind
  | Bind        lhs         .   jvSrcInd    =   jvBind "Indirection" @nm "new Indirection()"
                            .   jvSrcSetInd =   jvCall (jvNmPP @nm >|< ".set") [@expr.jvSrc] >#< ";"
                            .   jvSrc       =   jvBind "Object" @nm @expr.jvSrc
                            .   jvSrcStrict =   jvBind "Object" @nm (jvForceEval @expr.jvSrc)

ATTR CAlt CAltL CPat CPatL CPatBind CPatBindL [ jvCaseScrutinee: HsName ^^^ jvCaseResult: HsName | | ]
ATTR CPat [ | | fldNm: HsName ]

SEM CPat
  | Var Con     lhs         .   fldNm       =   cpatNmNm @pnm
  | Undef       lhs         .   fldNm       =   hsnUnknown

SEM CPatBind
  | Bind        lhs         .   jvSrc       =   jvBind "Object" @pat.fldNm (jvInx (jvNmPP @lhs.jvCaseScrutinee) (@offset + @lhs.tagSz))

SEM CAlt
  | Alt         lhs         .   jvSrc       =   @pats.jvSrc
                                                >-< jvAssign @lhs.jvCaseResult @expr.jvSrc
                                                >-< "break ;"

SEM CPat
  | Con         lhs         .   jvSrc       =   "case" >#< @tag >#< ":"
                                                >-< @binds.jvSrc
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Builtin distr to outer let
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ jvBuiltin: PP_Doc | | ]

SEM CExpr
  | Let         body        .   jvBuiltin   =   empty

SEM CBind
  | Bind        expr        .   jvBuiltin   =   empty

SEM CAlt
  | Alt         expr        .   jvBuiltin   =   empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Var name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | varNm: HsName ]

SEM CExpr
  | Var         lhs         .   varNm       =   @nm
  | Int Let Lam Tup Char Sel App
                lhs         .   varNm       =   hsnUnknown
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Has tag?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CPatBindL CPatBind [ tagSz: Int | | ]
ATTR CPatL CPat CAltL CAlt [ | | tagSz USE {`const`} {0}: Int ]

SEM CPat
  | Con         loc         .   tagSz       =   if @tag >= 0 then 1 else 0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% As args ++ func
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | jvSrcL: PP_DocL ]

SEM CExpr
  | App         loc         .   jvSrcL      =   @arg.jvSrc : @func.jvSrcL
  | * - App     lhs         .   jvSrcL      =   [@jvSrc]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% As body + args
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | jvArgL: {[HsName]} ^^ jvBody: PP_Doc ]

SEM CExpr
  | Lam         loc         .   jvArgL      =   @arg : @body.jvArgL
                            .   jvBody      =   @body.jvBody
  | * - Lam     lhs         .   jvArgL      =   []
                            .   jvBody      =   @jvSrc
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is CExpr the creation of a tuple?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | isTupApp: Bool ]

SEM CExpr
  | Tup         lhs         .   isTupApp    =   True
  | App         lhs         .   isTupApp    =   @func.isTupApp
  | * - Tup App
                lhs         .   isTupApp    =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Mapping of 'prim' functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
primToJavaMp :: AssocL HsName HsName
primToJavaMp
  =  [ ( HNm "primAddInt", HNm "uu.jazy.prelude.Int.add" )
     , ( HNm "primDivInt", HNm "uu.jazy.prelude.Int.div" )
     , ( HNm "primMulInt", HNm "uu.jazy.prelude.Int.mul" )
     , ( HNm "primSubInt", HNm "uu.jazy.prelude.Int.sub" )
     , ( HNm "primCmpInt", HNm "primCmpInt" )
     ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Distribution of name of lambda, if any is available
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ mbLamNm: {Maybe HsName} | | ]

SEM CExpr
  | App Lam     loc         .   mbLamNm     =   Nothing

SEM CAlt
  | Alt         loc         .   mbLamNm     =   Nothing

SEM CBind
  | Bind        expr        .   mbLamNm     =   Just @nm

SEM CModule
  | Mod         expr        .   mbLamNm     =   Nothing
%%]





