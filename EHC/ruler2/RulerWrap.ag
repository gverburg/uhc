-- $Id: Ruler.ag 231 2005-06-07 14:39:41Z atze $

-------------------------------------------------------------------------
-- Interfacing to top level
-------------------------------------------------------------------------

WRAPPER AGItf 

-------------------------------------------------------------------------
-- Interfacing to RlSel
-------------------------------------------------------------------------

WRAPPER AGRlSelItf

{
wrapRlSel :: DpdGr Nm -> RlSel -> Syn_AGRlSelItf
wrapRlSel vwDpdGr vs
  = let r1 = sem_AGRlSelItf (AGRlSelItf_AGItf vs)
    in  wrap_AGRlSelItf r1
            (Inh_AGRlSelItf {vwDpdGr_Inh_AGRlSelItf = vwDpdGr
                            })

wrapRlSelT :: DpdGr Nm -> T_RlSel -> Syn_AGRlSelItf
wrapRlSelT vwDpdGr vs
  = let r1 = sem_AGRlSelItf_AGItf vs
    in  wrap_AGRlSelItf r1
            (Inh_AGRlSelItf {vwDpdGr_Inh_AGRlSelItf = vwDpdGr
                            })

rlSelSelfT :: T_RlSel -> RlSel
rlSelSelfT vs
  = self_Syn_AGRlSelItf r
  where r = wrapRlSelT emptyVwDpdGr vs

rlSelIsSel :: DpdGr Nm -> RlSel -> RlSelIsSel
rlSelIsSel vwDpdGr rs
  = rlSelIsSel_Syn_AGRlSelItf r
  where r = wrapRlSel vwDpdGr rs

rlSelRnmM :: RlSel -> Map.Map Nm Nm
rlSelRnmM rs
  = vwRnmM_Syn_AGRlSelItf r
  where r = wrapRlSel emptyVwDpdGr rs

}

-------------------------------------------------------------------------
-- Interfacing to ViewSel
-------------------------------------------------------------------------

WRAPPER AGViewSelsItf

{
wrapViewSels :: DpdGr Nm -> ViewSels -> Syn_AGViewSelsItf
wrapViewSels vwDpdGr vs
  = let r1 = sem_AGViewSelsItf (AGViewSelsItf_AGItf vs)
    in  wrap_AGViewSelsItf r1
            (Inh_AGViewSelsItf {vwDpdGr_Inh_AGViewSelsItf = vwDpdGr
                               })

wrapViewSelsT :: DpdGr Nm -> T_ViewSels -> Syn_AGViewSelsItf
wrapViewSelsT vwDpdGr vs
  = let r1 = sem_AGViewSelsItf_AGItf vs
    in  wrap_AGViewSelsItf r1
            (Inh_AGViewSelsItf {vwDpdGr_Inh_AGViewSelsItf = vwDpdGr
                               })

viewSelsNmS :: DpdGr Nm -> ViewSels -> Set.Set Nm
viewSelsNmS vwDpdGr vs
  = vwSelNmS_Syn_AGViewSelsItf r
  where r = wrapViewSels vwDpdGr vs

{-
viewSelsNmS' :: DpdGr Nm -> T_ViewSels -> Set.Set Nm
viewSelsNmS' vwDpdGr vs
  = vwSelNmS_Syn_AGViewSelsItf r
  where r = wrapViewSelsT vwDpdGr vs
-}

viewSelsSelfT :: T_ViewSels -> ViewSels
viewSelsSelfT vs
  = self_Syn_AGViewSelsItf r
  where r = wrapViewSelsT emptyVwDpdGr vs
}

-------------------------------------------------------------------------
-- Interfacing to ARule
-------------------------------------------------------------------------

WRAPPER AGARuleItf

{
wrapARule' :: Opts -> [Nm] -> AtDefdGam -> FmGam Expr -> ARule -> Syn_AGARuleItf
wrapARule' o co ag fg rl
  = let r1 = sem_AGARuleItf (AGARuleItf_AGItf rl)
    in  wrap_AGARuleItf r1
            (Inh_AGARuleItf {opts_Inh_AGARuleItf = o
                            ,croNmL_Inh_AGARuleItf = co
                            ,adGam_Inh_AGARuleItf = ag
                            ,fmGam_Inh_AGARuleItf = fg
                            })

arlUniq :: FmGam Expr -> [Nm] -> ARule -> ARule
arlUniq fg co = replUniq_Syn_AGARuleItf . wrapARule' defaultOpts co emptyGam fg

arlElimAlphaRename :: ARule -> ARule
arlElimAlphaRename = replRn_Syn_AGARuleItf . wrapARule' defaultOpts [] emptyGam emptyGam

arlElimCopyRule :: [Nm] -> AtDefdGam -> ARule -> ARule
arlElimCopyRule co ag = replCr_Syn_AGARuleItf . wrapARule' defaultOpts co ag emptyGam

arlElimWild :: ARule -> ARule
arlElimWild = replEw_Syn_AGARuleItf . wrapARule' defaultOpts [] emptyGam emptyGam

arlSubst :: FmGam Expr -> ARule -> ARule
arlSubst fg = repl_Syn_AGARuleItf . wrapARule' defaultOpts [] emptyGam fg

ppARule :: ARule -> PP_Doc
ppARule = pp_Syn_AGARuleItf . wrapARule' defaultOpts [] emptyGam emptyGam
}

-------------------------------------------------------------------------
-- Interfacing to Expr
-------------------------------------------------------------------------

WRAPPER AGExprItf

{
wrapExpr' :: Opts -> FmGam Expr -> RwExprGam -> ECnstrGam -> RnMp -> Expr -> Syn_AGExprItf
wrapExpr' o fmg rwg ecg rnm e
  = let r1 = sem_AGExprItf (AGExprItf_AGItf e)
    in  wrap_AGExprItf r1
            (Inh_AGExprItf { opts_Inh_AGExprItf = o
                           , fmGam_Inh_AGExprItf = fmg, rwGam_Inh_AGExprItf = rwg, ecGam_Inh_AGExprItf = ecg
                           , rnMp_Inh_AGExprItf = rnm
                           })

exprNmS :: Expr -> Set.Set Nm
exprNmS = nmS_Syn_AGExprItf . wrapExpr' defaultOpts emptyGam emptyGam emptyGam Map.empty

exprFmtTeX :: Opts -> Expr -> PP_Doc
exprFmtTeX o = ppLaTeX_Syn_AGExprItf . wrapExpr' o emptyGam emptyGam emptyGam Map.empty

ppExpr :: Expr -> PP_Doc
ppExpr = pp_Syn_AGExprItf . wrapExpr' defaultOpts emptyGam emptyGam emptyGam Map.empty

exprSubst :: Opts -> FmGam Expr -> Expr -> Expr
exprSubst o fmg = repl_Syn_AGExprItf . wrapExpr' o fmg emptyGam emptyGam Map.empty

exprASubst :: RnMp -> Expr -> Expr
exprASubst rnm = replRn_Syn_AGExprItf . wrapExpr' defaultOpts emptyGam emptyGam emptyGam rnm

exprRewrite :: Opts -> FmGam Expr -> RwExprGam -> ECnstrGam -> Expr -> Expr
exprRewrite o fmg rwg ecg e
  = r
  where (r,_,_) = exprRewrite' o fmg rwg ecg e

exprRewrite' :: Opts -> FmGam Expr -> RwExprGam -> ECnstrGam -> Expr -> (Expr,[AEqn],FmGam Expr)
exprRewrite' o fmg rwg ecg e
  = (repl_Syn_AGExprItf r,aEqnL_Syn_AGExprItf r,aEqnFmGam_Syn_AGExprItf r)
  where r = wrapExpr' o fmg rwg ecg Map.empty e

exprElimCnstr :: Expr -> (Expr,ECnstrGam)
exprElimCnstr e
  = (replEc_Syn_AGExprItf r,ecElimGam_Syn_AGExprItf r)
  where r = wrapExpr' defaultOpts emptyGam emptyGam emptyGam Map.empty e

exprIsRw :: Expr -> ExprIsRw
exprIsRw = exprIsRw_Syn_AGExprItf . wrapExpr' defaultOpts emptyGam emptyGam emptyGam Map.empty

exprNmGam :: Expr -> FmGam Expr
exprNmGam = reGamExprFmGam_Syn_AGExprItf . wrapExpr' defaultOpts emptyGam emptyGam emptyGam Map.empty

exprCoGam :: Expr -> ChOrdGam
exprCoGam = coGam_Syn_AGExprItf . wrapExpr' defaultOpts emptyGam emptyGam emptyGam Map.empty

exprFmtTeXSubst :: Opts -> FmGam Expr -> Expr -> PP_Doc
exprFmtTeXSubst o fmg = exprFmtTeX o . exprSubst o fmg

exprMbNm :: Expr -> Maybe Nm
exprMbNm (Expr_Var n) = Just n
exprMbNm _            = Nothing

exprAsNm :: Expr -> Nm
exprAsNm = maybe nmUnk id . exprMbNm

exprUnk :: Expr
exprUnk = Expr_Var nmUnk

{-
nmFmLookup :: FmKind -> Nm -> FmGam Expr -> Nm
nmFmLookup k n g = maybe n exprAsNm $ fmGamLookup n k g
-}

nmSubst :: Opts -> FmGam Expr -> Nm -> Nm
nmSubst o g = exprAsNm . exprSubst o g . Expr_Var

instance Show Expr where
  show _ = "Expr"

instance PP Expr where
  pp = ppExpr
}

-------------------------------------------------------------------------
-- Construction
-------------------------------------------------------------------------

{
mkExprApp :: Expr -> [Expr] -> Expr
mkExprApp f = Expr_AppTop . foldl Expr_App f
}

{
mkAFld :: Nm -> Expr
mkAFld n = Expr_AVar (ANm_Fld n)

mkALoc :: Nm -> Expr
mkALoc n = Expr_AVar (ANm_Loc n [])

mkALoc' :: Nm -> Expr
mkALoc' n = mkALoc (nmStrApd n nmWild)

mkALhs' :: [AtProp] -> Nm -> Expr
mkALhs' p n = Expr_AVar (ANm_Lhs n p)

mkALhs :: Nm -> Expr
mkALhs = mkALhs' []

mkANd :: Nm -> Nm -> Expr
mkANd n a = Expr_AVar (ANm_Node n a)
}

