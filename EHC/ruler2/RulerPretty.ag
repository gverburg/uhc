-- $Id: Ruler.ag 231 2005-06-07 14:39:41Z atze $

-------------------------------------------------------------------------
-- Pretty printing of ruler AST
-------------------------------------------------------------------------

{
ppExprMbEmpty :: Expr -> (PP_Doc -> PP_Doc) -> PP_Doc -> PP_Doc
ppExprMbEmpty (Expr_Empty) _ p = p
ppExprMbEmpty _            f p = f p
}

-------------------------------------------------------------------------
-- Need for parenthesis
-------------------------------------------------------------------------

{
data NeedParCtxt
  = ParCtxtAppL | ParCtxtAppR | ParCtxtOpL | ParCtxtOpR | ParCtxtOther
  deriving Eq

exprNeedPar :: NeedParCtxt -> Expr -> (PP_Doc -> PP_Doc)
exprNeedPar ctxt e
  = case e of
      Expr_Paren e
        -> case (t e,ctxt) of
             (Expr_Op    _ _ _ _,ParCtxtAppL) -> pp_parens
             (Expr_Op    _ _ _ _,ParCtxtAppR) -> pp_parens
             (Expr_Op    _ _ _ _,ParCtxtOpL ) -> pp_parens
             (Expr_App   _ _    ,ParCtxtAppR) -> pp_parens
             (Expr_Paren _      ,_          ) -> pp_parens
             _ -> id
      _ -> id
  where t (Expr_AppTop  e) = t e
        t (Expr_Named _ e) = t e
        t e                = e
}

{-
exprNeedPar :: NeedParCtxt -> Expr -> (PP_Doc -> PP_Doc)
exprNeedPar ctxt e
  = case (t e,ctxt) of
      (Expr_Op _ _ _ _,ParCtxtAppL) -> pp_parens
      (Expr_Op _ _ _ _,ParCtxtAppR) -> pp_parens
      (Expr_Op _ _ _ _,ParCtxtOpL) -> pp_parens
      (Expr_App _ _,ParCtxtAppR) -> pp_parens
      _ -> id
  where t (Expr_AppTop  e) = t e
        t (Expr_Named _ e) = t e
        t e                = e
-}

-------------------------------------------------------------------------
-- Plain, for all
-------------------------------------------------------------------------

ATTR AGItf AGExprItf AllNT AGARuleItf [ | | pp USE {>-<} {empty} : PP_Doc ]

SEM AGItf
  | AGItf           lhs     .   pp          =   @decls.pp
                                                >-< "---------- scheme gam" >-< ppGam @scGam
                                                >-< "---------- rule set gam" >-< ppGam @rsGam
                                                >-< "---------- topsorted vw dpd graph" >-< ppCommas (vgTopSort @vwDpdGr)

SEM Decl
  | Scheme          lhs     .   pp          =   "scheme"        >#< @scKind >#< @nm >-< "=" >#< @decls.pp
  | SchemeDeriv     lhs     .   pp          =   "scheme"        >#< @scKind >#< @nm >#< ":" >#< @scDeriv >-< "=" >#< @decls.pp
  | Fmt             lhs     .   pp          =   "format"        >#< @fmKind >#< @matchExpr.pp >#< "=" >#< @expr.pp
  | ScmView         lhs     .   pp          =   "view"          >#< @nm >-< "=" >#< @decls.pp
  | RulView         lhs     .   pp          =   "view"          >#< @nm >-< "=" >#< (@pre.pp >-< "-" >-< @post.pp)
  | Rules           lhs     .   pp          =   "rules"         >#< @nm >#< "scheme" >#< @schemeNm >-< "=" >#< @decls.pp
  | RulesGroup      lhs     .   pp          =   "rulesgroup"    >#< @nm >#< "scheme" >#< @schemeNm >-< "=" >#< (vlist . map (\(rs,r) -> "rule" >#< rs >#< r) $ @rlNms)
  | Rule            lhs     .   pp          =   "rule"          >#< @nm >#< "viewsel" >#< pp (show @viewSel.vwSelNmS) >-< "=" >#< @decls.pp
  | ViewHierarchy   lhs     .   pp          =   "viewhierarchy" >#< text (show @nmOrder)
  | ShpJudge        lhs     .   pp          =   "judgeshape"    >#< @expr.pp
  | ShpDel          lhs     .   pp          =   "judgeshape"    >#< "-" >#< ppCommas @fmKinds
  | Attr            lhs     .   pp          =   "hole"          >#< ("inh" >#< @inhs.pp >-< "i+s" >#< @inhsyns.pp >-< "syn" >#< @syns.pp)

SEM ViewSel
  | All             lhs     .   pp          =   pp "*"
  | View            lhs     .   pp          =   pp @nm
  | Range           lhs     .   pp          =   @vwFr.pp >#< ".." >#< @vwTo.pp

SEM ViewSels
  | Cons            lhs     .   pp          =   @hd.pp >|< "," >#< @tl.pp

SEM RExpr
  | Judge           lhs     .   pp          =   "judge" >#< maybe empty (\n -> pp n >#< "=") @mbRNm >#< pp @schemeNm >#< @eqns.pp
  | Del             lhs     .   pp          =   "judge" >#< "-" >#< ppCommas @nms

SEM Expr
  | App             lhs     .   pp          =   exprNeedPar ParCtxtAppL @lExpr.self @lExpr.pp
                                                >#< exprNeedPar ParCtxtAppR @rExpr.self @rExpr.pp
  | Op              lhs     .   pp          =   ppExprMbEmpty @lExpr.self (>|< " ")
                                                    (exprNeedPar ParCtxtOpL @lExpr.self @lExpr.pp)
                                                >|< @nmExpr.pp
                                                >|< ppExprMbEmpty @rExpr.self (" " >|<)
                                                        (exprNeedPar ParCtxtOpR @rExpr.self @rExpr.pp)
  | LF              lhs     .   pp          =   @lExpr.pp
                                                >-< @rExpr.pp
  | Sel             lhs     .   pp          =   exprNeedPar ParCtxtOther @expr.self @expr.pp >|< "." >|< @selMbExpr.pp
  | Var Uniq        lhs     .   pp          =   pp @nm
  | Int             lhs     .   pp          =   pp @int
  | StrText StrAsIs lhs     .   pp          =   pp @str
  | Paren           lhs     .   pp          =   {-pp_parens-} @expr.pp
  | AppTop          lhs     .   pp          =   @expr.pp
  | Named           lhs     .   pp          =   @expr.pp
  | Cnstr           lhs     .   pp          =   pp_braces (@expr.pp >|< "|" >|< @cnstr.pp)
{-
SEM Expr
  | Sel             lhs     .   pp          =   pp_brackets ("SEL" >#< exprNeedPar ParCtxtOther @expr.self @expr.pp) >|< "." >|< @selMbExpr.pp
  | Var Uniq        lhs     .   pp          =   pp_brackets ("VAR" >#< pp @nm)
  | AVar            lhs     .   pp          =   pp_brackets ("AVR" >#< @anm.pp)
  | Paren           lhs     .   pp          =   pp_brackets ("PAR" >#< @expr.pp)
  | AppTop          lhs     .   pp          =   pp_brackets ("TOP" >#< @expr.pp)
-}

SEM ECnstr
  | Ty              lhs     .   pp          =   ppCommas @nms
  | Var             lhs     .   pp          =   pp @nm

SEM AttrIntro
  | Intro           lhs     .   pp          =   pp @props >#< pp @nm >#< ":" >#< pp @ty

SEM AttrEqn
  | Eqn             lhs     .   pp          =   "|" >#< pp @nm >#< "=" >#< @expr.pp

SEM ANm
  | Wild            loc     .   nm          =   nmWild
                    lhs     .   pp          =   ppDest "W" @lhs.isDest @lhs.mbDstWd @lhs.mbPrevNdStr ""     ""     @nm
  | Loc             lhs     .   pp          =   ppDest "L" @lhs.isDest @lhs.mbDstWd @lhs.mbPrevNdStr @ndStr ""     @nm
  | Lhs             lhs     .   pp          =   ppDest "P" @lhs.isDest @lhs.mbDstWd @lhs.mbPrevNdStr @ndStr @ndStr @nm
  | Fld             lhs     .   pp          =   ppDest "F" @lhs.isDest @lhs.mbDstWd @lhs.mbPrevNdStr "??"   @ndStr @nm
  | Node            lhs     .   pp          =   ppDest "N" @lhs.isDest @lhs.mbDstWd @lhs.mbPrevNdStr @ndStr @ndStr @nm

-------------------------------------------------------------------------
-- ARule's PP
-------------------------------------------------------------------------

SEM ARule
  | Rule            lhs     .   pp          =   "SEM" >#< pp (head @ndNmL) -- >#< "--" >#< ppCommas @info
                                                >-< indent atLhs2texDist ("|" >#< @rlNm >|< indent atLhs2texDist @eqns.pp)

SEM AEqn
  | Eqn             lhs     .   pp          =   let (w1,w2) = fromJust @lhs.mbDstWd
                                                    w = w1 + w2 + atDstFillLen
                                                    cmb l r = if @dest.isComposite
                                                              then if @dest.dstWd > w - atLhs2texDist
                                                                   then l >-< strWhite w >|< r
                                                                   else l >|< strWhite (w - @dest.dstWd) >|< r
                                                              else l >|< r
                                                in  cmb @dest.pp ("=" >|< strWhite atLhs2texDist >|< @val.pp)
  | Err             lhs     .   pp          =   "ERR" >#< @expr.pp

SEM AEqnDest
  | Many            lhs     .   pp          =   ppListSep "(" ")" "," @dests.ppL

SEM AEqnDests [ | | ppL: {[PP_Doc]} ]
  | Cons            lhs     .   ppL         =   @hd.pp : @tl.ppL
  | Nil             lhs     .   ppL         =   []

-------------------------------------------------------------------------
-- ARule max column width info, for tabular like PP
-------------------------------------------------------------------------

ATTR AllARuleButARule [ mbDstWd: {Maybe (Int,Int)} | | mxDstNdWd, mxDstAtWd USE {`max`} {0}: Int ]

SEM ANm
  | Loc Lhs         lhs     .   mxDstNdWd   =   3
  | Wild            lhs     .   mxDstNdWd   =   0
  | Node            lhs     .   mxDstNdWd   =   length @ndStr
  | *               lhs     .   mxDstAtWd   =   length . show $ @nm

SEM ARule
  | Rule            loc     .   mbDstWd     =   Just (@eqns.mxDstNdWd,@eqns.mxDstAtWd)

SEM Expr
  | AVar            loc     .   mbDstWd     =   Nothing

SEM AEqnDest
  | Many            dests   .   mbDstWd     =   Nothing

-------------------------------------------------------------------------
-- ARule dest width info, for lining up multidestination AEqn
-------------------------------------------------------------------------

ATTR AEqnDest [ | | dstWd: Int ]
ATTR AEqnDests [ | | dstWdL: {[Int]} ]

SEM AEqnDest
  | Many            lhs     .   dstWd       =   sum @dests.dstWdL + length @dests.dstWdL + 1
  | One             lhs     .   dstWd       =   @anm.mxDstNdWd + @anm.mxDstAtWd + (if @anm.mxDstNdWd > 0 then 1 else 0)

SEM AEqnDests
  | Cons            lhs     .   dstWdL      =   @hd.dstWd : @tl.dstWdL
  | Nil             lhs     .   dstWdL      =   []

-------------------------------------------------------------------------
-- Kind of lhs of eqn, composite?
-------------------------------------------------------------------------

ATTR AEqnDest [ | | isComposite: Bool ]

SEM AEqnDest
  | Many            lhs     .   isComposite =   True
  | One             lhs     .   isComposite =   False

-------------------------------------------------------------------------
-- Node name of AEqnDest in an AEqn, for emitting only first of a series of same node names
-------------------------------------------------------------------------

ATTR ANm AEqnDest AEqn [ | | ndStr: String ]
ATTR ANm AEqnDest AEqn AEqns [ mbPrevNdStr: {Maybe String} | | ]

SEM ANm
  | Loc             loc     .   ndStr       =   strLoc
  | Lhs             loc     .   ndStr       =   if AtRetain `elem` @props then strLoc else strLhs
  | Node            loc     .   ndStr       =   show @ndNm
  | Fld Wild        loc     .   ndStr       =   ""

SEM AEqnDest
  | Many            lhs     .   ndStr       =   "??"

SEM AEqn
  | Err             lhs     .   ndStr       =   "??"

SEM AEqns
  | Cons            tl      .   mbPrevNdStr =   fmap (const @hd.ndStr) @lhs.mbDstWd

SEM ARule
  | Rule            loc     .   mbPrevNdStr =   Nothing

SEM AEqnDests
  | Cons            loc     .   mbPrevNdStr =   Nothing

SEM AEqnDest
  | Many            loc     .   mbPrevNdStr =   Nothing

SEM Expr
  | AVar            loc     .   mbPrevNdStr =   Nothing

-------------------------------------------------------------------------
-- Context of ANm
-------------------------------------------------------------------------

{
atLhs2texDist   = 2
atLhs2texFill   = strWhite atLhs2texDist
atDstFill1      = atLhs2texFill ++ "." ++ atLhs2texFill
atDstFill2      = atLhs2texFill
atDstFillLen    = length atDstFill1 + length atDstFill2

ppDest :: String -> Bool -> Maybe (Int,Int) -> Maybe String -> String -> String -> Nm -> PP_Doc
ppDest k isDest mbDstWd mbPrevNdStr dstPre srcPre n
  = tr $ if isDest
         then case mbDstWd of
                Just (ndW,atW)
                  -> strPad (if maybe False (==dstPre) mbPrevNdStr then "" else dstPre) ndW
                     >|< atDstFill1 >|< strPad (show n) atW >|< atDstFill2
                _ -> mkPre dstPre n
         else "@" >|< mkPre srcPre n
  where mkPre s n = if null s then pp n else s >|< "." >|< pp n
        tr x = x -- (pp k >|< pp_braces x)
}

ATTR ANm [ isDest: Bool | | ]

SEM Expr
  | AVar            anm     .   isDest      =   False

SEM AEqnDest
  | One             anm     .   isDest      =   True

-------------------------------------------------------------------------
-- Pretty printing, LaTeX, Expr
-------------------------------------------------------------------------

ATTR AGExprItf Expr [ | | ppLaTeX USE {>-<} {empty} : PP_Doc ]

SEM Expr
  | Int             loc     .   ppLaTeX     =   pp @int
  | StrText         loc     .   ppLaTeX     =   switchLaTeXLhs (mkMBox (text @str))
  | StrAsIs         loc     .   ppLaTeX     =   pp @str
  | App             loc     .   ppLaTeX     =   @lExpr.ppLaTeX >#< @rExpr.ppLaTeX
  | Op              loc     .   ppLaTeX     =   @lExpr.ppLaTeX >#< @nmExpr.ppLaTeX >#< @rExpr.ppLaTeX
  | LF              loc     .   ppLaTeX     =   @lExpr.ppLaTeX >#< switchLaTeXLhs (mkTexCmdUse "quad" empty) >#< @rExpr.ppLaTeX
  | Paren           loc     .   ppLaTeX     =   (if @lhs.needToParen then ppParens else id) @expr.ppLaTeX
  | Cnstr           loc     .   ppLaTeX     =   @expr.ppLaTeX
  | SelTop          loc     .   ppLaTeXSel  =   ppSelLaTeX (== nmVec) @expr.ppLaTeX (reverse @expr.selL)
                    loc     .   ppLaTeX     =   if @expr.exprKind == EKEmp then empty else @ppLaTeXSel
  | Sel             lhs     .   ppLaTeX     =   @expr.ppLaTeX
  | Var             loc     .   ppLaTeX     =   ppNmLaTeX . nmLhs2TeXSafe $ @nm
  | Wrap            loc     .   ppLaTeX     =   let wr o c e = switchLaTeXLhs (mkTexCmdUse (show o) empty) >#< e >#< switchLaTeXLhs (mkTexCmdUse (show c) empty)
                                                in  case Map.lookup @wrKind wrKindGam of
                                                      Just i -> wr (wkBegCmd i) (wkEndCmd i) @expr.ppLaTeX
                                                      _      -> @expr.ppLaTeX
  | ChildOrder      loc     .   ppLaTeX     =   @expr.ppLaTeX
  | Empty           loc     .   ppLaTeX     =   empty

-------------------------------------------------------------------------
-- Maybe Pretty printing, LaTeX
-------------------------------------------------------------------------

ATTR MbExpr [ | | mbPPLaTeX: {Maybe (Nm,PP_Doc)} ]

SEM MbExpr
  | Nothing         lhs     .   mbPPLaTeX   =   Nothing
  | Just            lhs     .   mbPPLaTeX   =   Just (@just.txt,@just.ppLaTeX)

-------------------------------------------------------------------------
-- Just the text of a name
-------------------------------------------------------------------------

ATTR Expr [ | | txt USE {`const`} {nmNone}: Nm ]

SEM Expr
  | Var             lhs     .   txt         =   @nm
  | StrText StrAsIs lhs     .   txt         =   Nm @str
  | App SelTop Op   lhs     .   txt         =   nmNone

-------------------------------------------------------------------------
-- Selections info
-------------------------------------------------------------------------

ATTR Expr [ | | selL: {[Maybe (Nm,PP_Doc)]}]

SEM Expr
  | Sel             lhs     .   selL        =   @selMbExpr.mbPPLaTeX : @expr.selL
  | * - Sel         lhs     .   selL        =   []

-------------------------------------------------------------------------
-- Empty expr?
-------------------------------------------------------------------------

{
data ExprKind = EKEmp | EKNm | EKOther deriving Eq
}

ATTR Expr [ | | exprKind: ExprKind ]

SEM Expr
  | Empty           lhs     .   exprKind    =   EKEmp
  | Var             lhs     .   exprKind    =   EKNm
  | Sel             lhs     .   exprKind    =   @expr.exprKind
  | * - Var Empty Sel AppTop Paren
                    lhs     .   exprKind    =   EKOther

-------------------------------------------------------------------------
-- Need parenthesis
-------------------------------------------------------------------------

ATTR MbExpr Expr [ needToParen: Bool | | ]

SEM Expr
  | Sel             selMbExpr   .   needToParen =   False
                    expr        .   needToParen =   case @selMbExpr.mbPPLaTeX of
                                                        Just (n,_) | n == nmVec
                                                          -> False
                                                        _ | @expr.exprKind == EKNm
                                                                      -> False
                                                          | otherwise -> @lhs.needToParen
  | Paren App Op SelTop
                    loc         .   needToParen =   True

SEM AGExprItf
  | AGItf           loc         .   needToParen =   True
  
SEM Decl
  | Fmt ShpJudge    loc         .   needToParen =   True
  
SEM RExprEqn
  | Expr            loc         .   needToParen =   True

SEM AttrEqn
  | Eqn             loc         .   needToParen =   True
  
SEM AExpr
  | Expr            loc         .   needToParen =   True
  
SEM AEqn
  | Err             loc         .   needToParen =   True
  
