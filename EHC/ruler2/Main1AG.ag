-------------------------------------------------------------------------
-- Main for AG, pass 1
-------------------------------------------------------------------------

{
module Main1AG
  where

import Data.Maybe
import Data.Char
import Data.List
import qualified Data.Set as Set
import qualified Data.Map as Map
import UU.Pretty
import FPath
import Utils
import Err
import Common
import Opts
import PPUtils
import LaTeXFmtUtils
import ExprUtils
import ARuleUtils
import ViewSelUtils
import KeywParser
import FmGam
import RwExprGam
import ECnstrGam
import RulerAbsSyn1
import qualified RulerAbsSyn2 as AS2
import qualified Main2AG as M2 -- for now
import RulerUtils
import RulerAdmin
import RulerMkAdmin
}

-------------------------------------------------------------------------
-- Inclusion of split off parts
-------------------------------------------------------------------------

INCLUDE "RulerAbsSyn1AG.ag"
INCLUDE "RulerAbsSynCommonAG.ag"
INCLUDE "RulerAS1Misc.ag"
INCLUDE "RulerAS1ViewDpd.ag"
INCLUDE "RulerAS1Pretty.ag"
INCLUDE "RulerAS1Gen.ag"
INCLUDE "RulerAS1RlSel.ag"

INCLUDE "RulerAS1GenAS2.ag"

INCLUDE "ExprAbsSynAG.ag"
INCLUDE "ExprIsRwAG.ag"
INCLUDE "ExprNmSAG.ag"
INCLUDE "ExprFmGamAG.ag"
INCLUDE "ExprPrettyPrintAG.ag"
INCLUDE "ExprSelfAG.ag"

-------------------------------------------------------------------------
-- Interfacing to AST
-------------------------------------------------------------------------

WRAPPER AGItf 

-------------------------------------------------------------------------
-- Error
-------------------------------------------------------------------------

ATTR AllDecl AllAttrEqn AllRExpr AGItf [ | | errL USE {++} {[]}: {[Err]} ]

SEM AGItf
  | AGItf           lhs     .   errL        =   @errDupSc ++ @errDupRs ++ @decls.errL

SEM RExpr
  | Judge           lhs     .   errL        =   @errSc
                                                ++ (if null @errSc
                                                    then @errVwSc
                                                         ++ (if null @errVwSc
                                                             then @errJd
                                                                  ++ (if null @errJd
                                                                      then @eqns.errL
                                                                      else []
                                                                     )
                                                             else []
                                                            )
                                                    else []
                                                   )

SEM RExprEqn
  | Expr            lhs     .   errL        =   @errJd
                                                ++ (if null @errJd
                                                    then @errMt
                                                    else []
                                                   )

SEM Decl
  | ShpJudge        lhs     .   errL        =   @errVwSc
                                                ++ (if null @errVwSc
                                                    then @errUndefs
                                                    else []
                                                   )
  | Rules           lhs     .   errL        =   @errUndefs ++ @decls.errL
  | Scheme          lhs     .   errL        =   @errDupVw ++ @errGathSc ++ @decls.errL
  | Rule            lhs     .   errL        =   @errDupVw ++ @decls.errL

-------------------------------------------------------------------------
-- Attr
-------------------------------------------------------------------------

ATTR AllAttrIntro AllDecl [ | | atGam USE {`gamUnion`} {emptyGam}: AtGam ]
ATTR AllAttrIntro [ atDirs: {[AtDir]} | | ]

SEM AttrIntro
  | Intro           loc     .   atGam       =   gamSingleton @nm (AtInfo @nm @lhs.atDirs @props @ty)

SEM Decl
  | Attr            inhs    .   atDirs      =   [AtInh]
                    inhsyns .   atDirs      =   [AtInh,AtSyn]
                    syns    .   atDirs      =   [AtSyn]

-------------------------------------------------------------------------
-- Externally declared identifiers
-------------------------------------------------------------------------

ATTR AllDecl [ extNmS: {Set.Set Nm} | | gathExtNmS USE {`Set.union`} {Set.empty}: {Set.Set Nm} ]

SEM AGItf
  | AGItf           loc     .   extNmS      =   @decls.gathExtNmS

SEM Decl
  | Extern          lhs     .   gathExtNmS  =   Set.fromList @nms

-------------------------------------------------------------------------
-- View (related to scheme)
-------------------------------------------------------------------------

ATTR AllDecl [ | | vwScGam USE {`gamUnion`} {emptyGam}: {VwScGam Expr} ]
ATTR AllDecl [ | | vwJdGam USE {`gamUnion`} {emptyGam}: {JdGam Expr} ]

SEM Decl
  | ScmView         lhs     .   vwScGam     =   gamSingleton @nm (VwScInfo @nm @decls.vwJdGam @decls.atGam emptyGam @decls.explGam)
  | ShpJudge        lhs     .   vwJdGam     =   gamSingleton @fmKind (JdInfo @expr.self)
                    loc     .   cxStr       =   "judgement for view '" ++ show @lhs.viewNm ++ "' for scheme '" ++ show @lhs.scmNm ++ "'"
                            .   (vwScInfo,errVwSc)
                                            =   case scVwGamLookup @lhs.scmNm @lhs.viewNm @lhs.scGam of
                                                    Just (_,i) -> (i,[])
                                                    Nothing    -> (emptyVwScInfo,[Err_UndefNm @pos @cxStr "view" [@lhs.viewNm]])
                            .   errUndefs   =   let nms = gamKeys (vwscFullAtGam @vwScInfo) \\ Set.toList @expr.nmS
                                                in  [] -- if null nms then [] else [Err_UndefNm @pos @cxStr "hole" nms]
  | ShpDel          lhs     .   vwJdGam     =   gamFromAssocs [ (k,JdDel) | k <- @fmKinds ]

-------------------------------------------------------------------------
-- Scheme, derived ones are expresses in terms of non-derived ones
-------------------------------------------------------------------------

{
type MkDerivScInfo = (ScInfo Expr -> ScInfo Expr,ScGam Expr -> RsInfo Expr)
type DrvGam = Gam Nm [MkDerivScInfo]

drvGamUnion :: DrvGam -> DrvGam -> DrvGam
drvGamUnion = gamUnionWith (++)
}

ATTR AllDecl [ drvGam: DrvGam | | gathDrvGam USE {`drvGamUnion`} {emptyGam}: DrvGam ]

SEM Decl
  | SchemeDeriv     lhs     .   gathDrvGam  =   let mkListSc si
                                                      = siNw
                                                      where siNw = ScInfo @pos @nm @mbAGNm @scKind vGm
                                                            vGm
                                                              = gamMapWithKey
                                                                  (\nVw vi
                                                                    -> let mbNdNm = atGamNode (vwscAtGam vi)
                                                                           (aGm,ndRenmG)
                                                                             = case mbNdNm of
                                                                                 Just n -> (n `Map.delete` vwscAtGam vi,fmGamFromList [(n,Expr_Var @nm)])
                                                                                 _      -> (vwscAtGam vi,emptyGam)
                                                                           aNdGamNw
                                                                             = if @firstVwNm == nVw
                                                                               then gamSingleton @nm (AtInfo @nm [AtInh] [AtNode] (nmCapitalize @nm))
                                                                               else emptyGam
                                                                           jdG = gamMap (\i -> i {jdExpr = exprSubst @lhs.opts ndRenmG (jdExpr i)}) (vwscJdGam vi)
                                                                       in  vi {vwscAtGam = aNdGamNw `gamUnion` aGm, vwscJdGam = jdG}
                                                                  )
                                                                  (scVwGam si)
                                                            mkNm n = n `nmStrApd` Nm "s"
                                                    vwSels = vgVertices @lhs.vwDpdGr
                                                    mkg mkn l = gamFromAssocs [ (mkn i,i) | i <- l ]
                                                    mkRsInfo nl scGam
                                                      = RsInfo (@nm `nmApd` Nm "base") @nm vwSels ("Rules for " ++ show @nm) (mkg rlNm [rl1])
                                                      where rl1
                                                              = RlInfo (@nm `nmApd` Nm "cons") emptySPos Nothing (Just "Cons") 0 vwSels (mkg vwrlNm [vw])
                                                              where nHd = Nm "hd"
                                                                    ndHd = @nm `nmApd` nHd
                                                                    nTl = Nm "tl"
                                                                    ndTl = @nm `nmApd` nTl
                                                                    vw = VwRlInfo @firstVwNm (mkg reNm [j1,j2]) (mkg reNm [j3]) emptyGam emptyGam [] Nothing
                                                                    j3 = REInfoJudge @nm @nm Set.empty Set.empty (mkg jaNm [a3])
                                                                    a3 = JAInfo @nm e3 (exprNmS e3)
                                                                    e3 = mkExprApp (Expr_ChildOrder 0 (Expr_Var ndHd))
                                                                                   [Expr_ChildOrder 1 (Expr_Var ndTl)]
                                                                    n2 = maybe nl id $ scVwGamNodeAt nl @firstVwNm scGam
                                                                    j2 = REInfoJudge nHd nl Set.empty Set.empty (mkg jaNm [a2])
                                                                    a2 = JAInfo n2 e2 (exprNmS e2)
                                                                    e2 = Expr_Var ndHd
                                                                    j1 = REInfoJudge nTl @nm Set.empty Set.empty (mkg jaNm [a1])
                                                                    a1 = JAInfo @nm e1(exprNmS e1)
                                                                    e1 = Expr_Var ndTl
                                                in  case @scDeriv of
                                                      ScList nl -> (gamSingleton nl [(mkListSc,mkRsInfo nl)])

SEM AGItf
  | AGItf           loc     .   drvGam      =   @decls.gathDrvGam

-------------------------------------------------------------------------
-- Scheme
-------------------------------------------------------------------------

ATTR AllDecl [ | | gathScGam USE {`gamUnion`} {emptyGam}: {ScGam Expr} ]
ATTR AllDecl AllRExpr [ scGam: {ScGam Expr} | | ]
ATTR AGItf [ | | scGam: {ScGam Expr} ]

SEM AGItf
  | AGItf           loc     .   scGam       =   @decls.gathScGam

SEM Decl
  | Scheme          (lhs.gathScGam,loc.errGathSc)
                                            =   let scInfo = ScInfo @pos @nm @mbAGNm @scKind @decls.vwScGam
                                                    drvScInfoL = maybe [] (\l -> map (($ scInfo) . fst) l) $ gamLookup @nm @lhs.drvGam
                                                    (ascL,errLL) = unzip [ ((scNm i',i'),e) | i <- (scInfo : drvScInfoL), let (i',e) = bldScInfo @lhs.vwDpdGr i ]
                                                in  (gamFromAssocs ascL,concat errLL)

-------------------------------------------------------------------------
-- Rule
-------------------------------------------------------------------------

ATTR AllAttrEqn [ | | jaGam USE {`gamUnion`} {emptyGam}: {JAGam Expr} ]

SEM AttrEqn
  | Eqn             lhs     .   jaGam       =   gamSingleton @nm (JAInfo @nm @expr.self @expr.nmS)
  | Del             lhs     .   jaGam       =   gamSingleton @nm (JAInfoDel @nm)

ATTR RExprEqn [ vwScInfo: {VwScInfo Expr}  pos: SPos  cxStr: String  schemeNm: Nm | | ]

SEM RExprEqn
  | Expr            loc     .   (jdExpr,errJd)
                                            =   gamTryLookups (Expr_Empty,[Err_NoJdSc @lhs.pos @lhs.cxStr [@lhs.schemeNm]])
                                                              (\i -> (jdExpr i,[]))
                                                              [FmSpec,FmTeX,FmAll] (vwscJdGam @lhs.vwScInfo)
                            .   mt          =   exprMatch (@lhs.opts {optMatchROpOpnd = False}) emptyGam @expr.self @jdExpr
                            .   errMt       =   if mtMatches @mt then [] else [Err_Match @lhs.pos @lhs.cxStr (pp @expr.self) (pp @jdExpr)]
                    lhs     .   jaGam       =   fmGamToJaGam FmAll (mtFmGam @mt) `gamIntersection` vwscFullAtGam @lhs.vwScInfo

ATTR AllRExpr [ | | reGam USE {`gamUnion`} {emptyGam}: {REGam Expr} ]

SEM RExpr
  | Judge           eqns    .   pos         =   @pos
                            .   schemeNm    =   @schemeNm
                    loc     .   nm          =   maybe (Nm ("_" ++ show @lUniq)) id @mbRNm
                            .   cxStr       =   "judgement for view '" ++ show @lhs.viewNm ++ "' for rule '" ++ show @lhs.ruleNm ++ "'"
                            .   cxStr2      =   @cxStr ++ " for scheme '" ++ show @schemeNm ++ "'"
                            .   (scInfo,errSc)
                                            =   case gamLookup @schemeNm @lhs.scGam of
                                                    Just i -> (i,[])
                                                    Nothing -> (emptyScInfo,[Err_UndefNm @pos @cxStr "scheme" [@schemeNm]])
                            .   (vwScInfo,errVwSc)
                                            =   case gamLookup @lhs.viewNm (scVwGam @scInfo) of
                                                    Just i -> (i,[])
                                                    Nothing -> (emptyVwScInfo,[Err_UndefNm @pos @cxStr "view" [@lhs.viewNm]])
                            .   reInfo      =   REInfoJudge @nm @schemeNm Set.empty Set.empty @eqns.jaGam
                            .   errJd       =   case gamKeys (@eqns.jaGam `gamDifference` vwscFullAtGam @vwScInfo) of
                                                  [] -> []
                                                  ks -> [Err_NoXXFor @pos @cxStr2 "scheme hole definition" ks]
                    lhs     .   reGam       =   gamSingleton @nm @reInfo
  | Del             lhs     .   reGam       =   gamSingleton (head @nms) (REInfoDel @nms)

-------------------------------------------------------------------------
-- Rules, names
-------------------------------------------------------------------------

ATTR AllRExpr AllDecl [ viewNm: Nm | | ]
ATTR AllRExpr AllDecl [ ruleNm: Nm | | ]
ATTR AllDecl [ scmNm: Nm | | ]

SEM Decl
  | Rule            loc     .   ruleNm      =   @nm

SEM Decl
  | Scheme          loc     .   scmNm       =   @nm

SEM Decl
  | RulView ScmView loc     .   viewNm      =   @nm

SEM AGItf
  | AGItf           decls   .   ruleNm      =   nmNone
                            .   scmNm       =   nmNone
                            .   viewNm      =   nmNone

-------------------------------------------------------------------------
-- Rules, views for rule
-------------------------------------------------------------------------

ATTR AllDecl [ | | vwRlGam USE {`gamUnion`} {emptyGam}: {VwRlGam Expr} ]

SEM Decl
  | RulView         lhs     .   vwRlGam     =   gamSingleton @nm (VwRlInfo @nm @pre.reGam @post.reGam emptyGam emptyGam [] Nothing)

-------------------------------------------------------------------------
-- Rules, individual rules for rule set
-------------------------------------------------------------------------

ATTR AllDecl [ | | rlGam USE {`gamUnion`} {emptyGam}: {RlGam Expr} ]

SEM Decl
  | Rule            lhs     .   rlGam       =   gamSingleton @nm (RlInfo @nm @pos @mbBasedOnNm @mbAGNm @lhs.rlSeqNr (viewSelNmS @lhs.vwDpdGr @viewSel) @decls.vwRlGam)

-------------------------------------------------------------------------
-- Rules, all rule sets
-------------------------------------------------------------------------

ATTR AllDecl [ rsGam: {RsGam Expr} | | gathRsGam USE {`gamUnion`} {emptyGam}: {RsGam Expr} ]

SEM Decl
  | Rules           (lhs.gathRsGam,loc.errUndefs)
                                            =   let rsInfo = RsInfo @nm @schemeNm (viewSelNmS @lhs.vwDpdGr @viewSel) @info @decls.rlGam
                                                    drvRsInfoL = maybe [] (\l -> map (($ @lhs.scGam) . snd) l) $ gamLookup @schemeNm @lhs.drvGam
                                                    (blds,errs)
                                                      = unzip [ ((rsNm i',i'),e) | i <- (rsInfo : drvRsInfoL)
                                                              , let (i',e) = bldRsInfo @lhs.vwDpdGr @lhs.extNmS @lhs.opts @lhs.scGam i
                                                              ]
                                                in  (gamFromAssocs blds,concat errs)
  | RulesGroup      lhs     .   gathRsGam   =   gamSingleton @nm (RsInfoGroup @nm @schemeNm (viewSelNmS @lhs.vwDpdGr @viewSel) @info @rlNms)

SEM AGItf
  | AGItf           loc     .   rsGam       =   @decls.gathRsGam

-------------------------------------------------------------------------
-- Formats, rewrites
-------------------------------------------------------------------------

ATTR AllDecl [ | | gathFmGam USE {`fmGamUnion`} {emptyGam}: {FmGam Expr} ]
ATTR AllDecl [ fmGam: {FmGam Expr} | | ]
ATTR AGItf [ | | fmGam: {FmGam Expr} ]

ATTR AllDecl [ | | gathRwGam USE {`rwGamUnion`} {emptyGam}: RwExprGam ]
ATTR AllDecl [ rwGam: RwExprGam | | ]
ATTR AGItf [ | | rwGam: RwExprGam ]

SEM AGItf
  | AGItf           loc     .   fmGam       =   @decls.gathFmGam
                            .   rwGam       =   @decls.gathRwGam

SEM Decl
  | Fmt             lhs     .   (gathFmGam,gathRwGam)
                                            =   case @matchExpr.exprIsRw of
                                                  ExprIsRw  n  -> (emptyGam,rwSingleton n @fmKind @atIO (@matchExpr.self,@expr.self))
                                                  ExprIsVar n  -> (fmSingleton n @fmKind @expr.self,emptyGam)
                                                  ExprIsOther  -> (emptyGam,emptyGam)

SEM RExprEqn
  | Expr            loc     .   fmGam       =   emptyGam
                            .   rwGam       =   emptyGam
                            .   ecGam       =   emptyGam

SEM AttrEqn
  | Eqn             loc     .   fmGam       =   emptyGam
                            .   rwGam       =   emptyGam
                            .   ecGam       =   emptyGam

SEM Decl
  | Fmt ShpJudge Explain
                    loc     .   fmGam       =   emptyGam
                            .   rwGam       =   emptyGam
                            .   ecGam       =   emptyGam

-------------------------------------------------------------------------
-- Explanations
-------------------------------------------------------------------------

ATTR AllDecl [ | | explGam USE {`gamUnion`} {emptyGam}: {ExplGam Expr} ]

SEM Decl
  | Explain         lhs     .   explGam     =   gamSingleton (maybe nmNone id @mbNm) (ExplInfo @expr.self)

-------------------------------------------------------------------------
-- Preambles
-------------------------------------------------------------------------

ATTR AllDecl [ | | paGam USE {`gamUnion`} {emptyGam}: {FmKdGam String} ]

SEM Decl
  | Preamble        lhs     .   paGam       =   gamSingleton @fmKind @preamble

-------------------------------------------------------------------------
-- Error checks for duplicate names
-------------------------------------------------------------------------

SEM AGItf
  | AGItf           loc     .   errDupRs    =   gamCheckDups emptySPos "toplevel" "ruleset/rulegroup" @decls.gathRsGam
                            .   errDupSc    =   gamCheckDups emptySPos "toplevel" "scheme" @decls.gathScGam

SEM Decl
  | Rule            loc     .   errDupVw    =   gamCheckDups @pos "rule" "view" @decls.vwRlGam
  | Scheme          loc     .   errDupVw    =   gamCheckDups @pos "scheme" "view" @decls.vwScGam

-------------------------------------------------------------------------
-- Wrapping context (stack)
-------------------------------------------------------------------------

{-
ATTR AllExpr [ wrKindStk: {[WrKind]} | | ]

SEM Expr
  | Wrap            expr    .   wrKindStk   =   @wrKind : @lhs.wrKindStk

SEM AGExprItf
  | AGItf           expr    .   wrKindStk   =   [WrNone]

SEM Decl
  | Fmt             loc     .   wrKindStk   =   [WrNone]

SEM RExprEqn
  | Expr            loc     .   wrKindStk   =   [WrNone]

SEM AttrEqn
  | Eqn             loc     .   wrKindStk   =   [WrNone]

SEM AExpr
  | Expr            loc     .   wrKindStk   =   [WrNone]

SEM AEqn
  | Err             loc     .   wrKindStk   =   [WrNone]

SEM Decl
  | Fmt ShpJudge Explain
                    expr    .   wrKindStk   =   [WrNone]
-}
