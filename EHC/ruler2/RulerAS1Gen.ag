-------------------------------------------------------------------------
-- Use of attrs
-------------------------------------------------------------------------

{
type AtUsage  = (Expr,FmGam Expr)
type AtUsInfo = (Nm,FmGam Expr,[(AtDir,AtUsage)])

emptyAtUsInfo = (nmUnk,emptyGam,[])

type AtUsGam = Gam Nm AtUsInfo

rlAtUsage :: Opts -> ScGam Expr ->  FmGam Expr -> VwRlInfo Expr -> (AtUsGam,FmGam Expr,ChOrdGam,AtDefdGam,ECnstrGam)
rlAtUsage opts scGam fmGam vwRlInfo
  = (preDfG `Map.union` postDfG
    ,preExtraG `fmGamUnion` postExtraG
    ,postCoG
    ,preAdG `Map.union` postAdG
    ,preEcG `Map.union` postEcG
    )
  where (preDfG ,preExtraG ,_      ,preAdG ,preEcG ) = mk True  (vwrlFullPreGam  vwRlInfo)
        (postDfG,postExtraG,postCoG,postAdG,postEcG) = mk False (vwrlFullPostGam vwRlInfo)
        opts' = opts {optSubstFullNm=False}
        sbsn = nmSubst opts' fmGam
        sbse = exprSubst opts' fmGam
        mk isPre g
          = Map.foldWithKey
              (\jdNm reInfo (atDefG,atExtraG,coG,adG,ecG)
                -> let (Just (scInfo,vwScInfo)) = scVwGamLookup (reScNm reInfo) (vwrlNm vwRlInfo) scGam
                       isJd         = scKind scInfo == ScJudge
                       flipDir      = not isPre
                       scAtGam      = vwscFullAtGam vwScInfo
                       jaGam        = reJAGam reInfo
                       atLkup n     = maybe exprUnk jaExpr . Map.lookup n $ jaGam
                       nmWtProp f p = [ (atNm i,atTy i) | i <- Map.elems scAtGam, p (f i) ]
                       nmWtProp2 f p= map fst (nmWtProp f p)
                       
                       -- node
                       nNd          = maybeHd nmUnk fst . nmWtProp atProps $ (AtNode `elem`)
                       eNd          = atLkup nNd
                       eNdSubs      = sbse eNd
                       eNdNm        = exprAsNm eNdSubs
                       eNdNmS       = exprNmS eNd
                       eNdFmGam     = fmGamFromList' FmAG [ (n,mkAFld . sbsn $ n) | n <- Set.toList eNdNmS ]
                       eNdCoGam     = exprCoGam . exprSubst opts' eNdFmGam $ eNd
                       
                       -- in/out attr's
                       nmWtDir at   = [ nt | nt@(n,_) <- nmWtProp atDirs (at `elem`), n `notElem` [nNd] ]
                       nInL         = nmWtDir (if flipDir then AtSyn else AtInh)
                       nOuL         = nmWtDir (if flipDir then AtInh else AtSyn)
                       nBiDirL      = nmWtProp atProps (let ps = Map.elems propsSynInhMp in \psn -> not (null (psn `intersect` ps)))
                       
                       -- other props
                       nmRetainMp   = Map.map ((`intersect` [AtRetain]) . atProps) scAtGam
                       retainOf n   = maybe [] id . Map.lookup n $ nmRetainMp
                       
                       -- construction of rhs of eqn
                       mkInRhs, mkOuRhs :: Nm -> Nm -> Expr
                       mkInRhs n _  = atLkup n
                       mkOuRhs _ n' = if flipDir then mkALhs n' else mkANd eNdNm n'
                       
                       -- construction of lhs of eqn
                       mkInLhs, mkOuLhs :: (Nm -> Expr) -> (Nm -> Nm) -> Nm -> Nm -> (Expr,FmGam Expr,FmGam Expr,[Nm])
                       mkInLhs _ _ n n'
                         = (nd,fmGamFromList' FmAG [(n,nd)],fmGamFromList' FmAG [(n,atUse n')],[n'])
                         where nd = if flipDir then mkALhs' (retainOf n) n' else mkANd eNdNm n'
                               atUse = if flipDir then mkANd eNdNm else mkALhs
                       mkOuLhs atUse nmAdapt n _
                         = (r',fmr,fmr',[])
                         where r = atLkup n
                               b = [ (n,Nm . nmShowAG . nmAdapt $ sbsn n) | n <- Set.toList (exprNmS r), n /= nmWild ]
                               fmr  = fmGamFromList' FmAG [ (n,mkALoc' n') | (n,n') <- b ]
                               fmr' = fmGamFromList' FmAG [ (n,atUse n') | (n,n') <- b ]
                               r' = exprSubst opts' fmr r
                       
                       -- construction of eqn
                       mkDef dir nmAdapt mkL mkR (n,ty)
                         = if fmNull fmDef then [] else [(fmDef, (dir,(eqn,fmUse)), (n,l), atNmL, eqnEcG `Map.union` ecG)]
                         where n' = Nm . nmShowAG . sbsn . nmAdapt $ n
                               (l,fmDef,fmUse,atNmL) = mkL preUse' nmAdapt' n n'
                               r = mkR n n'
                               (nmAdapt',preUse') = (id,mkALoc')
                               c = ECnstr_Ty [ty]
                               (eqn,eqnEcG) = exprElimCnstr (mkExprEqn l r)
                               ecG = ecGamFromList [ (l,c), (r,c) ]
                       mkDefs mk nL
                         = (Map.unions fg,dirL,atL,atNmL,Map.unions ecG)
                         where (fg,dirL,atL,atNmL,ecG) = unzip5 . concat . map mk $ nL
                       
                       -- construction of the whole lot
                       (fmInBi   ,inBiL   ,_     ,atInBiLL   ,ecGInBi   ) = mkDefs (mkDef AtIn  nmInit mkInLhs mkInRhs) $ (nInL `intersect` nBiDirL)
                       (fmInNonBi,inNonBiL,_     ,atInNonBiLL,ecGInNonBi) = mkDefs (mkDef AtIn  id     mkInLhs mkInRhs) $ (nInL \\          nBiDirL)
                       (fmOuBi   ,ouBiL   ,_     ,_          ,ecGOuBi   ) = mkDefs (mkDef AtOut nmInit mkOuLhs mkOuRhs) $ (nOuL `intersect` nBiDirL)
                       (fmOuNonBi,ouNonBiL,ouAscL,_          ,ecGOuNonBi) = mkDefs (mkDef AtOut id     mkOuLhs mkOuRhs) $ (nOuL \\          nBiDirL)
                       fmOf l = fmGamUnions [ g | (_,(_,g)) <- l ]
                       fmNd = fmGamFromList' FmAG [(eNdNm,mkALoc eNdNm)]
                       mkAdGam d l = Map.fromList [ (n,d) | n <- concat l ]
                       (r,extraG)
                         = if isJd
                           then if isPre
                                then ((eNdNm
                                      ,fmInBi `fmGamUnion` fmInNonBi `fmGamUnion` fmOuBi `fmGamUnion` fmOuNonBi
                                      ,inBiL ++ inNonBiL ++ ouBiL ++ ouNonBiL
                                      )
                                     ,emptyGam
                                     )
                                else ((eNdNm
                                      ,fmInBi `fmGamUnion` fmInNonBi `fmGamUnion` fmOuBi `fmGamUnion` fmOuNonBi
                                      ,inBiL ++ inNonBiL ++ ouBiL ++ ouNonBiL
                                      )
                                     ,eNdFmGam
                                     )
                           else let fma = fmGamFromList' FmAG ouAscL
                                    fmja = fma `Map.union` jaGamToFmGam id jaGam
                                    jd = fkGamLookup exprUnk jdExpr [FmAG] . vwscJdGam $ vwScInfo
                                    jd' = exprSubst opts fmja jd
                                in  ((eNdNm,fmOuNonBi,[(AtInOut,(j,fmOf ouNonBiL)) | j <- exprLines jd'])
                                    ,emptyGam
                                    )
                   in  (Map.singleton jdNm r `Map.union` atDefG
                       ,extraG `fmGamUnion` atExtraG
                       ,eNdCoGam
                       ,mkAdGam True atInBiLL `Map.union` adG `Map.union` mkAdGam False atInNonBiLL
                       ,ecGInBi `Map.union` ecGInNonBi `Map.union` ecGOuBi `Map.union` ecGOuNonBi `Map.union` ecG
                       )
              )
              (emptyGam,emptyGam,emptyGam,emptyGam,emptyGam)
              g
}

-------------------------------------------------------------------------
-- Utils for generation
-------------------------------------------------------------------------

{
genWrapShuffle :: Opts -> Nm -> PP_Doc -> PP_Doc
genWrapShuffle opts n
  = if optFragWrap opts
    then ppWrapShuffle n
    else id
}

-------------------------------------------------------------------------
-- Abstractions for generation
-------------------------------------------------------------------------

{
data Gen
  = Gen
      { -- data
        genOpts         :: Opts
      , genScGam        :: ScGam Expr
      , genRsGam        :: RsGam Expr
      , genFmGam        :: FmGam Expr
      , genInFmGam      :: FmGam Expr
      , genRwGam        :: RwExprGam
      , genRsInfo       :: RsInfo Expr
      , genRlInfo       :: RlInfo Expr
      , genScInfo       :: ScInfo Expr
      , genVwScInfo     :: VwScInfo Expr
      , genVwRlInfo     :: VwRlInfo Expr
        -- functions
      , genRlSelIsSel   :: RlSelIsSel
      , genNmDef        :: Nm -> PP_Doc -> PP_Doc
      , genNmUse        :: Nm -> PP_Doc
      , genRl           :: Gen -> (Nm,Nm,Nm,Nm) -> PP_Doc
      , genRs           :: Gen -> (Nm,Nm) -> PP_Doc -> [Nm] -> [PP_Doc] -> PP_Doc
      , genSc           :: Gen -> Set.Set Nm -> PP_Doc
      , genJdExpr       :: Gen -> (Nm -> Maybe Bool) -> FmGam Expr -> FmGam Expr -> Expr -> PP_Doc
      , genMkJdInfo     :: Gen -> (Nm,Nm) -> REGam Expr -> (ScInfo Expr,VwScInfo Expr,REInfo Expr,FmGam Expr,Expr)
      }

genDflt
  = Gen
      { genOpts         = defaultOpts
      , genScGam        = emptyGam
      , genRsGam        = emptyGam
      , genFmGam        = emptyGam
      , genInFmGam      = emptyGam
      , genRwGam        = emptyGam
      , genRlInfo       = emptyRlInfo
      , genRsInfo       = emptyRsInfo
      , genScInfo       = emptyScInfo
      , genVwScInfo     = emptyVwScInfo
      , genVwRlInfo     = emptyVwRlInfo
      --
      , genRlSelIsSel   = \_ _ _ -> True
      , genNmDef        = \n def -> empty
      , genNmUse        = \n -> empty
      , genRl           = \gen (nFull,nVw,nVwRnm,nRl) -> empty
      , genRs           = \gen (nScMeta,nVwFull) meta defNms defVals -> empty
      , genSc           = \gen nVwS -> empty
      , genJdExpr       = \gen atIsChanged jaFmGam fmGam e -> empty
      , genMkJdInfo     = \gen (nVw,nJd) reGam ->
          let reInfo = maybe (panic "genMkJdInfo") id (Map.lookup nJd reGam)
              (scInfo,vwScInfo) = fromJust (scVwGamLookup (reScNm reInfo) nVw (genScGam gen))
              fg = jaGamToFmGam (exprSubst (genOpts gen) (genFmGam gen)) . reJAGam $ reInfo
              scVwExpr = jdGamFmExpr (optGenFM . genOpts $ gen) . vwscJdGam $ vwScInfo
          in  (scInfo,vwScInfo,reInfo,fg,scVwExpr)
      }

genTeX
  = genDflt
      { genNmDef = \n def ->
          mkCmdNmDef n def
      , genNmUse = \n ->
          mkCmdNmUse n
      , genRl = \gen (nRlFull,nVw,nVwRnm,nRl) ->
          let atIsChanged
                = case vwrlMbChGam (genVwRlInfo gen) of
                    Just g  -> \j a -> maybe (Just False) (const (Just True)) $ dblGamLookup id j a g
                    Nothing -> \_ _ -> Nothing
              mkJd nJd atIsChanged reGam
                = switchLaTeXLhs ePP
                where (scInfo,vwScInfo,reInfo,fg,scVwExpr) = genMkJdInfo gen (gen {genOpts = (genOpts gen) {optSubstFullNm=False}}) (nVw,nJd) reGam
                      gen' = gen {genScInfo=scInfo, genVwScInfo=vwScInfo}
                      ePP = genJdExpr gen' gen' atIsChanged fg (genFmGam gen') scVwExpr
              mkJds reGam order
                = map (\nJd -> mkJd nJd (atIsChanged nJd) reGam) order
              prePPL   = mkJds (vwrlFullPreGam (genVwRlInfo gen)) (concat . vwrlPreScc $ genVwRlInfo gen)
              postPPL  = mkJds (vwrlFullPostGam (genVwRlInfo gen)) (Map.keys . vwrlFullPostGam $ genVwRlInfo gen)
              r = "\\ehinfruleB" >|< ppCurly nRl >|< ppCurly nVw
                  >-< ppListSepVV "{%" "}" "\\\\" prePPL
                  >-< ppListSepVV "{%" "}" "\\\\" postPPL
          in  mkCmdNmDef nRlFull r
      , genRs = \gen (nScMeta,nVwFull) meta defNms defVals ->
          let eFigPP
                = "\\begin{RulesFigureB}" >|< ppCurly (mkCmdNmUse nScMeta) >|< ppCurly (pp (rsDescr (genRsInfo gen))) >|< ppCurly nVwFull >|< (ppCurly . vwscNm . genVwScInfo $ gen)
                  >-< vlist (intersperse (pp "\\hspace{1ex}") . map mkCmdNmUse $ defNms)
                  >-< "\\end{RulesFigureB}"
          in  vlist defVals
              >-< mkCmdNmDef nScMeta (ensureTeXMath . mkInLhs2Tex $ meta)
              >-< mkCmdNmDef nVwFull eFigPP
      , genJdExpr   = \gen atIsChanged jaFmGam fmGam e ->
          let mkChng
                = case optMbMarkChange (genOpts gen) of
                    Just _  -> \nAt -> case atIsChanged nAt of
                                         Just isCh -> Expr_Wrap (if isCh then WrIsChanged else WrIsSame)
                                         Nothing   -> id
                    Nothing -> \_   -> id
              (jaFmGam',wrFullJd)
                = if null chs    then (jaFmGam,id)
                  else if or chs then (fmGamMap mkChng jaFmGam,id)
                                 else (jaFmGam,Expr_Wrap WrIsSame)
                where chs = catMaybes . map atIsChanged . Map.keys $ jaFmGam
          in  exprFmtTeXSubst (genOpts gen) fmGam . wrFullJd . exprSubst ((genOpts gen) {optSubstOnce=True}) jaFmGam' $ e
      }

genAG
  = genDflt
      { genRl = \gen (nRlFull,nVw,nVwRnm,nRl) ->
          let (atUsGam,fmNd,choGam,adGam,ecGam)
                = rlAtUsage (genOpts gen) (genScGam gen) (genFmGam gen) (genVwRlInfo gen)
              atUseFmGam  = Map.unions [ g | (_,_,as) <- Map.elems atUsGam, (_,(_,g)) <- as ] `fmGamUnion` fmNd
              atUseFmGam2 = atUseFmGam `fmGamUnion` genFmGam gen
              ecGam' = Map.mapKeys (exprSubst (genOpts gen) atUseFmGam2) ecGam
              mkJds reGam order
                = (concat eqnL,fmGamUnions eqnGamL)
                where (eqnL,eqnGamL)
                        = unzip
                        . map (\nJd
                                -> let (scInfo,vwScInfo,reInfo,fg,scVwExpr) = genMkJdInfo gen gen (nVw,nJd) reGam
                                       atUsInfo@(_,_,atL) = maybe (panic "genRl") id (Map.lookup nJd atUsGam)
                                       gen' = gen {genScInfo=scInfo, genVwScInfo=vwScInfo}
                                       mk e
                                         = -- tr "YY" (pp e >-< ppARule (ARule_Rule [nmUnk] (nmUnk) [] aEqnL))
                                           (aEqnL,g)
                                         where (_,aEqnL,g) = exprRewrite' (genOpts gen') atUseFmGam2 (genRwGam gen') ecGam' e
                                       (eqnL,gL) = unzip . map (\(_,(eqn,_)) -> mk eqn) $ atL
                                   in  (concat eqnL,fmGamUnions gL)
                              )
                        $ order
              (preL ,preEqnG ) = mkJds (vwrlFullPreGam (genVwRlInfo gen)) (concat . vwrlPreScc $ genVwRlInfo gen)
              (postL,postEqnG) = mkJds (vwrlFullPostGam (genVwRlInfo gen)) (Map.keys . vwrlFullPostGam $ genVwRlInfo gen)
              eqnG = preEqnG `fmGamUnion` postEqnG
              rl = ARule_Rule [maybe (scNm (genScInfo gen)) Nm (scMbAGStr (genScInfo gen))]
                              (maybe nRl Nm (rlMbAGStr (genRlInfo gen)))
                              ["rule " ++ show nRl,"view " ++ show nVw]
                              (preL ++ postL)
              croNmL = coGamNmL choGam
              wrapFrag
                = genWrapShuffle (genOpts gen) (nVwRnm `nmApd` scNm (genScInfo gen) `nmApd` rlNm (genRlInfo gen))
              r = (>-< "") . wrapFrag . ppARule
                  . arlElimWild
                  . (if optAGCopyElim (genOpts gen) then arlElimCopyRule croNmL adGam emptyGam else id)
                  . arlElimAlphaRename
                  . arlUniq (genFmGam gen) croNmL
                  . arlSubst eqnG
                  $ rl
              -- r = (>-< "") . wrapFrag . ppARule . arlElimWild . arlElimCopyRule croNmL adGam . arlUniq (genFmGam gen) croNmL . arlSubst eqnG $ rl
              -- r = (>-< "") . wrapFrag . ppARule . arlUniq (genFmGam gen) croNmL . arlSubst eqnG $ rl
          in  -- trp "ZZ" (r >-< ppECGam ecGam')
              r
      , genRs = \gen (_,nVwFull) _ _ defVals ->
          "" -- "--" >#< pp (rsDescr (genRsInfo gen)) >#< nVwFull
          >-< vlist defVals
      , genSc = \gen nVwS ->
          let sv = Map.fromListWith Set.union
                     [ (rsScNm i,vs) | i <- Map.elems (genRsGam gen)
                                     , let vs = Set.filter (\v -> genRlSelIsSel gen v (rsNm i) nmAny) nVwS, not (Set.null vs)
                     ]
              wrapFrag s v
                = if optFragWrap (genOpts gen)
                  then ppWrapShuffle (v `nmApd` s `nmApd` Nm "ATTR")
                  else id
              mk s v
                = case scVwGamLookup s v (genScGam gen) of
                    Just (si,vi)
                      -> "ATTR" >#< maybe (pp (scNm si)) (pp) (scMbAGStr si) >#< pp_brackets (mka agi >#< "|" >#< mka agsi >#< "|" >#< mka ags)
                      where ag1 = Map.filter (\ai -> AtNode `notElem` atProps ai) (vwscFullAtGam vi)
                            (agsi,ag2) = Map.partition (\ai -> isJust (atMbSynInh ai)) ag1
                            (ags,agi) = Map.partition (\ai -> AtSyn `elem` atDirs ai) ag2
                            mka g = ppListSep "" "" "  " [ atNm ai >|< ":" >#< atTy ai | ai <- Map.elems (mkg g) ]
                            mkg g = Map.fromList [ (n,ai {atNm = n}) | ai <- Map.elems g, let n = nmSubst (genOpts gen) (genFmGam gen) $ maybe (atNm ai) id $ atMbSynInh ai ]
                    _ -> empty
          in  vlist [ wrapFrag s v (mk s v) | (s,vs) <- Map.toList sv, v <- Set.toList vs ] 
      }

genAS2
  = genDflt

type GenGam = Gam FmKind Gen

genGam :: GenGam
genGam = Map.fromList [ (FmTeX,genTeX), (FmAG,genAG) ]
}

-------------------------------------------------------------------------
-- Generation of lhs2tex/AG for rules
-------------------------------------------------------------------------

{
rlGen :: Gen -> (Nm,Nm->Nm) -> Gam Nm (Nm,PP_Doc)
rlGen gen (nRl',mkFullNm)
  = Map.mapWithKey
      (\nVw vwRlInfo
        ->  let nRlFull = mkFullNm nVw
                nVwRnm = rsSelMapVwNm (optMbRlSel $ genOpts gen) nVw
                gen' = gen {genVwRlInfo=vwRlInfo}
                r = genRl gen' gen' (nRlFull,nVw,nVwRnm,nRl')
            in  (nRlFull,r)
      )
    . Map.filterWithKey
      (\nVw vwRlInfo -> genRlSelIsSel gen nVw (rsNm $ genRsInfo gen) (rlNm $ genRlInfo gen))
    $ (rlVwGam (genRlInfo gen))

vwRlLtxGen :: Gen -> Gam Nm (Gam Nm (Nm,PP_Doc)) -> Gam Nm PP_Doc
vwRlLtxGen gen vwRlLtxGam
  = Map.mapWithKey
      (\nVw rMp
        ->  let rs = catMaybes [ Map.lookup n rMp | n <- rsRlOrder (genRsInfo gen) ]
                nVwFull = nmInit . fst . head $ rs
                nScMeta = nVwFull `nmApd` Nm "scheme"
                vwScInfo = fromJust $ Map.lookup nVw $ scVwGam $ genScInfo gen
                gen' = gen {genVwScInfo=vwScInfo}
                eScmPP
                  = genJdExpr gen' gen' (const Nothing) emptyGam (genFmGam gen')
                    . jdGamFmExpr (optGenFM . genOpts $ gen')
                    . vwscJdGam
                    $ vwScInfo
            in  genRs gen' gen'
                      (nScMeta,nVwFull)
                      eScmPP (map fst rs) (map snd rs)
      )
    . Map.filterWithKey
      (\nVw _ -> genRlSelIsSel gen nVw nmAny nmAny)
    $ vwRlLtxGam

rsGen :: Gen -> [Nm] -> RsGam Expr -> Gam Nm (Gam Nm PP_Doc)
rsGen gen vwOrder rsGam
  = Map.mapWithKey
      (\nRs rsInfo
        -> let gen' = gen {genRsInfo=rsInfo}
           in  case rsInfo of
                 RsInfo nRs nSc vwSel _ rlGam
                   -> vwRlLtxGen gen'' (rlLtxGamTranspose r)
                   where scInfo = fromJust (Map.lookup nSc (genScGam gen'))
                         gen'' = gen' {genScInfo=scInfo}
                         r = Map.mapWithKey
                               (\nRl rlInfo
                                 -> let nRl' = mkRlNm nRl
                                    in  rlGen (gen'' {genRlInfo=rlInfo})
                                              (nRl',\nVw -> mkFullRlNm nBs nVw nRs nRl')
                               )
                               rlGam
                 RsInfoGroup nRs nSc vwSel _ rlNms
                   -> vwRlLtxGen gen'' (Map.unions r)
                   where scInfo = fromJust (Map.lookup nSc (genScGam gen'))
                         gen'' = gen' {genScInfo=scInfo}
                         r = map
                               (\nVw
                                 -> let rs = [ let nRl' = mkRlNm nRl
                                                   nd = mkFullRlNm nBs nVw nRs  nRl'
                                                   nu = mkFullRlNm nBs nVw nRs' nRl'
                                               in  Map.singleton nRl (nd,genNmDef gen'' nd (genNmUse gen'' nu))
                                             | (nRs',nRl) <- rlNms, rlVwIsDef nRs' nRl nVw
                                             ]
                                    in  if null rs then emptyGam else Map.singleton nVw (Map.unions rs)
                               )
                               vwOrder
      )
    . Map.filterWithKey
      (\nRs _ -> genRlSelIsSel gen nmAny nRs nmAny)
    $ rsGam
  where nBs = Nm (optBaseNm (genOpts gen))
        mkRlNm
          = if optDot2Dash (genOpts gen) then nmDashed else nmFlatten
        mkFullRlNm b v rs r
          = nmApd b $ (if v == nmNone then id else nmApd v) $ nmApd rs $ r
        rlVwIsDef rs r v
          = isJust (do rsInfo <- Map.lookup rs rsGam
                       rlGam <- rsInfoMbRlGam rsInfo
                       rlVwGamLookup r v rlGam
                   )

}

ATTR AllDecl [ | | mkRsFmtGam USE {++} {[]} : {[FmKind -> Gam Nm (Gam Nm PP_Doc)]} ]
ATTR AGItf [ | | mkPP: {FmKind -> PP_Doc} ]

SEM AGItf
  | AGItf           lhs     .   mkPP        =   \fm -> fkGamLookup empty (\p -> if optPreamble @lhs.opts then pp p else empty) [fm] @decls.paGam
                                                       >-< @mkScPP fm
                                                       >-< (vlist . Map.elems . Map.map (vlist . Map.elems) . Map.unions . map ($ fm) $ @decls.mkRsFmtGam)

SEM Decl
  | Rules RulesGroup
                    loc     .   mkGen       =   \gen -> gen { genOpts = @lhs.opts
                                                            , genScGam = @lhs.scGam
                                                            , genFmGam = @lhs.fmGam
                                                            , genRwGam = @lhs.rwGam
                                                            , genRlSelIsSel = @lhs.rlSelIsSel
                                                            }
                    lhs     .   mkRsFmtGam  =   [\fm -> let gen = @mkGen (maybe genDflt id (Map.lookup fm genGam))
                                                        in  rsGen gen (vgTopSort @lhs.vwDpdGr) @lhs.rsGam
                                                ]

-------------------------------------------------------------------------
-- Generation of lhs2tex/AG for schemes
-------------------------------------------------------------------------

SEM AGItf
  | AGItf           loc     .   mkScPP      =   \fm ->
                                                    let gen1 = maybe genDflt id (Map.lookup fm genGam)
                                                        gen2 = gen1 { genOpts = @lhs.opts
                                                                    , genScGam = @scGam
                                                                    , genRsGam = @rsGam
                                                                    , genFmGam = @fmGam
                                                                    , genRlSelIsSel = @rlSelIsSel
                                                                    }
                                                    in  if optGenAGAttr @lhs.opts
                                                        then genSc gen2 gen2 (vgVertices @vwDpdGr)
                                                        else empty

-------------------------------------------------------------------------
-- Generation of lhs2tex for schemes scheme explanation
-------------------------------------------------------------------------

ATTR AGItf [ | | scExplPP: PP_Doc ]

SEM AGItf
  | AGItf           lhs     .   scExplPP    =   let sl = Map.mapWithKey
                                                            (\scNm si
                                                              -> let vl = Map.mapWithKey
                                                                            (\vwNm vi
                                                                              -> let d = maybe empty fmtex . Map.lookup nmNone . vwscExplGam $ vi
                                                                                     opts = @lhs.opts {optSubstFullNm=False, optGenFM = FmTeX}
                                                                                     fmte = exprFmtTeX @lhs.opts . exprSubst opts @fmGam
                                                                                     fmtex = fmte . explExpr
                                                                                     nm n = scNm `nmApd` vwNm `nmApd` Nm n
                                                                                     dhl = Map.mapWithKey
                                                                                             (\atNm ei -> (fmte . Expr_Expr . Expr_Var $ atNm) >#< "&" >#< fmtex ei >#< "\\\\")
                                                                                             (vwscExplGam vi `Map.intersection` vwscFullAtGam vi)
                                                                                     dh = vlist (Map.elems dhl)
                                                                                 in  genWrapShuffle @lhs.opts (nm "explain.scheme") d
                                                                                     >-< genWrapShuffle @lhs.opts (nm "explain.holes") dh
                                                                            )
                                                                            (scVwGam si)
                                                                 in  vlist . Map.elems $ vl
                                                            )
                                                            @scGam
                                                in  vlist . Map.elems $ sl
