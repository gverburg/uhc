-- $Id: Ruler.ag 231 2005-06-07 14:39:41Z atze $

-------------------------------------------------------------------------
-- Optimisation
-------------------------------------------------------------------------

-------------------------------------------------------------------------
-- Common to other optimisations
-------------------------------------------------------------------------

-- Context: is in composite dest?

ATTR AEqnDest AEqnDests [ isInComposite: Bool | | ]

SEM AEqn
  | Eqn             dest    .   isInComposite
                                            =   False

SEM AEqnDest
  | Many            dests   .   isInComposite
                                            =   True

-------------------------------------------------------------------------
-- Is lhs a single name?
-------------------------------------------------------------------------

ATTR AEqnDest [ | | mbSingleANm: {Maybe ANm} ]

SEM AEqnDest
  | One             lhs     .   mbSingleANm =   if @lhs.isInComposite then Nothing else Just @anm.replRn
  | Many            lhs     .   mbSingleANm =   Nothing

-------------------------------------------------------------------------
-- Is rhs a single name?
-------------------------------------------------------------------------

ATTR Expr AExpr [ | | mbSingleANm: {Maybe ANm} ]

SEM Expr
  | AVar            lhs     .   mbSingleANm =   Just @anm.replRn
  | * - AppTop Paren AVar
                    lhs     .   mbSingleANm =   Nothing

-------------------------------------------------------------------------
-- Part I: Elimination of alpha renaming
-------------------------------------------------------------------------

-------------------------------------------------------------------------
-- Rename map gather
-------------------------------------------------------------------------

{
data RnSrc = RnNm ANm | RnExpr Expr | RnNone

rnSrc2Expr :: RnSrc -> Expr
rnSrc2Expr (RnNm   a) = Expr_AVar a
rnSrc2Expr (RnExpr e) = e

type RnMp = Map.Map Nm (Int,RnSrc)

rnRepl :: RnMp -> RnSrc -> RnSrc
rnRepl m e
  = case e of
      RnExpr (Expr_AVar (ANm_Loc n _)) -> r n
      RnNm   (ANm_Loc n _)             -> r n
      _                                -> e
  where r n = maybe e (RnExpr . exprASubst (Map.delete n m) . rnSrc2Expr . snd) (Map.lookup n m)

rnMpUnion :: RnMp -> RnMp -> RnMp
rnMpUnion m1 m2
  = Map.unionWith (\(c1,v1) (c2,v2) -> (c1+c2,u v1 v2)) m1 m2
  where u RnNone r = r
        u r      _ = r
}

ATTR AEqns AEqn ANm AllExpr AExpr [ | | gathRnMp USE {`rnMpUnion`} {Map.empty}: RnMp ]
ATTR AllARuleButARule AllExpr AGExprItf [ rnMp: RnMp | | ]

SEM AEqn
  | Eqn             loc     .   gathRnMp    =   let m = case @dest.mbSingleANm of
                                                            Just (ANm_Loc dn p) | AtRetain `notElem` p
                                                              -> Map.singleton dn (0,v)
                                                              where v = case (@val.mbSingleANm,@val.self) of
                                                                          (Just sn,_           ) -> RnNm sn
                                                                          (_      ,AExpr_Expr e) -> RnExpr e
                                                            _ -> Map.empty
                                                in  m `rnMpUnion` @val.gathRnMp

SEM ANm
  | Loc             lhs     .   gathRnMp    =   Map.singleton @nm (1,RnNone)

SEM ARule
  | Rule            eqns    .   rnMp        =   Map.filter (\(c,v)
                                                             -> case v of 
                                                                  RnNone           -> False
                                                                  RnExpr _ | c > 1 -> False
                                                                  _                -> True
                                                           )
                                                           @eqns.gathRnMp

SEM AttrEqn
  | Eqn             loc     .   rnMp        =   Map.empty

SEM RExprEqn
  | Expr            loc     .   rnMp        =   Map.empty

SEM Decl
  | Fmt ShpJudge    loc     .   rnMp        =   Map.empty

-------------------------------------------------------------------------
-- Replica
-------------------------------------------------------------------------

ATTR AllARule AllExpr [ | | replRn: SELF ]
ATTR AGARuleItf [ | | replRn: ARule ]
ATTR AGExprItf [ | | replRn: Expr ]
ATTR AEqns AEqn [ | | replRnEqns USE {++} {[]}: {[AEqn]} ]

SEM Expr
  | AVar            lhs     .   replRn      =   rnSrc2Expr (rnRepl @lhs.rnMp (RnExpr @replRn))

SEM AEqn
  | Eqn             lhs     .   replRnEqns  =   case @dest.mbSingleANm of
                                                    Just (ANm_Loc n _)
                                                      -> case Map.lookup n @lhs.rnMp of
                                                           Just _ -> []
                                                           _      -> [@replRn]
                                                    _ -> [@replRn]
  | * - Eqn         lhs     .   replRnEqns  =   [@replRn]

SEM ARule
  | Rule            lhs     .   replRn      =   ARule_Rule @ndNmL @rlNm @info @eqns.replRnEqns

