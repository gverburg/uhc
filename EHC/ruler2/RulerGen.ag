-- $Id: Ruler.ag 231 2005-06-07 14:39:41Z atze $

-------------------------------------------------------------------------
-- Use of attrs
-------------------------------------------------------------------------

{
type AtUsage  = (Expr,FmGam Expr)
type AtUsInfo = (Nm,FmGam Expr,[(AtDir,AtUsage)])

emptyAtUsInfo = (nmUnk,emptyGam,[])

type AtUsGam = Gam Nm AtUsInfo

rlAtUsage :: Opts -> ScGam Expr ->  FmGam Expr -> VwRlInfo Expr -> (AtUsGam,FmGam Expr)
rlAtUsage opts scGam fmGam vwRlInfo
  = (preDfG `Map.union` postDfG,preExtraG `fmGamUnion` postExtraG)
  where (preDfG,preExtraG) = mk True (vwrlFullPreGam vwRlInfo)
        (postDfG,postExtraG) = mk False (vwrlFullPostGam vwRlInfo)
        opts' = opts {optSubstFullNm=False}
        sbsn = nmSubst opts' fmGam
        sbse = exprSubst opts' fmGam
        mk isPre g
          = Map.foldWithKey
              (\jdNm reInfo (atDefG,atExtraG)
                -> let (Just (scInfo,vwScInfo)) = scVwGamLookup (reScNm reInfo) (vwrlNm vwRlInfo) scGam
                       isJd         = scKind scInfo == ScJudge
                       flipDir      = not isPre
                       scAtGam      = vwscFullAtGam vwScInfo
                       jaGam        = reJAGam reInfo
                       atLkup n     = maybe exprUnk jaExpr . Map.lookup n $ jaGam
                       nmWtProp f p = Map.keys . Map.filter (\i -> p (f i)) $ scAtGam
                       nNd          = maybeHd nmUnk id . nmWtProp atProps $ (AtNode `elem`)
                       eNd          = atLkup nNd
                       eNdNm        = exprAsNm . sbse $ eNd
                       nmWtDir at   = nmWtProp atDirs (at `elem`) \\ [nNd]
                       nInL         = nmWtDir (if flipDir then AtSyn else AtInh)
                       nOuL         = nmWtDir (if flipDir then AtInh else AtSyn)
                       nBiDirL      = nmWtProp atProps (let ps = Map.elems propsMp in \psn -> not (null (psn `intersect` ps)))
                       mkInLhs _ _ n n'
                                    = (nd,fmGamFromList [(n,nd)],fmGamFromList [(n,atUse n')])
                                    where nd = if flipDir then mkALhs n' else mkANd eNdNm n'
                                          atUse = if flipDir then mkANd eNdNm else mkALhs
                       mkInRhs n n' = atLkup n
                       mkOuLhs atUse nmAdapt n n' = (r',fmr,fmr')
                                    where r = atLkup n
                                          b = [ (n,Nm . nmShowAG . nmAdapt $ sbsn n) | n <- Set.toList (exprNmS r), n /= nmWild ]
                                          fmr  = fmGamFromList [ (n,mkALoc n') | (n,n') <- b ]
                                          fmr' = fmGamFromList [ (n,atUse n') | (n,n') <- b ]
                                          r' = exprSubst opts' fmr r
                       mkOuRhs n n' = atUse n'
                                    where atUse = if flipDir then mkALhs else mkANd eNdNm
                       mkDef dir nmAdapt mkL mkR mkEqn n
                                    = if fmNull fmDef then [] else [(fmDef,(dir,(mkEqn l r,fmUse)),(n,l))]
                                    where n' = Nm . nmShowAG . sbsn . nmAdapt $ n
                                          (l,fmDef,fmUse) = mkL preUse' nmAdapt' n n'
                                          r = mkR n n'
                                          (nmAdapt',preUse') = if flipDir then (nmInit,mkALhs) else (id,mkALoc)
                       mkDefs mk    = unzip3 . concat . map mk
                       mkEqn l r    = Expr_AppTop (Expr_Op (nmEql) (Expr_Var (nmEql)) l r)
                       fmIOUnion g1 g2 = fmGamUnions g1 `fmGamUnion` fmGamUnions g2
                       (fmInBi   ,inBiL   ,_     ) = mkDefs (mkDef AtIn nmInit  mkInLhs mkInRhs mkEqn) $ (nInL `intersect` nBiDirL)
                       (fmInNonBi,inNonBiL,_     ) = mkDefs (mkDef AtIn id      mkInLhs mkInRhs mkEqn) $ (nInL \\          nBiDirL)
                       (fmOuBi   ,ouBiL   ,_     ) = mkDefs (mkDef AtOut nmInit mkOuLhs mkOuRhs mkEqn) $ (nOuL `intersect` nBiDirL)
                       (fmOuNonBi,ouNonBiL,ouAscL) = mkDefs (mkDef AtOut id     mkOuLhs mkOuRhs mkEqn) $ (nOuL \\          nBiDirL)
                       fmOf l = fmGamUnions [ g | (_,(_,g)) <- l ]
                       fmNd = fmGamFromList [(eNdNm,mkALoc eNdNm)]
                       (r,extraG)
                         = if isJd
                           then if isPre
                                then ((eNdNm
                                      ,(fmInBi `fmIOUnion` fmInNonBi) `fmGamUnion` (fmOuBi `fmIOUnion` fmOuNonBi)
                                      ,inBiL ++ inNonBiL ++ ouBiL ++ ouNonBiL
                                      ),emptyGam)
                                else ((eNdNm
                                      ,fmInBi `fmIOUnion` fmInNonBi
                                      ,inBiL ++ inNonBiL
                                      ),fmOf ouBiL `fmGamUnion` fmOf ouNonBiL
                                     )
                           else let fm = fmGamUnions fmOuNonBi
                                    fma = fmGamFromList ouAscL
                                    fmja = fma `Map.union` jaGamToFmGam id jaGam
                                    jd = fkGamLookup exprUnk jdExpr FmAG . vwscJdGam $ vwScInfo
                                    jd' = exprSubst opts fmja jd
                                in  ((eNdNm,fm,[(AtInOut,(jd',fmOf ouNonBiL))]),emptyGam)
                   in  (Map.singleton jdNm r `Map.union` atDefG,{-fmNd `fmGamUnion`-} extraG `fmGamUnion` atExtraG)
              )
              (emptyGam,emptyGam)
              g
}

-------------------------------------------------------------------------
-- Abstractions for generation
-------------------------------------------------------------------------

{
data Gen
  = Gen
      { -- data
        genOpts     :: Opts
      , genScGam    :: ScGam Expr
      , genFmGam    :: FmGam Expr
      , genInFmGam  :: FmGam Expr
      , genRwGam    :: RwExprGam
      , genRsInfo   :: RsInfo Expr
      , genRlInfo   :: RlInfo Expr
      , genScInfo   :: ScInfo Expr
      , genVwScInfo :: VwScInfo Expr
      , genVwRlInfo :: VwRlInfo Expr
        -- functions
      , genNmDef    :: Nm -> PP_Doc -> PP_Doc
      , genNmUse    :: Nm -> PP_Doc
      , genRl       :: Gen -> (Nm,Nm,Nm) -> PP_Doc
      , genRs       :: Gen -> (Nm,Nm) -> PP_Doc -> [Nm] -> [PP_Doc] -> PP_Doc
      , genJdExpr   :: Gen -> (Nm -> Maybe Bool) -> FmGam Expr -> FmGam Expr -> Expr -> PP_Doc
      , genMkJdInfo :: Gen -> (Nm,Nm) -> REGam Expr -> (ScInfo Expr,VwScInfo Expr,REInfo Expr,FmGam Expr,Expr)
      }

genDflt
  = Gen
      { genOpts     = defaultOpts
      , genScGam    = emptyGam
      , genFmGam    = emptyGam
      , genInFmGam  = emptyGam
      , genRwGam    = emptyGam
      , genRlInfo   = emptyRlInfo
      , genRsInfo   = emptyRsInfo
      , genScInfo   = emptyScInfo
      , genVwScInfo = emptyVwScInfo
      , genVwRlInfo = emptyVwRlInfo
      --
      , genNmDef    = \n def -> empty
      , genNmUse    = \n -> empty
      , genRl       = \gen (nFull,nVw,nRl) -> empty
      , genRs       = \gen (nScMeta,nVwFull) meta defNms defVals -> empty
      , genJdExpr   = \gen atIsChanged jaFmGam fmGam e -> empty
      , genMkJdInfo = \gen (nVw,nJd) reGam ->
          let reInfo = maybe (panic "genMkJdInfo") id (Map.lookup nJd reGam)
              (scInfo,vwScInfo) = fromJust (scVwGamLookup (reScNm reInfo) nVw (genScGam gen))
              fg = jaGamToFmGam (exprSubst (genOpts gen) (genFmGam gen)) . reJAGam $ reInfo
              scVwExpr = jdGamFmExpr (optGenFM . genOpts $ gen) . vwscJdGam $ vwScInfo
          in  (scInfo,vwScInfo,reInfo,fg,scVwExpr)
      }

genTeX
  = genDflt
      { genNmDef = \n def ->
          mkCmdNmDef n def
      , genNmUse = \n ->
          mkCmdNmUse n
      , genRl = \gen (nRlFull,nVw,nRl) ->
      	  let atIsChanged
                = case vwrlMbChGam (genVwRlInfo gen) of
                    Just g  -> \j a -> maybe (Just False) (const (Just True)) $ dblGamLookup id j a g
                    Nothing -> \_ _ -> Nothing
              mkJd nJd atIsChanged reGam
                = switchLaTeXLhs ePP
                where (scInfo,vwScInfo,reInfo,fg,scVwExpr) = genMkJdInfo gen (gen {genOpts = (genOpts gen) {optSubstFullNm=False}}) (nVw,nJd) reGam
                      gen' = gen {genScInfo=scInfo, genVwScInfo=vwScInfo}
                      ePP = genJdExpr gen' gen' atIsChanged fg (genFmGam gen') scVwExpr
              mkJds reGam order
                = map (\nJd -> mkJd nJd (atIsChanged nJd) reGam) order
              prePPL   = mkJds (vwrlFullPreGam (genVwRlInfo gen)) (concat . vwrlPreScc $ genVwRlInfo gen)
              postPPL  = mkJds (vwrlFullPostGam (genVwRlInfo gen)) (Map.keys . vwrlFullPostGam $ genVwRlInfo gen)
              r = "\\ehinfruleB" >|< ppCurly nRl >|< ppCurly nVw
                  >-< ppListSepVV "{%" "}" "\\\\" prePPL
                  >-< ppListSepVV "{%" "}" "\\\\" postPPL
      	  in  mkCmdNmDef nRlFull r
      , genRs = \gen (nScMeta,nVwFull) meta defNms defVals ->
          let eFigPP
                = "\\begin{RulesFigureB}" >|< ppCurly (mkCmdNmUse nScMeta) >|< ppCurly (pp (rsDescr (genRsInfo gen))) >|< ppCurly nVwFull
                  >-< vlist (intersperse (pp "\\hspace{1ex}") . map mkCmdNmUse $ defNms)
                  >-< "\\end{RulesFigureB}"
          in  vlist defVals
              >-< mkCmdNmDef nScMeta (ensureTeXMath . mkInLhs2Tex $ meta)
              >-< mkCmdNmDef nVwFull eFigPP
      , genJdExpr   = \gen atIsChanged jaFmGam fmGam e ->
          let mkChng
                = case optMbMarkChange (genOpts gen) of
                    Just _  -> \nAt -> case atIsChanged nAt of
                                         Just isCh -> Expr_Wrap (if isCh then WrIsChanged else WrIsSame)
                                         Nothing   -> id
                    Nothing -> \_   -> id
              (jaFmGam',wrFullJd)
                = if null chs    then (jaFmGam,id)
                  else if or chs then (fmGamMap mkChng jaFmGam,id)
                                 else (jaFmGam,Expr_Wrap WrIsSame)
                where chs = catMaybes . map atIsChanged . Map.keys $ jaFmGam
          in  exprFmtTeXSubst (genOpts gen) fmGam . wrFullJd . exprSubst (genOpts gen) jaFmGam' $ e
      }

genAG
  = genDflt
      { genRl = \gen (nRlFull,nVw,nRl) ->
      	  let (atUsGam,fmNd) = rlAtUsage (genOpts gen) (genScGam gen) (genFmGam gen) (genVwRlInfo gen)
      	      atUseFmGam
      	        = Map.unions [ g | (_,_,as) <- Map.elems atUsGam, (_,(_,g)) <- as ]
      	          `fmGamUnion` fmNd
      	      mkJds reGam order
      	        = map (\nJd
                          -> let (scInfo,vwScInfo,reInfo,fg,scVwExpr) = genMkJdInfo gen gen (nVw,nJd) reGam
                                 atUsInfo@(_,_,atL) = maybe (panic "genRl") id (Map.lookup nJd atUsGam)
                                 gen' = gen {genScInfo=scInfo, genVwScInfo=vwScInfo}
                                 atEqn (_,(eqn,_)) = eqn
                                 opts = genOpts gen'
                                 mk dir e
                                   = maybe (AEqn_Err e') id (exprMbAEqn e')
                                   where e' = exprRewrite (opts {optAtDir = dir}) atUseFmGam (genRwGam gen') e
                                 mkIO d l = map (mk d) . map atEqn . filter ((==d) . fst) $ l
                                 mkIn = mkIO AtIn
                                 mkOu = mkIO AtOut
                                 mkInOu = mkIO AtInOut
                             in  mkIn atL ++ mkOu atL ++ mkInOu atL
                      )
                      order
              preL   = mkJds (vwrlFullPreGam (genVwRlInfo gen)) (concat . vwrlPreScc $ genVwRlInfo gen)
              postL  = mkJds (vwrlFullPostGam (genVwRlInfo gen)) (Map.keys . vwrlFullPostGam $ genVwRlInfo gen)
              rl = ARule_Rule [maybe (scNm (genScInfo gen)) Nm (scMbAGStr (genScInfo gen))]
                              (maybe nRl Nm (rlMbAGStr (genRlInfo gen)))
                              ["rule " ++ show nRl,"view " ++ show nVw]
                              (concat preL ++ concat postL)
              r = ppARule rl
      	  in  r
      , genRs = \gen (_,nVwFull) _ _ defVals ->
          "--" >#< pp (rsDescr (genRsInfo gen)) >#< nVwFull
          >-< vlist defVals
      }
{-
          let cmtPP = "{-" >#< (pp (if isPre then "pre:" else "post:")
                               >-< ("def gam:" >#< ppGam atDefFmGam
                                    >-< "use gam:" >#< ppGam atUseFmGam
                                    >-< "at gam:" >#< ppGam jaFmGam
                                   )
                               )
                       >#< "-}"
-}

type GenGam = Gam FmKind Gen

genGam :: GenGam
genGam = Map.fromList [ (FmTeX,genTeX), (FmAG,genAG) ]
}

-------------------------------------------------------------------------
-- Generation of lhs2tex/AG for rules
-------------------------------------------------------------------------

{
rlGen :: Gen -> (Nm,Nm->Nm) -> Gam Nm (Nm,PP_Doc)
rlGen gen (nRl',mkFullNm)
  = Map.mapWithKey
      (\nVw vwRlInfo
        ->  let nRlFull = mkFullNm nVw
                gen' = gen {genVwRlInfo=vwRlInfo}
                r = genRl gen' gen' (nRlFull,nVw,nRl')
            in  (nRlFull,r)
      )
      (rlVwGam (genRlInfo gen))

rlLtxGamTranspose :: Ord k => Gam k (Gam k (n,v)) -> Gam k (Gam k (n,v))
rlLtxGamTranspose g
  = Map.fromListWith Map.union [ (v,Map.singleton r (n,d)) | (r,vm) <- Map.toList g, (v,(n,d)) <- Map.toList vm ]

vwRlLtxGen :: Gen -> Gam Nm (Gam Nm (Nm,PP_Doc)) -> Gam Nm PP_Doc
vwRlLtxGen gen vwRlLtxGam
  = Map.mapWithKey
      (\nVw rMp
        ->  let rs = catMaybes [ Map.lookup n rMp | n <- rsRlOrder (genRsInfo gen) ]
                nVwFull = nmInit . fst . head $ rs
                nScMeta = nVwFull `nmApd` Nm "scheme"
                vwScInfo = fromJust $ Map.lookup nVw $ scVwGam $ genScInfo gen
                gen' = gen {genVwScInfo=vwScInfo}
                eScmPP
                  = genJdExpr gen' gen' (const Nothing) emptyGam (genFmGam gen')
                    . jdGamFmExpr (optGenFM . genOpts $ gen')
                    . vwscJdGam
                    $ vwScInfo
            in  genRs gen' gen'
                      (nScMeta,nVwFull)
                      eScmPP (map fst rs) (map snd rs)
      )
      vwRlLtxGam

rsGen :: Gen -> [Nm] -> RsGam Expr -> Gam Nm (Gam Nm PP_Doc)
rsGen gen vwOrder rsGam
  = Map.mapWithKey
      (\nRs rsInfo
        -> let gen' = gen {genRsInfo=rsInfo}
           in  case rsInfo of
                 RsInfo nRs nSc _ rlGam
                   -> vwRlLtxGen gen'' (rlLtxGamTranspose r)
                   where scInfo = fromJust (Map.lookup nSc (genScGam gen'))
                         gen'' = gen' {genScInfo=scInfo}
                         r = Map.mapWithKey
                               (\nRl rlInfo
                                 -> let nRl' = nmLaTeX nRl
                                    in  rlGen (gen'' {genRlInfo=rlInfo})
                                              (nRl',\nVw -> mkRlNm nBs nVw nRs nRl')
                               )
                               rlGam
                 RsInfoGroup nRs nSc _ rlNms
                   -> vwRlLtxGen gen'' (Map.unions r)
                   where scInfo = fromJust (Map.lookup nSc (genScGam gen'))
                         gen'' = gen' {genScInfo=scInfo}
                         r = map
                               (\nVw
                                 -> let rs = [ let nRl' = nmLaTeX nRl
                                                   nd = mkRlNm nBs nVw nRs nRl'
                                                   nu = mkRlNm nBs nVw nRs' nRl'
                                               in  Map.singleton nRl (nd,genNmDef gen'' nd (genNmUse gen'' nu))
                                             | (nRs',nRl) <- rlNms, rlVwIsDef nRs' nRl nVw
                                             ]
                                    in  if null rs then emptyGam else Map.singleton nVw (Map.unions rs)
                               )
                               vwOrder
      )
      rsGam
  where nBs = Nm (optBaseNm (genOpts gen))
        mkRlNm b v rs r
          = nmApd b $ (if v == nmNone then id else nmApd v) $ nmApd rs $ r
        rlVwIsDef rs r v
          = isJust (do rsInfo <- Map.lookup rs rsGam
                       rlGam <- rsInfoMbRlGam rsInfo
                       rlVwGamLookup r v rlGam
                   )

}

ATTR AllDecl [ | | mkRsFmtGam USE {++} {[]} : {[FmKind -> Gam Nm (Gam Nm PP_Doc)]} ]
ATTR AGItf [ | | mkPP: {FmKind -> PP_Doc} ]

SEM AGItf
  | AGItf           lhs     .   mkPP        =   \fm -> fkGamLookup empty pp fm @decls.paGam
                                                       >-< (vlist . Map.elems . Map.map (vlist . Map.elems) . Map.unions . map ($ fm) $ @decls.mkRsFmtGam)

SEM Decl
  | Rules RulesGroup
                    loc     .   mkGen       =   \gen -> gen {genOpts = @lhs.opts, genScGam = @lhs.scGam, genFmGam = @lhs.fmGam, genRwGam = @lhs.rwGam}
                    lhs     .   mkRsFmtGam  =   [\fm -> let gen = @mkGen (maybe genDflt id (Map.lookup fm genGam))
                                                        in  rsGen gen (vgTopSort @lhs.vwDpdGr) @lhs.rsGam
                                                ]

