-------------------------------------------------------------------------
-- Generate ARule's from attr bindings
-------------------------------------------------------------------------

{
module TrfAS2GenARule
  ( as2ARule
  )
  where

import Data.Maybe
import Data.Char
import Data.List
import qualified Data.Set as Set
import qualified Data.Map as Map
import Utils
import Opts
import Common
import KeywParser( propsSynInhMp )
import ExprUtils
import ARuleUtils
import FmGam
import RwExprGam
import ECnstrGam
import RulerAbsSyn2
import RulerAdmin

-- for ppDbg
import UU.Pretty
import PPUtils
}

-------------------------------------------------------------------------
-- Inclusion of split off parts
-------------------------------------------------------------------------

INCLUDE "RulerAbsSyn2AG.ag"
INCLUDE "RulerAbsSynCommonAG.ag"
INCLUDE "RulerAS2Opts.ag"

INCLUDE "TrfAS2CommonAG.ag"

INCLUDE "ExprAbsSynAG.ag"
INCLUDE "ExprSelfAG.ag"

INCLUDE "ARuleAbsSynAG.ag"
INCLUDE "ARuleSelfAG.ag"

-------------------------------------------------------------------------
-- Interfacing to AST
-------------------------------------------------------------------------

WRAPPER AGItf 

{
as2ARule :: Opts -> ScGam Expr -> FmGam Expr -> RwExprGam -> Decls -> (Decls,PP_Doc,[Err])
as2ARule o scg fmg rwg r
  = (self_Syn_AGItf r2,ppDbg_Syn_AGItf r2,errL_Syn_AGItf r2)
  where r1 = sem_AGItf (AGItf_AGItf r)
        r2 = wrap_AGItf r1
                (Inh_AGItf {opts_Inh_AGItf = o, fmGam_Inh_AGItf = fmg, rwGam_Inh_AGItf = rwg, scGam_Inh_AGItf = scg})
}

-------------------------------------------------------------------------
-- Context: options, position, etc
-------------------------------------------------------------------------

ATTR AllJd AllAt [ pos: SPos | | ]

SEM RlDecl
  | Rl LTX          loc     .   pos         =   @pos

-------------------------------------------------------------------------
-- Context: substitution
-------------------------------------------------------------------------

SEM JdAt
  | At              loc     .   sbse        =   exprSubst (@lhs.opts {optSubstFullNm=False}) @lhs.fmGam
                            .   sbsn        =   nmSubst (@lhs.opts {optSubstFullNm=False}) @lhs.fmGam

SEM Jd
  | Ats             loc     .   sbse        =   exprSubst (@lhs.opts {optSubstFullNm=False}) @lhs.fmGam
                            .   sbsn        =   nmSubst (@lhs.opts {optSubstFullNm=False}) @lhs.fmGam

-------------------------------------------------------------------------
-- Context: scInfo
-------------------------------------------------------------------------

SEM RlDecl
  | Rl              loc     .   rsScInfo    =   maybe (panic "RlDecl_Rl: rsScInfo") id $ Map.lookup @lhs.rsScNm @lhs.scGam

SEM Jd
  | Ats             loc     .   (scInfo,vwScInfo)
                                            =   maybe (panic "Jd_Ats: scInfo") id
                                                $ scVwGamLookup @scNm @lhs.vwNm @lhs.scGam

-------------------------------------------------------------------------
-- Context: is a judgement (and not a relation)?
-------------------------------------------------------------------------

ATTR AllAt [ isJd: Bool | | ]

SEM Jd
  | Ats             loc     .   isJd        =   scKind @scInfo == ScJudge

-------------------------------------------------------------------------
-- Context: is in premise?
-------------------------------------------------------------------------

ATTR AllJd AllAt [ isPre: Bool | | ]

SEM RlDecl
  | Rl LTX          preJds  .   isPre       =   True
                    postJds .   isPre       =   False

-------------------------------------------------------------------------
-- Context: name info from higher up
-------------------------------------------------------------------------

ATTR AllJd [ agStr: Nm | | ]

SEM RlDecl
  | Rl              loc     .   agStr       =   maybe @rlNm Nm @mbAGStr
  | * - Rl          loc     .   agStr       =   nmNone

-------------------------------------------------------------------------
-- Context: scAtGam
-------------------------------------------------------------------------

ATTR AllAt [ scAtGam: AtGam | | ]

SEM Jd
  | Ats             ats     .   scAtGam     =   vwscFullAtGam @vwScInfo

SEM JdAt
  | At              loc     .   atInfo      =   maybe emptyAtInfo id $ Map.lookup @nm @lhs.scAtGam
                            .   propRetain  =   atProps @atInfo `intersect` [AtRetain]

-------------------------------------------------------------------------
-- Local properties for attr
-------------------------------------------------------------------------

{
data Dir = Def | Use | Node | NoDir deriving (Show,Eq,Ord)
}

SEM JdAt
  | At              loc     .   dir         =   let isSyn = AtSyn `elem` atDirs @atInfo
                                                    isInh = AtInh `elem` atDirs @atInfo
                                                in  if AtNode `elem` atProps @atInfo
                                                    then Node
                                                    else if isSyn
                                                    then if @lhs.isPre then Use else Def
                                                    else if isInh
                                                    then if @lhs.isPre then Def else Use
                                                    else NoDir
                            .   isBi        =   not $ null $ Map.elems propsSynInhMp `intersect` atProps @atInfo

SEM JdAt
  | At              loc     .   atTy        =   atTy @atInfo
                            .   atCnstr     =   ECnstr_Ty [@atTy]

-------------------------------------------------------------------------
-- Context: node name
-------------------------------------------------------------------------

ATTR JdAt [ | | mbNmNd: {Maybe Nm} ]
ATTR JdAts [ | | gathNmNd: Nm ]

ATTR AllAt [ | | gathExNd: Expr ]

SEM JdAt
  | At              lhs     .   mbNmNd      =   if @dir == Node then Just @nm else Nothing
                            .   gathExNd    =   @expr.self

SEM JdAts
  | Nil             lhs     .   gathNmNd    =   nmUnk
                            .   gathExNd    =   exprUnk
  | Cons            lhs     .   (gathNmNd,gathExNd)
                                            =   maybe (@tl.gathNmNd,@tl.gathExNd) (\n -> (n,@hd.gathExNd)) @hd.mbNmNd

ATTR AllAt [ nmNd: Nm | | ]

SEM Jd
  | Ats             loc     .   nmNd        =   if @lhs.isPre then exprAsNm $ @sbse $ @ats.gathExNd else nmLhs

-------------------------------------------------------------------------
-- Scheme of children node map/gam
-------------------------------------------------------------------------

{-
ATTR AllJd [ | | ndToScGam USE {`Map.union`} {Map.empty}: {Gam Nm Nm} ]

SEM Jd
  | Ats             lhs     .   ndToScGam   =   Map.singleton @nmNd @scNm
-}

-------------------------------------------------------------------------
-- Node order gam
-------------------------------------------------------------------------

ATTR AllJd [ | | coGam USE {`Map.union`} {Map.empty}: ChOrdGam ]

SEM Jd
  | Ats             loc     .   exNdNmS     =   exprNmS @ats.gathExNd
                            .   exNdFmGam   =   fmGamFromList' @lhs.fm [ (n,mkAFld . @sbsn $ n) | n <- Set.toList @exNdNmS ]
                    lhs     .   coGam       =   exprCoGam . exprSubst (@lhs.opts {optSubstFullNm=False}) @exNdFmGam $ @ats.gathExNd 

SEM RlDecl
  | Rl              loc     .   coNmL       =   coGamNmL @postJds.coGam

-------------------------------------------------------------------------
-- Attr bindings as FmGam
-------------------------------------------------------------------------

ATTR AllAt [ | | atFmGam USE {`fmGamUnion`} {emptyGam}: {FmGam (Expr,ECnstr)} ]

SEM JdAt
  | At              lhs     .   atFmGam     =   if False -- exprAsNm @expr.self == nmWild
                                                then emptyGam
                                                else fmSingleton @nm @lhs.fm (@expr.self,@atCnstr)

-------------------------------------------------------------------------
-- Building blocks for transforming
-------------------------------------------------------------------------

SEM JdAt
  | At              loc     .   nmAdapt     =   if @isBi then nmInit else id
                            .   nmSbs       =   Nm . nmShowAG . @sbsn . @nmAdapt $ @nm
                            .   defLhs      =   if @lhs.isPre then mkANd @lhs.nmNd @nmSbs else mkALhs' @propRetain @nmSbs
                            .   defRhs      =   @expr.self
                            .   useLhs      =   @expr.self
                            .   useRhs      =   if @lhs.isPre then mkANd @lhs.nmNd @nmSbs else mkALhs @nmSbs

-------------------------------------------------------------------------
-- Introduced names, mapped to AG equivalent
-------------------------------------------------------------------------

ATTR AllJd AllAt [ | | introFmGam USE {`fmGamUnion`} {emptyGam}: {FmGam Expr} ]

SEM JdAt
  | At              loc     .   introFmGam  =   case @dir of
                                                  Use -> fmGamFromList' @lhs.fm [ (n,mkALoc' n') | (n,n') <- nmRefAscL ]
                                                      where nmRefAscL = [ (n,Nm . nmShowAG . @sbsn {- . nmAdapt -} $ n) | n <- Set.toList (exprNmS @useLhs), n /= nmWild ]
                                                  _   -> emptyGam

SEM Jd
  | Ats             lhs     .   introFmGam  =   case scKind @scInfo of
                                                  ScJudge | not @lhs.isPre -> @exNdFmGam `fmGamUnion` @ats.introFmGam
                                                  _                        -> @ats.introFmGam

SEM RlDecl
  | Rl              loc     .   introFmGam  =   @preJds.introFmGam `fmGamUnion` @postJds.introFmGam

-------------------------------------------------------------------------
-- Full fmGam
-------------------------------------------------------------------------

SEM RlDecl
  | Rl              loc     .   fullFmGam   =   @introFmGam `fmGamUnion` @lhs.fmGam

-------------------------------------------------------------------------
-- Constraint gam
-------------------------------------------------------------------------

ATTR AllJd AllAt [ | | introECGam USE {`Map.union`} {Map.empty}: ECnstrGam ]

SEM JdAt
  | At              lhs     .   introECGam  =   @introECGam

SEM Jd
  | Ats             lhs     .   introECGam  =   @introECGam
{-
  | Ats             lhs     .   introECGam  =   case scKind @scInfo of
                                                  ScRelation -> Map.fromList [ ec | (_,ec) <- fmGamToList' @lhs.fm @ats.atFmGam ]
                                                  _          -> @ats.introECGam
-}

SEM RlDecl
  | Rl              loc     .   introECGam  =   Map.mapKeys
                                                    (exprSubst (@lhs.opts {optSubstFullNm=False}) @fullFmGam)
                                                    (@preJds.introECGam `Map.union` @postJds.introECGam)

-------------------------------------------------------------------------
-- 'Attr defined' gam
-------------------------------------------------------------------------

ATTR AllJd AllAt [ | | introADGam USE {`Map.union`} {Map.empty}: AtDefdGam ]

SEM JdAt
  | At              lhs     .   introADGam  =   case @dir of
                                                  Def -> Map.fromList [(@nmSbs,@isBi)]
                                                  _   -> emptyGam

SEM RlDecl
  | Rl              loc     .   adGam       =   @preJds.introADGam `Map.union` @postJds.introADGam

-------------------------------------------------------------------------
-- 'Attr defined' gam, new version
-------------------------------------------------------------------------

ATTR AllJd AllAt [ | | introAD2Gam USE {`adGamUnion`} {emptyGam}: {AtDefdGam'} ]

SEM JdAt
  | At              lhs     .   introAD2Gam =   case @dir of
                                                  Use | @lhs.isJd
                                                    -> Map.fromList [(@nmSbs,Set.singleton @lhs.nmNd)]
                                                  _ -> emptyGam

SEM RlDecl
  | Rl              loc     .   ad2Gam      =   @preJds.introAD2Gam `adGamUnion` @postJds.introAD2Gam

-------------------------------------------------------------------------
-- Replica
-------------------------------------------------------------------------

ATTR AllAt AllJd [ | | exprEqnL USE {++} {[]}: {[Expr]} ]

SEM JdAt
  | At              loc     .   (exprEqnL,introECGam)
                                            =   let mk l r = ([eqn2],ecGam `Map.union` ecGamFromList [ (l,@atCnstr), (r,@atCnstr) ])
                                                           where eqn1         = mkExprEqn l r
                                                                 (eqn2,ecGam) = exprElimCnstr eqn1
                                                in  case @dir of
                                                      Use | not (fmNull @introFmGam)
                                                          -> mk @useLhs @useRhs
                                                      Def -> mk @defLhs @defRhs
                                                      _   -> ([],Map.empty)

SEM Jd
  | Ats             loc     .   (exprEqnL,introECGam,eqnErrs)
                                            =   case scKind @scInfo of
                                                  ScJudge    -> (@ats.exprEqnL,@ats.introECGam,[])
                                                  ScRelation -> (exprLines jd2,introECGam2,concat jd1ErrLL)
                                                             where jd1      = fkGamLookup exprUnk jdExpr [@lhs.fm] . vwscJdGam $ @vwScInfo
                                                                   (jd1EqlL,jd1ErrLL)
                                                                            = unzip
                                                                                [ maybe (Map.empty,[Err_NotAEqnForm @lhs.pos (pp l)]) (\e -> (e,[])) (exprCheckAEqnForm l)
                                                                                | l <- exprLines jd1
                                                                                ]
                                                                   jd2      = exprSubst (@lhs.opts) (fmGamMap (const fst) @ats.atFmGam) jd1
                                                                   mkG eqm gn
                                                                            = if null n1 then [] else n1 ++ mkG (foldr (\(e,_) m -> Map.delete e m) eqm n1) n1
                                                                            where n1 = [ (exprEnsureAppTop e',c) | (e,c) <- gn, e' <- maybeToList (Map.lookup e eqm) ]
                                                                   (introECL,introECGL)
                                                                            = unzip [ ((e,c),eg) | (_,(e,c)) <- fmGamToList' @lhs.fm @ats.atFmGam, let (e',eg) = exprElimCnstr e ]
                                                                   introECGam2
                                                                            = (ecGamFromList $ introECL ++ mkG (Map.unions jd1EqlL) introECL)
                                                                              `Map.union` Map.unions introECGL

SEM RlDecl
  | Rl              (lhs.self,loc.selfNonOptim1,loc.selfNonOptim2)
                                            =   let (eqnLL,eqnGamL)
                                                      = unzip
                                                          [ (es,g)
                                                          | e <- @preJds.exprEqnL ++ @postJds.exprEqnL
                                                          , let (_,es,g) = exprRewrite' (@lhs.opts {optSubstFullNm=False}) @fullFmGam @lhs.rwGam @introECGam e
                                                          ]
                                                    aRule1
                                                      = ARule_Rule
                                                          [maybe (scNm @rsScInfo) Nm (scMbAGStr @rsScInfo)]
                                                          @agStr
                                                          ["rule " ++ show @rlNm,"view " ++ show @lhs.vwNm]
                                                          (concat eqnLL)
                                                    aRule2
                                                      = arlUniq @lhs.fmGam @coNmL
                                                        $ arlSubst (fmGamUnions eqnGamL)
                                                        $ aRule1
                                                    aRule3
                                                      = arlElimAlphaRename
                                                        $ aRule2
                                                    aRule4
                                                      = arlElimWild
                                                        $ (if optAGCopyElim @lhs.opts then arlElimCopyRule @coNmL @adGam @ad2Gam else id)
                                                        $ aRule3
                                                in  (RlDecl_AG @nm @pos aRule4,aRule2,aRule3)

-------------------------------------------------------------------------
-- Debug pretty printing of ruler AST2
-------------------------------------------------------------------------

{-
-}
SEM RlDecl
  | Rl              lhs     .   ppDbg       =   "-- debug info"
                                                >-< @nm >#< ppCommaList [pp @pos,pp @mbAGStr]
                                                >-< "introFmGam" >#< ppGam @introFmGam
                                                >-< "introECGam" >#< ppECGam @introECGam
                                                >-< "lhs.rwGam" >#< ppGam @lhs.rwGam
                                                >-< "adGam" >#< ppGam @adGam
                                                >-< "ad2Gam" >#< ppADGam @ad2Gam
                                                >-< "lhs.opts" >#< text (show @lhs.opts)
                                                >-< "coNmL" >#< ppListSep "[" "]" "," @coNmL
                                                >-< "non optim1" >#< pp @selfNonOptim1
                                                >-< "non optim2" >#< pp @selfNonOptim2

-------------------------------------------------------------------------
-- Error
-------------------------------------------------------------------------

SEM Jd
  | Ats             lhs     .   errL        =   @eqnErrs

