-- $Id: Ruler.ag 231 2005-06-07 14:39:41Z atze $

-------------------------------------------------------------------------
-- Variable substition (merged with rewriting)
-------------------------------------------------------------------------

{
nmMatch :: Opts -> FmKind -> Nm -> FmGam Expr -> Maybe ([Maybe String],[Maybe String],Expr)
nmMatch opts fk n fmGam
  = match
  where nmL = nmToMbL n
        nmLen = length nmL
        nLL
          = if optSubstFullNm opts
            then [nmL]
            else reverse . tail . inits $ nmL 
        match
          = foldr (\nL m
                    -> case fmGamLookup (nmFromMbL nL) fk fmGam of
                         Just e | isOkLen
                           -> Just (nL,drop len nmL,e)
                           where isOkLen = maybe True (\n -> len == length (nmToMbL n) || len == nmLen) (mbNmOfSel e)
                                 len = length nL
                         _ -> m
                  )
                  Nothing nLL

nmLAsSelExpr :: (Expr -> Expr) -> Expr -> [Maybe String] -> Expr
nmLAsSelExpr subst e nL
  = case nL of
      [] -> e
      _  -> Expr_SelTop . foldl Expr_Sel e $ eL
         where eL = map (fmap (subst . Expr_Var . Nm)) nL

mbNmOfSel :: Expr -> Maybe Nm
mbNmOfSel e
  = t e
  where t (Expr_SelTop st) = n st
        t e                = exprMbNm e
        n (Expr_Sel se (Just (Expr_Var (Nm s)))) = fmap (\n -> NmSel n (Just s)) (n se)
        n (Expr_Sel se Nothing)                  = fmap (\n -> NmSel n Nothing) (n se)
        n (Expr_Var n)                           = Just n
        n _                                      = Nothing

mbNmLOfSel :: Expr -> Maybe [Maybe String]
mbNmLOfSel = fmap nmToMbL . mbNmOfSel

exprVarSubst :: Opts -> FmGam Expr -> RwExprGam -> ECnstrGam -> Expr -> Nm -> Expr
exprVarSubst opts fmGam rwGam ecGam dfltRepl nm
  = case nmMatch opts (optGenFM opts) nm fmGam of
      Just (matchNmL,remNmL,matchExpr)
        -> case mbNmLOfSel se of
             Just sNmL
               -> Expr_Var (nmFromMbL (sNmL ++ remNmL))
             _ -> nmLAsSelExpr id se remNmL
        where se = if optSubstOnce opts then matchExpr else sbsWoNm matchExpr
              sbsWoNm = exprSubst opts (nmFromMbL matchNmL `Map.delete` fmGam)
      _ -> dfltRepl
}

ATTR AllExpr ANm AllARule [ | | repl: SELF ]
ATTR AGExprItf [ | | repl: Expr ]
ATTR AGARuleItf [ | | repl: ARule ]

SEM Expr
  | Var             loc     .   replVar     =   exprVarSubst @lhs.opts @lhs.fmGam @lhs.rwGam @lhs.ecGam @repl @nm
                            .   (replEcVar,varEcGam)
                                            =   exprElimCnstr @replVar

SEM ECnstr
  | Var             lhs     .   repl        =   case nmMatch @lhs.opts FmCnstr @nm @lhs.fmGam of
                                                    Just (_,_,Expr_WrapCnstr c)
                                                      -> c
                                                    _ -> @repl

-------------------------------------------------------------------------
-- Rewriting (merged with variable substition)
-------------------------------------------------------------------------

{
mkRwExpr :: InEqnLoc -> Opts -> FmGam Expr -> RwExprGam -> ECnstrGam -> Expr -> (Expr,FmGam Expr,ECnstrGam)
mkRwExpr inEqnLoc opts fmGam rwGam ecGam repl
  = case exprIsRw repl of
      ExprIsRw n | isJust mbRw
        -> ({- trp "YS2" (n >|< ":" >#< pp r) -} r,mtFmGam mt,ecg)
        where mbRw = rwGamLookup n (optGenFM opts) (if inEqnLoc == EqnInRhs then AtIn else AtOut) rwGam
              (r,mt,ecg)
                = foldr (\(me,e) r
                          -> let mt = exprMatch opts ecGam repl me
                             in  if mtMatches mt
                                 then let e2 = exprSubst opts (mtFmGam mt `Map.union` fmGam) e
                                          (e3,ecg) = exprElimCnstr e2
                                      in  (e3,mt,{- trp "EL" (ppECGam ecg) -} ecg)
                                 else r
                        )
                        ({- trp "YS1" (pp repl) -} repl,emptyEMtOut,emptyGam)
                        (maybe (panic "mkRwExpr") (\x -> {- trp "YS3" (vlist . map (\(a,b) -> pp a >#< "//" >#< pp b) $ x) -} x) mbRw)
      _ -> ({- trp "NO" (pp repl) -} repl,emptyGam,emptyGam)
}

ATTR AllExpr AGExprItf [ | | rwMtGam USE {`fmGamUnion`} {emptyGam}: {FmGam Expr} ]
ATTR AllExpr AGExprItf [ | | rwEcGam USE {`Map.union`} {emptyGam}: {ECnstrGam} ]

SEM Expr
  | Var             loc     .   forRwEcGam  =   @varEcGam `Map.union` @lhs.ecGam
                    (lhs.repl,lhs.rwMtGam,loc.rwEcGam)
                                            =   mkRwExpr @lhs.inEqnLoc @lhs.opts @lhs.fmGam @lhs.rwGam ({- trp "RW1" (pp @replEcVar >-< ppECGam @forRwEcGam) -} @forRwEcGam) @replEcVar
                    lhs     .   rwEcGam     =   @rwEcGam `Map.union` @varEcGam
  | AppTop          loc     .   forRwEcGam  =   @expr.rwEcGam `Map.union` @lhs.ecGam
                    (loc.rwRepl,loc.rwMtGam,loc.rwEcGam)
                                            =   mkRwExpr @lhs.inEqnLoc @lhs.opts @lhs.fmGam @lhs.rwGam ({- trp "RW2" (pp @repl >-< ppECGam @forRwEcGam) -} @forRwEcGam) @repl
                    lhs     .   rwMtGam     =   @rwMtGam `fmGamUnion` @expr.rwMtGam
                            .   rwEcGam     =   @rwEcGam `Map.union` @expr.rwEcGam
                            .   repl        =   @rwRepl

-------------------------------------------------------------------------
-- Resulting AEqn's
-------------------------------------------------------------------------

ATTR Expr AGExprItf [ | | aEqnL USE {++} {[]}: {[AEqn]} ]

SEM Expr
  | AppTop          (lhs.aEqnL,loc.aEqnFmGam)
                                            =   case exprMbAEqnRest @rwRepl of
                                                    Just (aEqn,remEqnL,fmGam) | @expr.isEqnAtEql
                                                      -> (aEqn : concat rwEqnL, fmGam `fmGamUnion` fmGamUnions fmGamL)
                                                      where (rwEqnL,fmGamL)
                                                              = unzip [ (e,g) | eqn <- remEqnL, let (_,e,g) = exprRewrite' @lhs.opts @lhs.fmGam @lhs.rwGam @lhs.ecGam eqn ]
                                                    _ -> ([AEqn_Err @rwRepl],emptyGam)

-------------------------------------------------------------------------
-- Additional subst for names
-------------------------------------------------------------------------

ATTR Expr AGExprItf [ | | aEqnFmGam USE {`fmGamUnion`} {emptyGam}: {FmGam Expr} ]

-------------------------------------------------------------------------
-- Context for use in rewriting
-------------------------------------------------------------------------

{
data InEqnLoc
  = EqnInTop | EqnInLhs | EqnInRhs
  deriving (Show,Eq,Ord)
}

ATTR AllExpr [ inEqnLoc: InEqnLoc | | ]
ATTR Expr [ | | isEqnAtEql: Bool ]

SEM Expr
  | Op              loc     .   isEqnAtEql  =   @lhs.inEqnLoc == EqnInTop && @nm == nmEql
                    (lExpr.inEqnLoc,rExpr.inEqnLoc)
                                            =   if @isEqnAtEql
                                                then (EqnInLhs,EqnInRhs)
                                                else (@lhs.inEqnLoc,@lhs.inEqnLoc)
  | * - Op Paren Named
                    lhs     .   isEqnAtEql  =   False

SEM AGExprItf
  | AGItf           expr    .   inEqnLoc    =   EqnInTop

SEM Decl
  | Fmt             loc     .   inEqnLoc    =   EqnInTop

SEM RExprEqn
  | Expr            loc     .   inEqnLoc    =   EqnInTop

SEM AttrEqn
  | Eqn             loc     .   inEqnLoc    =   EqnInTop

SEM AExpr
  | Expr            loc     .   inEqnLoc    =   EqnInTop

SEM AEqn
  | Err             loc     .   inEqnLoc    =   EqnInTop

SEM Decl
  | Fmt ShpJudge    expr    .   inEqnLoc    =   EqnInTop

-------------------------------------------------------------------------
-- Matching
-------------------------------------------------------------------------

{
data MtOut e
  = MtOut {mtMatches :: Bool, mtExpr :: e, mtFmGam :: FmGam Expr}

instance Show (MtOut e) where
  show _ = "MtOut"

instance PP e => PP (MtOut e) where
  pp i = "Mt" >#< pp (mtMatches i) >#< pp (mtExpr i) >#< ppGam (mtFmGam i)

emptyMtOut e = MtOut {mtMatches = True, mtExpr = e, mtFmGam = emptyGam}
emptyEMtOut = emptyMtOut Expr_Empty
emptyCMtOut = emptyMtOut ECnstr_Empty

-- lhs into rhs matching, expects rhs, given lhs
exprMatch :: Opts -> ECnstrGam -> Expr -> Expr -> MtOut Expr
exprMatch opts ecGam e1 e2
  = r
  where r = mt e1 e2
        -- r' = trp "XX" (pp e1 >-< pp e2 >-< pp r) $ r
        mt (Expr_Int i1)            e2@(Expr_Int i2)        | i1 == i2      = res e2
        mt (Expr_StrText s1)        e2@(Expr_StrText s2)    | s1 == s2      = res e2
        mt (Expr_StrAsIs s1)        e2@(Expr_StrAsIs s2)    | s1 == s2      = res e2
        mt (Expr_Empty)             (Expr_Empty)                            = res Expr_Empty
        mt (Expr_AppTop e1)         (Expr_AppTop e2)                        = let m = mt e1 e2 in res' (Expr_AppTop (mtExpr m)) m
        mt (Expr_Paren e1)          (Expr_Paren e2@(Expr_Var n2))           = bnd n2 e1 $ res e2
        mt (Expr_Paren e1)          e2@(Expr_Var n2)                        = bnd n2 e1 $ res e2
        mt (Expr_Paren e1)          (Expr_Paren e2)                         = let m = mt e1 e2 in res' (Expr_Paren (mtExpr m)) m
        mt e1                       (Expr_Paren e2)                         = mt e1 e2
        mt (Expr_Op n1 ne1 l1 r1)   e2@(Expr_Var n2)        | not (optMatchROpOpnd opts)
                                                                            = err
        mt e1                       e2@(Expr_Var n2)                        = bnd n2 e1 $ res e2
        mt (Expr_Op n1 ne1 l1 r1)   (Expr_Op n2 ne2 l2 r2)  | n1 == n2
          = bnd' (m2 {mtFmGam = n1 `Map.delete` mtFmGam m2}) m1
          where m1 = app l1 l2 r1 r2 (\l r -> Expr_Op n2 ne2 l r)
                m2 = mt ne1 ne2
        mt (Expr_App l1 r1)         (Expr_App l2 r2)                        = app l1 l2 r1 r2 Expr_App
        mt (Expr_SelTop t1)         e2@(Expr_SelTop t2)                     = bnd' (mt t1 t2) $ res e2
        mt (Expr_Sel e1 (Just s1))  (Expr_Sel e2 (Just s2))                 = app e1 e2 s1 s2 (\l r -> Expr_Sel l (Just r))
        mt (Expr_Named n e1)        e2                                      = let m = mt e1 e2 in res' (Expr_Named n (mtExpr m)) m
        mt e1                       (Expr_Cnstr e2 c2)
          = case ecGamLookup e1 ecGam of
              Just c1 | mtMatches mc
                -> bnd' mc $ mt e1 e2
                where mc = mtc c1 c2
              _ -> err
        mt _                        _                                       = err
        mtc (ECnstr_Ty t1)          c2@(ECnstr_Ty t2)       | not (null t)
          = resc (ECnstr_Ty t)
          where t = t1 `intersect` t2
        mtc c1                      c2@(ECnstr_Var n2)                      = bndc n2 c1 $ resc c2
        mtc _                       _                                       = errc
        app l1 l2 r1 r2 mk
          = foldr1 (\m1 m2 -> if mtMatches m1 then m2 else m1) [ml,mr,m]
          where ml = mt l1 l2
                mr = mt r1 r2
                m  = bnd' ml . res' (mk (mtExpr ml) (mtExpr mr)) $ mr
        bnd' mn m = m {mtFmGam = mtFmGam mn `fmGamUnion` mtFmGam m}
        bnd n e m = bnd' (emptyEMtOut {mtFmGam = fmSingleton n FmAll e}) m
        bndc n e m = bnd' (emptyCMtOut {mtFmGam = fmSingleton n FmCnstr (Expr_WrapCnstr e)}) m
        res' e m = m {mtExpr = e}
        res e = res' e emptyEMtOut
        resc e = res' e emptyEMtOut
        err' m = m {mtMatches = False}
        err = err' emptyEMtOut
        errc = err' emptyCMtOut
}

-------------------------------------------------------------------------
-- Constraint info about Expr
-------------------------------------------------------------------------

{
type ECnstrGam = Gam Expr ECnstr
type ECnstrAsc = [(Expr,ECnstr)]

ecStrip :: Expr -> Expr
ecStrip (Expr_Paren  e  ) = e
-- ecStrip (Expr_AppTop e  ) = e
ecStrip (Expr_Cnstr  e _) = e
ecStrip (Expr_Retain e  ) = e
ecStrip (Expr_Named  _ e) = e
ecStrip e                 = e

ecGamLookup :: Expr -> ECnstrGam -> Maybe ECnstr
ecGamLookup e g = Map.lookup (ecStrip e) g

ecGamInsert :: Expr -> ECnstr -> ECnstrGam -> ECnstrGam
ecGamInsert e c g = Map.insert (ecStrip e) c g

ecGamFromList :: [(Expr,ECnstr)] -> ECnstrGam
ecGamFromList l = Map.fromList [ (ecStrip e,c) | (e,c) <- l ]

ppECGam :: ECnstrGam -> PP_Doc
ppECGam g = vlist [ pp (Expr_Cnstr n v) | (n,v) <- Map.toList g]
}

-------------------------------------------------------------------------
-- Elimination of Expr_Cnstr
-------------------------------------------------------------------------

ATTR AllExpr ANm [ | | replEc: SELF ]
ATTR AGExprItf [ | | replEc: Expr ]
ATTR AGExprItf AllExpr [ | | ecElimGam USE {`Map.union`} {Map.empty}: ECnstrGam ]

SEM Expr
  | Cnstr           lhs     .   replEc      =   @expr.replEc
                            .   ecElimGam   =   ecGamInsert @expr.replEc @cnstr.replEc @expr.ecElimGam
