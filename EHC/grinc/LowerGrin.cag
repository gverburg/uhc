% $Id$

Some transformations are needed to allow easy code generation for GRIN
  - variables can refer only to pointers or basic values (tags or integers)
  - case statement on tag only (not on a complete node)
  - fetch must have offset attached
  - update need to have a known tag

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(EHCommon, FiniteMap, GrinCode) export(lowerGrin)
lowerGrin :: GrModule -> GrModule
lowerGrin grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                  in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]
%%]

%%%%%%%%%%%%%
%% TagSize %%
%%%%%%%%%%%%%

For now we use the maximum tagsize. This will change as soon as we have
heap-point-to analysis

%%[8
ATTR AllGrNT [ maxTagSizeAll: {Int} | | maxTagSize USE {`max`} {0}: Int ]

SEM GrAGItf
  | AGItf  module . maxTagSizeAll = @module.maxTagSize

-- first element in fldL is arity, which must not be added to the size.
-- Node size is arity + 1 (for tag) so result in fldL.len - 1 + 1
-- But for now we keep the first field element
SEM GrVal
  | Node      lhs . maxTagSize = @fldL.len + 1
  | NodeAdapt lhs . maxTagSize = error "cannot handle NodeAdapt"

ATTR GrValL [ | | len: {Int} ]
SEM GrValL
  | Cons lhs . len = 1 + @tl.len
  | Nil  lhs . len = 0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Locations of Patterns and values %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Since GrVal is not really structured, we need to know if we are inside a Node
already.  For case simplifying we must know whether the GrPat and GrVal are in
a case or not.

%%[8
ATTR GrVal GrValL AllAdapt GrPat GrPatL GrAlt GrAltL [ isInCase: {Bool} | | ]
SEM GrExpr
  | * - Case loc  . isInCase = False
  | Case     loc  . isInCase = True

ATTR GrVal GrValL AllAdapt [ isInNode: {Bool} | | ]
SEM GrExpr  
  | *        loc  . isInNode = False
SEM GrVal
  | Node     fldL . isInNode = True
             fldL . isInCase = False

-- TODO: what must stand here?
SEM GrSplit
  | Sel      loc  . isInNode = True
                  . isInCase = False
%%]


%%%%%%%%%%%%%%%%%%%
%% Vectorisation %%
%%%%%%%%%%%%%%%%%%%

New names are generated by suffixing the name with Tag and field numbers
TODO: is this name generation correct (clashes?!)

%%[8 hs
newNames :: HsName -> Int -> [HsName]
newNames base count | count == 0 = []
                    | otherwise  = suffix "_Tag" : map (\n -> suffix $ "_Field" ++ show n) [1..(count-1)]
	where
	suffix = hsnSuffix base

fromJust :: String -> Maybe a -> a
fromJust s m = case m of
  Just a  -> a
  Nothing -> error $ "fromJust: " ++ s

isJust :: Maybe a -> Bool
isJust m = case m of
  Just _  -> True
  Nothing -> False
  
%%]


Substitution is not done on all places
So we retrieve the new pattern

%%[8
ATTR GrExpr [ | | noVector: {Bool} ]
ATTR GrPat [ | | newPat: {GrPat} ]

SEM GrExpr
  | Store      lhs . noVector      = True
  | * - Store  lhs . noVector      = False

SEM GrExpr
  | Seq     loc  . patNode      = if @expr.noVector then @pat.grTrf else @pat.newPat
	    body . grNodeSubst  = if @expr.noVector then @lhs.grNodeSubst else @pat.grNodeSubst
            lhs  . grTrf        = GrExpr_Seq @expr.grTrf @patNode @body.grTrf
%%]

%% Rename \v to \(t f1 f2 fl)
%%[8
SEM GrPat
  | Var       loc . (tn, fldnL)  = let (tn:fldnL) = newNames @nm @lhs.maxTagSizeAll
                                   in (tn, fldnL)
              lhs . newPat        = GrPat_Node (GrTag_Var @tn) @fldnL
  | * - Var   lhs . newPat        = @grTrf
%%]

%% Substitute names!
%% Substitution in a case will be different (see below)
%% We here already change the value of the case to represent only the tag

%%[8
ATTR AllGrNT [ grNodeSubst : {FiniteMap HsName GrVal} | |                                        ]
ATTR GrPat   [                                        | | grNodeSubst : {FiniteMap HsName GrVal} ]


SEM GrAGItf
  | AGItf    module . grNodeSubst = emptyFM

-- TODO: this breaks the arity in first field!
SEM GrPat
  | Var      lhs . grNodeSubst = addToFM @lhs.grNodeSubst @nm (GrVal_Node (GrTag_Var @tn) (map GrVal_Var @fldnL))

SEM GrVal
  | Var      loc . maybeNode   = lookupFM @lhs.grNodeSubst @nm
                 . node        = maybe @grTrf id @maybeNode
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Case simplification %%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
-- replace patterns in case with Tag only
SEM GrVal
  | Node          loc  . node     = @grTrf
  | Var Node      lhs  . grTrf    = let tag = case @node of
                                                GrVal_Node t _ -> GrVal_Tag t
                                                otherwise        -> error $ "Not a node in case: " ++(show @node)
                                    in if @lhs.isInCase then tag else @node

SEM GrPat
  | Node          lhs  . grTrf       = if @lhs.isInCase then GrPat_Tag @tag.grTrf else @grTrf


-- return the fields of pattern and value to the Alternative node

ATTR AllAlt [ varFieldL: {[GrVal]} | | ]

ATTR GrVal [ | | varFieldL: {[GrVal]} ]

SEM GrVal
  | Node          lhs  . varFieldL   = @fldL.grTrf
  | Var           lhs  . varFieldL   = let fldL = case @node of 
                                                    (GrVal_Node _ l) -> l
                                                    otherwise        -> error $ "Not a node in case: " ++(show @node)
                                       in if @lhs.isInCase then fldL else undefined
  | * - Node Var  lhs  . varFieldL   = undefined

ATTR GrPat [ | | patFieldL: {[HsName]} ]

SEM GrPat 
  | Node          lhs  . patFieldL   = @fldL
  | Tag           lhs  . patFieldL   = []
  | * - Node Tag  lhs  . patFieldL   = error "Only Node or Tag values expected in a case"


-- add the substitutions for the case alternatives
SEM GrAlt
  | Alt           expr . grNodeSubst = let mappings = listToFM $ zipWith (\o n -> (o, n)) @pat.patFieldL @lhs.varFieldL
                                       in @lhs.grNodeSubst `plusFM` mappings
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% BUG FIX: Skip apply %%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllGrNT [ | | copy: SELF ]

SEM GrBind
  | Bind lhs . grTrf = if @nm == HNm "apply" then GrBind_Bind @nm @argNmL @expr.copy else @grTrf
%%]
