% $Id$

Some transformations are needed to allow easy code generation for GRIN
  - variables can refer only to pointers or basic values (tags or integers)
  - case statement on tag only (not on a complete node)
  - fetch must have offset attached
  - update need to have a known tag

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(EHCommon, FiniteMap, GrinCode) export(lowerGrin)
lowerGrin :: GrModule -> GrModule
lowerGrin grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                  in grTrf_Syn_GrAGItf t
%%]

%%%%%%%%%%%%%
%% TagSize %%
%%%%%%%%%%%%%

For now we use the maximum tagsize. This will change as soon as we have
heap-point-to analysis

%%[8
ATTR AllGrNT [ maxTagSizeAll: {Int} | | maxTagSize USE {`max`} {0}: Int ]

SEM GrAGItf
  | AGItf  module . maxTagSizeAll = @module.maxTagSize

-- first element in fldL is arity, which must not be added to the size.
-- Node size is arity + 1 (for tag) so result in fldL.len - 1 + 1
SEM GrVal
  | Node      lhs . maxTagSize = @fldL.len
  | NodeAdapt lhs . maxTagSize = error "cannot handle NodeAdapt"

ATTR GrValL [ | | len: {Int} ]
SEM GrValL
  | Cons lhs . len = 1 + @tl.len
  | Nil  lhs . len = 0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Locations of Patterns and values %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Since GrVal is not really structured, we need to know if we are inside a Node
already.  The substitution of GrVal in a Case is different from the others, so
we want to know that also.

%%[8
ATTR GrVal GrValL AllAdapt GrPat GrPatL GrAlt GrAltL [ isInCase: {Bool} | | ]
SEM GrExpr
  | * - Case loc  . isInCase = False
  | Case     loc  . isInCase = True

ATTR GrVal GrValL AllAdapt [ isInNode: {Bool} | | ]
SEM GrExpr  
  | *        loc  . isInNode = False
SEM GrVal
  | Node     fldL . isInNode = True
%%]


%%%%%%%%%%%%%%%%%%%
%% Vectorisation %%
%%%%%%%%%%%%%%%%%%%

New name are generated by suffixing the name with Tag and field numbers
TODO: is this name generation correct (clashes?!)

%%[8 hs
newNames :: HsName -> Int -> [HsName]
newNames base count | count == 0 = []
                    | otherwise  = suffix ".Tag" : map (\n -> suffix $ ".Field" ++ show n) [1..(count-1)]
	where
	suffix = hsnSuffix base

fromJust :: Maybe a -> a
fromJust m = case m of
  Just a  -> a
  Nothing -> error "fromJust: Nothing"

isJust :: Maybe a -> Bool
isJust m = case m of
  Just _  -> True
  Nothing -> False
  
%%]

%% Rename \v to \(t f1 f2 fl)
%% TODO: if unboxed values are returned, this should not be done, ehc output need to change

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

SEM GrPat
  | Var       loc . (tn, fldnL)  = let (tn:fldnL) = newNames @nm @lhs.maxTagSizeAll
                                   in (tn, fldnL)
              lhs . grTrf        = GrPat_Node (GrTag_Var @tn) @fldnL
%%]

%% Substitute names!
%% Substitution in a case will be different (see below)
%% We here already change the value of the case to represent only the tag

%%[8
ATTR AllGrNT [ grNodeSubst : {FiniteMap HsName GrVal} | |                                        ]
ATTR GrPat   [                                        | | grNodeSubst : {FiniteMap HsName GrVal} ]
ATTR GrVal   [ | | isTrf : {Bool} ]


SEM GrAGItf
  | AGItf    module . grNodeSubst = emptyFM

SEM GrPat
  | Var      lhs . grNodeSubst = addToFM @lhs.grNodeSubst @nm (GrVal_Node (GrTag_Var @tn) (map GrVal_Var @fldnL))

SEM GrVal
  | Var      loc .maybeNode    = lookupFM @lhs.grNodeSubst @nm
                 . node        = fromJust @maybeNode 
                 . newVal      = let tag      = case @node of 
                                                  GrVal_Node t _ -> t
                                     caseNode = GrVal_Tag tag
				 in if @lhs.isInCase then caseNode else @node
             loc . isTrf       = isJust @maybeNode && not @lhs.isInNode
             lhs . grTrf       = if @isTrf then @newVal else @grTrf
  | * - Var  loc . isTrf       = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Case simplification %%
%%%%%%%%%%%%%%%%%%%%%%%%%

We use the framework of the vectorisation transformation en transform the alternatives and patterns of a case

%%[8

-- Collect the information of the transformation and send it to the pattern inside the case
ATTR GrVal [ || changedVal : {(Maybe HsName, GrVal)} ]
ATTR GrPat GrPatL GrAlt GrAltL  [ changedVal : {(Maybe HsName, GrVal)} | | ]
SEM GrVal
  | Var           lhs . changedVal  = (Just @nm, @node)
  | * - Var Node  lhs . changedVal  = error "no change for anything but GrVal_Var or GrVal_Node in a case"

SEM GrExpr
  |  Case         loc  . changedVal = @val.changedVal
  | * - Case      loc  . changedVal = undefined

-- A case on a node should be translated into a tag only (the vectorisation already does so)
SEM GrVal
  | Node          lhs  . grTrf      = if @lhs.isInCase then  GrVal_Tag @tag.grTrf else @grTrf
	          lhs  . changedVal = (Nothing, @grTrf)
	          lhs  . isTrf      = @lhs.isInCase -- this overides the local atribute defined above


-- We need to change the Alternatives patterns to a Tag only
SEM GrPat
  | Node          loc  . newNode = GrPat_Tag @tag.grTrf
                  lhs  . grTrf   = if @lhs.isInCase then @newNode else @grTrf
  | * - Node Var  lhs  . grTrf   = if @lhs.isInCase then error "Not a GrPat_Node in a case" else @grTrf

SEM GrSplit
  | Sel          loc . changedVal = error "GrSplit_Sel"
                 loc . isInNode   = error "GrSplit_Sel"
                 loc . isInCase   = error "GrSplit_Sel"


-- Now we need to update the changes in the substition mapping
-- as a bonus we translate nodes with variable tags into known tags
ATTR GrPat GrAlt [ | | grAltNodeSubst: {FiniteMap HsName GrVal} ]
ATTR GrAlt GrAltL [ canTrf : {Bool} | | ]
SEM GrExpr
  |  Case      altL . canTrf          = @val.isTrf

SEM GrAlt
  | Alt        expr . grNodeSubst    = if @lhs.canTrf then @pat.grAltNodeSubst else @pat.grNodeSubst
  

SEM GrPat 
  | Node         lhs  . grAltNodeSubst = let (name, GrVal_Node (GrTag_Var tv) fldL) = @lhs.changedVal
					     newNode  = GrVal_Node @tag.grTrf fldL
                                             mappings = listToFM $ zipWith (\o n -> (o, n)) @fldL fldL
                                             fm       = maybe @lhs.grNodeSubst (\n -> addToFM @lhs.grNodeSubst n newNode) name
                                         in fm `plusFM` mappings
  | Tag          lhs  . grAltNodeSubst = let (name, _) = @lhs.changedVal
                                         in maybe @lhs.grNodeSubst (\n -> addToFM @lhs.grNodeSubst n (GrVal_Tag @tag.grTrf)) name
  | * - Node Tag lhs  . grAltNodeSubst = error "GrPat_??? not handled in Case simplification"
%%]
