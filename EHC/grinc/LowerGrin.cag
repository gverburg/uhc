% $Id$

Some transformations are needed to allow easy code generation for GRIN
  - variables can refer only to pointers or basic values (tags or integers)
  - case statement on tag only (not on a complete node)
  - fetch must have offset attached
  - update need to have a known tag

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(EHCommon, FiniteMap, GrinCode) export(lowerGrin)
lowerGrin :: GrModule -> GrModule
lowerGrin grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                  in grTrf_Syn_GrAGItf t
%%]

%%%%%%%%%%%%%
%% TagSize %%
%%%%%%%%%%%%%

For now we use the maximum tagsize. This will change as soon as we have
heap-point-to analysis

%%[8
ATTR AllGrNT [ maxTagSizeAll: {Int} | | maxTagSize USE {`max`} {0}: Int ]

SEM GrAGItf
  | AGItf  module . maxTagSizeAll = @module.maxTagSize

-- first element in fldL is arity, which must not be added to the size.
-- Node size is arity + 1 (for tag) so result in fldL.len - 1 + 1
SEM GrVal
  | Node      lhs . maxTagSize = @fldL.len
  | NodeAdapt lhs . maxTagSize = error "cannot handle NodeAdapt"

ATTR GrValL [ | | len: {Int} ]
SEM GrValL
  | Cons lhs . len = 1 + @tl.len
  | Nil  lhs . len = 0
%%]

%%%%%%%%%%%%%%%%%%%
%% Vectorisation %%
%%%%%%%%%%%%%%%%%%%

New name are generated by suffixing the name with Tag and field numbers
TODO: is this name generation correct (clashes?!)

%%[8 hs
newNames :: HsName -> Int -> [HsName]
newNames base count | count == 0 = []
                    | otherwise  = suffix ".Tag" : map (\n -> suffix $ ".Field" ++ show n) [1..(count-1)]
	where
	suffix = hsnSuffix base

fromJust :: Maybe a -> a
fromJust m = case m of
  Just a  -> a
  Nothing -> error "fromJust: Nothing"

isJust :: Maybe a -> Bool
isJust m = case m of
  Just _  -> True
  Nothing -> False
  
%%]


%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

SEM GrPat
  | Var       loc . (tn, fldnL)  = let (tn:fldnL) = newNames @nm @lhs.maxTagSizeAll
                                   in (tn, fldnL)
              lhs . grTrf        = GrPat_Node (GrTag_Var @tn) @fldnL

ATTR AllGrNT [ grNodeSubst : {FiniteMap HsName GrVal} | |                                        ]
ATTR GrPat   [                                        | | grNodeSubst : {FiniteMap HsName GrVal} ]
ATTR GrVal GrPat   [ | | isTrf : {Bool} ]

SEM GrAGItf
  | AGItf    module . grNodeSubst = emptyFM

SEM GrPat
  | Var      lhs . grNodeSubst = addToFM @lhs.grNodeSubst @nm (GrVal_Node (GrTag_Var @tn) (map GrVal_Var @fldnL))
             lhs . isTrf       = True
  | * - Var  lhs . isTrf       = False

SEM GrVal
  | Var      loc . newVal      = lookupFM @lhs.grNodeSubst @nm
             lhs . isTrf       = isJust @newVal
             lhs . grTrf       = maybe @grTrf id @newVal
  | * - Var  lhs . isTrf       = False

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Case simplification %%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrPat GrAlt GrAltL  [ changedVal : {(HsName, GrVal)} | | ]
ATTR GrPat GrAlt [ | | grAltNodeSubst: {FiniteMap HsName GrVal} ]
ATTR GrVal [ || newVal : {Maybe GrVal} oldName : {HsName} ]
ATTR GrAlt GrAltL [ canTrf : {Bool} | | ]

SEM GrExpr
  |  Case      loc  . changedVal     = if @val.isTrf then (@val.oldName, fromJust @val.newVal) else undefined
                    . canTrf         = @val.isTrf

SEM GrAlt
  | Alt        expr . grNodeSubst    = if @lhs.canTrf then @pat.grAltNodeSubst else @pat.grNodeSubst

SEM GrVal
  | Var        lhs . oldName = @nm
  | * - Var    lhs . oldName = error "no old name for anything but GrVal_Var"

SEM GrPat 
  | Node       lhs  . grAltNodeSubst = let (name, GrVal_Node (GrTag_Var tv) fldL) = @lhs.changedVal
					   newTag   = GrVal_Node @tag.grTrf fldL
					   mappings = listToFM $ zipWith (\o n -> (o, n)) @fldL fldL
                                       in (addToFM @lhs.grNodeSubst name newTag) `plusFM` mappings
  | NodeSplit  lhs  . grAltNodeSubst = error "GrPat_NodeSplit not handled in Case simplification"
  | Var        lhs  . grAltNodeSubst = error "variable in case!"
  | Tag        lhs  . grAltNodeSubst = let (name, _) = @lhs.changedVal
                                       in addToFM @lhs.grNodeSubst name (GrVal_Tag @tag.grTrf)
  | Empty LitInt lhs . grAltNodeSubst = error "not expected GrPat_{Empty,LitInt} in Case simplification"
%%]
