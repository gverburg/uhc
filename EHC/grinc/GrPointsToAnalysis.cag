% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../GrinCodeAbsSyn)
%%]

%%[8 hs import(Data.List(transpose), EHCommon(HsName), Debug.Trace) 
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(GRINCCommon, EHCommon, Data.FiniteMap, Data.Maybe, GrinCode,HeapPointsToFixpoint) export(addPointsToInfo)
type CafMap = FiniteMap HsName HsName

addPointsToInfo :: CafMap -> GrModule -> GrModule
addPointsToInfo cm grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) 
                                                (Inh_GrAGItf { cafMap_Inh_GrAGItf = cm })
                           in grTrf_Syn_GrAGItf t
%%]

%%[8.CafMap
ATTR GrAGItf AllGrNT [ cafMap: CafMap | | ]
%%]
-- Todo: Use arrays in stead of lookup lists
%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ pointsTo: AbstractEnv | | grTrf: SELF ]

ATTR AllGrNT [ | | absEnv USE {.} {id}: {AbstractEnv -> AbstractEnv} absHeap USE {.} {id}: {AbstractHeap -> AbstractHeap} ]

SEM GrAGItf
  | AGItf  module . pointsTo = trace ("RESULT: " ++ show @analysisResult) fst @analysisResult 
           loc    . deps     = buildDeps @absEnv @absHeap
                  . absEnv'  = @module.absEnv  @absEnvCAF
                  . absEnv   = filter ((wildcardNr /=) . aeLabel) @absEnv'
                  . absHeap  = @module.absHeap @absHeapCAF
                  . analysisResult = heapPointsTo @absEnv @absHeap @deps
           lhs    . grTrf    = trace ("env: " ++ show @absEnv) (trace ("heap: " ++ show @absHeap) @module.grTrf)

SEM GrModule
  | Mod   lhs . grTrf = trace (show @lhs.pointsTo) @grTrf

SEM GrBind
  | Bind  loc . prune   = (@nm == evalNr) || (@nm == applyNr)
          lhs . absHeap = if @prune then id else @expr.absHeap
              . absEnv  = if @prune then id else @loc.absEnvBind . @expr.absEnv
%%]

%%[8.deps hs
buildDeps env heap label = trace ("DEPS " ++ show label ++ ": " ++ show allDeps) allDeps
        where
	allDeps     = case label of { Left _ -> deps; Right _ -> deps ++ evalDeps }
        evalDeps    = [ depend | (Right _, depend) <- envTable ]
        deps        = [ depend | (mine   , depend) <- table, me <- f mine, me == label ]
        f (Left l)  = [l]
        f (Right v) = case aeBaseSet . lookupEnv env $ v of 
                        AV_Locations ls -> Left v : map Right ls
                        AV_Nothing      -> Left v : []
                        _               -> error "No location in eval"
        table       = heapTable ++ envTable
        heapTable   = concatMap depHeapElem heap
        envTable    = concatMap depEnvElem env

depHeapElem :: AbstractHeapElement -> [(Either Label Variable, Label)]
depHeapElem he = let me              = Right (ahLabel he)
                     ((_,vars), var) = ahMod  he
                 in [ (Left $ Left v, me) | Just v <- (var:vars) ]

depEnvElem :: AbstractEnvElement -> [(Either Label Variable, Label)]
depEnvElem ee = let me          = Left (aeLabel ee)
                    mvar2Label  = maybe id (\v -> ((Left $ Left v, me):))
                in case aeMod ee of
                     EnvNoChange       -> []
                     EnvUnion vars     -> map (\v -> (Left $ Left v,me)) vars
                     EnvEval var       -> [(Right var, me)]
                     EnvSelect var _ _ -> [(Left $ Left  var, me)]
                     EnvTag _ mvs mrv  -> foldr (\mv f -> mvar2Label mv . f) (mvar2Label mrv) mvs []
%%]

%%%%%%%%%%%%%%%%%%%
%% Tag2ResultVar %%
%%%%%%%%%%%%%%%%%%%

%%[8.tag2resultVar
ATTR AllGrNT [ tag2resultVar: {AssocL GrTag HsName} | | ]
ATTR GrModule [ | | tag2resultVar: {AssocL GrTag HsName} ]
SEM GrModule
  | Mod     loc . tag2resultVar = [ (t, f) | ((t,_), EvApTagVar f) <- @evalTagMp ]

SEM GrAGItf
  | AGItf   module . tag2resultVar = []
%%]

%%[8.valueCopy
ATTR GrVal GrValL GrTag [ | | copy                : SELF     ]
SEM GrVal
  | NodeAdapt loc . copy = error "No Node adapt"
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Unique Pointers %%
%%%%%%%%%%%%%%%%%%%%%

%%[8.heapPointer
ATTR AllGrNT [ | heapPointer: Int | ]
SEM GrAGItf
  | AGItf  module . heapPointer = @afterCAFPointer
%%]

%%%%%%%%%%%%%
%% TagName %%
%%%%%%%%%%%%%

%We use the name @UNBOXED for unboxed nodes.
%Any other node should have a named tag.

%%[8.tagName 
SEM GrTag [ | | tagName: SELF ]
  | Var     lhs . tagName = error "Tag variables are not allowed in GRIN Points-To Analysis"
%%]


A grin node is either a single variable or a complete node (with a known tag)

%%[8.nodeInfo hs
type NodeInfo a = Either HsName (GrTag, [a])
%%]

%%%%%%%%%%%%%%%%
%% value Info %%
%%%%%%%%%%%%%%%%

A grin value is either a single variable or a complete node (known tag)

%%[8.valInfo
SEM GrVal [ | | valInfo : {NodeInfo (Maybe HsName)}]
  | Node      lhs . valInfo = Right (@tag.tagName, @fldL.depVars)
  | Tag       lhs . valInfo = Right (@tag.tagName, [])
  | Var       lhs . valInfo = Left @nm
  | Empty     lhs . valInfo = error "no empty value expected!"
  | LitInt    lhs . valInfo = error "no literal value expected!"
  | NodeAdapt lhs . valInfo = error "no support for NodeAdapt"
%%]

%%[8.depVars
SEM GrVal  [ | | depVar:  {Maybe HsName} ]
  | Var      lhs . depVar = Just @nm
  | * - Var  lhs . depVar = Nothing
SEM GrValL [ | | depVars: {[Maybe HsName]}  ]
  | Cons     lhs . depVars = @hd.depVar : @tl.depVars
  | Nil      lhs . depVars = []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pattern Information %%
%%%%%%%%%%%%%%%%%%%%%%%%%

A grin pattern is either a single variable or a compete node pattern (known tag)

%%[8.patInfo
SEM GrPat [ | | patInfo: {NodeInfo HsName} ]
  | Node       lhs . patInfo = Right (@tag.tagName, @fldL)
  | Tag        lhs . patInfo = Right (@tag.tagName, [])
  | Var        lhs . patInfo = Left  @nm
  | Empty      lhs . patInfo = error "empty pattern no expected!"
  | LitInt     lhs . patInfo = error "literal int in pattern? I did not know that..."
  | NodeSplit  lhs . patInfo = error "no support for NodeSplit"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

The target info is basicly the pattern information. However, for the last
expression in a binding it is the result variable of that binding.

%%[8.targetInformation
ATTR AllGrExpr [ targetInfo: {NodeInfo HsName} | | ]

SEM GrBind
  | Bind  loc  . resultVar  = @nm
          expr . targetInfo = Left @resultVar -- result variable for this function

SEM GrExpr
  | Seq   expr . targetInfo = @pat.patInfo
          body . targetInfo = @lhs.targetInfo
%%]

4 possibilities of source and target info

%%[8.genInfo hs
genInfo :: NodeInfo a 
        -> NodeInfo b
        -> (HsName->HsName->c)
        -> (HsName->GrTag->[b]->c)
        -> (GrTag->[a]->HsName->c)
        -> (GrTag->[a]->GrTag->[b]->c)
        -> c
genInfo sourceInfo targetInfo llf lrf rlf rrf =
  case (sourceInfo, targetInfo) of
    (Left  sn      , Left  tn       ) -> llf sn     tn
    (Left  sn      , Right (tt, tns)) -> lrf sn     tt  tns
    (Right (st,sns), Left  tn       ) -> rlf st sns tn
    (Right (st,sns), Right (tt, tns)) -> rrf st sns tt  tns
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%
%% Unit %%
%%%%%%%%%%

unit node;           -> \n              => n:
                                             absVal = Nothing
                                             envMod = Union [node]
unit (Tag e1 .. en); -> \n              => n:
                                             absVal = Tag[(absVal e1), .., (absVal en)]  |_| resultVar(Tag)
                                             envMod = Tag[(depVar e1), .., (depVar en)]
unit node;           -> \(Tag e1 .. en) => e1: 
                                             absVal = Nothing
                                             envMod = node ! Tag ! 1
                                           en: 
                                             absVal = Nothing
                                             envMod = node ! Tag ! n
unit (Tag d1 .. dn); -> \(Tag e1 .. en) => e1:
                                             absVal = (absVal d1)
                                             envMod = Union (depVar d1)
                                           en:
                                             absVal = (absVal dn)
                                             envMod = Union (depVar dn)

note: The resultVar will always be Nothing.
      A node not in the heap representing a function is strange at least...

%%[8.unit
SEM GrExpr
  | Unit   loc . fVar2Var   = \s t         -> (makeEnvElem t AV_Nothing (EnvUnion [s]) :)
               . fNode2Var  = \tag names t -> let absVals   = map sn2av names
                                                  resultVar = lookup tag @lhs.tag2resultVar
                                                  env       = makeEnvElem t 
                                                                          (AV_Nodes [(tag, absVals)])
                                                                          (EnvTag tag names resultVar)
                                              in (env :)
               . fVar2Node  = buildSelectElems
               . fNode2Node = \st snms tt tnms -> let sn2mod = maybe EnvNoChange (\x -> EnvUnion [x]) 
                                                      toEnvElem sn tn = makeEnvElem tn (sn2av sn) (sn2mod sn)
                                                  in (zipWith toEnvElem snms tnms ++) -- note: st == tt
               . absEnv  = genInfo @val.valInfo @lhs.targetInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
%%]

%%[8.selectVar hs
sn2av :: Maybe HsName -> AbstractValue
sn2av = maybe AV_Basic (const AV_Nothing)

buildSelectElems selectVar tag nms
  = let step (i, f) v     = (i+1, f . (makeEnvElem v AV_Nothing (EnvSelect selectVar tag i) :))
        (count, envElems) = foldl step (0, id) nms
    in envElems
%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%

store (Tag e1 .. en); -> \n              => n:
                                              absVal = newLocation
                                              envMod = NoChange
                                            newLocation:
                                              absVal  = Tag[(absVal e1), .., (absVal en)] 
                                              heapMod = Tag[(depVar e1), .., (depVar en)] |_| resultVar(Tag)

%%[8.store
SEM GrExpr
  | Store  loc . (heapPointer, absEnv, absHeap) = makeStore (flip lookup @lhs.tag2resultVar)
                                                            @lhs.heapPointer
                                                            @val.valInfo
                                                            @lhs.targetInfo
%%]

%%[8.store hs
makeStore ftag2resultVar heapPointer valInfo targetInfo
	= let fNode2Var  tag names t = let absVals   = map sn2av names
	                                   resultVar = ftag2resultVar tag
	                                   env       = makeEnvElem t (AV_Locations [heapPointer]) EnvNoChange
	                                   heap      = makeHeapElem heapPointer
	                                                            (AV_Nodes [(tag, absVals)])
	                                                            ((tag, names), resultVar)
	                               in ( (env:), (heap:) )
	      fVar2Var   = error "Single variable in a store not allowed!"
	      fVar2Node  = error "No location variable afer a store!"
	      fNode2Node = error "No location variable afer a store! (And always store a node!)"
	      (absEnv, absHeap) = genInfo valInfo targetInfo fVar2Var fVar2Node fNode2Var fNode2Node
	  in (heapPointer + 1, absEnv, absHeap)
%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%

eval(l); -> \n              => n:
                                 absVal = Nothing
                                 envMod = Eval l

eval(l); -> \(Tag e1 .. en) => @eval@l:
                                 absVal = Nothing
                                 envMod = Eval l
                               e1: 
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! 1
                               en: 
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! n
%%[8.eval
SEM GrExpr
  | Eval   loc . absEnv = case @lhs.targetInfo of
                            Left  n           -> (makeEnvElem n AV_Nothing (EnvEval @nm) :)
                            Right (tag,names) -> let tmpVar     = hsnPrefix "@eval@" @nm
                                                     tmpEnvElem = (makeEnvElem tmpVar AV_Nothing (EnvEval @nm) :)
                                                 in  tmpEnvElem . buildSelectElems tmpVar tag names
%%]

%%%%%%%%%%
%% Call %%
%%%%%%%%%%

foo a1 .. an; -> \n             => n:
                                     absVal = Nothing
                                     envMod = Union [@foo]

foo a1 ..an; -> \(Tag e1 .. en) => e1: 
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! 1
                                   en: 
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! n
%%[8.call
SEM GrExpr
  | Call  loc . resultVar = @nm
              . absEnv = case @lhs.targetInfo of
                            Left  n           -> (makeEnvElem n AV_Nothing (EnvUnion [@resultVar]) :)
                            Right (tag,names) -> buildSelectElems @resultVar tag names
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%

case node of (T e1 .. en)             => e1: 
                                           absVal = Nothing
                                           envMod = node ! Tag ! 1
                                         en: 
                                           absVal = Nothing
                                           envMod = node ! Tag ! n
case (Tag d1 .. dn) of (Tag e1 .. en) => e1:
                                           absVal = (absVal d1)
                                           envMod = Union (depVar d1)
                                         en:
                                           absVal = (absVal dn)
                                           envMod = Union (depVar dn)

%%[8.alt
ATTR AllAlt [ valInfo: {NodeInfo (Maybe HsName)} | | ]

SEM GrAlt
  | Alt  loc . fVar2Node  = buildSelectElems
             . fNode2Node = \st snms tt tnms -> let sn2mod = maybe EnvNoChange (\x -> EnvUnion [x]) 
                                                    toEnvElem sn tn = makeEnvElem tn (sn2av sn) (sn2mod sn)
                                                in (zipWith toEnvElem snms tnms ++) -- note: st == tt
             . fVar2Var   = error "no variable in alternative pattern expected!"
             . fNode2Var  = error "no variable in alternative pattern expected!"
             . absEnv     = genInfo @lhs.valInfo @pat.patInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
         lhs . absEnv     = @absEnv . @expr.absEnv

%%]

%%%%%%%%%%
%% Case %%
%%%%%%%%%%

Since we can have multiple arms in a case, the question is how we merge the result of each arm.

case n of
  ... expr1 =>  alt1@n: equation of expr1
  ... exprn =>  altn@n: equation of exprn
; \r ->     => r:
                 absVal: Nothing
                 absEnv: Union [alt1@n, .., altn@n]

case n of
  ... expr1           => alt1@n: equation of expr1
  ... exprna          => altn@n: equation of exprn
; \(Tag e1 en) ->     => alt1@n@e1
                           absVal: Nothing
                           absEnv: alt1@n ! tag ! 1
                      => alt1@n@en
                           absVal: Nothing
                           absEnv: alt1@n ! tag ! n
                      => altn@n@e1
                           absVal: Nothing
                           absEnv: altn@n ! tag ! 1
                      => altn@n@en
                           absVal: Nothing
                           absEnv: altn@n ! tag ! n
                         e1: 
                           absVal: Nothing
                           absEnv: Union [alt1@n@e1, .., altn@n@e1]
                         en: 
                           absVal: Nothing
                           absEnv: Union [alt1@n@en, .., altn@n@en]

%%[8.case
ATTR AllAlt [ count: Int | | ]
SEM GrExpr
  | Case  altL . count = 0
SEM GrAltL
  | Cons  tl  . count = @lhs.count + 1


ATTR GrAlt    [ | | altTargetName: {HsName}    ]
SEM GrAltL    [ | | altTargetNames: {[HsName]} ]
  | Cons  lhs . altTargetNames = @hd.altTargetName : @tl.altTargetNames
  | Nil   lhs . altTargetNames = []

SEM GrAlt
  | Alt   loc  . altTargetName = case @lhs.valInfo of
                                   Left nm -> hsnPrefix ("alt" ++ show @lhs.count ++ "@") nm
                                   Right _ -> error "No node expected in case expression!" -- TODO: fix?
          expr . targetInfo    = Left @altTargetName

SEM GrExpr
  | Case  loc . absEnv = case @lhs.targetInfo of
                           Left resVar     -> (makeEnvElem resVar AV_Nothing (EnvUnion @altL.altTargetNames) :)
                           Right (tag,nms) -> error "No node expected after a case expression!" -- TODO: fix?
          lhs . absEnv = @absEnv . @altL.absEnv
%%]

%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%

ffi "primFoo"; \(Tag e1 en)  => e1:
                                  absVal = prim(Foo) ! Tag ! 1
				  envMod = NoChange
                                en:
                                  absVal = prim(Foo) ! Tag ! n
				  envMod = NoChange
ffi "primFoo"; \r            => r:
                                 absVal  = prim(Foo)

ffi "foo"; \(Tag e1 e2)      => note: (Tag == Unboxed)
                                e1: Basic
                                en: Basic

%%[8.ffi
SEM GrExpr
  | FFI  loc . primAbsVal = getPrimAbsVal @nm
             . prim       = case @lhs.targetInfo of
                              Left nm          -> (makeEnvElem nm @primAbsVal EnvNoChange :)
                              Right (tag, nms) -> let (AV_Nodes nodes) = @primAbsVal 
                                                      tagElementsAV    = fromJust $ lookup tag nodes
                                                      makeAV teAV nm   = makeEnvElem nm teAV EnvNoChange
                                                  in (zipWith makeAV tagElementsAV nms ++)
             . ffi        = case @lhs.targetInfo of
                              Left  nm         -> error "FFI should be followed by an unboxed node pattern"
                              Right (tag, nms) -> (map (\e -> makeEnvElem e AV_Basic EnvNoChange) nms ++)
             . absEnv     = if isPrim @nm then @prim else @ffi
%%]

Note: we have the ctable, can we do something with that?
      e.g. we could get the result Tags from it. If we save result type for a FFI.

%%[8.prim hs

getPrimAbsVal :: String -> AbstractValue
getPrimAbsVal n = maybe (error $ "primitve '" ++ n ++ "' not found") id (lookup n primTable)
        where 
        primTable = [ ("primAddInt", makeUnboxedAV [AV_Basic])
                    , ("primCmpInt", AV_Nodes [ (GrTag_Lit GrTagCon 0 (HNm "_EQ"), [AV_Basic])
                                              , (GrTag_Lit GrTagCon 1 (HNm "_GT"), [AV_Basic])
                                              , (GrTag_Lit GrTagCon 2 (HNm "_LT"), [AV_Basic])
                                              ]
                      )
                    ]

makeUnboxedAV vals = AV_Nodes [(GrTag_Unboxed, vals)]
%%]

%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%

Not implemented yet.

%%[8.apply
SEM GrExpr
  | App    loc . err     = error "apply support not implemented yet"
               . absEnv  = @err
               . absHeap = @err
%%]

%%%%%%%%%%%
%% Fetch %%
%%%%%%%%%%%

Fetch sould not occur outside eval. And eval is skipped.

%%[8.fetch
SEM GrExpr
  | Fetch  loc . err     = error "no fetch expected"
               . absEnv  = @err
               . absHeap = @err
%%]

%%%%%%%%%%%%
%% Update %%
%%%%%%%%%%%%

Update sould not occur outside eval. And eval is skipped.

%%[8.update
SEM GrExpr
  | Update  loc . err     = error "no update expected"
                . absEnv  = @err
                . absHeap = @err
%%]

%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllGrNT [ | | actualsEnv USE {.} {id} : {[(HsName, [Maybe HsName])] -> [(HsName, [Maybe HsName])]} ]
ATTR AllBind [ allActuals: {[(HsName, [Maybe HsName])]} | | ]

SEM GrExpr
  | Store Unit  loc . fGenActuals = \tag mns n -> let args      = tail mns -- first element is the size of the rest of the node
                                                      resultVar = lookup tag @lhs.tag2resultVar
                                                      actuals r = ((r,args) :)
                                                  in maybe id actuals resultVar
                loc . actualsEnv  = case (@val.valInfo, @lhs.targetInfo) of
                                      (Right (st,snms), Left tn) -> @fGenActuals st snms tn
                                      otherwise                  -> id
  | Call        loc . actualsEnv = ((@resultVar, @argL.depVars) :)

SEM GrModule
  | Mod       bindL . allActuals  = @bindL.actualsEnv []

SEM GrBind
  | Bind      loc   . bindActuals = transpose [ actuals | (resVar, actuals) <- @lhs.allActuals, resVar == @resultVar ]
                    . absEnvBind  = let getActuals = filter isJust
		                        envElem formal actuals = makeEnvElem formal AV_Nothing (EnvUnion [ actual | Just actual <- actuals])
                                    in (zipWith envElem @argNmL @bindActuals ++)
                    . actualsEnv  = if @prune then id else @expr.actualsEnv
%%]

%%%%%%%%%
%% CAF %%
%%%%%%%%%

for each CAF there exist a variable. Which looks like a store to that variable

store (FCAF); \-> bla


%%[8.CAF import(GrCAFNames)
SEM GrAGItf
  | AGItf   loc . mergeCAF = \n (p, e, h) -> let resVar       = n
                                                 cafVar       = getCafVar @lhs.cafMap n
                                                 tag          = fromJust $ revLookup @module.tag2resultVar resVar
                                                 (p', e', h') = makeStore (const . Just $ resVar) p (Right (tag, [Nothing])) (Left cafVar)
                                             in (p', e' e, h' h)
                . (afterCAFPointer, absEnvCAF, absHeapCAF)  = foldr @mergeCAF (0, [], []) @module.cafNames
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
--revLookup :: (Eq b) => [(a,b)] -> b -> Maybe a
revLookup l e = lookup e (map swap l)
	where swap = uncurry (flip (,))

getCafVar m k = fromJust' ("cafVar not found " ++ show k) $ lookupFM m k

fromJust' _ (Just a ) = a
fromJust' m (Nothing) = error $ "fromJust: " ++ m


makeEnvElem  v initial eq = AbstractEnvElement  { aeLabel = v, aeBaseSet = initial, aeMod = eq}
makeHeapElem l initial eq = AbstractHeapElement { ahLabel = l, ahBaseSet = initial, ahMod = eq}
isPrim (a:b:c:d:_) = ("prim" == a:b:c:d:[])
isPrim _           = False
%%]
