% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../GrinCodeAbsSyn)
%%]

%%[8 hs import(Data.List(transpose), EHCommon(HsName), Debug.Trace) 
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(EHCommon, Data.FiniteMap, Data.Maybe, GrinCode,HeapPointsToFixpoint) export(addPointsToInfo)
addPointsToInfo :: GrModule -> GrModule
addPointsToInfo grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                    in grTrf_Syn_GrAGItf t
%%]

-- Todo: Use arrays in stead of lookup lists
%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ pointsTo: AbstractEnv | | grTrf: SELF ]

ATTR AllGrNT [ | | absEnv USE {.} {id}: {AbstractEnv -> AbstractEnv} absHeap USE {.} {id}: {AbstractHeap -> AbstractHeap} ]

SEM GrAGItf
  | AGItf  module . pointsTo = fst (heapPointsTo @absEnv @absHeap @deps)
           loc    . deps     = const [] --error "no dependency generation yet"
                  . absEnv   = @module.absEnv  @absEnvCAF
                  . absHeap  = @module.absHeap @absHeapCAF
           lhs    . grTrf    = trace ("env: " ++ show @absEnv) (trace ("heap: " ++ show @absHeap) @module.grTrf)

SEM GrModule
  | Mod   lhs . grTrf = trace (show @lhs.pointsTo) @grTrf

SEM GrBind
  | Bind  loc . prune   = (@nm == HNm "eval") || (@nm == HNm "apply")
          lhs . absHeap = if @prune then id else @expr.absHeap
              . absEnv  = if @prune then id else @loc.absEnvBind . @expr.absEnv
%%]

%%%%%%%%%%%%%%%%%%%
%% Tag2ResultVar %%
%%%%%%%%%%%%%%%%%%%

%%[8.tag2resultVar
ATTR AllGrNT [ tag2resultVar: {AssocL GrTag HsName} | | ]
SEM GrModule
  | Mod     loc . tag2resultVar = [ (t, hsnPrefix "@" f) | ((t,_), EvApTagVar f) <- @evalTagMp ]

SEM GrAGItf
  | AGItf   loc . tag2resultVar = []
%%]

%%[8.valueCopy
ATTR GrVal GrValL GrTag [ | | copy                : SELF     ]
SEM GrVal
  | NodeAdapt loc . copy = error "No Node adapt"
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Unique Pointers %%
%%%%%%%%%%%%%%%%%%%%%

%%[8.heapPointer
ATTR AllGrNT [ | heapPointer: Int | ]
SEM GrAGItf
  | AGItf  module . heapPointer = @afterCAFPointer
%%]

%%%%%%%%%%%%%
%% TagName %%
%%%%%%%%%%%%%

%We use the name @UNBOXED for unboxed nodes.
%Any other node should have a named tag.

%%[8.tagName 
SEM GrTag [ | | tagName: SELF ]
  | Var     lhs . tagName = error "Tag variables are not allowed in GRIN Points-To Analysis"
%%]


A grin node is either a single variable or a complete node (with a known tag)

%%[8.nodeInfo hs
type NodeInfo a = Either HsName (GrTag, [a])
%%]

%%%%%%%%%%%%%%%%
%% value Info %%
%%%%%%%%%%%%%%%%

A grin value is either a single variable or a complete node (known tag)

%%[8.valInfo
SEM GrVal [ | | valInfo : {NodeInfo (Maybe HsName)}]
  | Node      lhs . valInfo = Right (@tag.tagName, @fldL.depVars)
  | Tag       lhs . valInfo = Right (@tag.tagName, [])
  | Var       lhs . valInfo = Left @nm
  | Empty     lhs . valInfo = error "no empty value expected!"
  | LitInt    lhs . valInfo = error "no literal value expected!"
  | NodeAdapt lhs . valInfo = error "no support for NodeAdapt"
%%]

%%[8.depVars
SEM GrVal  [ | | depVar:  {Maybe HsName} ]
  | Var      lhs . depVar = Just @nm
  | * - Var  lhs . depVar = Nothing
SEM GrValL [ | | depVars: {[Maybe HsName]}  ]
  | Cons     lhs . depVars = @hd.depVar : @tl.depVars
  | Nil      lhs . depVars = []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pattern Information %%
%%%%%%%%%%%%%%%%%%%%%%%%%

A grin pattern is either a single variable or a compete node pattern (known tag)

%%[8.patInfo
SEM GrPat [ | | patInfo: {NodeInfo HsName} ]
  | Node       lhs . patInfo = Right (@tag.tagName, @fldL)
  | Tag        lhs . patInfo = Right (@tag.tagName, [])
  | Var        lhs . patInfo = Left  @nm
  | Empty      lhs . patInfo = error "empty pattern no expected!"
  | LitInt     lhs . patInfo = error "literal int in pattern? I did not know that..."
  | NodeSplit  lhs . patInfo = error "no support for NodeSplit"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

The target info is basicly the pattern information. However, for the last
expression in a binding it is the result variable of that binding.

%%[8.targetInformation
ATTR AllGrExpr [ targetInfo: {NodeInfo HsName} | | ]

SEM GrBind
  | Bind  loc  . resultVar  = hsnPrefix "@" @nm
          expr . targetInfo = Left @resultVar -- result variable for this function

SEM GrExpr
  | Seq   expr . targetInfo = @pat.patInfo
          body . targetInfo = @lhs.targetInfo
%%]

4 possibilities of source and target info

%%[8.genInfo hs
genInfo :: NodeInfo a 
        -> NodeInfo b
        -> (HsName->HsName->c)
        -> (HsName->GrTag->[b]->c)
        -> (GrTag->[a]->HsName->c)
        -> (GrTag->[a]->GrTag->[b]->c)
        -> c
genInfo sourceInfo targetInfo llf lrf rlf rrf =
  case (sourceInfo, targetInfo) of
    (Left  sn      , Left  tn       ) -> llf sn     tn
    (Left  sn      , Right (tt, tns)) -> lrf sn     tt  tns
    (Right (st,sns), Left  tn       ) -> rlf st sns tn
    (Right (st,sns), Right (tt, tns)) -> rrf st sns tt  tns
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.rotzooi
ATTR AllAlt [ scrutinizer: {HsName} | | ]
SEM GrExpr
  | Case altL . scrutinizer = @val.caseNm

SEM GrVal [ | | caseNm : {HsName} ]
  | Var      lhs . caseNm = @nm
  | * - Var  lhs . caseNm = error "no value variable"
%%]




%%%%%%%%%%
%% Unit %%
%%%%%%%%%%

unit node;           -> \n              => n:
                                             absVal = Nothing
                                             envMod = Union [node]
unit (Tag e1 .. en); -> \n              => n:
                                             absVal = Tag[(absVal e1), .., (absVal en)]  |_| resultVar(Tag)
                                             envMod = Tag[(depVar e1), .., (depVar en)]
unit node;           -> \(Tag e1 .. en) => e1: 
                                             absVal = Nothing
                                             envMod = node ! Tag ! 1
                                           en: 
                                             absVal = Nothing
                                             envMod = node ! Tag ! n
unit (Tag d1 .. dn); -> \(Tag e1 .. en) => e1:
                                             absVal = (absVal d1)
                                             envMod = Union (depVar d1)
                                           en:
                                             absVal = (absVal dn)
                                             envMod = Union (depVar dn)

note: The resultVar will always be Nothing.
      A node not in the heap representing a function is strange at least...

%%[8.unit
SEM GrExpr
  | Unit   loc . fVar2Var   = \s t         -> (makeEnvElem t AV_Nothing (EnvUnion [s]) :)
               . fNode2Var  = \tag names t -> let absVals   = map sn2av names
                                                  resultVar = lookup tag @lhs.tag2resultVar
                                                  env       = makeEnvElem t 
                                                                          (AV_Nodes [(tag, absVals)])
                                                                          (EnvTag tag names resultVar)
                                              in (env :)
               . fVar2Node  = buildSelectElems
               . fNode2Node = \st snms tt tnms -> let sn2mod = maybe EnvNoChange (\x -> EnvUnion [x]) 
                                                      toEnvElem sn tn = makeEnvElem tn (sn2av sn) (sn2mod sn)
                                                  in (zipWith toEnvElem snms tnms ++) -- note: st == tt
               . absEnv  = genInfo @val.valInfo @lhs.targetInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
%%]

%%[8.selectVar hs
sn2av :: Maybe HsName -> AbstractValue
sn2av = maybe AV_Basic (const AV_Nothing)

buildSelectElems selectVar tag nms
  = let step (i, f) v     = (i+1, f . (makeEnvElem v AV_Nothing (EnvSelect selectVar tag i) :))
        (count, envElems) = foldl step (0, id) nms
    in envElems
%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%

store (Tag e1 .. en); -> \n              => n:
                                              absVal = newLocation
                                              envMod = NoChange
                                            newLocation:
                                              absVal  = Tag[(absVal e1), .., (absVal en)] 
                                              heapMod = Tag[(depVar e1), .., (depVar en)] |_| resultVar(Tag)

%%[8.store
SEM GrExpr
  | Store  loc . (heapPointer, absEnv, absHeap) = makeStore @lhs.tag2resultVar 
                                                            @lhs.heapPointer
                                                            @val.valInfo
                                                            @lhs.targetInfo
%%]

%%[8.store hs
makeStore tag2resultVar heapPointer valInfo targetInfo
	= let fNode2Var  tag names t = let absVals   = map sn2av names
	                                   resultVar = lookup tag tag2resultVar
	                                   env       = makeEnvElem t (AV_Locations [heapPointer]) EnvNoChange
	                                   heap      = makeHeapElem heapPointer
	                                                            (AV_Nodes [(tag, absVals)])
	                                                            ((tag, names), resultVar)
	                               in ( (env:), (heap:) )
	      fVar2Var   = error "Single variable in a store not allowed!"
	      fVar2Node  = error "No location variable afer a store!"
	      fNode2Node = error "No location variable afer a store! (And always store a node!)"
	      (absEnv, absHeap) = genInfo valInfo targetInfo fVar2Var fVar2Node fNode2Var fNode2Node
	  in (heapPointer + 1, absEnv, absHeap)
%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%

eval(l); -> \n              => n:
                                 absVal = Nothing
                                 envMod = Eval l

eval(l); -> \(Tag e1 .. en) => @eval@l:
                                 absVal = Nothing
                                 envMod = Eval l
                               e1: 
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! 1
                               en: 
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! n
%%[8.eval
SEM GrExpr
  | Eval   loc . absEnv = case @lhs.targetInfo of
                            Left  n           -> (makeEnvElem n AV_Nothing (EnvEval @nm) :)
                            Right (tag,names) -> let tmpVar     = hsnPrefix "@eval@" @nm
                                                     tmpEnvElem = (makeEnvElem tmpVar AV_Nothing (EnvEval @nm) :)
                                                 in  tmpEnvElem . buildSelectElems tmpVar tag names
%%]

%%%%%%%%%%
%% Call %%
%%%%%%%%%%

foo a1 .. an; -> \n             => n:
                                     absVal = Nothing
                                     envMod = Union [@foo]

foo a1 ..an; -> \(Tag e1 .. en) => e1: 
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! 1
                                   en: 
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! n
%%[8.call
SEM GrExpr
  | Call  loc . resultVar = hsnPrefix "@" @nm
              . absEnv = case @lhs.targetInfo of
                            Left  n           -> (makeEnvElem n AV_Nothing (EnvUnion [@nm]) :)
                            Right (tag,names) -> buildSelectElems @resultVar tag names
%%]

%%%%%%%%%%
%% Case %%
%%%%%%%%%%

case node of (T e1 .. en)             => e1: 
                                           absVal = Nothing
                                           envMod = node ! Tag ! 1
                                         en: 
                                           absVal = Nothing
                                           envMod = node ! Tag ! n
case (Tag d1 .. dn) of (Tag e1 .. en) => e1:
                                           absVal = (absVal d1)
                                           envMod = Union (depVar d1)
                                         en:
                                           absVal = (absVal dn)
                                           envMod = Union (depVar dn)

%%[8.case
ATTR AllAlt [ valInfo: {NodeInfo (Maybe HsName)} | | ]

SEM GrAlt
  | Alt  loc . fVar2Node  = buildSelectElems
             . fNode2Node = \st snms tt tnms -> let sn2mod = maybe EnvNoChange (\x -> EnvUnion [x]) 
                                                    toEnvElem sn tn = makeEnvElem tn (sn2av sn) (sn2mod sn)
                                                in (zipWith toEnvElem snms tnms ++) -- note: st == tt
             . fVar2Var   = error "no variable in alternative pattern expected!"
             . fNode2Var  = error "no variable in alternative pattern expected!"
             . absEnv     = genInfo @lhs.valInfo @pat.patInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
         lhs . absEnv     = @absEnv . @expr.absEnv

%%]

%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllGrNT [ | actualsEnv USE {.} {id} : {[(HsName, [HsName])] -> [(HsName, [HsName])]} | ]
ATTR AllBind [ allActuals: {[(HsName, [HsName])]} | | ]

SEM GrExpr
  | Store Unit  loc . fGenActuals = \tag mns n -> let args      = [ arg | Just arg <- mns ]
                                                      resultVar = lookup tag @lhs.tag2resultVar
                                                      actuals r = ((r,args) :)
                                                  in maybe id actuals resultVar
                    . actualsEnv  = case (@val.valInfo, @lhs.targetInfo) of
                                      (Right (st,snms), Left tn) -> @fGenActuals st snms tn
                                      otherwise                  -> id

SEM GrAGItf
  | AGItf    module . actualsEnv  = id

SEM GrModule
  | Mod       bindL . allActuals  = @bindL.actualsEnv []

SEM GrBind
  | Bind      loc   . bindActuals = transpose [ actuals | (resVar, actuals) <- @lhs.allActuals, resVar == @resultVar ]
                    . absEnvBind  = let envElem formal actuals = makeEnvElem formal AV_Nothing (EnvUnion actuals)
                                    in (zipWith envElem @argNmL @bindActuals ++)
%%]

%%%%%%%%%
%% CAF %%
%%%%%%%%%

for each CAF there exist a variable. Which looks like a store to that variable

store (FCAF); \-> bla


%%[8.CAF import(GrCAFNames)
SEM GrAGItf
  | AGItf   loc . mergeCAF = \n (p, e, h) -> let tag        n = fromJust $ revLookup @tag2resultVar (hsnPrefix "@" n)
                                                 (p', e', h') = makeStore @tag2resultVar p (Right (tag n, [])) (Left n)
                                             in (p', e' e, h' h)
                . (afterCAFPointer, absEnvCAF, absHeapCAF)  = foldr @mergeCAF
                                                                    (0, [], [])
                                                                    (trace ("CAF: " ++ show @module.cafNames) @module.cafNames)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
--revLookup :: (Eq b) => [(a,b)] -> b -> Maybe a
revLookup l e = lookup e (map swap l)
	where swap = uncurry (flip (,))


makeEnvElem  v initial eq = AbstractEnvElement  { aeLabel = v, aeBaseSet = AV_Nothing, aeChangeSet = initial, aeMod = eq}
makeHeapElem l initial eq = AbstractHeapElement { ahLabel = l, ahBaseSet = AV_Nothing, ahChangeSet = initial, ahMod = eq}
%%]
