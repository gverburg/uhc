% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(GrinCodeAbsSyn)
%%]

%%[8 hs import(Data.List(transpose), EHCommon(HsName), Debug.Trace)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import("qualified Data.Map as Map", Data.Maybe, Control.Monad, Control.Monad.ST, Data.Array.ST, Data.Array.IArray)
%%]

%%[8 hs import(Debug.Trace)
%%]

%%[8 hs import(GRINCCommon, EHCommon, GrinCode,HeapPointsToFixpoint) export(heapPointsToAnalysis)

type Action          = ST RealWorld ()
type EnvAction       = ST RealWorld (AbstractEnv RealWorld)
type HeapAction      = ST RealWorld (AbstractHeap RealWorld)
type HPTResult       = (Int, Array Int AbstractEnvElement, Array Int AbstractHeapElement)
type SetEnv          = Variable -> AbstractValue -> AbstractEnvModifier -> Action
type GetEnv          = Variable -> ST RealWorld AbstractEnvElement

heapPointsToAnalysis :: (Int,Int) -> GrModule -> IO HPTResult
heapPointsToAnalysis (low,high) grmod = stToIO $ do
    { let applyArg = low - 1 ;
    ; absEnv <- (newArray_ (applyArg,high) ) :: EnvAction
    ; foldM_ (\_ v -> writeArray absEnv v (error $ "no equation for variable " ++ show v)) () [applyArg..high]
    ; let setEnvVar v initial eq = writeArray absEnv v (AbstractEnvElement  {aeBaseSet = initial, aeMod = eq})
    ; let getEnvVar v            = readArray absEnv v
          t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                        (Inh_GrAGItf
                                            { setEnvVar_Inh_GrAGItf  = setEnvVar
                                            , getEnvVar_Inh_GrAGItf  = getEnvVar
                                            , tmpVar_Inh_GrAGItf     = applyArg
                                            }
                                        )
    ; fillEnv_Syn_GrAGItf t
    ; absHeap <- makeHeap_Syn_GrAGItf t
    ; setEnvVar applyArg AV_Nothing EnvNoChange
    ; let applyMap = applyMap_Syn_GrAGItf t
    ; count   <- heapPointsTo absEnv absHeap applyMap
    ; absHeap <- unsafeFreeze absHeap
    ; absEnv  <- unsafeFreeze absEnv
    ; return (count, absEnv, absHeap)
    }
%%]

%%[8.toplevelCombining
ATTR GrAGItf AllGrNT [ getEnvVar: GetEnv  setEnvVar: SetEnv tmpVar: Variable | | fillEnv USE {>>} {return ()}: {Action} ]
ATTR AllGrNT [ | heapList: {[(Location, AbstractHeapElement)]} | ]
ATTR GrAGItf [ | | makeHeap: HeapAction ]

SEM GrAGItf
  | AGItf  lhs     .  makeHeap  =  do { arr <- newArray_ (0, @module.heapPointer - 1)
                                      ; mapM (uncurry $ writeArray arr ) @module.heapList
                                      ; return arr
                                      }
           module  . heapList   =  []

SEM GrBind
  | Bind  loc  .  prune     = (@nm == evalNr) || (@nm == applyNr)
          lhs  .  heapList  = if @prune then @lhs.heapList else @expr.heapList
               .  fillEnv   = if @prune then (return ()) else @fillEnvBind >> @exceptEq >> @expr.fillEnv
%%]

%%%%%%%%%%%%%%%%%%%
%% Tag2ResultVar %%
%%%%%%%%%%%%%%%%%%%

%%[8.tag2resultVar
ATTR AllGrNT [ tag2resultVar: {AssocL GrTag Int} | | ]
ATTR GrModule [ | | tag2resultVar: {AssocL GrTag Int} ]
SEM GrModule
  | Mod     loc . tag2resultVar = [ (t, f) | ((t,_), EvApTagVar (HNPos f)) <- @evalTagMp ]

SEM GrAGItf
  | AGItf   module . tag2resultVar = []
%%]

%%[8.valueCopy
ATTR GrVal GrValL GrTag [ | | copy                : SELF     ]
SEM GrVal
  | NodeAdapt loc . copy = error "No Node adapt"
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Unique Pointers %%
%%%%%%%%%%%%%%%%%%%%%

%%[8.heapPointerfillEnv
ATTR AllGrNT [ | heapPointer: Int | ]
SEM GrAGItf
  | AGItf  module . heapPointer = 0
%%]

%%%%%%%%%%%%%
%% TagName %%
%%%%%%%%%%%%%

%We use the name @UNBOXED for unboxed nodes.
%Any other node should have a named tag.

%%[8.tagName
SEM GrTag [ | | tagName: SELF ]
  | Var     lhs . tagName = error "Tag variables are not allowed in GRIN Points-To Analysis"
%%]


A grin node is either a single variable or a complete node (with a known tag)

%%[8.nodeInfo hs
type NodeInfo a = Either Int (GrTag, [a])
%%]

%%%%%%%%%%%%%%%%
%% value Info %%
%%%%%%%%%%%%%%%%

A grin value is either a single variable or a complete node (known tag)

%%[8.valInfo
SEM GrValL [ | | valsInfo : {[NodeInfo (Maybe Int)]}]
  | Cons      lhs . valsInfo = @hd.valInfo : @tl.valsInfo
  | Nil       lhs . valsInfo = []

SEM GrVal [ | | valInfo : {NodeInfo (Maybe Int)}]
  | Node      lhs . valInfo = Right (@tag.tagName, @fldL.depVars)
  | Tag       lhs . valInfo = Right (@tag.tagName, [])
  | Var       lhs . valInfo = Left (getNr @nm)
  | Empty     lhs . valInfo = error "no empty value expected!"
  | LitInt    lhs . valInfo = error "no literal value expected!"
  | NodeAdapt lhs . valInfo = error "no support for NodeAdapt"
%%]

%%[8.depVars
SEM GrVal  [ | | depVar:  {Maybe Int} ]
  | Var      lhs . depVar = Just (getNr @nm)
  | * - Var  lhs . depVar = Nothing
SEM GrValL [ | | depVars: {[Maybe Int]}  ]
  | Cons     lhs . depVars = @hd.depVar : @tl.depVars
  | Nil      lhs . depVars = []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pattern Information %%
%%%%%%%%%%%%%%%%%%%%%%%%%

A grin pattern is either a single variable or a compete node pattern (known tag)

%%[8.patInfo
SEM GrPat [ | | patInfo: {NodeInfo Int} ]
  | Node       lhs . patInfo = Right (@tag.tagName, map getNr @fldL)
  | Tag        lhs . patInfo = Right (@tag.tagName, [])
  | Var        lhs . patInfo = Left (getNr @nm)
  | Empty      lhs . patInfo = error "empty pattern no expected!"
  | LitInt     lhs . patInfo = error "literal int in pattern? I did not know that..."
  | NodeSplit  lhs . patInfo = error "no support for NodeSplit"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

The target info is basicly the pattern information. However, for the last
expression in a binding it is the result variable of that binding.

%%[8.targetInformation
ATTR AllGrExpr [ targetInfo: {NodeInfo Int} | exceptions: {[Int]} | ]

SEM GrBind
  | Bind  loc  . resultVar   =  getNr @nm
          expr . targetInfo  =  Left @resultVar

SEM GrExpr
  | Seq    expr     .  targetInfo = @pat.patInfo
           body     .  targetInfo = @lhs.targetInfo
%%]

4 possibilities of source and target info

%%[8.genInfo hs
genInfo :: NodeInfo a
        -> NodeInfo b
        -> (Int->Int->c)
        -> (Int->GrTag->[b]->c)
        -> (GrTag->[a]->Int->c)
        -> (GrTag->[a]->GrTag->[b]->c)
        -> c
genInfo sourceInfo targetInfo llf lrf rlf rrf =
  case (sourceInfo, targetInfo) of
    (Left  sn      , Left  tn       ) -> llf sn     tn
    (Left  sn      , Right (tt, tns)) -> lrf sn     tt  tns
    (Right (st,sns), Left  tn       ) -> rlf st sns tn
    (Right (st,sns), Right (tt, tns)) -> rrf st sns tt  tns
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%
%% Unit %%
%%%%%%%%%%

unit node;           -> \n              => n:
                                             absVal = Nothing
                                             envMod = Union [node]
unit (Tag e1 .. en); -> \n              => n:
                                             absVal = Tag[(absVal e1), .., (absVal en)]
                                             envMod = Tag[(depVar e1), .., (depVar en)]
unit node;           -> \(Tag e1 .. en) => e1:
                                             absVal = Nothing
                                             envMod = node ! Tag ! 1
                                           en:
                                             absVal = Nothing
                                             envMod = node ! Tag ! n
unit (Tag d1 .. dn); -> \(Tag e1 .. en) => e1:
                                             absVal = (absVal d1)
                                             envMod = Union (depVar d1)
                                           en:
                                             absVal = (absVal dn)
                                             envMod = Union (depVar dn)

note: The resultVar will always be Nothing.
      A node not in the heap representing a function is strange at least...

%%[8.unit
SEM GrExpr
  | Unit   loc . fVar2Var   = \s t         -> @lhs.setEnvVar t AV_Nothing (EnvUnion [s] Nothing)
               . fNode2Var  = \tag names t -> let absVals   = map sn2av names
                                                  resultVar = lookup tag @lhs.tag2resultVar
                                                  env       = @lhs.setEnvVar t
                                                                          (AV_Nodes [(tag, absVals)])
                                                                          (EnvTag tag names Nothing)
                                              in env
               . fVar2Node  = buildSelectElems @lhs.setEnvVar
               . fNode2Node = \st snms tt tnms -> let sn2mod = maybe EnvNoChange (\x -> EnvUnion [x] Nothing)
                                                      toEnvElem sn tn = if tn == getNr wildcardNr
                                                                        then return ()
                                                                        else @lhs.setEnvVar tn (sn2av sn) (sn2mod sn)
                                                  in zipWithM_ toEnvElem snms tnms -- note: st == tt
               . fillEnv    = genInfo @val.valInfo @lhs.targetInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
%%]

%%[8.selectVar hs
sn2av :: Maybe Int -> AbstractValue
sn2av = maybe AV_Basic (const AV_Nothing)

buildSelectElems :: (Variable -> AbstractValue -> AbstractEnvModifier -> Action) -> Variable -> GrTag -> [Variable] -> Action
buildSelectElems setEnvVar selectVar tag nms
  = let step (i, f) v     = (i+1, if v == getNr wildcardNr then f else f >> setEnvVar v AV_Nothing (EnvSelect selectVar tag i))
        (count, envElems) = foldl step (0, return ()) nms
    in envElems
%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%

store (Tag e1 .. en); -> \n              => n:
                                              absVal = newLocation
                                              envMod = NoChange
                                            newLocation:
                                              absVal  = Tag[(absVal e1), .., (absVal en)]
                                              heapMod = Tag[(depVar e1), .., (depVar en)] |_| resultVar(Tag)

%%[8.store
SEM GrExpr
  | Store  loc . (heapPointer, fillEnv, heapElem) = makeStore @lhs.setEnvVar
                                                              (flip lookup @lhs.tag2resultVar)
                                                              @lhs.heapPointer
                                                              @val.valInfo
                                                              @lhs.targetInfo
           lhs . heapList  = @heapElem : @lhs.heapList
%%]

%%[8.store hs
makeStore setEnvVar ftag2resultVar heapPointer valInfo targetInfo
    = let fNode2Var  tag names t = let absVals     = map sn2av names
                                       resultVar   = ftag2resultVar tag
                                       env         = setEnvVar t (AV_Locations [heapPointer]) envMod
                                       heap        = makeHeapElem heapPointer
                                                                 (AV_Nodes [(tag, absVals)])
                                                                 ((tag, names), resultVar)
                                       isApplyTag  = case tag of
                                                        GrTag_Lit GrTagApp _ _ -> True
                                                        otherwise              -> False
                                       (f,args)    = case names of
                                                        _:f:args  -> (fromJust' "store f" f
                                                                     , map (Left . fromJust' "store args")  args
                                                                     )
                                                        otherwise -> error "No lazy apply tag!"
                                       envMod      = if isApplyTag
                                                     then EnvLazyApp f args
                                                     else EnvNoChange
                                   in ( env, heap )
          fVar2Var   = error "Single variable in a store not allowed!"
          fVar2Node  = error "No location variable afer a store!"
          fNode2Node = error "No location variable afer a store! (And always store a node!)"
          (fillEnv, absHeap) = genInfo valInfo targetInfo fVar2Var fVar2Node fNode2Var fNode2Node
      in (heapPointer + 1, fillEnv, absHeap)
%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%

eval(l); -> \n              => n:
                                 absVal = AV_Nodes []
                                 envMod = Eval l

the next is not needed because of normalisation:

eval(l); -> \(Tag e1 .. en) => @eval@l:
                                 absVal = Nothing
                                 envMod = Eval l
                               e1:
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! 1
                               en:
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! n
%%[8.eval
SEM GrExpr
  | Eval   loc . fillEnv = case @lhs.targetInfo of
                             Left  n           -> @lhs.setEnvVar n (AV_Nodes []) (EnvEval (getNr @nm) @lhs.exceptVar)
                             Right (tag,names) -> error "NormForHPT not executed"
%%]

%%%%%%%%%%
%% Call %%
%%%%%%%%%%

foo a1 .. an; -> \n             => n:
                                     absVal = Nothing
                                     envMod = Union [@foo]

foo a1 ..an; -> \(Tag e1 .. en) => e1:
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! 1
                                   en:
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! n
%%[8.call
SEM GrExpr
  | Call  loc  .  resultVar   =  getNr @nm
               .  fillEnv     =  case @lhs.targetInfo of
                                     Left  n           -> @lhs.setEnvVar n (AV_Nodes []) (EnvUnion [@resultVar] Nothing)
                                     Right (tag,names) -> buildSelectElems @lhs.setEnvVar @resultVar tag names
               .  exceptions  =  @resultVar + 1 : @lhs.exceptions
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%

case node of (T e1 .. en)             => e1:
                                           absVal = Nothing
                                           envMod = node ! Tag ! 1
                                         en:
                                           absVal = Nothing
                                           envMod = node ! Tag ! n

the following is not needed because of normalisation
case (Tag d1 .. dn) of (Tag e1 .. en) => e1:
                                           absVal = (absVal d1)
                                           envMod = Union (depVar d1)
                                         en:
                                           absVal = (absVal dn)
                                           envMod = Union (depVar dn)

%%[8.alt
ATTR AllAlt [ valInfo: {NodeInfo (Maybe Int)} | | ]

SEM GrAlt
  | Alt  loc . fVar2Node  = buildSelectElems @lhs.setEnvVar
             . fNode2Node = error "NormForHPT not executed"
             . fVar2Var   = error "no variable in alternative pattern expected!"
             . fNode2Var  = error "no variable in alternative pattern expected!"
             . fillEnv    = genInfo @lhs.valInfo @pat.patInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
         lhs . fillEnv    = @fillEnv >> @expr.fillEnv
%%]

%%%%%%%%%%%%%%%%%%%%
%% Case and Catch %%
%%%%%%%%%%%%%%%%%%%%

We can have multiple arms in a case, how do we merge the result of each arm?

Since we normalise each case to end with a simple unit (e.g. unit v). So we
collect the last elements of the arms and join these afterwards.

We use the targetName of the wildcard variable so that these last equations and
partial collections are filtered afterwards.

%%[8.case
SEM GrAltL
  | Cons  lhs   .   fillEnv    =  do { @hd.fillEnv
                                     ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                     ; let (EnvUnion hdn _) = aeMod elem
                                     ; @tl.fillEnv
                                     ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                     ; let (EnvUnion tln _) = aeMod elem
                                     ; @lhs.setEnvVar @lhs.tmpVar AV_Nothing (EnvUnion (tln ++ hdn) Nothing)
                                     }
  | Nil   lhs   .   fillEnv    =  @lhs.setEnvVar @lhs.tmpVar AV_Nothing (EnvUnion [] Nothing)
SEM GrAlt
  | Alt  expr   .  targetInfo   =  Left @lhs.tmpVar

SEM GrExpr
  | Case   loc   .  fillEnv     =  case @lhs.targetInfo of
                                     Left resVar     -> do { elem <- @lhs.getEnvVar @lhs.tmpVar
                                                           ; @lhs.setEnvVar resVar AV_Nothing (aeMod elem)
                                                           }
                                     Right (tag,nms) -> error "No node expected after a case expression!"
           lhs   .  fillEnv     =  @altL.fillEnv >> @fillEnv
  | Catch  loc   .  targetInfo  =  Left @lhs.tmpVar
           lhs   .  fillEnv     =  do { @body.fillEnv
                                      ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                      ; let (EnvUnion bn _) = aeMod elem
                                      ; @handler.fillEnv
                                      ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                      ; let (EnvUnion hn _) = aeMod elem
                                      ;  case @lhs.targetInfo of
                                           Left resVar     -> @lhs.setEnvVar resVar AV_Nothing (EnvUnion (bn ++ hn) Nothing)
                                           Right (tag,nms) -> error "No node expected after a Catch expression!"
                                      ; @exceptEq
                                      }
%%]

%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%

ffi "primFoo"; \(Tag e1 en)  => e1:
                                  absVal = prim(Foo) ! Tag ! 1
				  envMod = NoChange
                                en:
                                  absVal = prim(Foo) ! Tag ! n
				  envMod = NoChange
ffi "primFoo"; \r            => r:
                                 absVal  = prim(Foo)

ffi "foo"; \(Tag e1 e2)      => note: (Tag == Unboxed)
                                e1: Basic
                                en: Basic

%%[8.ffi
SEM GrExpr
  | FFI  loc . primAbsVal = primAV @nm
             . prim       = case @lhs.targetInfo of
                              Left nm          -> @lhs.setEnvVar nm @primAbsVal EnvNoChange
                              Right (tag, nms) -> let (AV_Nodes nodes) = @primAbsVal
                                                      tagElementsAV    = fromJust' "FFI" $ lookup tag nodes
                                                      makeAV teAV nm   = @lhs.setEnvVar nm teAV EnvNoChange
                                                  in zipWithM_ makeAV tagElementsAV nms
             . ffi        = case @lhs.targetInfo of
                              Left  nm         -> error "FFI should be followed by an unboxed node pattern"
                              Right (tag, nms) -> mapM_ (\e -> @lhs.setEnvVar e AV_Basic EnvNoChange) nms
             . fillEnv    = if isPrim @nm then @prim else @ffi
%%]

Note: we have the ctable, can we do something with that?
      e.g. we could get the result Tags from it. If we save result type for a FFI.

%%[8.prim hs import(Primitives)
%%]

%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%

Every call to apply equals to an rewrite using the apply map. We must join all
these apply into one argument, so we join them in a list and put them in the
equation array at the top level.in a list and put them in the equation array at
the top level.in a list and put them in the equation array at the top level.in
a list and put them in the equation array at the top level.

apply (P2upto  ) a => (P1upto a)
apply (P1upto a) b => (Fupto  a b)


apply (P/1/apply f) a == apply f a  -- a P/1/apply should not occur? right?!

notes: - all tags should be of type Partial application
       - all tags should miss the same number of arguments

eval (Fapply a b)

%%[8.apply
SEM GrExpr
  | App    loc . fillEnv  = case @lhs.targetInfo of
                              Right (tag, nms) -> error "Apply bound to pattern?!"
                              Left  nm         -> let makeAppArgInfo = map mkAppInfo
                                                      mkAppInfo :: NodeInfo (Maybe Int) -> Either Variable AbstractEnvModifier
                                                      mkAppInfo l = case l of
                                                                        Left  v  -> Left v
                                                                        Right n  -> error $ "Node in apply argument not implemented: " ++ show n
                                                  in @lhs.setEnvVar nm (AV_Nodes []) (EnvApp (getNr @nm) (makeAppArgInfo @argL.valsInfo) @lhs.exceptVar)

%%]

%%[8.applyMap
ATTR GrModule GrAGItf [ | | applyMap : {AssocL GrTag (Either GrTag Int)} ]
SEM GrModule
  | Mod     loc . applyMap = let rewrite (EvApTagVar (HNPos f)) = Right f
                                 rewrite (EvApTagTag t        ) = Left  t
                             in [ (t, rewrite v) | ((t,_), v) <- @applyTagMp ]
%%]

%%%%%%%%%%%
%% Fetch %%
%%%%%%%%%%%

Fetch sould not occur outside eval. And eval is skipped.

%%[8.fetch
SEM GrExpr
  | Fetch  loc . err      = error "no fetch expected"
               . fillEnv  = @err
               . absHeap  = @err
%%]

%%%%%%%%%%%%
%% Update %%
%%%%%%%%%%%%

Update sould not occur outside eval. And eval is skipped.

%%[8.update
SEM GrExpr
  | Update  loc . err      = error "no update expected"
                . fillEnv  = @err
                . absHeap  = @err
%%]

%%%%%%%%%%%
%% Throw %%
%%%%%%%%%%%

%%[8.throw
SEM GrExpr
  | Throw  loc  . exceptions  =  getNr @nm : @lhs.exceptions
%%]

%%%%%%%%%%%
%% Catch %%
%%%%%%%%%%%

%%[8.catch
SEM GrExpr
  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEq    =  @lhs.setEnvVar @handlerVar (AV_Locations []) (EnvUnion @body.exceptions Nothing)
                   . handlerVar  =  getNr @arg
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Non local exceptions %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)

%%[8.catch
ATTR AllGrExpr [ exceptVar: Variable | | ]
SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   = @resultVar + 1
          loc     . exceptEq    =  @lhs.setEnvVar @exceptVar (AV_Locations []) (EnvUnion @expr.exceptions Nothing)
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllGrNT [ | | actualsEnv USE {.} {id} : {[(Int, [Maybe Int])] -> [(Int, [Maybe Int])]} ]
ATTR AllBind [ allActuals: {[(Int, [Maybe Int])]} | | ]

SEM GrExpr
  | Store Unit  loc  .  fGenActuals  = \tag mns n -> let args      = tail mns -- first element is the size of the rest of the node
                                                         resultVar = lookup tag @lhs.tag2resultVar
                                                         actuals r = ((r, args) :)
                                                     in maybe id actuals resultVar
                loc  .  actualsEnv   = case (@val.valInfo, @lhs.targetInfo) of
                                           (Right (st,snms), Left tn) -> @fGenActuals st snms tn
                                           otherwise                  -> id
  | Call        loc  .  actualsEnv   = ((@resultVar, @argL.depVars) :)

SEM GrModule
  | Mod       bindL  .  allActuals   = @bindL.actualsEnv []

SEM GrBind
  | Bind      loc    .  bindActuals  = transpose [ actuals | (resVar, actuals) <- @lhs.allActuals, resVar == @resultVar ]
                     .  fillEnvBind  = let envElem (formal, i) actuals = @lhs.setEnvVar (getNr formal) AV_Nothing (EnvUnion [ actual | Just actual <- actuals] (Just . @applySelect $ i))
                                       in zipWithM_ envElem (zip @argNmL [1..]) (if null @bindActuals then replicate (length @argNmL) [] else @bindActuals)
                     .  actualsEnv   = if @prune then id else @expr.actualsEnv
                     .  applySelect  = EnvSelect @lhs.tmpVar (GrTag_Var @nm)
%%]

%%%%%%%%%%%%%
%% Globals %%
%%%%%%%%%%%%%

The globals look like the expression

store (Tag f1 fn); \bla ->

%%[8.global
SEM GrGlobal
  | Global  loc  .  (heapPointer, fillEnv, heapElem)  =  makeStore @lhs.setEnvVar
                                                                (flip lookup @lhs.tag2resultVar)
                                                                @lhs.heapPointer
                                                                @val.valInfo
                                                                (Left $ getNr @nm)
            lhs  .  heapList                          =  @heapElem : @lhs.heapList
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
--revLookup :: (Eq b) => [(a,b)] -> b -> Maybe a
revLookup l e = lookup e (map swap l)
	where swap = uncurry (flip (,))

getCafVar m k = getNr . fromJust' ("cafVar not found " ++ show k) $ Map.lookup k m

fromJust' _ (Just a ) = a
fromJust' m (Nothing) = error $ "fromJust: " ++ m

makeHeapElem l initial eq = (l, AbstractHeapElement { ahBaseSet = initial, ahMod = eq})
%%]

% vim:et:ts=4:ai:
