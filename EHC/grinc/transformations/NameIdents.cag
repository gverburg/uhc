% $Id$

Rename numbered identifiers to their names.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../../GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(GRINCCommon, EHCommon, GrinCode, Data.Array.IArray) export(nameIdents)
type IdentNameMap = Array Int HsName

nameIdents :: IdentNameMap -> GrModule -> GrModule
nameIdents m grmod = let t        = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                 (Inh_GrAGItf { names_Inh_GrAGItf = m })
                     in grTrf_Syn_GrAGItf t
%%]

%%[8.lookup hs
findNewVar names nm@(HNPos i) = if i `inBetween` bounds names
                                then names ! i
                                else if wildcardNr == nm
                                then wildcardNm
                                else if applyNr == nm
                                then applyNm
                                else if evalNr == nm
                                then evalNm
                                else nm
    where
    inBetween n (l, h) = n >= l && n <= h
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]

%%[8.rename
ATTR GrAGItf AllGrNT  [ names: IdentNameMap | | ]

SEM GrPat
  | Node  lhs  .  grTrf     = GrPat_Node @tag.grTrf (map (findNewVar @lhs.names) @fldL)
  | Var   lhs  .  grTrf     = GrPat_Var  (findNewVar @lhs.names @nm)

SEM GrBind
  | Bind  loc  .  bindName  = findNewVar @lhs.names @nm
               .  newNames  = map (findNewVar @lhs.names) @argNmL
          lhs  .  grTrf     = GrBind_Bind @bindName @newNames @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (findNewVar @lhs.names @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (findNewVar @lhs.names @nm)

SEM GrExpr
  | App Eval Call Fetch Update  loc  .  newName  =  findNewVar @lhs.names @nm
  | App                         lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                        lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                        lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                       lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset
  | Update                      lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf
  | FFI                         lhs  .  grTrf    =  GrExpr_FFI     @nm (map (findNewVar @lhs.names) @argL)

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @baseName @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.names) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.names) @applyTagMp
%%]

%%[8 hs
newMap map (k, EvApTagVar nm) = (k, EvApTagVar $ findNewVar map nm)
newMap map x                  = x
%%]

% vim:ts=4:et:ai:
