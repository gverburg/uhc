% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../../GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import("Data.Set as Set")
%%]

%%[8 hs import(EHCommon, GRINCCommon, GrinCode) export(dropUnusedBindings)
dropUnusedBindings :: Bool -> GrModule -> GrModule
dropUnusedBindings ds grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                 (Inh_GrAGItf { dropSpecial_Inh_GrAGItf = ds })
                            in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

ATTR GrAGItf GrModule [ dropSpecial: Bool | | ]
%%]

%%[8.retrieveUsedBindings
ATTR AllBind AllGrExpr [ tag2binding: {[(GrTag, HsName)]} | usedBindings: {Set HsName} | ]

SEM GrModule
  | Mod  loc    .  evalMap       =  [ (k, v)                         | ((k, _), EvApTagVar v) <- @evalTagMp  ]                
                .  applyMap      =  [ (k, findBindName @searchMap a) | ((k, _), a           ) <- @applyTagMp ]
                .  searchMap     =  [ (k, v)                         | ((k, _), v)            <- @applyTagMp ]
         bindL  .  tag2binding   =  @applyMap ++ @evalMap
                .  usedBindings  =  Set.emptySet

SEM GrExpr
  | Call         lhs  .  usedBindings  =  Set.addToSet @lhs.usedBindings @nm
  | Store Unit   loc  .  mbBindName    =  @val.mbTag >>= flip lookup @lhs.tag2binding
                 lhs  .  usedBindings  =  maybe @lhs.usedBindings (Set.addToSet @lhs.usedBindings) @mbBindName

SEM GrVal [ | | mbTag: {Maybe GrTag} ]
  | Node Tag      lhs  .  mbTag         = Just @tag.grTrf
  | * - Node Tag  lhs  .  mbTag         = Nothing
%%]


%%[8.findBindName hs
findBindName map e = case e of
    EvApTagTag  t ->  maybe (error $ "could not find bind name for tag " ++ show t) (findBindName map) (lookup t map)
    EvApTagVar  v ->  v
    EvApTagUnit   ->  error "unit tag not expected"
%%]

%%[8.dropUnusedBindings
ATTR AllBind [ allUsedBindings: {Set HsName} | | ]

SEM GrModule
  | Mod  loc    .  specialNames     =  [evalNm, evalNr,  applyNm, applyNr]
                .  modifier         =  if @lhs.dropSpecial then Set.delFromSet else Set.addToSet
         bindL  .  allUsedBindings  =  foldl @modifier @bindL.usedBindings @specialNames
         
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  not $ elementOf @nm @lhs.allUsedBindings
  | Rec   lhs  . dropBinding  =  @bindL.count == 0


SEM GrBindL [ | | count: Int ]
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf
                            else @hd.grTrf : @tl.grTrf
               .  count  =  1 + @tl.count          
  | Nil   lhs  .  count  =  0
%%]

% vim:ts=4:et:ai:
