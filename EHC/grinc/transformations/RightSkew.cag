% $Id$

Restores the right skewed property of the bind (Seq) operator:
	In a GrExpr_Seq the expr field shall not contain a GrExpr_Seq constructor.

(m ; \a -> k a) ; \b -> h b  =>  m; \a -> (k a ; \b -> h b)

Seq (Seq m a k) b h
Seq m a (Seq k b h)

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(EHCommon, FiniteMap, GrinCode) export(lowerGrin)
rightSkew :: GrModule -> (GrModule, Bool)
rightSkew grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                    in (grTrf_Syn_GrAGItf t, active_Syn_GrAGItf t)
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ] 
ATTR AllExpr [ | | copy:  SELF     ]
ATTR AllGrExpr AllBind GrModule GrAGItf [ | | active USE {||} {False} : Bool ]
%%]

The copy is needed to implement the transformation in a top down fashen rather
than bottom up. This saves needless movements.  (If the tree is left skewed
more than one deep.)

Seq (Seq m a k) b h
Seq m a (Seq k b h)

%%[8.rightSkew
SEM GrExpr
  | Seq  lhs  . (active, grTrf) = case @expr.copy of
                                      GrExpr_Seq e p b -> (True , GrExpr_Seq e p (GrExpr_Seq b @pat.grTrf @body.grTrf))
                                      otherwise        -> (@active, @grTrf)
%%]

% vim:ts=4:et:
