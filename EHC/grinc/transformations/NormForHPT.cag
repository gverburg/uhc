% $Id$

Normalisation for the Heap-points-to analysis

- A case alternative must end with a simple unit (e.g. "unit var")

- The scrutinized expression must be a variable, not a complete node.

- The following locations in the code must contain a simple pattern (e.g \var)
    - After an eval or apply call 
    - After a case statement

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../../GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(EHCommon, GrinCode) export(normForHPT)
normForHPT :: Int -> GrModule -> (Int, GrModule)
normForHPT unique grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) 
                                               (Inh_GrAGItf { unique_Syn_GrAGItf = unique })
                          in (unique_Syn_GrAGItf t, grTrf_Syn_GrAGItf t)

newVar :: Int -> (HsName, Int)
newVar u = (HNPos u, u+1)

newVar' :: Bool -> Int -> (HsName, Int)
newVar' b u = (undefined, u)

newGrIdent :: HsName -> (GrVal, GrPat)
newGrIdent n = (GrVal_Var n, GrPat_Var n)
%%]

%%[8
ATTR GrAGItf [ | unique: Int | grTrf: GrModule ]
ATTR AllGrNT [ | unique: Int | grTrf: SELF ]
%%]

Change last expression of binding to last of alternative (or binding)

%%[8.lastOfAlt include(../GrLastExpr)
GrExpr
  | Case    altL . hasNext   = False
%%]

Keep track if we are inside an alternative

%%[8.inAlt
ATTR AllGrExpr [ isInAlt: Bool | | ]

SEM GrBind
  |  Bind   expr  .  isInAlt  =  False

SEM GrExpr
  |  Case   altL  .  isInAlt  =  True
%%]

Is the statement a simple unit

%%[8.simpleUnit
GrExpr
  | Unit      loc  .  simpleUnit  =  case @val.grTrf of
                                        Var _     -> True
                                        otherwise -> False
  | * - Unit  loc  .  simpleUnit  =  False
%%]

Transform the last statment in an alternative which is no simple unit

%%[8.lastUnit
GrExpr
  | Unit  loc  .  doUnitTrans    = @lhs.isInAlt && @isLastExpr && (not @simpleUnit)
               .  (var, unique)  = newVar' @doUnitTrans @lhs.unique
               .  (val', pat')   = newGrIdent @var
          lhs  .  gtTrf          = if @doUnitTrans
                                   then GrExpr_Seq @grTrf @pat' (GrExpr_Unit @var')
                                   else @grTrf
%%]

The scrutinizer must be a variable

%%[8.scrutinizer
GrExpr
  | Case  loc  .  doCaseTrans    = case @val.grTrf of
                                       GrVal_Var _ -> False
                                       otherwise   -> True
          loc  .  (var, unique)  = newVar' @doCaseTrans @lhs.unique
               .  (val', pat')   = newGrIdent @var
          lhs  .  grTrf          = if @doCaseTrans
                                   then GrExpr_Seq (GrExpr_Unit @val.grTrf) @pat'
                                                   (GrExpr_Case @val' @altL.grTrf)
                                   else @grTrf
%%]

Which expressions need a simple pattern after the statement

%%[8.needSimplePattern
SEM GrExpr [ | |  needsSimplePattern : Bool ]
  | Case Eval Apply      lhs  . needsSimplePattern = True
  | * - Case Eval Apply  lhs  . needsSimplePattern = False
%%]

%%[8.isSimplePattern
SEM GrPat [ | | isSimplePattern: Bool ]
  | Var      loc . isSimplePattern  =  True
  | * - Var  loc . isSimplePattern  =  False
%%]

All patterns which does not contain a simple pattern after these expressions
are rewritten into a copy

%%[8.simplePattern
SEM GrExpr
  | Seq  loc  .  doPatternTrans  = @expr.needsSimplePattern && not @pat.isSimplePattern
              .  (var, unique)   = newVar' @doPatternTrans @lhs.unique
              .  (val', pat')    = newGrIdent @var
         lhs  .  grTrf           = if @doPatternTrans
                                   then GrExpr_Seq @expr.grTrf @val'
                                                   (GrExpr_Seq (GrExpr_Unit @pat') @pat.grTrf @body.grTrf)
                                   else @grTrf
%%]

% vim:ts=4:et:
