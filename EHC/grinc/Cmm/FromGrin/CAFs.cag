% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%
%% Collecting CAF %%
%%%%%%%%%%%%%%%%%%%%

CAF are special treated. For each CAF a FNode must be present in the heap.  A
CAF is a GRIN function which takes no parametes. every CAF has a variable named
the same as GRIN function that maps to a FNode. Which, if evaluated, calls the
corresponding GRIN function.

FNode are 1 element long, so they always have the standard node layout.

%%[8
ATTR GrAGItf GrModule  [ cafMap: CafMap | | ]
ATTR GrModule [ | | cafNodeNames USE {++} {[]}: {[(CmmName, CmmName)]} ]
%%]

%%[8
SEM GrModule
  | Mod       loc . bind2tagname    = [ (b, n) | ((GrTag_Lit _ _ n,_),EvApTagVar b) <- @evalTagMp ]
              loc . cafNodeNames    = let foo (b,v) = (cmmName' v, cafNode4name . cmmName' . fromJust' ("no caf var for " ++ show b) $ lookup b @bind2tagname)
	                              in map foo $ Map.toList @lhs.cafMap
                  . sectionCAFNodes = let data2section d    = lift (CmmToplevel_Section "data") [CmmSectionElement_Data d]
                                          zeros             = replicate 3 (int 0)
                                          cmmCAFNode (i,n)  = [ CmmDatum_Label i, reserve 4 valType $ listInit (cmmVar n : zeros)]
                                      in  data2section (CmmDatum_Label "@CAF_Nodes" : concatMap cmmCAFNode @cafNodeNames)
%%]
