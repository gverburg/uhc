% $Id$

This transformation drops all not directly called functions. Because only
direct calls are counted, this should be used after inlining eval and apply
calls. (When no hidden function calls exists anymore.)

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import("../GrinCodeAbsSyn")
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.DropUnusedBindings import("qualified Data.Set as Set",Data.Graph)
type EdgeF = [Edge] -> [Edge]
%%]

%%[8 hs import(EHCommon, GRINCCommon, GrinCode) export(dropUnusedBindings)
dropUnusedBindings :: HsName -> GrModule -> GrModule
dropUnusedBindings e grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                  (Inh_GrAGItf { entry_Inh_GrAGItf = e })
                             in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

ATTR GrAGItf GrModule [ entry: HsName | | ]
%%]

%%[8.graphInfo
ATTR AllBind            [ | | biggest USE {`max`} {minBound}: Int  smallest USE {`min`} {maxBound}: Int ]
ATTR AllGrExpr          [ bindNr: Int | | ]
ATTR AllBind AllGrExpr  [ | | edges USE {.} {id}: EdgeF ]

SEM GrBind
  | Bind  loc   .  bindNr    = getNr @nm
          lhs   .  smallest  = @bindNr
                .  biggest   = @bindNr

SEM GrExpr
  | Call         lhs  .  edges  =  ((@lhs.bindNr, getNr @nm) :)
%%]

%%[8.dropUnusedBindings
ATTR AllBind [ lifeBindings: {Set.Set Int} | | ]

SEM GrModule
  | Mod  loc    .  graph         =  buildG (@bindL.smallest, @bindL.biggest) (@bindL.edges [])
                .  lifeBindings  =  Set.fromList $ reachable @graph (getNr @lhs.entry)
         
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  not (@bindNr `Set.elementOf` @lhs.lifeBindings)
  | Rec   lhs  . dropBinding  =  @bindL.count == 0


SEM GrBindL [ | | count: Int ]
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf
                            else @hd.grTrf : @tl.grTrf
               .  count  =  if @hd.dropBinding then @tl.count else 1 + @tl.count
  | Nil   lhs  .  count  =  0
%%]

% vim:ts=4:et:ai:
