% $Id$

TODO: Complete Left unit implementation

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import("../GrinCodeAbsSyn")
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.CopyPropagation import(EHCommon, GRINCCommon, GrinCode, Data.Maybe) export(propagate)
propagate :: GrModule -> (Bool, GrModule)
propagate grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                       (Inh_GrAGItf)
                  in (isTrf_Syn_GrAGItf t, grTrf_Syn_GrAGItf t)
%%]


%%[8
ATTR GrAGItf [ | | grTrf: GrModule  isTrf: Bool                   ]
ATTR AllGrNT [ | | grTrf: SELF      isTrf USE {||} {False}: Bool  ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Value Information %%%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
-- fix empty patterns and values are not handled cleanly.
genInfo v p nnf nvf vnf vvf e = case (v,p) of
    (GrVal_Node vt vls, GrPat_Node pt nms) -> nnf vt vls pt nms
    (GrVal_Tag  vt    , GrPat_Node pt nms) -> nnf vt  [] pt nms
    (GrVal_Node vt vls, GrPat_Tag  pt    ) -> nnf vt vls pt  []
    (GrVal_Tag  vt    , GrPat_Tag  pt    ) -> nnf vt  [] pt  []
    (GrVal_Node vt vls, GrPat_Var  pn    ) -> nvf vt vls pn
    (GrVal_Tag  vt    , GrPat_Var  pn    ) -> nvf vt  [] pn
    (GrVal_Var  vn    , GrPat_Node pt nms) -> vnf vn     pt nms
    (GrVal_Var  vn    , GrPat_Tag  pt    ) -> vnf vn     pt  []
    (GrVal_Var  vn    , GrPat_Var  pn    ) -> vvf vn     pn
    (GrVal_Empty      , _                ) -> e
    (_                , GrPat_Empty      ) -> e
%%]

%%[8.valueInfo
ATTR GrExpr [ | | unitInfo : {Maybe GrVal} ]

SEM GrExpr
  | Unit          loc  .  unitInfo = Just @val.grTrf
  | Seq           loc  .  unitInfo = @expr.unitInfo
  | * - Unit Seq  loc  .  unitInfo = Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%
%%% Right Unit law %%%
%%%%%%%%%%%%%%%%%%%%%%

change terms like '<m>; \x -> unit x' => '<m>'

one form possible:
    seq v x (unit x)           => v

example:    
    seq f 8 (seq (unit 8) 13 (seq (unit 13) p e))

   inner: lhs.grTrf = seq f  8 (seq (unit  8) p e)
   outer: lhs.grTrf = seq f 13 (seq (unit 13) p e)

We give the v and x to the next element. 

%%[8.rightUnit hs
makeRightUnitExpr seqPat unitVal seqExpr = 
    do { p <- seqPat
       ; e <- seqExpr
       ; v <- unitVal
       ; let vvf vn pn          = if vn == pn
                                  then Just e
                                  else Nothing
             nnf vt vls pt pls  = let sameArgs     = zipWith sameArg vls pls
                                      sameArg v p  = case v of
                                                         GrVal_Var n -> n == p
                                                         otherwise   -> False
                                  in if vt == pt && and sameArgs
                                     then Just e
                                     else Nothing
             vnf vn     pt pls  = Nothing
             nvf vt vls pn      = Nothing
       ; genInfo v p nnf nvf vnf vvf Nothing
       }
%%]

seqExpr ; \seqPat -> body  --- seqExpr and seqPat are given to the body.

%%[8.rightUnit
ATTR GrExpr [ seqExpr: {Maybe GrExpr}  seqPat: {Maybe GrPat} | | rightTrf: {Maybe GrExpr} ]

SEM GrExpr
  |  Seq   lhs   .  grTrf       =  maybe @fromLeftUnit id @body.rightTrf
                 .  isTrf       =  @isRightTrf || @expr.isTrf || @body.isTrf || @isLeftTrf
           body  .  seqExpr     =  Just @expr.grTrf
                 .  seqPat      =  Just @pat.grTrf
           expr  .  seqExpr     =  Nothing
                 .  seqPat      =  Nothing
           loc   .  isRightTrf  =  isJust @body.rightTrf
  |  Unit  lhs   .  rightTrf    =  makeRightUnitExpr @lhs.seqPat @unitInfo 
                                                   @lhs.seqExpr
  | * - Unit  lhs  .  rightTrf = Nothing

SEM GrAlt
  | Alt   expr  .  seqExpr  = Nothing
                .  seqPat   = Nothing
SEM GrBind
  | Bind  expr  .  seqExpr  = Nothing
                .  seqPat   = Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%
%%% Left Unit law %%%
%%%%%%%%%%%%%%%%%%%%%


unit (t a1 an); \(t' a1' an') -> e => [t/t' a1/a1' an/an']
unit v        ; \(t' a1' an') -> e => Do not propogate, only if a1 .. an do not occur in e. (do we lose tag info in that case?)
unit (t a1 an); \v'           -> e => [(t a1 an)/v']
unit v        ; \v'           -> e => [v/v']


%%[8 hs import("qualified Data.Map as Map")
type ValueMap = (Map.Map HsName GrVal, Map.Map HsName GrTag)
%%]

%%[8.leftUnit
ATTR AllExpr [ valueMap: ValueMap | | ]

SEM GrBind
  | Bind  expr  .  valueMap  =  (Map.empty, Map.empty)
%%]

%%[8.leftUnit hs
addLeftUnitSubst seqPat unitVal (valMap, tagMap) =
    do { let p = seqPat
       ; v <- unitVal
       ; let vvf vn pn          = Just (Map.insert pn (GrVal_Var vn) valMap, tagMap)
             nnf vt vls pt pls  = Nothing
             vnf vn     pt pls  = Nothing
             nvf vt vls pn      = Just (Map.insert pn (GrVal_Node vt vls) valMap, tagMap)
             e                  = Nothing
       ; genInfo v p nnf nvf vnf vvf e
       }
%%]

%%[8.leftUnit
SEM GrExpr
  | Seq  loc   .  leftSubst     = addLeftUnitSubst @pat.grTrf @expr.unitInfo @lhs.valueMap
               .  isLeftTrf     = isJust @leftSubst
               .  fromLeftUnit  = if @isLeftTrf then @body.grTrf else @grTrf
         body  .  valueMap      = maybe @lhs.valueMap id @leftSubst
%%]

%%[8.applySubstitutions
SEM GrVal
  | Var  lhs  .  grTrf  =  Map.findWithDefault @grTrf @nm (fst @lhs.valueMap)
SEM GrTag
  | Var  lhs  .  grTrf  =  Map.findWithDefault @grTrf @nm (snd @lhs.valueMap)
SEM GrExpr
  | Fetch Update  loc  .  mbVal     =  Map.lookup @nm (fst @lhs.valueMap)
                       .  mbName  =  do { n <- @mbVal
                                        ; case n of
                                              GrVal_Var v -> Just v
                                              _           -> Nothing
                                        }
                       . name     = maybe @nm id @mbName

  | Fetch   lhs  . grTrf  = GrExpr_Fetch  @name @mbOffset
  | Update  lhs  . grTrf  = GrExpr_Update @name @val.grTrf
%%]

% vim:ts=4:et:ai:
