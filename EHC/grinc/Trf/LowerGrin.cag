% $Id$

Some transformations are needed to allow easy code generation for GRIN
  - variables can refer only to pointers or basic values (tags or integers)
  - case statement on tag only (not on a complete node)
later:
  - fetch must have offset attached
  - update need to have a known tag

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../../GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.LowerGrin import(EHCommon, FiniteMap, GrinCode) export(lowerGrin)
lowerGrin :: GrModule -> GrModule
lowerGrin grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                  in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]
%%]

%%%%%%%%%%%%%
%% TagSize %%
%%%%%%%%%%%%%

For now we use the maximum tagsize. This will change as soon as we have
heap-point-to analysis

%%[8
ATTR AllGrNT [ maxTagSizeAll: {Int} | | maxTagSize USE {`max`} {0}: Int ]

SEM GrAGItf
  | AGItf  module . maxTagSizeAll = @module.maxTagSize

-- first element in fldL is arity, which must be added to the size.
-- Node size is arity + 2 (for tag) so result in fldL.len + 1
-- But for now we keep the first field element
SEM GrVal
  | Node      lhs . maxTagSize = @fldL.len + 1
  | NodeAdapt lhs . maxTagSize = error "cannot handle NodeAdapt"

ATTR GrValL [ | | len: {Int} ]
SEM GrValL
  | Cons lhs . len = 1 + @tl.len
  | Nil  lhs . len = 0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Locations of Patterns and values %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Since GrVal is not really structured, we need to know if we are inside a Node
already.  For case simplifying we must know whether the GrPat and GrVal are in
a case or not.

%%[8
ATTR GrVal GrValL AllAdapt GrPat GrPatL GrAlt GrAltL [ isInCase: {Bool} | | ]
SEM GrExpr
  | * - Case loc  . isInCase = False
  | Case     loc  . isInCase = True

ATTR GrVal GrValL AllAdapt [ isInNode: {Bool} | | ]
SEM GrExpr  
  | *        loc  . isInNode = False
SEM GrVal
  | Node     fldL . isInNode = True
             fldL . isInCase = False

-- TODO: what must stand here?
SEM GrSplit
  | Sel      loc  . isInNode = True
                  . isInCase = False
%%]


%%%%%%%%%%%%%%%%%%%
%% Vectorisation %%
%%%%%%%%%%%%%%%%%%%

New names are generated by suffixing the name with Tag and field numbers
TODO: is this name generation correct (clashes?!)

%%[8 hs
newNames :: HsName -> Int -> [HsName]
newNames base count | count == 0 = []
                    | otherwise  = suffix "_Tag" : map (\n -> suffix $ "_Field" ++ show n) [1..(count-1)]
	where
	suffix = hsnSuffix base

fromJust :: String -> Maybe a -> a
fromJust s m = case m of
  Just a  -> a
  Nothing -> error $ "fromJust: " ++ s

isJust :: Maybe a -> Bool
isJust m = case m of
  Just _  -> True
  Nothing -> False
  
%%]


CAF variables have the same name as the bindings. These variables are locations
and must not change in the vectorisation transformation.  Every binding has as
arguments a set of locations. The only exception is apply.

These two together are the initial location variables of the body of a binding.

%%[8
ATTR AllBind [ allCafNames : {[HsName]} | | cafNames USE {++} {[]}: {[HsName]} ]

SEM GrBind
  | Bind  loc   . cafNames    = if null @argNmL then [@nm] else []

SEM GrModule
  | Mod   bindL . allCafNames = @bindL.cafNames

SEM GrBind
  | Bind  loc  . (vectorArg,locArgs) = let (va:las) = @argNmL
                                       in (va, las)
               . argumentLocs        = if @nm == HNm "apply" 
                                       then @locArgs
                                       else @argNmL
          expr . locations           = @argumentLocs ++ @lhs.allCafNames
  
%%]

Vectorisation is not done on all places. Location variables are pointers and
should be left alone.

%%[8
ATTR AllGrExpr [ | locations: {[HsName]} | ]
ATTR AllGrExpr [ | | returnsLocation USE {||} {False} : {Bool} ]
ATTR GrVal GrPat [ | | varName: {Maybe HsName} ]

SEM GrVal
  | Var      lhs . varName = Just @nm
  | * - Var  lhs . varName = Nothing

SEM GrPat
  | Var      lhs . varName = Just @nm
  | * - Var  lhs . varName = Nothing
  

SEM GrExpr
  | Store                lhs  . returnsLocation  = True
  | Unit                 lhs  . returnsLocation  = @val.varName `maybeElem` @lhs.locations
  | * - Case Store Unit  lhs  . returnsLocation  = False
  | Seq                  body . locations        = if @expr.returnsLocation 
                                                   then fromJust "GrExpr_Seq failed" @pat.varName : @expr.locations
                                                   else @expr.locations
%%]

Rename all non location patterns \v to \(t f1 f2 fl)
%%[8
ATTR GrPat [ | | newPat: {GrPat} ]
SEM GrPat
  | Var       loc . (tn, fldnL)  = let (tn:fldnL) = newNames @nm @lhs.maxTagSizeAll
                                   in (tn, fldnL)
              lhs . newPat        = GrPat_Node (GrTag_Var @tn) @fldnL
  | * - Var   lhs . newPat        = @grTrf


SEM GrExpr
  | Seq     loc  . patNode      = if @expr.returnsLocation then @pat.grTrf else @pat.newPat
	    body . grNodeSubst  = if @expr.returnsLocation then @lhs.grNodeSubst else @pat.grNodeSubst
            lhs  . grTrf        = GrExpr_Seq @expr.grTrf @patNode @body.grTrf
%%]

%%[8 hs
maybeElem :: Eq a => Maybe a -> [a] -> Bool
maybeElem (Nothing) _  = False
maybeElem (Just v ) ls = v `elem` ls
%%]

Substitute variable uses.

In a case we transform from the maximal node size of the scrutinized value to
the maximal node size in each alternative. (see below)

%%[8
ATTR AllGrNT [ grNodeSubst : {FiniteMap HsName GrVal} | |                                        ]
ATTR GrPat   [                                        | | grNodeSubst : {FiniteMap HsName GrVal} ]


SEM GrAGItf
  | AGItf    module . grNodeSubst = emptyFM

-- An apply has one argument which shoud be vectorised
SEM GrBind
  | Bind     expr   . grNodeSubst = let (tn:fldnL) = @newVectorArgs
                                        vars       = map GrVal_Var fldnL
                                    in if @nm == HNm "apply"
                                       then addToFM @lhs.grNodeSubst @vectorArg
                                            (GrVal_Node (GrTag_Var tn) vars)
                                       else @lhs.grNodeSubst

SEM GrPat
  | Var      lhs . grNodeSubst = addToFM @lhs.grNodeSubst @nm (GrVal_Node (GrTag_Var @tn) (map GrVal_Var @fldnL))

SEM GrVal
  | Var      loc . maybeNode   = lookupFM @lhs.grNodeSubst @nm
                 . node        = maybe @grTrf id @maybeNode

SEM GrExpr
  | Eval     loc . maybeNode   = lookupFM @lhs.grNodeSubst @nm
                 . newName     = maybe @nm (\(GrVal_Var nm) -> nm) @maybeNode
             lhs . grTrf       = GrExpr_Eval @newName
%%]

For apply we need to change the first argument in a list of arguments

%%[8
ATTR AllGrNT [ | | copy: SELF ]

SEM GrBind
  | Bind  loc  . newVectorArgs  = newNames @vectorArg @lhs.maxTagSizeAll
          loc  . applyArguments = @newVectorArgs ++ @locArgs
          lhs  . grTrf          = if @nm == HNm "apply"
                                  then GrBind_Bind @nm @applyArguments @expr.grTrf
                                  else @grTrf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Case simplification %%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
-- replace patterns in case with Tag only
SEM GrVal
  | Node          loc  . node     = @grTrf
  | Var Node      lhs  . grTrf    = let tag = case @node of
                                                GrVal_Node t _ -> GrVal_Tag t
                                                otherwise        -> error $ "Not a node in case: " ++(show @node)
                                    in if @lhs.isInCase then tag else @node

SEM GrPat
  | Node          lhs  . grTrf       = if @lhs.isInCase then GrPat_Tag @tag.grTrf else @grTrf


-- return the fields of pattern and value to the Alternative node

ATTR AllAlt [ varNode: {GrVal} varName: {Maybe HsName} | | ]

ATTR GrVal [ | | varNode: {GrVal} ]

SEM GrVal
  | Node Var      lhs  . varNode = if @lhs.isInCase then @node else undefined
  | * - Node Var  lhs  . varNode = undefined

ATTR GrPat [ | | patFieldL: {[HsName]} ]

SEM GrPat 
  | Node          lhs  . patFieldL   = @fldL
  | Tag           lhs  . patFieldL   = []
  | * - Node Tag  lhs  . patFieldL   = error "Only Node or Tag values expected in a case"


-- add the substitutions for the case alternatives
SEM GrAlt
  | Alt           expr . grNodeSubst = let (GrVal_Node t l) = @lhs.varNode -- if failed: no node in a case
                                           mappings         = listToFM $ zipWith (\o n -> (o, n)) @pat.patFieldL l
                                           newNode          = GrVal_Node t (zipWith const l @pat.patFieldL)
                                           addVectorMap  fm = maybe fm (\n -> addToFM fm n newNode) @lhs.varName
                                       in addVectorMap $ @lhs.grNodeSubst `plusFM` mappings
%%]
