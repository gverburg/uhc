% $Id$

Rename all identifiers to unique numbers. exceptions are the FFI names (and
primitves) as well as the eval and apply function names.

To rename everyting fast and efficient we can use the fact that the scope of a
variable is local to a binding, but we don't do that yet.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../../GrinCodeAbsSyn)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.NumberIdents import(GRINCCommon, EHCommon, GrinCode, Data.Array.IArray, Data.FiniteMap, Data.Maybe) export(numberIdents)

numberIdents :: Int -> GrModule -> (Int, GrModule, IdentNameMap, CafMap)
numberIdents u grmod = let t        = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                   (Inh_GrAGItf { unique_Inh_GrAGItf = u })
                           newU     = unique_Syn_GrAGItf t
                           newGrMod = grTrf_Syn_GrAGItf  t
                           varMap   = varMap_Syn_GrAGItf t
                           cafMap   = cafMap_Syn_GrAGItf t
                       in (newU, newGrMod, varMap, cafMap)
%%]

%%[8.lookup hs
type LookupList = FiniteMap HsName HsName

findNewVar fm e = lookupWithDefaultFM fm (HNPos $ -999) e

addMaybe u fm = maybe (fm, u) addName
	where
	addName e | e == wildcardNm  = (fm                    , u  )
	          | otherwise        = (addToFM fm e (HNPos u), u+1)

addList u fm = onFst (addListToFM fm) . foldr addName ([], [], u)
	where
	onFst f (a, b, c)                       = (f a          , b             , c  )
	addName e (l, l2, u) | e == wildcardNm  = (l            , wildcardNr:l2 , u  )
	                     | otherwise        = ((e,HNPos u):l, ((HNPos u):l2), u+1)
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]

%%[8.unique
ATTR GrAGItf          [ | unique: Int | ]
ATTR AllGrNT          [ | unique: Int | ]
ATTR GrModule AllBind [ | cafUniq: Int cafVarUniq: Int | ]

SEM GrAGItf
  | AGItf  loc     .  low         = @lhs.unique
                   .  high        = @module.unique
           module  .  cafUniq     = @lhs.unique
                   .  cafVarUniq  = @module.cafUniq
                   .  unique      = @module.cafVarUniq
%%]

%%[8.maps
ATTR GrAGItf          [ | | cafMap: CafMap varMap:  IdentNameMap ]
ATTR AllGrNT          [ bind2id: LookupList  | var2id: LookupList | ]
ATTR GrModule AllBind [ | bind2idFrag: LookupList cafVar: LookupList | ]
ATTR GrModule AllBind [ | cafMap: CafMap | ]

SEM GrAGItf
  | AGItf  module  .  bind2idFrag  = emptyFM
                   .  cafVar       = emptyFM
                   .  cafMap       = emptyFM
                   .  var2id       = @module.cafVar
           loc     .  bind2id      = @module.bind2idFrag
                   .  origNames    = fmToList @bind2id ++ fmToList @module.var2id
                   .  varMapping   = [ (i, n) | (n, HNPos i) <- @origNames, not (n `elem` [applyNm, evalNm]) ]
                   .  varMap       = array (@low, @high-1) @varMapping
%%]

retrieving names and their mapping

%%[8.addMbFM hs
addMbToFM fm mbk mbv = maybe fm id mbFM
    where
    mbFM = do
        k <- mbk
        v <- mbv
        return $ addToFM fm k v
%%]

%%[8.caf
SEM GrBind
  | Bind  loc  .  isCaf        = null @argNmL
               .  cafName      = if @isCaf then Just $ HNPos @lhs.cafUniq    else Nothing
               .  cafVarName   = if @isCaf then Just $ HNPos @lhs.cafVarUniq else Nothing
               .  cafUniq      = if @isCaf then @lhs.cafUniq+1               else @lhs.cafUniq
               .  cafVarUniq   = if @isCaf then @lhs.cafVarUniq+1            else @lhs.cafVarUniq
               .  cafMap       = addMbToFM @lhs.cafMap @cafName   @cafVarName
               .  cafVar       = addMbToFM @lhs.cafVar (Just @nm) @cafVarName
%%]

%%[8.bindings
SEM GrBind
  | Bind  loc  .  (bindName, unique')  =  if @isCaf
                                          then (fromJust @cafName, @lhs.unique  )
                                          else if @nm == applyNm
                                          then (applyNr          , @lhs.unique  )
                                          else if @nm == evalNm
                                          then (evalNr           , @lhs.unique  )
                                          else (HNPos @lhs.unique, @lhs.unique+1)
               .  bind2idFrag          = if isSpecialBind @nm
                                         then @lhs.bind2idFrag
                                         else addToFM @lhs.bind2idFrag @nm @bindName
%%]

%%[8.TagName
SEM GrTag [ | | varName: {Maybe HsName} ]
  | Var       lhs  .  varName  =  Just @nm
  | * - Var   lhs  .  varName  =  Nothing
%%]

%%[8.GetDefinedNames
SEM GrPat
  | Node       loc  .  (var2id', newNames, unique') = addList @lhs.unique @lhs.var2id @fldL
  | Tag        loc  .  var2id'  = @lhs.var2id
                    .  unique'  = @unique'
  | Var        lhs  .  var2id   = addToFM @lhs.var2id @nm (HNPos @lhs.unique)
                    .  unique   = @lhs.unique + 1
               loc  .  newName  = HNPos @lhs.unique
  | Node Tag   loc  .  (var2id , unique )  = addMaybe @unique' @var2id' @tag.varName
               loc  .  newTag              = maybe @tag.grTrf GrTag_Var @tag.varName
    
SEM GrBind
  | Bind      loc   .  (var2id', newNames, unique'')  =  addList @unique' @lhs.var2id @argNmL
              expr  .  var2id                         =  @var2id'
                    .  unique                         =  @unique''
%%]

replacing every identifier with a number. Exception: eval and apply names are kept as they are

%%[8.ReplaceIdents
SEM GrPat
  | Node  lhs  .  grTrf  = GrPat_Node @newTag @newNames
  | Tag   lhs  .  grTrf  = GrPat_Tag  @newTag
  | Var   lhs  .  grTrf  = GrPat_Var  @newName

SEM GrBind
  | Bind  lhs  .  grTrf  = GrBind_Bind @bindName @newNames @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (findNewVar @lhs.var2id @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (findNewVar @lhs.var2id @nm)

SEM GrExpr
  | App Eval Fetch Update  loc  .  newName  =  findNewVar @lhs.var2id @nm
  | App                    lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                   lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                   loc  .  newName  =  findNewVar @lhs.bind2id @nm
                           lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                  lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset
  | Update                 lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf
  | FFI                    lhs  .  grTrf    =  GrExpr_FFI     @nm (map (findNewVar @lhs.var2id) @argL)

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @baseName @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.bind2id) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.bind2id) @applyTagMp
%%]

%%[8 hs
newMap map (k, EvApTagVar nm) = let newNm = if applyNm == nm
                                            then applyNr
                                            else if evalNm == nm
                                            then evalNr
                                            else findNewVar map nm
                                in (k, EvApTagVar newNm)
newMap map x                  = x


%%]

% vim:ts=4:et:ai:
