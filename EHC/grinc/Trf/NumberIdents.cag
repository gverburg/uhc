% $Id$

Rename all identifiers to unique numbers. exceptions are the FFI names (and
primitves) as well as the eval and apply function names.

To rename efficient we can use the fact that the scope of a variable is local
to a binding, but it's easier not to.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import("../GrinCodeAbsSyn")
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.NumberIdents import(GRINCCommon, EHCommon, GrinCode, Data.Array.IArray, "qualified Data.Map as Map", Data.Maybe) export(numberIdents)

numberIdents :: Int -> HsName -> GrModule -> (Int, HsName, GrModule, IdentNameMap, CafMap)
numberIdents u entry grmod = let t        = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                         (Inh_GrAGItf { unique_Inh_GrAGItf = u, entry_Inh_GrAGItf = entry })
                                 newU     = unique_Syn_GrAGItf t
                                 newGrMod = grTrf_Syn_GrAGItf  t
                                 varMap   = varMap_Syn_GrAGItf t
                                 cafMap   = cafMap_Syn_GrAGItf t
                                 newEntry = entry_Syn_GrAGItf  t
                             in (newU, newEntry, newGrMod, varMap, cafMap)
%%]

%%[8.lookup hs
type LookupList = Map.Map HsName HsName

findNewVar fm e = Map.findWithDefault (HNPos $ -999) e fm

addMaybe u fm = maybe (fm, u) addName
	where
	addName e | e == wildcardNm  = (fm                       , u  )
	          | otherwise        = (Map.insert e (HNPos u) fm, u+1)

addList u fm = onFst (flip listInsert fm) . foldr addName ([], [], u)
	where
	onFst f (a, b, c)                       = (f a          , b             , c  )
	addName e (l, l2, u) | e == wildcardNm  = (l            , wildcardNr:l2 , u  )
	                     | otherwise        = ((e,HNPos u):l, ((HNPos u):l2), u+1)
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]

%%[8.unique
ATTR GrAGItf          [ | unique: Int | ]
ATTR AllGrNT          [ | unique: Int | ]
ATTR GrModule AllBind [ | cafUniq: Int cafVarUniq: Int | ]

SEM GrAGItf
  | AGItf  loc     .  low         = @lhs.unique
                   .  high        = @module.unique
           module  .  cafUniq     = @lhs.unique
                   .  cafVarUniq  = @module.cafUniq
                   .  unique      = @module.cafVarUniq
%%]

%%[8.translateEntry
ATTR GrAGItf [ | entry: HsName | ]
SEM GrAGItf
  | AGItf  lhs . entry = fromJust $ Map.lookup @lhs.entry @bind2id
%%]

%%[8.maps
ATTR GrAGItf          [ | | cafMap: CafMap varMap:  IdentNameMap ]
ATTR AllGrNT          [ bind2id: LookupList  | var2id: LookupList | ]
ATTR GrModule AllBind [ | bind2idFrag: LookupList cafVar: LookupList | ]
ATTR GrModule AllBind [ | cafMap: CafMap | ]

SEM GrAGItf
  | AGItf  module  .  bind2idFrag  = Map.empty
                   .  cafVar       = Map.empty
                   .  cafMap       = Map.empty
                   .  var2id       = @module.cafVar
           loc     .  bind2id      = @module.bind2idFrag
                   .  bind2idList  = Map.toList @module.bind2idFrag
                   .  var2idList   = Map.toList @module.var2id
                   .  bindMapping  = [ (i, n) | (n, HNPos i) <- @bind2idList, not (n `elem` [applyNm, evalNm]) ]
                   .  varMapping   = let changeCaf n = if Map.member n @module.cafVar then hsnSuffix n "_caf" else n
                                     in [ (i, changeCaf n) | (n, HNPos i) <- @var2idList ]
                   .  varMap       = (array (@low, @high-1) (@bindMapping ++ @varMapping), Map.empty)
%%]

retrieving names and their mapping

%%[8.addMbFM hs
addMbToMap fm mbk mbv = maybe fm id mbMap
    where
    mbMap = do
        k <- mbk
        v <- mbv
        return $ Map.insert k v fm
%%]

%%[8.caf
SEM GrBind
  | Bind  loc  .  isCaf        = null @argNmL
               .  cafName      = if @isCaf then Just $ HNPos @lhs.cafUniq    else Nothing
               .  cafVarName   = if @isCaf then Just $ HNPos @lhs.cafVarUniq else Nothing
               .  cafUniq      = if @isCaf then @lhs.cafUniq+1               else @lhs.cafUniq
               .  cafVarUniq   = if @isCaf then @lhs.cafVarUniq+1            else @lhs.cafVarUniq
               .  cafMap       = addMbToMap @lhs.cafMap @cafName   @cafVarName
               .  cafVar       = addMbToMap @lhs.cafVar (Just @nm) @cafVarName
%%]

%%[8.bindings
SEM GrBind
  | Bind  loc  .  (bindName, unique')  =  if @isCaf
                                          then (fromJust @cafName, @lhs.unique  )
                                          else if @nm == applyNm
                                          then (applyNr          , @lhs.unique  )
                                          else if @nm == evalNm
                                          then (evalNr           , @lhs.unique  )
                                          else (HNPos @lhs.unique, @lhs.unique+1)
               .  bind2idFrag          = if isSpecialBind @nm
                                         then @lhs.bind2idFrag
                                         else Map.insert @nm @bindName @lhs.bind2idFrag
%%]

%%[8.TagName
SEM GrTag [ | | varName: {Maybe HsName} ]
  | Var       lhs  .  varName  =  Just @nm
  | * - Var   lhs  .  varName  =  Nothing
%%]

%%[8.GetDefinedNames
SEM GrPat
  | Node       loc  .  (var2id', newNames, unique') = addList @lhs.unique @lhs.var2id @fldL
  | Tag        loc  .  var2id'  = @lhs.var2id
                    .  unique'  = @unique'
  | Var        lhs  .  var2id   = Map.insert @nm (HNPos @lhs.unique) @lhs.var2id
                    .  unique   = @lhs.unique + 1
               loc  .  newName  = HNPos @lhs.unique
  | Node Tag   loc  .  (var2id , unique )  = addMaybe @unique' @var2id' @tag.varName
               loc  .  newTag              = maybe @tag.grTrf GrTag_Var @tag.varName
    
SEM GrBind
  | Bind      loc   .  (var2id', newNames, unique'')  =  addList @unique' @lhs.var2id @argNmL
              expr  .  var2id                         =  @var2id'
                    .  unique                         =  @unique''
%%]

replacing every identifier with a number. Exception: eval and apply names are kept as they are

%%[8.ReplaceIdents
SEM GrPat
  | Node  lhs  .  grTrf  = GrPat_Node @newTag @newNames
  | Tag   lhs  .  grTrf  = GrPat_Tag  @newTag
  | Var   lhs  .  grTrf  = GrPat_Var  @newName

SEM GrBind
  | Bind  lhs  .  grTrf  = GrBind_Bind @bindName @newNames @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (findNewVar @lhs.var2id @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (findNewVar @lhs.var2id @nm)
  | Lit  lhs  .  grTrf  = GrTag_Lit (if @categ == GrTagPApp 0 then GrTagFun else @categ) @int @nm  -- BUGFIX of ehc output

SEM GrExpr
  | App Eval Fetch Update  loc  .  newName  =  findNewVar @lhs.var2id @nm
  | App                    lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                   lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                   loc  .  newName  =  findNewVar @lhs.bind2id @nm
                           lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                  lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset @mbTag
  | Update                 lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf @mbTag
  | FFI                    lhs  .  grTrf    =  GrExpr_FFI     @nm (map (findNewVar @lhs.var2id) @argL)

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @baseName @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.bind2id) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.bind2id) @applyTagMp
%%]

%%[8 hs
newMap map (k, EvApTagVar nm) = let newNm = if applyNm == nm
                                            then applyNr
                                            else if evalNm == nm
                                            then evalNr
                                            else findNewVar map nm
                                in (k, EvApTagVar newNm)
newMap map x                  = x


%%]

% vim:ts=4:et:ai:
