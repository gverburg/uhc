% $Id$

As we must travel the whole program anyway, we do here some bugfixes and
replacements of exception primitives.

Rename all identifiers to unique numbers. exceptions are the FFI names (and
primitves) as well as the eval and apply function names.

To rename efficient we can use the fact that the scope of a variable is local
to a binding, but it's easier not to.

Note: after each binding we skip one number (as a binding needs two result variables)


%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import("../GrinCodeAbsSyn")
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.NumberIdents import(GRINCCommon, EHCommon, GrinCode, Data.Array.IArray, "qualified Data.Map as Map", Data.Maybe) export(numberIdents)

numberIdents :: Int -> HsName -> GrModule -> (Int, HsName, GrModule, IdentNameMap, Int)
numberIdents u entry grmod = let t          = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                           (Inh_GrAGItf { unique_Inh_GrAGItf = u, entry_Inh_GrAGItf = entry })
                                 nrOfBinds  = nrOfBinds_Syn_GrAGItf t
                                 newU       = unique_Syn_GrAGItf t
                                 newGrMod   = grTrf_Syn_GrAGItf  t
                                 varMap     = varMap_Syn_GrAGItf t
                                 newEntry   = entry_Syn_GrAGItf  t
                             in (newU, newEntry, newGrMod, varMap, newU - u - nrOfBinds)
%%]

%%[8.lookup hs
type LookupList = Map.Map HsName HsName

findNewVar fm e = Map.findWithDefault (HNPos $ -999) e fm

addMaybe u fm = maybe (fm, u) addName
	where
	addName e | e == wildcardNm  = (fm                       , u  )
	          | otherwise        = (Map.insert e (HNPos u) fm, u+1)

addList u fm = onFst (flip listInsert fm) . foldr addName ([], [], u)
	where
	onFst f (a, b, c)                       = (f a          , b             , c  )
	addName e (l, l2, u) | e == wildcardNm  = (l            , wildcardNr:l2 , u  )
	                     | otherwise        = ((e,HNPos u):l, ((HNPos u):l2), u+1)
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]

%%[8.unique
ATTR GrAGItf          [ | unique: Int | ]
ATTR AllGrNT          [ | unique: Int | ]

SEM GrAGItf
  | AGItf  loc     .  low         = @lhs.unique
                   .  high        = @module.unique
%%]

%%[8.translateEntry
ATTR GrAGItf [ | entry: HsName | ]
SEM GrAGItf
  | AGItf  lhs . entry = fromJust $ Map.lookup @lhs.entry @bind2id
%%]

%%[8.maps
ATTR GrAGItf          [ | | varMap:  IdentNameMap ]
ATTR AllGrNT          [ bind2id: LookupList  | var2id: LookupList | ]
ATTR GrModule AllBind [ | bind2idFrag: LookupList | ]
ATTR GrModule         [ | | globalVars: LookupList ]

SEM GrAGItf
  | AGItf  module  .  bind2idFrag  = Map.empty
                   .  var2id       = Map.empty
           loc     .  bind2id      = @module.bind2idFrag
                   .  bind2idList  = Map.toList @module.bind2idFrag
                   .  var2idList   = Map.toList @module.var2id
                   .  bindMapping  = concat [ [(i, n), (i+1, n)] | (n, HNPos i) <- @bind2idList, not (n `elem` [applyNm, evalNm]) ] -- ugly
                   .  varMapping   = let changeCaf n = if Map.member n @module.globalVars then hsnSuffix n "$global" else n
                                     in [ (i, changeCaf n) | (n, HNPos i) <- @var2idList ]
                   .  varMap       = (array (@low, @high-1) (@bindMapping ++ @varMapping), Map.empty)

SEM GrModule
  | Mod  lhs  .  globalVars  =  @globalL.var2id
%%]

retrieving names and their mapping

%%[8.addMbFM hs import(Debug.Trace)
addMbToMap fm mbk mbv = maybe fm id mbMap
    where
    mbMap = do
        k <- mbk
        v <- mbv
        return $ Map.insert k v fm
%%]

%%[8.bindings
SEM GrBind
  | Bind  loc  .  (bindName, unique')  =  if @nm == applyNm
                                          then (applyNr          , @lhs.unique  )
                                          else if @nm == evalNm
                                          then (evalNr           , @lhs.unique  )
                                          else (HNPos @lhs.unique, @lhs.unique+2)
               .  bind2idFrag          = if isSpecialBind @nm
                                         then @lhs.bind2idFrag
                                         else Map.insert @nm @bindName @lhs.bind2idFrag
%%]

%%[8.TagName
SEM GrTag [ | | varName: {Maybe HsName} ]
  | Var       lhs  .  varName  =  Just @nm
  | * - Var   lhs  .  varName  =  Nothing
%%]

%%[8.GetDefinedNames
SEM GrGlobal
  | Global    loc   .  newName  = HNPos @lhs.unique
              lhs   .  var2id   = Map.insert @nm @newName @lhs.var2id
                    .  unique   = @lhs.unique + 1

SEM GrPat
  | Node       loc  .  (var2id', newNames, unique') = addList @lhs.unique @lhs.var2id @fldL
  | Tag        loc  .  var2id'  = @lhs.var2id
                    .  unique'  = @unique'
  | Var        lhs  .  var2id   = Map.insert @nm @newName @lhs.var2id
                    .  unique   = @lhs.unique + 1
               loc  .  newName  = HNPos @lhs.unique
  | Node Tag   loc  .  (var2id , unique )  = addMaybe @unique' @var2id' @tag.varName
               loc  .  newTag              = maybe @tag.grTrf GrTag_Var @tag.varName

SEM GrExpr
  | Catch      handler  .  var2id   = Map.insert @arg @newName @body.var2id
                        .  unique   = @body.unique + 1
               loc      .  newName  = HNPos @body.unique
 
SEM GrBind
  | Bind      loc   .  (var2id', newNames, unique'')  =  addList @unique' @lhs.var2id @argNmL
                    .  isCatch                        =  @nm == HNm "_catch"
                    .  catchName                      = HNPos $ @unique''
                    .  evalName                       = HNPos $ @unique'' + 1
              expr  .  var2id                         =  if @isCatch then undefined else @var2id'
                    .  unique                         =  if @isCatch then undefined else @unique''
              lhs   .  unique                         =  if @isCatch then @unique'' + 2 else @expr.unique
                    .  var2id                         =  if @isCatch
                                                         then Map.insert @catchName @catchName (Map.insert @evalName @evalName @var2id')
                                                         else @expr.var2id
%%]

replacing every identifier with a number. Exception: eval and apply names are kept as they are

%%[8.ReplaceIdents
SEM GrGlobal
  | Global  lhs  .  grTrf  =  GrGlobal_Global @newName @val.grTrf

SEM GrPat
  | Node  lhs  .  grTrf  = GrPat_Node @newTag @newNames
  | Tag   lhs  .  grTrf  = GrPat_Tag  @newTag
  | Var   lhs  .  grTrf  = GrPat_Var  @newName

SEM GrBind
  | Bind  lhs  .  grTrf    = GrBind_Bind @bindName @newNames @newExpr
          loc  .  newExpr  = if @nm == HNm "_catch" then buildCatchExpr @unique'' @newNames else @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (findNewVar @lhs.var2id @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (findNewVar @lhs.var2id @nm)
  | Lit  lhs  .  grTrf  = GrTag_Lit (if @categ == GrTagPApp 0 then GrTagFun else @categ) @int @nm  -- BUGFIX of ehc output

SEM GrExpr
  | App Eval Fetch Update Throw  loc  .  newName  =  findNewVar @lhs.var2id @nm
  | App                          lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                         lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                         loc  .  newName  =  findNewVar     @lhs.bind2id @nm
                                 lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                        lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset @mbTag
  | Update                       lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf @mbTag
  | Throw                        lhs  .  grTrf    =  GrExpr_Throw   @newName
  | Catch                        lhs  .  grTrf    =  GrExpr_Catch   @body.grTrf @newName @handler.grTrf
  | FFI                          lhs  .  grTrf    =  if @nm == "primThrow"
                                                     then addThrow @lhs.var2id @argL
                                                     else GrExpr_FFI @nm (map (findNewVar @lhs.var2id) @argL)

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @baseName @globalL.grTrf @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = ((throwTag,1), EvApTagThrow) : map (newMap @lhs.bind2id) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.bind2id) @applyTagMp
%%]

%%[8.countBindings
ATTR GrAGItf GrModule AllBind [ | | nrOfBinds USE {+} {1}: {Int} ]
SEM GrBindL
  | Nil  lhs  .  nrOfBinds  =  0
%%]

%%[8 hs
newMap mp (k, EvApTagVar nm)  =  let newNm = if applyNm == nm
                                             then applyNr
                                             else if evalNm == nm
                                             then evalNr
                                             else findNewVar mp nm
                                 in (k, EvApTagVar newNm)
newMap mp x                   =  x

-- this is a hack to transform the primThrow into the correct GRIN code
-- as grinc expect every function to return a node (and not an empty value) we finish with a (unreachable) unit statement.
addThrow m [HNm e] = let unitExpr  = GrExpr_Unit  (GrVal_Var $ findNewVar m (HNm e))
                         throwExpr = GrExpr_Throw (findNewVar m (HNm $ tail e))
                     in GrExpr_Seq throwExpr GrPat_Empty unitExpr

addThrow _ _   = error "primThrow should have one (named) argument"

--unique is good for two variables...
buildCatchExpr unique [tryNm, handlerNm] = let  exceptNm = HNPos $ unique
                                                evalNm   = HNPos $ unique + 1
                                           in GrExpr_Catch (GrExpr_Eval tryNm)
                                                           exceptNm
                                                           (GrExpr_Seq (GrExpr_Eval handlerNm)
                                                                       (GrPat_Var evalNm)
                                                                       (GrExpr_App evalNm [GrVal_Var exceptNm])
                                                           )
%%]

% vim:ts=4:et:ai:
