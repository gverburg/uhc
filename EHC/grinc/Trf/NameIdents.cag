% $Id$

Rename numbered identifiers to their names.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import("../GrinCodeAbsSyn")
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.NameIdents import(GRINCCommon, EHCommon, GrinCode, Data.Array.IArray, "qualified Data.Map as Map") export(nameIdents)

nameIdents :: IdentNameMap -> CafMap -> GrModule -> (CafMap, GrModule)
nameIdents m cafMap grmod = let t        = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                        (Inh_GrAGItf { names_Inh_GrAGItf = m })
                                cafMap' = Map.fromList . map (\(k,v) -> (findNewVar m k, findNewVar m v)) $ Map.toList cafMap
                     in (cafMap', grTrf_Syn_GrAGItf t)
%%]

%%[8.lookup hs export(findNewVar)
findNewVar (names, map) nm@(HNPos i) = if wildcardNr == nm
                                       then wildcardNm
                                       else if applyNr == nm
                                       then applyNm
                                       else if evalNr == nm
                                       then evalNm
                                       else findNewVar' i ""
    where
    inBetween n (l, h) = n >= l && n <= h
    findNewVar' v suffix = if v `inBetween` bounds names 
                           then hsnSuffix (names ! v) suffix 
                           else maybe (hsnSuffix (HNPos v) suffix) id (Map.lookup v map >>= return . flip findNewVar' ("_" ++ show v ++ suffix))

findNewVar _  nm = error $ "findNewVar: Not a number: " ++ show nm
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]

%%[8.rename
ATTR GrAGItf AllGrNT  [ names: IdentNameMap | | ]

SEM GrPat
  | Node  lhs  .  grTrf     = GrPat_Node @tag.grTrf (map (findNewVar @lhs.names) @fldL)
  | Var   lhs  .  grTrf     = GrPat_Var  (findNewVar @lhs.names @nm)

SEM GrBind
  | Bind  loc  .  bindName  = findNewVar @lhs.names @nm
               .  newNames  = map (findNewVar @lhs.names) @argNmL
          lhs  .  grTrf     = GrBind_Bind @bindName @newNames @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (findNewVar @lhs.names @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (findNewVar @lhs.names @nm)

SEM GrExpr
  | App Eval Call Fetch Update Throw  loc  .  newName  =  findNewVar @lhs.names @nm
  | App                               lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                              lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                              lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                             lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset @mbTag
  | Update                            lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf @mbTag
  | FFI                               lhs  .  grTrf    =  GrExpr_FFI     @nm (map (findNewVar @lhs.names) @argL)
  | Throw                             lhs  .  grTrf    =  GrExpr_Throw   @newName
  | Catch                             lhs  .  grTrf    =  GrExpr_Catch   @body.grTrf (findNewVar @lhs.names @arg) @handler.grTrf

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @baseName @globalL.grTrf @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.names) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.names) @applyTagMp
%%]

%%[8 hs
newMap map (k, EvApTagVar nm) = (k, EvApTagVar $ findNewVar map nm)
newMap map x                  = x
%%]

% vim:ts=4:et:ai:
