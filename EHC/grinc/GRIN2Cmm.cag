% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(GrinCodeAbsSyn)
%%]

BUG in Shuffle: hiding kan niet geparsed worden voor infix functies (haakjes worden verwijderd)!
%%[8 hs
import EHCommon hiding ((<+>))
%%]

%%[8 hs import(Data.Char, Data.List(nub) Data.List(nubBy), Data.Maybe, GrinCode, CmmCode) export(grin2cmm,CmmUnit(..))
grin2cmm :: GrModule -> CmmUnit
grin2cmm gr = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr))
                                   (Inh_GrAGItf {})
              in cmmUnit_Syn_GrAGItf t
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% helper functions %%
%%%%%%%%%%%%%%%%%%%%%%

%%[8.helpers hs
-- toplevel
class Toplevel a where
 toplevel :: a -> CmmToplevel

instance Toplevel CmmProcedure where
  toplevel = CmmToplevel_Procedure 

instance Toplevel CmmDeclaration where
  toplevel = CmmToplevel_Declaration 

-- section
class Section a where
 section :: a -> CmmSectionElement

instance Section CmmProcedure where
  section = CmmSectionElement_Procedure 

instance Section CmmDeclaration where
  section = CmmSectionElement_Declaration 

-- Body
class Body a where
  body :: a -> CmmBodyElement

instance Body CmmStatement where
  body = CmmBodyElement_Statement 

instance Body CmmDeclaration where
  body = CmmBodyElement_Declaration 

-- declarations

typedefs  = CmmDeclaration_Typedef
imports   = CmmDeclaration_Import
exports   = CmmDeclaration_Export
constant  = CmmDeclaration_Constant
var       = CmmDeclaration_Var
target   :: Int -> CmmByteOrder -> Int -> Int -> CmmDeclaration
target ms bo ps ws = CmmDeclaration_Target $ TargetSpec ms bo ps ws

-- statements
nop               = CmmStatement_Nop
ite c t (Just e ) = CmmStatement_IfElse c t e
ite c t (Nothing) = CmmStatement_If c t
switch            = CmmStatement_Switch
assign            = CmmStatement_Assign
call              = CmmStatement_Call
tailcall          = CmmStatement_TailCall
ret               = CmmStatement_Return
label             = CmmStatement_Label
goto              = CmmStatement_GoTo

-- procedure & arguments
procedure n c a b  = CmmProcedure_Procedure n c a $ map body b

-- expressions
int   v = CmmExpression_Int v Nothing
char  v = CmmExpression_Char v Nothing
varRef  = CmmExpression_Var
prim    = CmmExpression_Primitive
memRef  = CmmExpression_MemRef

buildVarRef :: [(HsName, Int)] -> HsName -> CmmExpression
buildVarRef env nm = maybe (varRef' nm) cafLocation $ lookup nm env
	where
	cafLocation offset = varRef "@CAF_Nodes" <+> int offset

infixl 7 <*>, </>
infixl 6 <+>, <->

a <*> b = prim "mul" [CmmActual_Actual "" a, CmmActual_Actual "" b]
a </> b = prim "div" [CmmActual_Actual "" a, CmmActual_Actual "" b]
a <+> b = prim "add" [CmmActual_Actual "" a, CmmActual_Actual "" b]
a <-> b = prim "sub" [CmmActual_Actual "" a, CmmActual_Actual "" b]

-- calls
ptrArg e           = CmmActual_Actual "address" e
valArg e           = CmmActual_Actual "" e

buildCall :: Bool -> CmmName -> CmmActuals -> CmmKindedNames -> CmmStatement
buildCall tail name = fcall "" (varRef name)
	where
	fcall = if tail then (\a b c d -> tailcall a b c) else call

buildArg :: [(HsName, Int)] -> HsName -> CmmActual
buildArg env nm =ptrArg $ buildVarRef env nm

apply                = "$apply"
eval                 = "$eval"
callEval      e      = buildCall False eval [e]
tailcallEval  e      = buildCall True  eval [e] []
callApply     e args = buildCall False apply (ptrArg e : args)
tailcallApply e args = buildCall True  apply (ptrArg e : args) []



-- reserve data (initialized or not)
reserve t s i = CmmDatum_Reserve t (CmmSize_Sized $ int s) i

noInit        = CmmInitString_None
strInit       = CmmInitString_String
ustrInit      = CmmInitString_UnicodeString
expInit       = CmmInitString_List

-- mem refs
fetch :: CmmType -> CmmExpression -> Int -> CmmExpression
fetch t l i | i == 0    = memRef t l
            | otherwise = memRef t (l <+> int i)

-- value updates
memUpdate t l i | i == 0    = CmmLValue_MemRef t l
                | otherwise = CmmLValue_MemRef t (l <+> int i)
varUpdate                   = CmmLValue_Var

updates :: [(CmmLValue,CmmExpression)] -> CmmStatement
updates = uncurry assign . unzip

-- common types
bits n = CmmBits n
bits8  = bits 8
bits16 = bits 16
bits32 = bits 32

%%]


%%%%%%%%%%%
%% Names %%
%%%%%%%%%%%

Naming convention:

- GRIN names are converted to C-- in the following way:
    - prepend a $ (dollar)
    - escape a @ (at) with @@ (at at)
    - escape all but [a-zA-Z] (letter), [0-9] (digit), _ (underscore),
      $ (dollar), @ (at) in a name with a @ <ascii code> @ 
- Compiler introduced names start with an @

%%[8.names hs
-- convert GRIN to C-- names
hsName2cmmName :: HsName -> CmmName
hsName2cmmName = cmmName . show 

cmmName :: String -> CmmName
cmmName s = '$' : concatMap escapeChar s
	where
	escapeChar c | isAlphaNum c || c `elem` "_$" = [c]
                     | c == '@'                      = ['@','@']
                     | otherwise                     = '@' : (show (ord c) ++ "@")

-- type names
ptrType = CmmName "@ptr"
valType = CmmName "@val"

-- alternative var name funtions
varRef'    = varRef    . hsName2cmmName
varUpdate' = varUpdate . hsName2cmmName
%%]

%%%%%%%%%%%%%
%% TagInfo %%
%%%%%%%%%%%%%

A tag can be known, unknown or non existent (unboxed) All this information is
gathered in attributes for C-- code generation.

%%[8.TagName
ATTR GrTag [ | | tagName: {Maybe CmmName} ]
SEM GrTag
  | Lit      loc . tagName = let categStr = case @categ of
                                              GrTagCon        -> "C"
                                              GrTagHole       -> "H"
                                              GrTagRec        -> "R"
                                              GrTagApp        -> "A"
                                              GrTagFun        -> "F" 
                                              GrTagPApp need  -> 'P' : show need
                             in Just $ '@' : categStr ++ hsName2cmmName @nm
  | Var      loc . tagName = Just $ hsName2cmmName @nm
  | Unboxed  loc . tagName = Nothing

ATTR GrTag [ | | cmmExpr: {Maybe CmmExpression} isPtr: {Bool} ]
SEM GrTag
  | *        loc . cmmExpr = do { n <- @tagName; return $ varRef n }
  | Var      loc . isPtr   = True
  | * - Var  loc . isPtr   = False

%%]

%%%%%%%%%%%%%%%%%%%%%%
%%  Collecting Tags %%
%%%%%%%%%%%%%%%%%%%%%%

Tags will become constants in C--. Here they are collected to give each tag an
unique number.

%%[8.tagConstants
ATTR AllGrNT [ | | tags USE {++} {[]}: {[CmmName]} ]

SEM GrModule
  | Mod  loc . tags    = nub @bindL.tags

SEM GrTag
  | Lit  loc . tags    = maybe [] (\e -> [e]) @tagName
%%]


%%%%%%%%%%%%%%%%
%% Primitives %%
%%%%%%%%%%%%%%%%

%%[8 hs
-- primitivesTable: list of (name, (required imports, arguments -> result variables -> primitve))
primitivesTable :: [(String, ([String], CmmNames -> CmmNames -> CmmStatement))]
primitivesTable
  = [ ("primAddInt", ([], emitPrimAddInt))
    , ("primCmpInt", ([], emitPrimCmpInt))
    ]

emitPrimAddInt (l:r:[]) tn = assignOrReturn tn (varRef l <+> varRef r)

emitPrimCmpInt (l:r:[]) tn 
  = ite (prim "gt" [valArg $ varRef l,valArg $ varRef r])
        [body . assignOrReturn tn $ varRef "@C$_GT"]
        (Just [body $ ite (prim "lt" [valArg $ varRef l,valArg $ varRef r])
            [body . assignOrReturn tn $ varRef "@C$_LT"]
            (Just [body . assignOrReturn tn $ varRef "@C$_EQ"])
        ])

assignOrReturn tn expr = case tn of
                             [e] -> assign [varUpdate e] [expr]
                             [ ] -> ret "" [valArg expr]
                             _   -> error $ "too many arguments in call: " ++ show tn
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Collecting Imports  %%
%%%%%%%%%%%%%%%%%%%%%%%%%

Imports depend on the primitives availible. See also: Primitives

%%[8
ATTR GrModule [ | | imports: {Maybe CmmToplevel} ]
ATTR AllGrNT [ | | importedNames USE {++} {[]}: {CmmExternalNames} ]

SEM GrModule
  | Mod           loc . importedNames = nub @bindL.importedNames
                  loc . imports       = if null @importedNames
                                        then Nothing
                                        else Just $ CmmToplevel_Declaration (imports @importedNames)
SEM GrExpr
  | FFI           loc . neededNames   = maybe [@nm] fst $ lookup @nm primitivesTable
                      . importedNames = map (\n -> (cmmName n, Just n)) @neededNames
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Collecting Exports  %%
%%%%%%%%%%%%%%%%%%%%%%%%%

exports are not availible yet. Only the startup function is exported.

%%[8
ATTR GrModule [ | | exports: {Maybe CmmToplevel} ]

SEM GrModule
  | Mod            loc . exportedNames = ("@grin_main", (Just "grin_main")) : []
                   loc . exports       = if null @exportedNames
                                           then Nothing
                                           else Just $ CmmToplevel_Declaration (exports @exportedNames)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Cmm code, top level %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Merge everyting together into a C-- compilation unit

%%[8
ATTR GrAGItf GrModule [ | | cmmUnit : CmmUnit ]

SEM GrModule
  | Mod          loc . cmmUnit  = let addTl :: Maybe CmmToplevel -> CmmToplevels -> CmmToplevels
                                      addTl mtl tll        = maybe tll (:tll) mtl
                                      externals            = addTl @imports . addTl @exports 
                                      cafNodes             = @sectionCAFNodes :: CmmToplevel
                                      unitTypedefs         = toplevel $ typedefs bits32 ["@ptr", "@val"]
                                      unitTarget           = toplevel $ target 8 LittleEndian 32 32
				      heapPointer          = toplevel $ var False "address" bits32 [("@hp", Nothing)]
				      grin_main            = buildDriver (HNm "main") @lhs.cafEnv
                                      toplevelProcedures   = grin_main : map toplevel @bindL.cmmProcs
                                      tagConstants         = map buildTagConst $ zip @tags [1..]
                                      buildTagConst (t, i) = toplevel . constant (Just valType) t $ int i
                                  in CmmUnit_Unit 
                                       $ unitTarget : unitTypedefs : heapPointer :
                                         (externals $ tagConstants ++ cafNodes : toplevelProcedures)
%%]

%%[8.driver hs
buildDriver nm env = toplevel $ procedure "@grin_main" "" [] [ tailcallEval (buildArg env nm) ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, procedures %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

We collect the code for each Grin binding to map to a C-- procedure. Note that
we skip here apply, since we cannot generate code for this function.

%%[8 hs
buildProcedure :: HsName -> [HsName] -> CmmBody -> CmmProcedure
buildProcedure name args bodyElems = CmmProcedure_Procedure (hsName2cmmName name) "C--" (map buildFormal args) bodyElems

buildFormal :: HsName -> CmmFormal
buildFormal name = ("address", False, ptrType, hsName2cmmName name)
%%]

%%[8
ATTR AllBind [ | | cmmProcs USE {++} {[]}: {[CmmProcedure]} ]

SEM GrBind
  | Bind        loc . cmmProcs = [ buildProcedure @nm @argNmL @cmmBody ]
                lhs . cmmProcs = if @nm == HNm "apply" then [] else @cmmProcs


%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Expressions %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

The attributes needed for code generation for expressions. The names in which
to generate the code and the function which builds up the C-- body representing
the Grin code.

%%[8.Expressions
ATTR GrExpr    [ | | buildBody USE {.} {id}: {CmmBody->CmmBody} ]

SEM GrBind
  | Bind        loc . declaredVars = map (body . nrege2varDef) $ nubBy (\x y -> fst x == fst y) @expr.allUsedNames
                loc . cmmBody      =  @declaredVars ++ @expr.buildBody []
                

%%]

For each introduced identifier:
- what kind of identifier is it. (pointers, floats or anyting else)
  - All functions except the apply function take only pointer arguments!
- what type of identifiers is it. (pointer, tag, or a node value)
  - variables are introduced by means of attribute targetNames, other values
    already have a type.
- the name of the identifier (duh)

%%[8 hs
type CmmNameRegisterElement = (CmmName, (CmmType, CmmKind))
type CmmNameRegister = [CmmNameRegisterElement]

nreg2knames :: CmmNameRegister -> CmmKindedNames
nreg2knames = map (\(n, (t, k)) -> (k,n))

nreg2names :: CmmNameRegister -> CmmNames
nreg2names = map fst

nrege2varDef :: CmmNameRegisterElement -> CmmDeclaration
nrege2varDef = \(n, (t, k)) -> var False k t [(n, Nothing)]

tagVar n = (n, (valType, ""))
elemVar n = (n, (valType, ""))
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find Last Grin Expression of a binding %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To keep track of whether the expression should return a value or should copy it
to target names.

%%[8
ATTR AllGrExpr [ hasNext: {Bool} | | ]

SEM GrBind
  | Bind     expr . hasNext = False

SEM GrExpr
  | Seq      expr . hasNext = True
             body . hasNext = False

SEM GrExpr
  | * - Seq Case  loc . isLastExpr = not @lhs.hasNext
  | Seq Case      loc . isLastExpr = False
%%]


%%%%%%%%%%%%%%%%%%%
%% Cmm code, Seq %%
%%%%%%%%%%%%%%%%%%%

The sequence operation does not generate code by itself, but does the chaining
of commands.  The left hand side must create its result in the variables named
in the pattern in this bind operation.

%%[8.Seq
ATTR AllGrExpr [ targetNames: {CmmNameRegister} | | allUsedNames USE {++} {[]}: {CmmNameRegister} ]

SEM GrExpr
  | Seq      expr . targetNames  = @pat.definedNames
             body . targetNames  = []

SEM GrExpr  
  | Seq	         lhs  . allUsedNames = @expr.allUsedNames ++ @pat.definedNames ++ @body.allUsedNames

SEM GrBind
  | Bind   expr . targetNames = []

  
-- Collect names for a pattern in Seq
ATTR GrPat [ | | definedNames USE {++} {[]}: {CmmNameRegister} ]
SEM GrPat
  | Node       loc . fldNames = map (elemVar.hsName2cmmName) @fldL
               loc . definedNames = let 
	                                knownTag   = maybe @fldNames (const $ tagVar "@tmp" : @fldNames) @tag.tagName
	                                unknownTag = maybe @fldNames (\n -> tagVar n : @fldNames) @tag.tagName
				    in if @tag.isPtr then unknownTag else knownTag
  | NodeSplit  loc . definedNames = error "No NodeAdapt suport in GrPat"
  | Tag        loc . definedNames = let knownTag   = maybe [] (const [tagVar "@tmp"]) @tag.tagName
	                                unknownTag = maybe [] (\e -> [tagVar e]) @tag.tagName
				    in if @tag.isPtr then unknownTag else knownTag
  | Empty      loc . definedNames = []
  | Var        loc . definedNames = [ elemVar . hsName2cmmName $ @nm ]
%%]

%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Unit %%
%%%%%%%%%%%%%%%%%%%%

The grin unit operation returns values, both as a function return and as a copy
operation.

%%[8.Unit
SEM GrExpr
  | Unit   loc  . returnStm   = ret "" @val.cmmReturnArgs
                . copyStm     = updates $ zipWith (\l e -> (varUpdate . fst $ l, e)) @lhs.targetNames @val.cmmExpressions
                . unitStm     = if @isLastExpr then @returnStm else @copyStm
                . buildBody   = (body @unitStm :)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Value reference %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Unit operation can contain a grin value of various forms. All these forms
should return the correct reference names.

allowed forms of a GrVal and their mappings
- (var     field*) => var : fields
- (const   field*) => var : fields
- (Unboxed field*) => fields
- (Unboxed)        => []

Note that we silent ignore the fact that a value with a single integer also
succeed, as well as a node within a node. This is because the loosy grin AST.

%%[8.GrValReference
ATTR GrVal GrValL [ | | cmmReturnArgs USE {++} {[]}: {CmmActuals} cmmExpressions USE {++} {[]}: {CmmExpressions} ]
SEM GrVal
  | Node       loc . cmmReturnArgs  = addTagArg @tag.isPtr @tag.cmmExpr @fldL.cmmReturnArgs
                   . cmmExpressions = maybe @fldL.cmmExpressions (: @fldL.cmmExpressions) @tag.cmmExpr
  | NodeAdapt  loc . cmmReturnArgs  = error "no cmmReturnArgs for GrVal_NodeAdapt"
                   . cmmExpressions = error "no cmmExpressions for GrVal_NodeAdapt"
  | Tag        loc . cmmReturnArgs  = addTagArg @tag.isPtr @tag.cmmExpr []
                   . cmmExpressions = maybe [] (:[]) @tag.cmmExpr
  | Empty      loc . cmmReturnArgs  = []
                   . cmmExpressions = []
  | LitInt     loc . cmmExpr        = int @int
                   . cmmReturnArgs  = [ valArg @cmmExpr ]
                   . cmmExpressions = [ @cmmExpr ]
  | Var        loc . cmmExpr        = buildVarRef @lhs.cafEnv @nm
                   . cmmReturnArgs  = [ ptrArg @cmmExpr ]
                   . cmmExpressions = [ @cmmExpr ]
%%]

%%[8 hs
addTagArg :: Bool -> Maybe CmmExpression -> CmmActuals -> CmmActuals
addTagArg isPtr me as = maybe as addActual me
	where
	addActual = (: as). toArg
	toArg     = if isPtr then ptrArg else valArg
%%]


%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Case %%
%%%%%%%%%%%%%%%%%%%%

The case is more a lot of translation work than anything else.  However case
shortcutting might be done here. This is currently not implemented.

TODO: implement case shortcutting

Lowering grin has made the case expressions simple: the value to be scrutinised
is a tag variable.  A pattern in an alternative list only a tag constant.

%%[8.case
ATTR GrAltL    [  | | cmmAlts: {CmmAlternatives} ]
ATTR GrAlt     [  | | cmmAlt: {CmmAlternative} ]

SEM GrAltL
  | Cons   lhs  . cmmAlts     = @hd.cmmAlt : @tl.cmmAlts
  | Nil    lhs  . cmmAlts     = []

SEM GrAlt 
  | Alt    loc  . cmmBody     = @expr.buildBody []
           lhs  . cmmAlt      = CmmAlternative_Alt [@pat.cmmRange] @cmmBody 

-- case alternative range
ATTR GrPat [ | | cmmRange: {CmmRange} ] 
SEM GrPat
  | Tag        loc . cmmTN    = maybe (error "unknown tag in case pattern") (\n -> CmmRange_Single $ varRef n) @tag.tagName
                   . cmmRange = if @tag.isPtr then error "variable in pettern of case alternative" else @cmmTN
  | * - Tag    loc . cmmRange = error "no tag in case pattern"

-- case scrutiniser
ATTR GrVal [ | | caseExpr: {CmmExpression} ]
SEM GrVal
  | Tag        lhs . caseExpr = maybe (error "cannot scrutinise an unbox tag") id @tag.cmmExpr
  | * - Tag    lhs . caseExpr = error "not a tag in a case"

SEM GrExpr
  | Case   loc  . switchStm   = switch @val.caseExpr @altL.cmmAlts
                . buildBody   = (body @switchStm:)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Calls     %%
%%%%%%%%%%%%%%%%%%%%%%%%%

Function call, which can be tail calls if they are the last statement.
targetNames might need to change to tell what kind of names are used. so
names2knames can use this info.

Apply and Eval calls are handled exactly the same currently.

%%[8.Call
SEM GrExpr
  | Call   loc  . recievers   = nreg2knames @lhs.targetNames
                . callStm     = buildCall @isLastExpr (hsName2cmmName @nm) @argL.cmmFunctionArgs @recievers
                . buildBody   = (body @callStm :)

  | App    loc  . recievers   = nreg2knames @lhs.targetNames
                . callStm     = buildCall @isLastExpr apply (buildArg @lhs.cafEnv @nm : @argL.cmmFunctionArgs) @recievers
                . buildBody   = (body @callStm :)

  | Eval   loc  . recievers   = nreg2knames @lhs.targetNames
                . callStm     = buildCall @isLastExpr eval [buildArg @lhs.cafEnv @nm] @recievers
                . buildBody   = (body @callStm :)

-- Collect fucntion arguments 
ATTR GrValL [ | | cmmFunctionArgs : {CmmActuals} ]
ATTR GrVal  [ | | cmmFunctionArg  : {CmmActual } ]

SEM GrValL
  | Cons     lhs . cmmFunctionArgs = @hd.cmmFunctionArg : @tl.cmmFunctionArgs
  | Nil      lhs . cmmFunctionArgs = []

SEM GrVal
  | Var      loc . cmmFunctionArg = head @cmmReturnArgs -- see: Cmm code, Unit
  | * - Var  loc . cmmFunctionArg = error $ "actual requested, but no GrVal_Var"
%%]

%%%%%%%%%%%%%%%%%%%
%% Cmm code, FFI %%
%%%%%%%%%%%%%%%%%%%

FFI is used for primitives and foreign calls (with the C calling convention).
note that a C call cannot be handled as a last expression, this might change.

%%[8.FFI
SEM GrExpr
  | FFI    loc  . recievers   = nreg2knames @lhs.targetNames
                . mbPrim      = lookup @nm primitivesTable
                . isPrim      = isJust @mbPrim
                . primStm     = snd (fromJust @mbPrim) (map hsName2cmmName @argL) (nreg2names @lhs.targetNames)
                . callStm     = call "C" (varRef $ cmmName @nm) (map (valArg . varRef') @argL) @recievers
                . buildBody   = if @isPrim then (body @primStm :)
                                else if not @isLastExpr then (body @callStm :)
                                else error "FFI as last expression"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Monadic operations %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We assume cmmExpressions gives us the correct code

%%[8.MO
SEM GrExpr
  | Store  loc  . buildBody   = buildStore @val.cmmExpressions (nreg2names @lhs.targetNames)

  | Fetch  loc  . buildBody   = buildFetch @nm  (nreg2names @lhs.targetNames)

  | Update loc  . buildBody   = buildUpdate @nm @val.cmmExpressions

%%]
%%[8.MO hs
buildStore nms [p] = let grow          = 4 * max 4 (length nms)
                         alloc         = [ (varUpdate p, varRef "@hp") 
                                         , (varUpdate "@hp", varRef "@hp" <+> int grow)
                                         ]
                         assign e tf i = let hd = (memUpdate valType (varRef p) i, e)
			                     tl = tf (i+4)
                                         in hd:tl
                         assigns       = foldr assign (const []) nms 0
                         allocStm      = body $ updates alloc
                         storeStm      = body $ updates assigns
                     in (allocStm:) . (storeStm:)

-- TODO: fix Fetch
-- just load as much as possible
buildFetch  p nms = let assign n tf i = let hd = (varUpdate n, fetch valType (varRef' p) i)
                                            tl = tf (i+4)
                                        in hd:tl
                        assigns       = foldr assign (const []) nms 0
                        fetchStm      = updates assigns
                    in (body fetchStm:)

-- TODO: fix Update
-- just store the values (do not take space as a problem)
buildUpdate p nms = let assign e tf i = let hd = (memUpdate valType (varRef' p) i, e)
                                            tl = tf (i+4)
                                        in hd:tl
                        assigns       = foldr assign (const []) nms 0
                        updateStm     = updates assigns
                    in (body updateStm:)
%%]

%%%%%%%%%%%%%%%%%%%%
%% Collecting CAF %%
%%%%%%%%%%%%%%%%%%%%

CAF are special treated. For each CAF a FNode must be present in the heap.  A
CAF is a GRIN function which takes no parametes. every CAF has a variable named
the same as GRIN function that maps to a FNode. Which, if evaluated, calls the
corresponding GRIN function.

FNode are 1 element long, so they only have the standard node layout.

NOTE: I am lazy, I push CAF information up to GrAGItf before pushing down the
environment.

%%[8
ATTR GrModule AllBind [ | | cafNames USE {++} {[]}: {[HsName]} ]

SEM GrBind
  | Bind        loc . cafNames = if null @argNmL then [@nm] else []


ATTR AllGrNT [ cafEnv : {[(HsName, Int)]} | | ] 

SEM GrAGItf
  | AGItf      module . cafEnv = zip @module.cafNames [0,4*4..] --Note: stdNode layout = 4, min addr size = 8, node element = 32

SEM GrModule
  | Mod       loc . sectionCAFNodes = let data2section d    = CmmToplevel_Section "data" [CmmSectionElement_Data d]
                                          zeros             = replicate 3 (int 0)
                                          cmmCAFNode (n,_)  = reserve valType 4 $ expInit (varRef (cafNode4name n) : zeros)
                                      in  data2section (CmmDatum_Label "@CAF_Nodes" : map cmmCAFNode @lhs.cafEnv)
%%]

%%[8 hs
-- NOTE: As a convention the tags are named after the their binding name with "@@0F" preprended
--       see also: Collecting Tags
cafNode4name :: HsName -> CmmName
cafNode4name hn = "@F" ++ hsName2cmmName hn

cafOffset :: HsName -> [(HsName, Int)] -> Int
cafOffset nm env = maybe (error $ "no CAF found named '" ++ show nm ++ "'") id $ lookup nm env
%%]
