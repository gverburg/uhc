% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(../GrinCodeAbsSyn)
%%]

%%[8 hs import("EHCommon hiding ((<+>))" Data.List(nub), Data.Maybe, GrinCode, CmmBuilding) export(grin2cmm,CmmUnit(..))
grin2cmm :: GrModule -> CmmUnit
grin2cmm gr = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr))
                                   (Inh_GrAGItf {})
              in cmmUnit_Syn_GrAGItf t
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%%%%%%%%%%%%
%% TagInfo %%
%%%%%%%%%%%%%

A tag can be known, unknown or non existent (unboxed) All this information is
gathered in attributes for C-- code generation.

%%[8.TagName
ATTR GrTag [ | | tagName: {Maybe CmmName} ]
SEM GrTag
  | Lit      loc . tagName = let categStr = case @categ of
                                              GrTagCon        -> "C"
                                              GrTagHole       -> "H"
                                              GrTagRec        -> "R"
                                              GrTagApp        -> "A"
                                              GrTagFun        -> "F" 
                                              GrTagPApp need  -> 'P' : show need
                             in Just $ '@' : categStr ++ cmmName' @nm
  | Var      loc . tagName = Just $ cmmName' @nm
  | Unboxed  loc . tagName = Nothing

-- is a tag unknown?
ATTR GrTag [ | | isPtr: {Bool} ]
SEM GrTag
  | Var      loc . isPtr   = True
  | * - Var  loc . isPtr   = False

-- tagName as expression
ATTR GrTag [ | | cmmExpr: {Maybe CmmExpression} ]
SEM GrTag
  | *        loc . cmmExpr = do { n <- @tagName; return $ cmmVar n }
%%]

%%%%%%%%%%%%%%%%%%%%%%
%%  Collecting Tags %%
%%%%%%%%%%%%%%%%%%%%%%

Tags will become constants in C--. Here they are collected to give each tag an
unique number. We need to know which tag layout should be used.

TODO: TagLayout info is bogus!

%%[8 hs
data TagLayout = SmallLayout | BigLayout
	deriving (Eq,Show)
type TagEnv    = [(CmmName, TagLayout)]
%%]

%%[8.tagConstants
ATTR AllGrNT [ | | tags USE {++} {[]}: {TagEnv} ]
ATTR GrTag [ nodeSize: {Int} | | ]

SEM GrVal
  | *         loc . nodeSize = 0

SEM GrPat
  | NodeSplit loc . nodeSize = error "NodeSplit not supported"
  | Tag       loc . nodeSize = 0 -- skip case patterns
  | Node      loc . nodeSize = 1 + length @fldL

SEM GrModule
  | Mod  loc . tags    = nub @bindL.tags

SEM GrTag
  | Lit  loc . tagLayout = if @lhs.nodeSize > 4 then error "tags do not fit" else Just SmallLayout
             . tagInfo   = do 
                           { n <- @tagName
                           ; l <- @tagLayout
                           ; return [(n,l)]
                           }
             . tags      = maybe [] id @tagInfo
%%]


%%%%%%%%%%%%%%%%
%% Primitives %%
%%%%%%%%%%%%%%%%

builtin primitives (like plus and compare on integers)

%%[8 hs
-- primitivesTable: list of (name, (required imports, CAFnames -> arguments -> result variables -> primitve))
primitivesTable :: [(String, ([String], CAFEnv -> CmmNames -> CmmNames -> CmmBodyBuilder))]
primitivesTable
  = [ ("primAddInt", ([], emitPrimAddInt))
    , ("primCmpInt", ([], emitPrimCmpInt))
    ]

emitPrimAddInt env (l:r:[]) tn = assignOrReturn tn [(cmmVar l <+> cmmVar r)]

emitPrimCmpInt env (l:r:[]) tn 
  = let ltA  = arg env "$_LT"
        gtA  = arg env "$_GT"
        eqA  = arg env "$_EQ"
        mkEvalCall a = if null tn -- TODO: is this always correct?
                       then call True  eval [a] []
                       else call False eval [a] (map (\n -> ("",n)) tn)
    in
    ite (prim "gt" [valArg $ cmmVar l,valArg $ cmmVar r])
        (mkEvalCall gtA)
        (ite (prim "lt" [valArg $ cmmVar l,valArg $ cmmVar r])
             (mkEvalCall ltA)
             (mkEvalCall eqA)
        )

assignOrReturn tn expr = if null tn
                         then cmmReturn "" (map valArg expr)
                         else updates (zipWith (\l r -> (varUpdate l,r)) tn expr)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Collecting Imports  %%
%%%%%%%%%%%%%%%%%%%%%%%%%

Imports depend on the primitives availible. See also: Primitives

%%[8
ATTR GrModule [ | | imports: {Maybe CmmToplevelBuilder} ]
ATTR AllGrNT [ | | importedNames USE {++} {[]}: {CmmExternalNames} ]

SEM GrModule
  | Mod           loc . importedNames = nub @bindL.importedNames
                  loc . imports       = if null @importedNames
                                        then Nothing
                                        else Just $ imports @importedNames
SEM GrExpr
  | FFI           loc . neededNames   = maybe [@nm] fst $ lookup @nm primitivesTable
                      . importedNames = map (\n -> (cmmName n, Just n)) @neededNames
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Collecting Exports  %%
%%%%%%%%%%%%%%%%%%%%%%%%%

exports are not availible yet. Only the startup function is exported.

%%[8
ATTR GrModule [ | | exports: {Maybe CmmToplevelBuilder} ]

SEM GrModule
  | Mod            loc . exportedNames = ("@grin_main", (Just "grin_main")) : []
                   loc . exports       = if null @exportedNames
                                           then Nothing
                                           else Just $ exports @exportedNames
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Cmm code, top level %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Merge everyting together into a C-- compilation unit

%%[8
ATTR GrAGItf GrModule [ | | cmmUnit : CmmUnit ]

SEM GrModule
  | Mod          loc . cmmUnit  = let addTl mtl             = maybe emptyBuilder id mtl
                                      externals             = addTl @imports ~> addTl @exports 
                                      cafNodes              = @sectionCAFNodes :: CmmToplevelBuilder
                                      unitTypedefs          = typedefs bits32 ["@ptr", "@val"]
                                      unitTarget            = target 8 LittleEndian 32 32
				      heapPointer           = globalVarDecl False "address" bits32 [("@hp", Nothing)]
				      grin_main             = buildDriver "$main" @lhs.cafEnv
                                      tagConstants          = fst $ foldr buildTagConst (emptyBuilder,0) @tags
                                      buildTagConst (n,_) (r,i) = (constant (Just valType) n (int i) ~> r, i+1)
                                  in CmmUnit_Unit (  build $ unitTarget ~> unitTypedefs ~> heapPointer
                                                  ~> externals ~> tagConstants ~> cafNodes ~> @strings
                                                  ~> grin_main ~> @bindL.cmmProcs
                                                  )
%%]

%%[8.driver hs
buildDriver nm env = procedure "" "@grin_main" [] 
  ( cmmTailcall "" (cmmVar eval) [arg env nm]
  )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, procedures %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

We collect the code for each Grin binding to map to a C-- procedure. Note that
we skip here apply, since we cannot generate code for this function.

%%[8
ATTR AllBind [ | | cmmProcs USE {~>} {emptyBuilder}: {CmmToplevelBuilder} ]

SEM GrBind
  | Bind        loc . cmmProcs = buildProcedure @nm @argNmL @cmmBody
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Procedure return size %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

Procedures in C-- need to have exactly the same return values as they have
recievers in the call.  The behaviour is unspecified if the sizes differ.

Here we will make sure we always return the same number of parameters. Also we
keep an environment which notes how much return values a procedure will return.

%%[8

ATTR AllGrNT   [ returnSizeEnv: {[(CmmName,Int)]} | | ]
ATTR AllBind   [ | returnSizes: {[(CmmName,Int)]} | ]

SEM GrModule
  | Mod        bindL . returnSizes   = []
                     . returnSizeEnv = @bindL.returnSizes

SEM GrBind
  | Bind       loc . maxReturnSize = @expr.returnSize
               lhs . returnSizes   = (cmmName' @nm, @maxReturnSize) : @lhs.returnSizes


ATTR AllGrExpr [ maxReturnSize: {Int} | | returnSize USE {`max`} {0}: {Int} ]
SEM GrExpr
  | Unit       loc . returnSize = if @isLastExpr then @val.size else 0
  | Call       loc . returnSize = if @isLastExpr then fromJust' "Call" (lookup (cmmName' @nm) @lhs.returnSizeEnv) else 0
  | App        loc . returnSize = if @isLastExpr then fromJust' "App" (lookup apply @lhs.returnSizeEnv) else 0
  | Eval       loc . returnSize = if @isLastExpr then fromJust' "Eval" (lookup eval @lhs.returnSizeEnv) else 0
  | FFI        loc . returnSize = if @isLastExpr then 
                                    if @isPrim then fromJust' "FFI" (lookup eval @lhs.returnSizeEnv)
                                     else error "ffi as last expression"
                                  else 0
  
  | Store Update loc . returnSize = if @isLastExpr then 1 else 0
  | Fetch        loc . returnSize = if @isLastExpr then error "fetch at return spine" else 0

ATTR GrVal GrTag GrValL [ | | size USE {+} {1}: {Int} ]
SEM GrTag
  | Unboxed    loc . size = 0
SEM GrValL
  | Nil        loc . size = 0

SEM GrVal
  | Empty      loc . size = 0
  | NodeAdapt  loc . size = error "unknown size of Val"


-- A set AllGrNM Might be better
-- This prevents a warning
SEM GrAGItf
  | AGItf       loc . returnSizeEnv = []
%%]

%%[8 hs
padWith :: (Int -> a) -> [a] -> Int -> [a]
padWith padFunction real size = take size real ++ map padFunction [length real + 1..size]

mkTempVar :: Int -> CmmKindedName
mkTempVar i = ("", ("@tmp" ++ show i))

fromJust' :: String -> Maybe a -> a
fromJust' _   (Just a) = a
fromJust' msg Nothing  = error $ "fromJust: " ++ msg
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Expressions %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

The attributes needed for code generation for expressions. The names in which
to generate the code and the function which builds up the C-- body representing
the Grin code.

%%[8.Expressions
ATTR GrExpr    [ | | cmmBody USE {~>} {emptyBuilder}: {CmmBodyBuilder} ]

SEM GrBind
  | Bind        loc . declaredVars = @tmpVars ~> nreg2varDef (noDups @expr.allUsedNames)
                loc . cmmBody      = @traceStm ~> @declaredVars ~> @expr.cmmBody
		loc . tmpVars      = foldr (\i f -> varDecl False "" valType [("@tmp" ++ show i, Nothing)] ~> f) emptyBuilder [1..4]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find Last Grin Expression of a binding %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To keep track of whether the expression should return a value or should copy it
to target names.

%%[8
ATTR AllGrExpr [ hasNext: {Bool} | | ]

SEM GrBind
  | Bind     expr . hasNext = False

SEM GrExpr
  | Seq      expr . hasNext = True
             body . hasNext = False

SEM GrExpr
  | * - Seq Case  loc . isLastExpr = not @lhs.hasNext
  | Seq Case      loc . isLastExpr = False
%%]


%%%%%%%%%%%%%%%%%%%
%% Cmm code, Seq %%
%%%%%%%%%%%%%%%%%%%

The sequence operation does not generate code by itself, but does the chaining
of commands.  The left hand side must create its result in the variables named
in the pattern in this bind operation. This is the main task of GrExpr_Seq.

%%[8.Seq
ATTR AllGrExpr [ targetNames: {CmmNameRegister} | | allUsedNames USE {++} {[]}: {CmmNameRegister} ]

SEM GrExpr
  | Seq      expr . targetNames  = @pat.definedNames
             body . targetNames  = []

SEM GrExpr  
  | Seq	         lhs  . allUsedNames = @expr.allUsedNames ++ @pat.definedNames ++ @body.allUsedNames

SEM GrBind
  | Bind   expr . targetNames = []

  
-- Collect names for a pattern in Seq
ATTR GrPat [ | | definedNames USE {++} {[]}: {CmmNameRegister} ]
SEM GrPat
  | Node       loc . fldNames = map (elemVar.cmmName') @fldL
               loc . definedNames = let 
	                                knownTag   = maybe @fldNames (const $ tagVar "@tmp" : @fldNames) @tag.tagName
	                                unknownTag = maybe @fldNames (\n -> tagVar n : @fldNames) @tag.tagName
				    in if @tag.isPtr then unknownTag else knownTag
  | NodeSplit  loc . definedNames = error "No NodeAdapt suport in GrPat"
  | Tag        loc . definedNames = let knownTag   = maybe [] (const [tagVar "@tmp"]) @tag.tagName
	                                unknownTag = maybe [] (\e -> [tagVar e]) @tag.tagName
				    in if @tag.isPtr then unknownTag else knownTag
  | Empty      loc . definedNames = []
  | Var        loc . definedNames = [ elemVar . cmmName' $ @nm ]
%%]

%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Unit %%
%%%%%%%%%%%%%%%%%%%%

The grin unit operation returns values, both as a function return and as a copy
operation. We use the size info to pad the return if necessary.

%%[8.Unit
SEM GrExpr
  | Unit   loc  . dummyRet    = const . valArg $ int (-1)
                . returnStm   = cmmReturn ""  (padWith @dummyRet @val.cmmReturnArgs @lhs.maxReturnSize)
                . copyStm     = updates $ zipWith (\l e -> (varUpdate . fst $ l, e)) @lhs.targetNames @val.cmmExpressions
                . cmmBody     = if @isLastExpr then @returnStm else @copyStm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Value reference %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Unit operation can contain a grin value of various forms. All these forms
should return the correct reference names.

allowed forms of a GrVal and their mappings
- (var     field*) => var : fields
- (const   field*) => var : fields
- (Unboxed field*) => fields
- (Unboxed)        => []

Note that we silent ignore the fact that a value with a single integer also
succeed, as well as a node within a node. This is because the grin AST allows
more than the concrete syntax.

%%[8.GrValReference
ATTR GrVal GrValL [ | | cmmReturnArgs USE {++} {[]}: {CmmActuals} cmmExpressions USE {++} {[]}: {CmmExpressions} ]
SEM GrVal
  | Node       loc . cmmReturnArgs  = addTagArg @tag.isPtr @tag.cmmExpr @fldL.cmmReturnArgs
                   . cmmExpressions = maybe @fldL.cmmExpressions (: @fldL.cmmExpressions) @tag.cmmExpr
  | NodeAdapt  loc . cmmReturnArgs  = error "no cmmReturnArgs for GrVal_NodeAdapt"
                   . cmmExpressions = error "no cmmExpressions for GrVal_NodeAdapt"
  | Tag        loc . cmmReturnArgs  = addTagArg @tag.isPtr @tag.cmmExpr []
                   . cmmExpressions = maybe [] (:[]) @tag.cmmExpr
  | Empty      loc . cmmReturnArgs  = []
                   . cmmExpressions = []
  | LitInt     loc . cmmExpr        = int @int
                   . cmmReturnArgs  = [ valArg @cmmExpr ]
                   . cmmExpressions = [ @cmmExpr ]
  | Var        loc . cmmExpr        = var' @lhs.cafEnv @nm
                   . cmmReturnArgs  = [ ptrArg @cmmExpr ]
                   . cmmExpressions = [ @cmmExpr ]
%%]

%%[8 hs
addTagArg :: Bool -> Maybe CmmExpression -> CmmActuals -> CmmActuals
addTagArg isPtr me as = maybe as addActual me
	where
	addActual = (: as). toArg
	toArg     = if isPtr then ptrArg else valArg
%%]


%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Case %%
%%%%%%%%%%%%%%%%%%%%

The case is more a lot of translation work than anything else.  However case
shortcutting might be done here. This is currently not implemented.

TODO: implement case shortcutting

Lowering grin has made the case expressions simple: the value to be scrutinised
is a tag variable.  A pattern in an alternative list only a tag constant.

%%[8.case
ATTR GrAltL    [  | | cmmAlts: {CmmAlternatives} ]
ATTR GrAlt     [  | | cmmAlt: {CmmAlternative} ]

SEM GrAltL
  | Cons   lhs  . cmmAlts     = @hd.cmmAlt : @tl.cmmAlts
  | Nil    lhs  . cmmAlts     = []

SEM GrAlt 
  | Alt    lhs  . cmmAlt      = CmmAlternative_Alt [@pat.cmmRange] (build @expr.cmmBody)

-- case alternative range
ATTR GrPat [ | | cmmRange: {CmmRange} ] 
SEM GrPat
  | Tag        loc . cmmTN    = maybe (error "unknown tag in case pattern") (\n -> CmmRange_Single $ cmmVar n) @tag.tagName
                   . cmmRange = if @tag.isPtr then error "not a constant in pattern of case alternative" else @cmmTN
  | * - Tag    loc . cmmRange = error "no tag in case pattern"

-- case scrutiniser
ATTR GrVal [ | | caseExpr: {CmmExpression} ]
SEM GrVal
  | Tag        lhs . caseExpr = maybe (error "cannot scrutinise an unbox tag") id @tag.cmmExpr
  | * - Tag    lhs . caseExpr = error "not a tag in a case"

SEM GrExpr
  | Case   loc  . cmmBody     = cmmSwitch @val.caseExpr @altL.cmmAlts
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Calls %%
%%%%%%%%%%%%%%%%%%%%%

Function call, which can be tail calls if they are the last statement.
targetNames might need to change to tell what kind of names are used. so
names2knames can use this info.

Apply and Eval calls are handled exactly the same currently.

Note: this is a copy paste - after inlining of app is done this is not needed anymore
%%[8 hs
newNames :: HsName -> Int -> [HsName]
newNames base count | count == 0 = []
                    | otherwise  = suffix "_Tag" : map (\n -> suffix $ "_Field" ++ show n) [1..(count-1)]
	where
	suffix = hsnSuffix base
%%]

%%[8.Call
SEM GrExpr
  | Call   loc  . realRecievers = nreg2knames @lhs.targetNames
                . argsReturned  = fromJust $ lookup (cmmName' @nm) @lhs.returnSizeEnv
                . recievers     = padWith mkTempVar @realRecievers @argsReturned
                . cmmBody     = call' @isLastExpr @nm @argL.cmmFunctionArgs @recievers

  | App    loc  . realRecievers = nreg2knames @lhs.targetNames
                . argsReturned  = fromJust $ lookup apply @lhs.returnSizeEnv
                . recievers     = padWith mkTempVar @realRecievers @argsReturned
                . evalReturnCount = fromJust $ lookup eval @lhs.returnSizeEnv
                . appArgs       = map (valArg. cmmVar') (newNames @nm @evalReturnCount)
                . cmmBody       = call @isLastExpr apply (@appArgs ++ @argL.cmmFunctionArgs) @recievers

  | Eval   loc  . realRecievers = nreg2knames @lhs.targetNames
                . argsReturned  = fromJust $ lookup eval @lhs.returnSizeEnv
                . recievers     = padWith mkTempVar @realRecievers @argsReturned
                . cmmBody     = call @isLastExpr eval [arg' @lhs.cafEnv @nm] @recievers

-- Collect fucntion arguments 
ATTR GrValL [ | | cmmFunctionArgs : {CmmActuals} ]
ATTR GrVal  [ | | cmmFunctionArg  : {CmmActual } ]

SEM GrValL
  | Cons     lhs . cmmFunctionArgs = @hd.cmmFunctionArg : @tl.cmmFunctionArgs
  | Nil      lhs . cmmFunctionArgs = []

SEM GrVal
  | Var      loc . cmmFunctionArg = head @cmmReturnArgs -- see: Cmm code, Unit
  | * - Var  loc . cmmFunctionArg = error $ "actual requested, but no GrVal_Var"
%%]

%%%%%%%%%%%%%%%%%%%
%% Cmm code, FFI %%
%%%%%%%%%%%%%%%%%%%

FFI is used for primitives and foreign calls (with the C calling convention).
note that a C call cannot be handled as a last expression, this might change.

%%[8.FFI
SEM GrExpr
  | FFI    loc  . recievers   = nreg2knames @lhs.targetNames
                . mbPrim      = lookup @nm primitivesTable
                . isPrim      = isJust @mbPrim
                . primStm     = snd (fromJust @mbPrim) @lhs.cafEnv (map cmmName' @argL) (nreg2names @lhs.targetNames)
                . callStm     = cmmCall "C" (cmmVar $ cmmName @nm) (map (valArg . cmmVar') @argL) @recievers
                . cmmBody     = if @isPrim then @primStm
                                else if not @isLastExpr then @callStm
                                else error "FFI as last expression"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, Monadic operations %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We assume cmmExpressions gives us the correct code

%%[8.MO
SEM GrExpr
  | Store  loc  . cmmBody     = buildStore @val.cmmExpressions (nreg2names @lhs.targetNames)

  | Fetch  loc  . cmmBody     = buildFetch @nm  (nreg2names @lhs.targetNames)

  | Update loc  . cmmBody     = buildUpdate @nm @val.cmmExpressions

%%]
TODO: make length etc correct
%%[8.MO hs
buildStore nms [p] = let grow          = 4 * max 4 (length nms)
                         alloc         = [ (varUpdate p, cmmVar "@hp") 
                                         , (varUpdate "@hp", cmmVar "@hp" <+> int grow)
                                         ]
                         assign e tf i = let hd = (memUpdate valType (cmmVar p) i, e)
			                     tl = tf (i+4)
                                         in hd:tl
                         store         = foldr assign (const []) nms 0
                     in updates alloc ~> updates store

-- TODO: fix Fetch
-- just load as much as possible
buildFetch  p nms = let assign n tf i = let hd = (varUpdate n, fetch (cmmVar' p) i)
                                            tl = tf (i+4)
                                        in hd:tl
                        fetches       = foldr assign (const []) nms 0
                    in updates fetches

-- TODO: fix Update
-- just store the values (do not take space as a problem)
buildUpdate p nms = let assign e tf i = let hd = (memUpdate valType (cmmVar' p) i, e)
                                            tl = tf (i+4)
                                        in hd:tl
                        stores        = foldr assign (const []) nms 0
                    in updates stores
%%]

%%%%%%%%%%%%%%%%%%%%
%% Collecting CAF %%
%%%%%%%%%%%%%%%%%%%%

CAF are special treated. For each CAF a FNode must be present in the heap.  A
CAF is a GRIN function which takes no parametes. every CAF has a variable named
the same as GRIN function that maps to a FNode. Which, if evaluated, calls the
corresponding GRIN function.

FNode are 1 element long, so they only have the standard node layout.

NOTE: I am lazy, I push CAF information up to GrAGItf before pushing down the
environment.

%%[8
ATTR GrModule AllBind [ | | cafNames USE {++} {[]}: {[CmmName]} ]

SEM GrBind
  | Bind        loc . cafNames = if null @argNmL then [cmmName' @nm] else []


ATTR AllGrNT [ cafEnv : {CAFEnv} | | ] 

SEM GrAGItf
  | AGItf      module . cafEnv = zip @module.cafNames [0,4*4..] --Note: stdNode layout = 4, min addr size = 8, node element = 32

SEM GrModule
  | Mod       loc . sectionCAFNodes = let data2section d    = lift (CmmToplevel_Section "data") [CmmSectionElement_Data d]
                                          zeros             = replicate 3 (int 0)
                                          cmmCAFNode (n,_)  = reserve 4 valType $ listInit (cmmVar (cafNode4name n) : zeros)
                                      in  data2section (CmmDatum_Label "@CAF_Nodes" : map cmmCAFNode @lhs.cafEnv)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Trace function calls %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind [ | | traces USE {++} {[]}: {[(CmmName, String)]} ]
SEM GrBind
  | Bind      loc . traceName     = cmmName' @nm
                  . traceAddress  = "@trace_" ++ @traceName
                  . traceStm'     = cmmCall "C" (cmmVar "puts") [ ptrArg $ cmmVar @traceAddress ] []
              lhs . importedNames = ("puts", Nothing) : @expr.importedNames
              loc . traces        = [(@traceAddress, @traceName)]
              lhs . traces        = if @nm == HNm "eval" then [] else @traces
              loc . traceStm      = if @nm == HNm "eval" then cmmNop else @traceStm'

SEM GrModule
  | Mod       loc . strings       = let data2section d  = lift (CmmToplevel_Section "data") [CmmSectionElement_Data d]
                                        traceData (l,t) = [CmmDatum_Label l, reserve many bits8 $ strInit (t ++ "\0")]
                                    in data2section (concatMap traceData @bindL.traces)
%%]
