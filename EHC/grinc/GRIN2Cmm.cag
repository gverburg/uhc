% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import(GrinCodeAbsSyn)
%%]

BUG in Shuffle: hiding kan niet geparsed worden voor infix functies (haakjes worden verwijderd)!
%%[8 hs
import EHCommon hiding ((<+>))
%%]

%%[8 hs import(Data.Char, Data.List(nub), GrinCode, CmmCode) export(grin2cmm,CmmUnit(..))
grin2cmm :: GrModule -> CmmUnit
grin2cmm gr = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr))
                                   (Inh_GrAGItf {})
              in cmmUnit_Syn_GrAGItf t
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% helper functions %%
%%%%%%%%%%%%%%%%%%%%%%

%%[8.helpers hs
-- toplevel
class Toplevel a where
 toplevel :: a -> CmmToplevel

instance Toplevel CmmProcedure where
  toplevel = CmmToplevel_Procedure 

instance Toplevel CmmDeclaration where
  toplevel = CmmToplevel_Declaration 

-- section
class Section a where
 section :: a -> CmmSectionElement

instance Section CmmProcedure where
  section = CmmSectionElement_Procedure 

instance Section CmmDeclaration where
  section = CmmSectionElement_Declaration 

-- Body
class Body a where
  body :: a -> CmmBodyElement

instance Body CmmStatement where
  body = CmmBodyElement_Statement 

instance Body CmmDeclaration where
  body = CmmBodyElement_Declaration 

-- declarations

typedefs  = CmmDeclaration_Typedef
imports   = CmmDeclaration_Import
exports   = CmmDeclaration_Export
constant  = CmmDeclaration_Constant
target   :: Int -> CmmByteOrder -> Int -> Int -> CmmDeclaration
target ms bo ps ws = CmmDeclaration_Target $ TargetSpec ms bo ps ws

-- statements
nop               = CmmStatement_Nop
ite c t (Just e ) = CmmStatement_IfElse c t e
ite c t (Nothing) = CmmStatement_If c t
switch            = CmmStatement_Switch
assign            = CmmStatement_Assign
call              = CmmStatement_Call
tailcall          = CmmStatement_TailCall
ret               = CmmStatement_Return
label             = CmmStatement_Label
goto              = CmmStatement_GoTo

-- procedure & arguments
procedure n c a b  = CmmProcedure_Procedure n c a $ map body b
ptrArg e           = CmmActual_Actual "address" e

eval               = varRef "$eval"
callEval      e    = call     "" eval [ptrArg e]
tailcallEval  e    = tailcall "" eval [ptrArg e]

-- expressions
int   v = CmmExpression_Int v Nothing
char  v = CmmExpression_Char v Nothing
varRef  = CmmExpression_Var
prim    = CmmExpression_Primitive
memRef  = CmmExpression_MemRef

infixl 7 <*>, </>
infixl 6 <+>, <->

a <*> b = prim "mul" [CmmActual_Actual "" a, CmmActual_Actual "" b]
a </> b = prim "div" [CmmActual_Actual "" a, CmmActual_Actual "" b]
a <+> b = prim "add" [CmmActual_Actual "" a, CmmActual_Actual "" b]
a <-> b = prim "sub" [CmmActual_Actual "" a, CmmActual_Actual "" b]

-- reserve data (initialized or not)
reserve t s i = CmmDatum_Reserve t (CmmSize_Sized $ int s) i

noInit        = CmmInitString_None
strInit       = CmmInitString_String
ustrInit      = CmmInitString_UnicodeString
expInit       = CmmInitString_List

-- mem refs
fetch :: CmmType -> CmmExpression -> Int -> CmmExpression
fetch t l i | i == 0    = memRef t l
            | otherwise = memRef t (l <+> int i)

-- value updates
memUpdate t l i | i == 0    = CmmLValue_MemRef t l
                | otherwise = CmmLValue_MemRef t (l <+> int i)
varUpdate                   = CmmLValue_Var

updates :: [(CmmLValue,CmmExpression)] -> CmmStatement
updates = uncurry assign . unzip

-- common types
bits n = CmmBits n
bits8  = bits 8
bits16 = bits 16
bits32 = bits 32

%%]


%%%%%%%%%%%
%% Names %%
%%%%%%%%%%%

Naming convention:

- GRIN names are converted to C-- in the following way:
    - prepend a $ (dollar)
    - escape a @ (at) with @@ (at at)
    - escape all but [a-zA-Z] (letter), [0-9] (digit), _ (underscore),
      $ (dollar), @ (at) in a name with a @ <ascii code> @ 
- Compiler introduced names start with an @

%%[8.names hs
-- convert GRIN to C-- names
hsName2cmmName :: HsName -> CmmName
hsName2cmmName = cmmName . show 

cmmName :: String -> CmmName
cmmName s = '$' : concatMap escapeChar s
	where
	escapeChar c | isAlphaNum c || c `elem` "_$" = [c]
                     | c == '@'                      = ['@','@']
                     | otherwise                     = '@' : (show (ord c) ++ "@")

-- type names
ptrType = CmmName "@ptr"
valType = CmmName "@val"

-- alternative var name funtions
varRef'    = varRef    . hsName2cmmName
varUpdate' = varUpdate . hsName2cmmName
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Collecting Imports  %%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrModule [ | | imports: {Maybe CmmToplevel} ]
ATTR AllGrNT [ | | importedNames USE {++} {[]}: {CmmExternalNames} ]

SEM GrModule
  | Mod            loc . importedNames = nub @bindL.importedNames
                   loc . imports       = if null @importedNames
                                         then Nothing
                                         else Just $ CmmToplevel_Declaration (imports @importedNames)
SEM GrExpr
  | FFI           loc .  importedNames = [(cmmName @nm, Just @nm)]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Collecting Exports  %%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrModule [ | | exports: {Maybe CmmToplevel} ]

SEM GrModule
  | Mod            loc . exportedNames = ("@grin_main", (Just "grin_main")) : []
                   loc . exports       = if null @exportedNames
                                           then Nothing
                                           else Just $ CmmToplevel_Declaration (exports @exportedNames)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Cmm code, top level %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrAGItf GrModule [ | | cmmUnit : CmmUnit ]

SEM GrModule
  | Mod          loc . cmmUnit  = let addTl :: Maybe CmmToplevel -> CmmToplevels -> CmmToplevels
                                      addTl mtl tll        = maybe tll (:tll) mtl
                                      externals            = addTl @imports . addTl @exports 
                                      cafNodes             = @sectionCAFNodes :: CmmToplevel
                                      unitTypedefs         = toplevel $ typedefs bits32 ["ptr", "tag", "int"]
                                      unitTarget           = toplevel $ target 32 LittleEndian 32 32
				      grin_main            = buildDriver (cafOffset (HNm "main") @lhs.cafEnv)
                                      toplevelProcedures   = grin_main : map toplevel @bindL.cmmProcs
                                      buildTagConst (t, i) = toplevel . constant (Just valType) t $ int i
                                      tagConstants         = map buildTagConst $ zip @tags [1..]
                                  in CmmUnit_Unit 
                                       $ unitTarget : unitTypedefs : 
                                         (externals $ tagConstants ++ cafNodes : toplevelProcedures)
%%]

%%[8.builder hs

buildDriver offset 
  = let location  = varRef "@CAF_Nodes" <+> int offset
        grin_main = procedure "@grin_main" "" [] [ tailcallEval location ] --TODO: arg invariant?
    in toplevel grin_main

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cmm code, procedures %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
buildProcedure :: HsName -> [HsName] -> CmmBody -> CmmProcedure
buildProcedure name args bodyElems = CmmProcedure_Procedure (hsName2cmmName name) "C--" (map buildFormal args) bodyElems

buildFormal :: HsName -> CmmFormal
buildFormal name = ("address", False, ptrType, hsName2cmmName name)
%%]

%%[8
ATTR AllBind [ | | cmmProcs USE {++} {[]}: {[CmmProcedure]} ]

SEM GrBind
  | Bind        loc . cmmProcs = [ buildProcedure @nm @argNmL @expr.cmmBody ]

ATTR GrExpr [ | | cmmBody USE {++} {[]}: {CmmBody} ]
%%]

%%%%%%%%%%%%%%%%%%%%%%
%%  Collecting Tags %%
%%%%%%%%%%%%%%%%%%%%%%

tag2cmm (GrTag_Var v)            = error $ "tag2cmm: GrTag contains a variable ("++ show v ++")"
tag2cmm (GrTag_Lit categ int nm) = '@' : (show int) ++ (categStr ++ hsName2cmmName nm)
	where

%%[8
ATTR AllGrNT [ | | tags USE {++} {[]}: {[CmmName]} ]
ATTR GrTag [ | | tagName: {CmmName} ]

SEM GrModule
  | Mod loc . tags    = nub @bindL.tags

SEM GrTag
  | Lit    loc . tagName = let categStr = case @categ of
                                            GrTagCon          -> "C"
                                            GrTagHole       -> "H"
                                            GrTagRec        -> "R"
                                            GrTagApp        -> "A"
                                            GrTagFun        -> "F" 
                                            GrTagPApp need  -> 'P' : show need
                           in '@' : (show @int) ++ categStr ++ hsName2cmmName @nm
           loc . tags    = [ @tagName ]
  | Var    loc . tagName = error $ "tag2cmm: GrTag contains a variable ("++ show @nm ++")"

%%]

%%%%%%%%%%%%%%%%%%%%
%% Collecting CAF %%
%%%%%%%%%%%%%%%%%%%%

CAF are special treated. For each CAF a FNode must be present in the heap.  A
CAF is a GRIN function which takes no parametes. every CAF has a variable named
the same as GRIN function that maps to a FNode. Which, if evaluated, calls the
corresponding GRIN function.

FNode are 1 element long, so they only have the standard node layout.

NOTE: I am lazy, I push CAF information up to GrAGItf before pushing down the
environment.

%%[8
ATTR GrModule AllBind [ | | cafNames USE {++} {[]}: {[HsName]} ]

SEM GrBind
  | Bind        loc . cafNames = if null @argNmL then [@nm] else []


ATTR AllGrNT [ cafEnv : {[(HsName, Int)]} | | ] 

SEM GrAGItf
  | AGItf      module . cafEnv = zip @module.cafNames [0,1..] -- TODO: with steps of size(standard node layout)

SEM GrModule
  | Mod       loc . sectionCAFNodes = let data2section d    = CmmToplevel_Section "data" [CmmSectionElement_Data d]
                                          cmmCAFNode (n,_)  = reserve valType 1 $ expInit [varRef $ cafNode4name n]
                                      in  data2section (CmmDatum_Label "@CAF_Nodes" : map cmmCAFNode @lhs.cafEnv)
%%]

%%[8 hs
-- NOTE: As a convention the tags are named after the their binding name with "@@0F" preprended
--       see also: Collecting Tags
cafNode4name :: HsName -> CmmName
cafNode4name hn = "@0F" ++ hsName2cmmName hn

cafOffset :: HsName -> [(HsName, Int)] -> Int
cafOffset nm env = maybe (error $ "no CAF found named '" ++ show nm ++ "'") id $ lookup nm env
%%]
